function x9(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const r=Object.getOwnPropertyDescriptor(s,i);r&&Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();var ff=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Zg(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function v9(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),t}var b3={exports:{}},Nm={},S3={exports:{}},ls={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var tA;function y9(){if(tA)return ls;tA=1;var n=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.provider"),o=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),u=Symbol.for("react.lazy"),d=Symbol.iterator;function h(V){return V===null||typeof V!="object"?null:(V=d&&V[d]||V["@@iterator"],typeof V=="function"?V:null)}var p={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,y={};function x(V,Z,he){this.props=V,this.context=Z,this.refs=y,this.updater=he||p}x.prototype.isReactComponent={},x.prototype.setState=function(V,Z){if(typeof V!="object"&&typeof V!="function"&&V!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,V,Z,"setState")},x.prototype.forceUpdate=function(V){this.updater.enqueueForceUpdate(this,V,"forceUpdate")};function v(){}v.prototype=x.prototype;function b(V,Z,he){this.props=V,this.context=Z,this.refs=y,this.updater=he||p}var S=b.prototype=new v;S.constructor=b,g(S,x.prototype),S.isPureReactComponent=!0;var C=Array.isArray,E=Object.prototype.hasOwnProperty,k={current:null},R={key:!0,ref:!0,__self:!0,__source:!0};function L(V,Z,he){var ve,be={},Ie=null,Xe=null;if(Z!=null)for(ve in Z.ref!==void 0&&(Xe=Z.ref),Z.key!==void 0&&(Ie=""+Z.key),Z)E.call(Z,ve)&&!R.hasOwnProperty(ve)&&(be[ve]=Z[ve]);var Fe=arguments.length-2;if(Fe===1)be.children=he;else if(1<Fe){for(var Pe=Array(Fe),ct=0;ct<Fe;ct++)Pe[ct]=arguments[ct+2];be.children=Pe}if(V&&V.defaultProps)for(ve in Fe=V.defaultProps,Fe)be[ve]===void 0&&(be[ve]=Fe[ve]);return{$$typeof:n,type:V,key:Ie,ref:Xe,props:be,_owner:k.current}}function I(V,Z){return{$$typeof:n,type:V.type,key:Z,ref:V.ref,props:V.props,_owner:V._owner}}function T(V){return typeof V=="object"&&V!==null&&V.$$typeof===n}function M(V){var Z={"=":"=0",":":"=2"};return"$"+V.replace(/[=:]/g,function(he){return Z[he]})}var j=/\/+/g;function W(V,Z){return typeof V=="object"&&V!==null&&V.key!=null?M(""+V.key):Z.toString(36)}function z(V,Z,he,ve,be){var Ie=typeof V;(Ie==="undefined"||Ie==="boolean")&&(V=null);var Xe=!1;if(V===null)Xe=!0;else switch(Ie){case"string":case"number":Xe=!0;break;case"object":switch(V.$$typeof){case n:case e:Xe=!0}}if(Xe)return Xe=V,be=be(Xe),V=ve===""?"."+W(Xe,0):ve,C(be)?(he="",V!=null&&(he=V.replace(j,"$&/")+"/"),z(be,Z,he,"",function(ct){return ct})):be!=null&&(T(be)&&(be=I(be,he+(!be.key||Xe&&Xe.key===be.key?"":(""+be.key).replace(j,"$&/")+"/")+V)),Z.push(be)),1;if(Xe=0,ve=ve===""?".":ve+":",C(V))for(var Fe=0;Fe<V.length;Fe++){Ie=V[Fe];var Pe=ve+W(Ie,Fe);Xe+=z(Ie,Z,he,Pe,be)}else if(Pe=h(V),typeof Pe=="function")for(V=Pe.call(V),Fe=0;!(Ie=V.next()).done;)Ie=Ie.value,Pe=ve+W(Ie,Fe++),Xe+=z(Ie,Z,he,Pe,be);else if(Ie==="object")throw Z=String(V),Error("Objects are not valid as a React child (found: "+(Z==="[object Object]"?"object with keys {"+Object.keys(V).join(", ")+"}":Z)+"). If you meant to render a collection of children, use an array instead.");return Xe}function X(V,Z,he){if(V==null)return V;var ve=[],be=0;return z(V,ve,"","",function(Ie){return Z.call(he,Ie,be++)}),ve}function B(V){if(V._status===-1){var Z=V._result;Z=Z(),Z.then(function(he){(V._status===0||V._status===-1)&&(V._status=1,V._result=he)},function(he){(V._status===0||V._status===-1)&&(V._status=2,V._result=he)}),V._status===-1&&(V._status=0,V._result=Z)}if(V._status===1)return V._result.default;throw V._result}var J={current:null},K={transition:null},ee={ReactCurrentDispatcher:J,ReactCurrentBatchConfig:K,ReactCurrentOwner:k};function ne(){throw Error("act(...) is not supported in production builds of React.")}return ls.Children={map:X,forEach:function(V,Z,he){X(V,function(){Z.apply(this,arguments)},he)},count:function(V){var Z=0;return X(V,function(){Z++}),Z},toArray:function(V){return X(V,function(Z){return Z})||[]},only:function(V){if(!T(V))throw Error("React.Children.only expected to receive a single React element child.");return V}},ls.Component=x,ls.Fragment=t,ls.Profiler=i,ls.PureComponent=b,ls.StrictMode=s,ls.Suspense=l,ls.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ee,ls.act=ne,ls.cloneElement=function(V,Z,he){if(V==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+V+".");var ve=g({},V.props),be=V.key,Ie=V.ref,Xe=V._owner;if(Z!=null){if(Z.ref!==void 0&&(Ie=Z.ref,Xe=k.current),Z.key!==void 0&&(be=""+Z.key),V.type&&V.type.defaultProps)var Fe=V.type.defaultProps;for(Pe in Z)E.call(Z,Pe)&&!R.hasOwnProperty(Pe)&&(ve[Pe]=Z[Pe]===void 0&&Fe!==void 0?Fe[Pe]:Z[Pe])}var Pe=arguments.length-2;if(Pe===1)ve.children=he;else if(1<Pe){Fe=Array(Pe);for(var ct=0;ct<Pe;ct++)Fe[ct]=arguments[ct+2];ve.children=Fe}return{$$typeof:n,type:V.type,key:be,ref:Ie,props:ve,_owner:Xe}},ls.createContext=function(V){return V={$$typeof:o,_currentValue:V,_currentValue2:V,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},V.Provider={$$typeof:r,_context:V},V.Consumer=V},ls.createElement=L,ls.createFactory=function(V){var Z=L.bind(null,V);return Z.type=V,Z},ls.createRef=function(){return{current:null}},ls.forwardRef=function(V){return{$$typeof:a,render:V}},ls.isValidElement=T,ls.lazy=function(V){return{$$typeof:u,_payload:{_status:-1,_result:V},_init:B}},ls.memo=function(V,Z){return{$$typeof:c,type:V,compare:Z===void 0?null:Z}},ls.startTransition=function(V){var Z=K.transition;K.transition={};try{V()}finally{K.transition=Z}},ls.unstable_act=ne,ls.useCallback=function(V,Z){return J.current.useCallback(V,Z)},ls.useContext=function(V){return J.current.useContext(V)},ls.useDebugValue=function(){},ls.useDeferredValue=function(V){return J.current.useDeferredValue(V)},ls.useEffect=function(V,Z){return J.current.useEffect(V,Z)},ls.useId=function(){return J.current.useId()},ls.useImperativeHandle=function(V,Z,he){return J.current.useImperativeHandle(V,Z,he)},ls.useInsertionEffect=function(V,Z){return J.current.useInsertionEffect(V,Z)},ls.useLayoutEffect=function(V,Z){return J.current.useLayoutEffect(V,Z)},ls.useMemo=function(V,Z){return J.current.useMemo(V,Z)},ls.useReducer=function(V,Z,he){return J.current.useReducer(V,Z,he)},ls.useRef=function(V){return J.current.useRef(V)},ls.useState=function(V){return J.current.useState(V)},ls.useSyncExternalStore=function(V,Z,he){return J.current.useSyncExternalStore(V,Z,he)},ls.useTransition=function(){return J.current.useTransition()},ls.version="18.3.1",ls}var nA;function O_(){return nA||(nA=1,S3.exports=y9()),S3.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sA;function w9(){if(sA)return Nm;sA=1;var n=O_(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,i=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,r={key:!0,ref:!0,__self:!0,__source:!0};function o(a,l,c){var u,d={},h=null,p=null;c!==void 0&&(h=""+c),l.key!==void 0&&(h=""+l.key),l.ref!==void 0&&(p=l.ref);for(u in l)s.call(l,u)&&!r.hasOwnProperty(u)&&(d[u]=l[u]);if(a&&a.defaultProps)for(u in l=a.defaultProps,l)d[u]===void 0&&(d[u]=l[u]);return{$$typeof:e,type:a,key:h,ref:p,props:d,_owner:i.current}}return Nm.Fragment=t,Nm.jsx=o,Nm.jsxs=o,Nm}var iA;function b9(){return iA||(iA=1,b3.exports=w9()),b3.exports}var G=b9(),le=O_();const AL=Zg(le);var Cx={},C3={exports:{}},uo={},_3={exports:{}},E3={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var rA;function S9(){return rA||(rA=1,function(n){function e(K,ee){var ne=K.length;K.push(ee);e:for(;0<ne;){var V=ne-1>>>1,Z=K[V];if(0<i(Z,ee))K[V]=ee,K[ne]=Z,ne=V;else break e}}function t(K){return K.length===0?null:K[0]}function s(K){if(K.length===0)return null;var ee=K[0],ne=K.pop();if(ne!==ee){K[0]=ne;e:for(var V=0,Z=K.length,he=Z>>>1;V<he;){var ve=2*(V+1)-1,be=K[ve],Ie=ve+1,Xe=K[Ie];if(0>i(be,ne))Ie<Z&&0>i(Xe,be)?(K[V]=Xe,K[Ie]=ne,V=Ie):(K[V]=be,K[ve]=ne,V=ve);else if(Ie<Z&&0>i(Xe,ne))K[V]=Xe,K[Ie]=ne,V=Ie;else break e}}return ee}function i(K,ee){var ne=K.sortIndex-ee.sortIndex;return ne!==0?ne:K.id-ee.id}if(typeof performance=="object"&&typeof performance.now=="function"){var r=performance;n.unstable_now=function(){return r.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,d=null,h=3,p=!1,g=!1,y=!1,x=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function S(K){for(var ee=t(c);ee!==null;){if(ee.callback===null)s(c);else if(ee.startTime<=K)s(c),ee.sortIndex=ee.expirationTime,e(l,ee);else break;ee=t(c)}}function C(K){if(y=!1,S(K),!g)if(t(l)!==null)g=!0,B(E);else{var ee=t(c);ee!==null&&J(C,ee.startTime-K)}}function E(K,ee){g=!1,y&&(y=!1,v(L),L=-1),p=!0;var ne=h;try{for(S(ee),d=t(l);d!==null&&(!(d.expirationTime>ee)||K&&!M());){var V=d.callback;if(typeof V=="function"){d.callback=null,h=d.priorityLevel;var Z=V(d.expirationTime<=ee);ee=n.unstable_now(),typeof Z=="function"?d.callback=Z:d===t(l)&&s(l),S(ee)}else s(l);d=t(l)}if(d!==null)var he=!0;else{var ve=t(c);ve!==null&&J(C,ve.startTime-ee),he=!1}return he}finally{d=null,h=ne,p=!1}}var k=!1,R=null,L=-1,I=5,T=-1;function M(){return!(n.unstable_now()-T<I)}function j(){if(R!==null){var K=n.unstable_now();T=K;var ee=!0;try{ee=R(!0,K)}finally{ee?W():(k=!1,R=null)}}else k=!1}var W;if(typeof b=="function")W=function(){b(j)};else if(typeof MessageChannel<"u"){var z=new MessageChannel,X=z.port2;z.port1.onmessage=j,W=function(){X.postMessage(null)}}else W=function(){x(j,0)};function B(K){R=K,k||(k=!0,W())}function J(K,ee){L=x(function(){K(n.unstable_now())},ee)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(K){K.callback=null},n.unstable_continueExecution=function(){g||p||(g=!0,B(E))},n.unstable_forceFrameRate=function(K){0>K||125<K?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):I=0<K?Math.floor(1e3/K):5},n.unstable_getCurrentPriorityLevel=function(){return h},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(K){switch(h){case 1:case 2:case 3:var ee=3;break;default:ee=h}var ne=h;h=ee;try{return K()}finally{h=ne}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(K,ee){switch(K){case 1:case 2:case 3:case 4:case 5:break;default:K=3}var ne=h;h=K;try{return ee()}finally{h=ne}},n.unstable_scheduleCallback=function(K,ee,ne){var V=n.unstable_now();switch(typeof ne=="object"&&ne!==null?(ne=ne.delay,ne=typeof ne=="number"&&0<ne?V+ne:V):ne=V,K){case 1:var Z=-1;break;case 2:Z=250;break;case 5:Z=1073741823;break;case 4:Z=1e4;break;default:Z=5e3}return Z=ne+Z,K={id:u++,callback:ee,priorityLevel:K,startTime:ne,expirationTime:Z,sortIndex:-1},ne>V?(K.sortIndex=ne,e(c,K),t(l)===null&&K===t(c)&&(y?(v(L),L=-1):y=!0,J(C,ne-V))):(K.sortIndex=Z,e(l,K),g||p||(g=!0,B(E))),K},n.unstable_shouldYield=M,n.unstable_wrapCallback=function(K){var ee=h;return function(){var ne=h;h=ee;try{return K.apply(this,arguments)}finally{h=ne}}}}(E3)),E3}var oA;function C9(){return oA||(oA=1,_3.exports=S9()),_3.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var aA;function _9(){if(aA)return uo;aA=1;var n=O_(),e=C9();function t(f){for(var m="https://reactjs.org/docs/error-decoder.html?invariant="+f,w=1;w<arguments.length;w++)m+="&args[]="+encodeURIComponent(arguments[w]);return"Minified React error #"+f+"; visit "+m+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var s=new Set,i={};function r(f,m){o(f,m),o(f+"Capture",m)}function o(f,m){for(i[f]=m,f=0;f<m.length;f++)s.add(m[f])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,c=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,u={},d={};function h(f){return l.call(d,f)?!0:l.call(u,f)?!1:c.test(f)?d[f]=!0:(u[f]=!0,!1)}function p(f,m,w,_){if(w!==null&&w.type===0)return!1;switch(typeof m){case"function":case"symbol":return!0;case"boolean":return _?!1:w!==null?!w.acceptsBooleans:(f=f.toLowerCase().slice(0,5),f!=="data-"&&f!=="aria-");default:return!1}}function g(f,m,w,_){if(m===null||typeof m>"u"||p(f,m,w,_))return!0;if(_)return!1;if(w!==null)switch(w.type){case 3:return!m;case 4:return m===!1;case 5:return isNaN(m);case 6:return isNaN(m)||1>m}return!1}function y(f,m,w,_,N,$,te){this.acceptsBooleans=m===2||m===3||m===4,this.attributeName=_,this.attributeNamespace=N,this.mustUseProperty=w,this.propertyName=f,this.type=m,this.sanitizeURL=$,this.removeEmptyString=te}var x={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(f){x[f]=new y(f,0,!1,f,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(f){var m=f[0];x[m]=new y(m,1,!1,f[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(f){x[f]=new y(f,2,!1,f.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(f){x[f]=new y(f,2,!1,f,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(f){x[f]=new y(f,3,!1,f.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(f){x[f]=new y(f,3,!0,f,null,!1,!1)}),["capture","download"].forEach(function(f){x[f]=new y(f,4,!1,f,null,!1,!1)}),["cols","rows","size","span"].forEach(function(f){x[f]=new y(f,6,!1,f,null,!1,!1)}),["rowSpan","start"].forEach(function(f){x[f]=new y(f,5,!1,f.toLowerCase(),null,!1,!1)});var v=/[\-:]([a-z])/g;function b(f){return f[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(f){var m=f.replace(v,b);x[m]=new y(m,1,!1,f,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(f){var m=f.replace(v,b);x[m]=new y(m,1,!1,f,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(f){var m=f.replace(v,b);x[m]=new y(m,1,!1,f,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(f){x[f]=new y(f,1,!1,f.toLowerCase(),null,!1,!1)}),x.xlinkHref=new y("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(f){x[f]=new y(f,1,!1,f.toLowerCase(),null,!0,!0)});function S(f,m,w,_){var N=x.hasOwnProperty(m)?x[m]:null;(N!==null?N.type!==0:_||!(2<m.length)||m[0]!=="o"&&m[0]!=="O"||m[1]!=="n"&&m[1]!=="N")&&(g(m,w,N,_)&&(w=null),_||N===null?h(m)&&(w===null?f.removeAttribute(m):f.setAttribute(m,""+w)):N.mustUseProperty?f[N.propertyName]=w===null?N.type===3?!1:"":w:(m=N.attributeName,_=N.attributeNamespace,w===null?f.removeAttribute(m):(N=N.type,w=N===3||N===4&&w===!0?"":""+w,_?f.setAttributeNS(_,m,w):f.setAttribute(m,w))))}var C=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,E=Symbol.for("react.element"),k=Symbol.for("react.portal"),R=Symbol.for("react.fragment"),L=Symbol.for("react.strict_mode"),I=Symbol.for("react.profiler"),T=Symbol.for("react.provider"),M=Symbol.for("react.context"),j=Symbol.for("react.forward_ref"),W=Symbol.for("react.suspense"),z=Symbol.for("react.suspense_list"),X=Symbol.for("react.memo"),B=Symbol.for("react.lazy"),J=Symbol.for("react.offscreen"),K=Symbol.iterator;function ee(f){return f===null||typeof f!="object"?null:(f=K&&f[K]||f["@@iterator"],typeof f=="function"?f:null)}var ne=Object.assign,V;function Z(f){if(V===void 0)try{throw Error()}catch(w){var m=w.stack.trim().match(/\n( *(at )?)/);V=m&&m[1]||""}return`
`+V+f}var he=!1;function ve(f,m){if(!f||he)return"";he=!0;var w=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(m)if(m=function(){throw Error()},Object.defineProperty(m.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(m,[])}catch(et){var _=et}Reflect.construct(f,[],m)}else{try{m.call()}catch(et){_=et}f.call(m.prototype)}else{try{throw Error()}catch(et){_=et}f()}}catch(et){if(et&&_&&typeof et.stack=="string"){for(var N=et.stack.split(`
`),$=_.stack.split(`
`),te=N.length-1,me=$.length-1;1<=te&&0<=me&&N[te]!==$[me];)me--;for(;1<=te&&0<=me;te--,me--)if(N[te]!==$[me]){if(te!==1||me!==1)do if(te--,me--,0>me||N[te]!==$[me]){var _e=`
`+N[te].replace(" at new "," at ");return f.displayName&&_e.includes("<anonymous>")&&(_e=_e.replace("<anonymous>",f.displayName)),_e}while(1<=te&&0<=me);break}}}finally{he=!1,Error.prepareStackTrace=w}return(f=f?f.displayName||f.name:"")?Z(f):""}function be(f){switch(f.tag){case 5:return Z(f.type);case 16:return Z("Lazy");case 13:return Z("Suspense");case 19:return Z("SuspenseList");case 0:case 2:case 15:return f=ve(f.type,!1),f;case 11:return f=ve(f.type.render,!1),f;case 1:return f=ve(f.type,!0),f;default:return""}}function Ie(f){if(f==null)return null;if(typeof f=="function")return f.displayName||f.name||null;if(typeof f=="string")return f;switch(f){case R:return"Fragment";case k:return"Portal";case I:return"Profiler";case L:return"StrictMode";case W:return"Suspense";case z:return"SuspenseList"}if(typeof f=="object")switch(f.$$typeof){case M:return(f.displayName||"Context")+".Consumer";case T:return(f._context.displayName||"Context")+".Provider";case j:var m=f.render;return f=f.displayName,f||(f=m.displayName||m.name||"",f=f!==""?"ForwardRef("+f+")":"ForwardRef"),f;case X:return m=f.displayName||null,m!==null?m:Ie(f.type)||"Memo";case B:m=f._payload,f=f._init;try{return Ie(f(m))}catch{}}return null}function Xe(f){var m=f.type;switch(f.tag){case 24:return"Cache";case 9:return(m.displayName||"Context")+".Consumer";case 10:return(m._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return f=m.render,f=f.displayName||f.name||"",m.displayName||(f!==""?"ForwardRef("+f+")":"ForwardRef");case 7:return"Fragment";case 5:return m;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Ie(m);case 8:return m===L?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof m=="function")return m.displayName||m.name||null;if(typeof m=="string")return m}return null}function Fe(f){switch(typeof f){case"boolean":case"number":case"string":case"undefined":return f;case"object":return f;default:return""}}function Pe(f){var m=f.type;return(f=f.nodeName)&&f.toLowerCase()==="input"&&(m==="checkbox"||m==="radio")}function ct(f){var m=Pe(f)?"checked":"value",w=Object.getOwnPropertyDescriptor(f.constructor.prototype,m),_=""+f[m];if(!f.hasOwnProperty(m)&&typeof w<"u"&&typeof w.get=="function"&&typeof w.set=="function"){var N=w.get,$=w.set;return Object.defineProperty(f,m,{configurable:!0,get:function(){return N.call(this)},set:function(te){_=""+te,$.call(this,te)}}),Object.defineProperty(f,m,{enumerable:w.enumerable}),{getValue:function(){return _},setValue:function(te){_=""+te},stopTracking:function(){f._valueTracker=null,delete f[m]}}}}function at(f){f._valueTracker||(f._valueTracker=ct(f))}function Ee(f){if(!f)return!1;var m=f._valueTracker;if(!m)return!0;var w=m.getValue(),_="";return f&&(_=Pe(f)?f.checked?"true":"false":f.value),f=_,f!==w?(m.setValue(f),!0):!1}function nn(f){if(f=f||(typeof document<"u"?document:void 0),typeof f>"u")return null;try{return f.activeElement||f.body}catch{return f.body}}function gt(f,m){var w=m.checked;return ne({},m,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:w??f._wrapperState.initialChecked})}function vt(f,m){var w=m.defaultValue==null?"":m.defaultValue,_=m.checked!=null?m.checked:m.defaultChecked;w=Fe(m.value!=null?m.value:w),f._wrapperState={initialChecked:_,initialValue:w,controlled:m.type==="checkbox"||m.type==="radio"?m.checked!=null:m.value!=null}}function wt(f,m){m=m.checked,m!=null&&S(f,"checked",m,!1)}function Vt(f,m){wt(f,m);var w=Fe(m.value),_=m.type;if(w!=null)_==="number"?(w===0&&f.value===""||f.value!=w)&&(f.value=""+w):f.value!==""+w&&(f.value=""+w);else if(_==="submit"||_==="reset"){f.removeAttribute("value");return}m.hasOwnProperty("value")?zt(f,m.type,w):m.hasOwnProperty("defaultValue")&&zt(f,m.type,Fe(m.defaultValue)),m.checked==null&&m.defaultChecked!=null&&(f.defaultChecked=!!m.defaultChecked)}function It(f,m,w){if(m.hasOwnProperty("value")||m.hasOwnProperty("defaultValue")){var _=m.type;if(!(_!=="submit"&&_!=="reset"||m.value!==void 0&&m.value!==null))return;m=""+f._wrapperState.initialValue,w||m===f.value||(f.value=m),f.defaultValue=m}w=f.name,w!==""&&(f.name=""),f.defaultChecked=!!f._wrapperState.initialChecked,w!==""&&(f.name=w)}function zt(f,m,w){(m!=="number"||nn(f.ownerDocument)!==f)&&(w==null?f.defaultValue=""+f._wrapperState.initialValue:f.defaultValue!==""+w&&(f.defaultValue=""+w))}var Gt=Array.isArray;function dn(f,m,w,_){if(f=f.options,m){m={};for(var N=0;N<w.length;N++)m["$"+w[N]]=!0;for(w=0;w<f.length;w++)N=m.hasOwnProperty("$"+f[w].value),f[w].selected!==N&&(f[w].selected=N),N&&_&&(f[w].defaultSelected=!0)}else{for(w=""+Fe(w),m=null,N=0;N<f.length;N++){if(f[N].value===w){f[N].selected=!0,_&&(f[N].defaultSelected=!0);return}m!==null||f[N].disabled||(m=f[N])}m!==null&&(m.selected=!0)}}function vn(f,m){if(m.dangerouslySetInnerHTML!=null)throw Error(t(91));return ne({},m,{value:void 0,defaultValue:void 0,children:""+f._wrapperState.initialValue})}function ce(f,m){var w=m.value;if(w==null){if(w=m.children,m=m.defaultValue,w!=null){if(m!=null)throw Error(t(92));if(Gt(w)){if(1<w.length)throw Error(t(93));w=w[0]}m=w}m==null&&(m=""),w=m}f._wrapperState={initialValue:Fe(w)}}function Y(f,m){var w=Fe(m.value),_=Fe(m.defaultValue);w!=null&&(w=""+w,w!==f.value&&(f.value=w),m.defaultValue==null&&f.defaultValue!==w&&(f.defaultValue=w)),_!=null&&(f.defaultValue=""+_)}function ye(f){var m=f.textContent;m===f._wrapperState.initialValue&&m!==""&&m!==null&&(f.value=m)}function Qe(f){switch(f){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function tt(f,m){return f==null||f==="http://www.w3.org/1999/xhtml"?Qe(m):f==="http://www.w3.org/2000/svg"&&m==="foreignObject"?"http://www.w3.org/1999/xhtml":f}var rt,Pt=function(f){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(m,w,_,N){MSApp.execUnsafeLocalFunction(function(){return f(m,w,_,N)})}:f}(function(f,m){if(f.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in f)f.innerHTML=m;else{for(rt=rt||document.createElement("div"),rt.innerHTML="<svg>"+m.valueOf().toString()+"</svg>",m=rt.firstChild;f.firstChild;)f.removeChild(f.firstChild);for(;m.firstChild;)f.appendChild(m.firstChild)}});function pt(f,m){if(m){var w=f.firstChild;if(w&&w===f.lastChild&&w.nodeType===3){w.nodeValue=m;return}}f.textContent=m}var At={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},xe=["Webkit","ms","Moz","O"];Object.keys(At).forEach(function(f){xe.forEach(function(m){m=m+f.charAt(0).toUpperCase()+f.substring(1),At[m]=At[f]})});function xt(f,m,w){return m==null||typeof m=="boolean"||m===""?"":w||typeof m!="number"||m===0||At.hasOwnProperty(f)&&At[f]?(""+m).trim():m+"px"}function Ye(f,m){f=f.style;for(var w in m)if(m.hasOwnProperty(w)){var _=w.indexOf("--")===0,N=xt(w,m[w],_);w==="float"&&(w="cssFloat"),_?f.setProperty(w,N):f[w]=N}}var kt=ne({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Et(f,m){if(m){if(kt[f]&&(m.children!=null||m.dangerouslySetInnerHTML!=null))throw Error(t(137,f));if(m.dangerouslySetInnerHTML!=null){if(m.children!=null)throw Error(t(60));if(typeof m.dangerouslySetInnerHTML!="object"||!("__html"in m.dangerouslySetInnerHTML))throw Error(t(61))}if(m.style!=null&&typeof m.style!="object")throw Error(t(62))}}function bt(f,m){if(f.indexOf("-")===-1)return typeof m.is=="string";switch(f){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Wt=null;function ht(f){return f=f.target||f.srcElement||window,f.correspondingUseElement&&(f=f.correspondingUseElement),f.nodeType===3?f.parentNode:f}var Ht=null,Ce=null,St=null;function dt(f){if(f=xm(f)){if(typeof Ht!="function")throw Error(t(280));var m=f.stateNode;m&&(m=O1(m),Ht(f.stateNode,f.type,m))}}function Be(f){Ce?St?St.push(f):St=[f]:Ce=f}function Rt(){if(Ce){var f=Ce,m=St;if(St=Ce=null,dt(f),m)for(f=0;f<m.length;f++)dt(m[f])}}function rn(f,m){return f(m)}function In(){}var zn=!1;function _s(f,m,w){if(zn)return f(m,w);zn=!0;try{return rn(f,m,w)}finally{zn=!1,(Ce!==null||St!==null)&&(In(),Rt())}}function ns(f,m){var w=f.stateNode;if(w===null)return null;var _=O1(w);if(_===null)return null;w=_[m];e:switch(m){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(_=!_.disabled)||(f=f.type,_=!(f==="button"||f==="input"||f==="select"||f==="textarea")),f=!_;break e;default:f=!1}if(f)return null;if(w&&typeof w!="function")throw Error(t(231,m,typeof w));return w}var hs=!1;if(a)try{var Ls={};Object.defineProperty(Ls,"passive",{get:function(){hs=!0}}),window.addEventListener("test",Ls,Ls),window.removeEventListener("test",Ls,Ls)}catch{hs=!1}function Or(f,m,w,_,N,$,te,me,_e){var et=Array.prototype.slice.call(arguments,3);try{m.apply(w,et)}catch(_t){this.onError(_t)}}var So=!1,ks=null,Ri=!1,fr=null,no={onError:function(f){So=!0,ks=f}};function ua(f,m,w,_,N,$,te,me,_e){So=!1,ks=null,Or.apply(no,arguments)}function so(f,m,w,_,N,$,te,me,_e){if(ua.apply(this,arguments),So){if(So){var et=ks;So=!1,ks=null}else throw Error(t(198));Ri||(Ri=!0,fr=et)}}function pr(f){var m=f,w=f;if(f.alternate)for(;m.return;)m=m.return;else{f=m;do m=f,(m.flags&4098)!==0&&(w=m.return),f=m.return;while(f)}return m.tag===3?w:null}function Co(f){if(f.tag===13){var m=f.memoizedState;if(m===null&&(f=f.alternate,f!==null&&(m=f.memoizedState)),m!==null)return m.dehydrated}return null}function oe(f){if(pr(f)!==f)throw Error(t(188))}function We(f){var m=f.alternate;if(!m){if(m=pr(f),m===null)throw Error(t(188));return m!==f?null:f}for(var w=f,_=m;;){var N=w.return;if(N===null)break;var $=N.alternate;if($===null){if(_=N.return,_!==null){w=_;continue}break}if(N.child===$.child){for($=N.child;$;){if($===w)return oe(N),f;if($===_)return oe(N),m;$=$.sibling}throw Error(t(188))}if(w.return!==_.return)w=N,_=$;else{for(var te=!1,me=N.child;me;){if(me===w){te=!0,w=N,_=$;break}if(me===_){te=!0,_=N,w=$;break}me=me.sibling}if(!te){for(me=$.child;me;){if(me===w){te=!0,w=$,_=N;break}if(me===_){te=!0,_=$,w=N;break}me=me.sibling}if(!te)throw Error(t(189))}}if(w.alternate!==_)throw Error(t(190))}if(w.tag!==3)throw Error(t(188));return w.stateNode.current===w?f:m}function Ze(f){return f=We(f),f!==null?Je(f):null}function Je(f){if(f.tag===5||f.tag===6)return f;for(f=f.child;f!==null;){var m=Je(f);if(m!==null)return m;f=f.sibling}return null}var nt=e.unstable_scheduleCallback,Kt=e.unstable_cancelCallback,on=e.unstable_shouldYield,bn=e.unstable_requestPaint,Yt=e.unstable_now,Bn=e.unstable_getCurrentPriorityLevel,_n=e.unstable_ImmediatePriority,En=e.unstable_UserBlockingPriority,fs=e.unstable_NormalPriority,ws=e.unstable_LowPriority,Ws=e.unstable_IdlePriority,Mi=null,ss=null;function Vn(f){if(ss&&typeof ss.onCommitFiberRoot=="function")try{ss.onCommitFiberRoot(Mi,f,void 0,(f.current.flags&128)===128)}catch{}}var Ss=Math.clz32?Math.clz32:q,D=Math.log,H=Math.LN2;function q(f){return f>>>=0,f===0?32:31-(D(f)/H|0)|0}var pe=64,Oe=4194304;function st(f){switch(f&-f){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return f&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return f}}function Ue(f,m){var w=f.pendingLanes;if(w===0)return 0;var _=0,N=f.suspendedLanes,$=f.pingedLanes,te=w&268435455;if(te!==0){var me=te&~N;me!==0?_=st(me):($&=te,$!==0&&(_=st($)))}else te=w&~N,te!==0?_=st(te):$!==0&&(_=st($));if(_===0)return 0;if(m!==0&&m!==_&&(m&N)===0&&(N=_&-_,$=m&-m,N>=$||N===16&&($&4194240)!==0))return m;if((_&4)!==0&&(_|=w&16),m=f.entangledLanes,m!==0)for(f=f.entanglements,m&=_;0<m;)w=31-Ss(m),N=1<<w,_|=f[w],m&=~N;return _}function ot(f,m){switch(f){case 1:case 2:case 4:return m+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function mt(f,m){for(var w=f.suspendedLanes,_=f.pingedLanes,N=f.expirationTimes,$=f.pendingLanes;0<$;){var te=31-Ss($),me=1<<te,_e=N[te];_e===-1?((me&w)===0||(me&_)!==0)&&(N[te]=ot(me,m)):_e<=m&&(f.expiredLanes|=me),$&=~me}}function qt(f){return f=f.pendingLanes&-1073741825,f!==0?f:f&1073741824?1073741824:0}function Tn(){var f=pe;return pe<<=1,(pe&4194240)===0&&(pe=64),f}function Jn(f){for(var m=[],w=0;31>w;w++)m.push(f);return m}function Dn(f,m,w){f.pendingLanes|=m,m!==536870912&&(f.suspendedLanes=0,f.pingedLanes=0),f=f.eventTimes,m=31-Ss(m),f[m]=w}function Nn(f,m){var w=f.pendingLanes&~m;f.pendingLanes=m,f.suspendedLanes=0,f.pingedLanes=0,f.expiredLanes&=m,f.mutableReadLanes&=m,f.entangledLanes&=m,m=f.entanglements;var _=f.eventTimes;for(f=f.expirationTimes;0<w;){var N=31-Ss(w),$=1<<N;m[N]=0,_[N]=-1,f[N]=-1,w&=~$}}function sn(f,m){var w=f.entangledLanes|=m;for(f=f.entanglements;w;){var _=31-Ss(w),N=1<<_;N&m|f[_]&m&&(f[_]|=m),w&=~N}}var jt=0;function Un(f){return f&=-f,1<f?4<f?(f&268435455)!==0?16:536870912:4:1}var Qn,Gs,ps,P,F,O=!1,ae=[],Se=null,Ve=null,Ae=null,Ge=new Map,ut=new Map,Tt=[],kn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function jn(f,m){switch(f){case"focusin":case"focusout":Se=null;break;case"dragenter":case"dragleave":Ve=null;break;case"mouseover":case"mouseout":Ae=null;break;case"pointerover":case"pointerout":Ge.delete(m.pointerId);break;case"gotpointercapture":case"lostpointercapture":ut.delete(m.pointerId)}}function Xn(f,m,w,_,N,$){return f===null||f.nativeEvent!==$?(f={blockedOn:m,domEventName:w,eventSystemFlags:_,nativeEvent:$,targetContainers:[N]},m!==null&&(m=xm(m),m!==null&&Gs(m)),f):(f.eventSystemFlags|=_,m=f.targetContainers,N!==null&&m.indexOf(N)===-1&&m.push(N),f)}function Wn(f,m,w,_,N){switch(m){case"focusin":return Se=Xn(Se,f,m,w,_,N),!0;case"dragenter":return Ve=Xn(Ve,f,m,w,_,N),!0;case"mouseover":return Ae=Xn(Ae,f,m,w,_,N),!0;case"pointerover":var $=N.pointerId;return Ge.set($,Xn(Ge.get($)||null,f,m,w,_,N)),!0;case"gotpointercapture":return $=N.pointerId,ut.set($,Xn(ut.get($)||null,f,m,w,_,N)),!0}return!1}function ln(f){var m=_u(f.target);if(m!==null){var w=pr(m);if(w!==null){if(m=w.tag,m===13){if(m=Co(w),m!==null){f.blockedOn=m,F(f.priority,function(){ps(w)});return}}else if(m===3&&w.stateNode.current.memoizedState.isDehydrated){f.blockedOn=w.tag===3?w.stateNode.containerInfo:null;return}}}f.blockedOn=null}function A(f){if(f.blockedOn!==null)return!1;for(var m=f.targetContainers;0<m.length;){var w=Dt(f.domEventName,f.eventSystemFlags,m[0],f.nativeEvent);if(w===null){w=f.nativeEvent;var _=new w.constructor(w.type,w);Wt=_,w.target.dispatchEvent(_),Wt=null}else return m=xm(w),m!==null&&Gs(m),f.blockedOn=w,!1;m.shift()}return!0}function U(f,m,w){A(f)&&w.delete(m)}function Q(){O=!1,Se!==null&&A(Se)&&(Se=null),Ve!==null&&A(Ve)&&(Ve=null),Ae!==null&&A(Ae)&&(Ae=null),Ge.forEach(U),ut.forEach(U)}function ie(f,m){f.blockedOn===m&&(f.blockedOn=null,O||(O=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,Q)))}function de(f){function m(N){return ie(N,f)}if(0<ae.length){ie(ae[0],f);for(var w=1;w<ae.length;w++){var _=ae[w];_.blockedOn===f&&(_.blockedOn=null)}}for(Se!==null&&ie(Se,f),Ve!==null&&ie(Ve,f),Ae!==null&&ie(Ae,f),Ge.forEach(m),ut.forEach(m),w=0;w<Tt.length;w++)_=Tt[w],_.blockedOn===f&&(_.blockedOn=null);for(;0<Tt.length&&(w=Tt[0],w.blockedOn===null);)ln(w),w.blockedOn===null&&Tt.shift()}var ue=C.ReactCurrentBatchConfig,fe=!0;function we(f,m,w,_){var N=jt,$=ue.transition;ue.transition=null;try{jt=1,lt(f,m,w,_)}finally{jt=N,ue.transition=$}}function Ke(f,m,w,_){var N=jt,$=ue.transition;ue.transition=null;try{jt=4,lt(f,m,w,_)}finally{jt=N,ue.transition=$}}function lt(f,m,w,_){if(fe){var N=Dt(f,m,w,_);if(N===null)db(f,m,_,ft,w),jn(f,_);else if(Wn(N,f,m,w,_))_.stopPropagation();else if(jn(f,_),m&4&&-1<kn.indexOf(f)){for(;N!==null;){var $=xm(N);if($!==null&&Qn($),$=Dt(f,m,w,_),$===null&&db(f,m,_,ft,w),$===N)break;N=$}N!==null&&_.stopPropagation()}else db(f,m,_,null,w)}}var ft=null;function Dt(f,m,w,_){if(ft=null,f=ht(_),f=_u(f),f!==null)if(m=pr(f),m===null)f=null;else if(w=m.tag,w===13){if(f=Co(m),f!==null)return f;f=null}else if(w===3){if(m.stateNode.current.memoizedState.isDehydrated)return m.tag===3?m.stateNode.containerInfo:null;f=null}else m!==f&&(f=null);return ft=f,null}function Ft(f){switch(f){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Bn()){case _n:return 1;case En:return 4;case fs:case ws:return 16;case Ws:return 536870912;default:return 16}default:return 16}}var Bt=null,Ln=null,qn=null;function As(){if(qn)return qn;var f,m=Ln,w=m.length,_,N="value"in Bt?Bt.value:Bt.textContent,$=N.length;for(f=0;f<w&&m[f]===N[f];f++);var te=w-f;for(_=1;_<=te&&m[w-_]===N[$-_];_++);return qn=N.slice(f,1<_?1-_:void 0)}function Rs(f){var m=f.keyCode;return"charCode"in f?(f=f.charCode,f===0&&m===13&&(f=13)):f=m,f===10&&(f=13),32<=f||f===13?f:0}function Ni(){return!0}function zr(){return!1}function zs(f){function m(w,_,N,$,te){this._reactName=w,this._targetInst=N,this.type=_,this.nativeEvent=$,this.target=te,this.currentTarget=null;for(var me in f)f.hasOwnProperty(me)&&(w=f[me],this[me]=w?w($):$[me]);return this.isDefaultPrevented=($.defaultPrevented!=null?$.defaultPrevented:$.returnValue===!1)?Ni:zr,this.isPropagationStopped=zr,this}return ne(m.prototype,{preventDefault:function(){this.defaultPrevented=!0;var w=this.nativeEvent;w&&(w.preventDefault?w.preventDefault():typeof w.returnValue!="unknown"&&(w.returnValue=!1),this.isDefaultPrevented=Ni)},stopPropagation:function(){var w=this.nativeEvent;w&&(w.stopPropagation?w.stopPropagation():typeof w.cancelBubble!="unknown"&&(w.cancelBubble=!0),this.isPropagationStopped=Ni)},persist:function(){},isPersistent:Ni}),m}var as={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(f){return f.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Ti=zs(as),io=ne({},as,{view:0,detail:0}),Ll=zs(io),nh,Ha,ja,yc=ne({},io,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:eb,button:0,buttons:0,relatedTarget:function(f){return f.relatedTarget===void 0?f.fromElement===f.srcElement?f.toElement:f.fromElement:f.relatedTarget},movementX:function(f){return"movementX"in f?f.movementX:(f!==ja&&(ja&&f.type==="mousemove"?(nh=f.screenX-ja.screenX,Ha=f.screenY-ja.screenY):Ha=nh=0,ja=f),nh)},movementY:function(f){return"movementY"in f?f.movementY:Ha}}),GI=zs(yc),HV=ne({},yc,{dataTransfer:0}),jV=zs(HV),XV=ne({},io,{relatedTarget:0}),Jw=zs(XV),qV=ne({},as,{animationName:0,elapsedTime:0,pseudoElement:0}),KV=zs(qV),YV=ne({},as,{clipboardData:function(f){return"clipboardData"in f?f.clipboardData:window.clipboardData}}),ZV=zs(YV),QV=ne({},as,{data:0}),HI=zs(QV),JV={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},e7={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},t7={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function n7(f){var m=this.nativeEvent;return m.getModifierState?m.getModifierState(f):(f=t7[f])?!!m[f]:!1}function eb(){return n7}var s7=ne({},io,{key:function(f){if(f.key){var m=JV[f.key]||f.key;if(m!=="Unidentified")return m}return f.type==="keypress"?(f=Rs(f),f===13?"Enter":String.fromCharCode(f)):f.type==="keydown"||f.type==="keyup"?e7[f.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:eb,charCode:function(f){return f.type==="keypress"?Rs(f):0},keyCode:function(f){return f.type==="keydown"||f.type==="keyup"?f.keyCode:0},which:function(f){return f.type==="keypress"?Rs(f):f.type==="keydown"||f.type==="keyup"?f.keyCode:0}}),i7=zs(s7),r7=ne({},yc,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),jI=zs(r7),o7=ne({},io,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:eb}),a7=zs(o7),l7=ne({},as,{propertyName:0,elapsedTime:0,pseudoElement:0}),c7=zs(l7),u7=ne({},yc,{deltaX:function(f){return"deltaX"in f?f.deltaX:"wheelDeltaX"in f?-f.wheelDeltaX:0},deltaY:function(f){return"deltaY"in f?f.deltaY:"wheelDeltaY"in f?-f.wheelDeltaY:"wheelDelta"in f?-f.wheelDelta:0},deltaZ:0,deltaMode:0}),d7=zs(u7),h7=[9,13,27,32],tb=a&&"CompositionEvent"in window,lm=null;a&&"documentMode"in document&&(lm=document.documentMode);var f7=a&&"TextEvent"in window&&!lm,XI=a&&(!tb||lm&&8<lm&&11>=lm),qI=" ",KI=!1;function YI(f,m){switch(f){case"keyup":return h7.indexOf(m.keyCode)!==-1;case"keydown":return m.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ZI(f){return f=f.detail,typeof f=="object"&&"data"in f?f.data:null}var sh=!1;function p7(f,m){switch(f){case"compositionend":return ZI(m);case"keypress":return m.which!==32?null:(KI=!0,qI);case"textInput":return f=m.data,f===qI&&KI?null:f;default:return null}}function m7(f,m){if(sh)return f==="compositionend"||!tb&&YI(f,m)?(f=As(),qn=Ln=Bt=null,sh=!1,f):null;switch(f){case"paste":return null;case"keypress":if(!(m.ctrlKey||m.altKey||m.metaKey)||m.ctrlKey&&m.altKey){if(m.char&&1<m.char.length)return m.char;if(m.which)return String.fromCharCode(m.which)}return null;case"compositionend":return XI&&m.locale!=="ko"?null:m.data;default:return null}}var g7={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function QI(f){var m=f&&f.nodeName&&f.nodeName.toLowerCase();return m==="input"?!!g7[f.type]:m==="textarea"}function JI(f,m,w,_){Be(_),m=L1(m,"onChange"),0<m.length&&(w=new Ti("onChange","change",null,w,_),f.push({event:w,listeners:m}))}var cm=null,um=null;function x7(f){x4(f,0)}function M1(f){var m=lh(f);if(Ee(m))return f}function v7(f,m){if(f==="change")return m}var e4=!1;if(a){var nb;if(a){var sb="oninput"in document;if(!sb){var t4=document.createElement("div");t4.setAttribute("oninput","return;"),sb=typeof t4.oninput=="function"}nb=sb}else nb=!1;e4=nb&&(!document.documentMode||9<document.documentMode)}function n4(){cm&&(cm.detachEvent("onpropertychange",s4),um=cm=null)}function s4(f){if(f.propertyName==="value"&&M1(um)){var m=[];JI(m,um,f,ht(f)),_s(x7,m)}}function y7(f,m,w){f==="focusin"?(n4(),cm=m,um=w,cm.attachEvent("onpropertychange",s4)):f==="focusout"&&n4()}function w7(f){if(f==="selectionchange"||f==="keyup"||f==="keydown")return M1(um)}function b7(f,m){if(f==="click")return M1(m)}function S7(f,m){if(f==="input"||f==="change")return M1(m)}function C7(f,m){return f===m&&(f!==0||1/f===1/m)||f!==f&&m!==m}var da=typeof Object.is=="function"?Object.is:C7;function dm(f,m){if(da(f,m))return!0;if(typeof f!="object"||f===null||typeof m!="object"||m===null)return!1;var w=Object.keys(f),_=Object.keys(m);if(w.length!==_.length)return!1;for(_=0;_<w.length;_++){var N=w[_];if(!l.call(m,N)||!da(f[N],m[N]))return!1}return!0}function i4(f){for(;f&&f.firstChild;)f=f.firstChild;return f}function r4(f,m){var w=i4(f);f=0;for(var _;w;){if(w.nodeType===3){if(_=f+w.textContent.length,f<=m&&_>=m)return{node:w,offset:m-f};f=_}e:{for(;w;){if(w.nextSibling){w=w.nextSibling;break e}w=w.parentNode}w=void 0}w=i4(w)}}function o4(f,m){return f&&m?f===m?!0:f&&f.nodeType===3?!1:m&&m.nodeType===3?o4(f,m.parentNode):"contains"in f?f.contains(m):f.compareDocumentPosition?!!(f.compareDocumentPosition(m)&16):!1:!1}function a4(){for(var f=window,m=nn();m instanceof f.HTMLIFrameElement;){try{var w=typeof m.contentWindow.location.href=="string"}catch{w=!1}if(w)f=m.contentWindow;else break;m=nn(f.document)}return m}function ib(f){var m=f&&f.nodeName&&f.nodeName.toLowerCase();return m&&(m==="input"&&(f.type==="text"||f.type==="search"||f.type==="tel"||f.type==="url"||f.type==="password")||m==="textarea"||f.contentEditable==="true")}function _7(f){var m=a4(),w=f.focusedElem,_=f.selectionRange;if(m!==w&&w&&w.ownerDocument&&o4(w.ownerDocument.documentElement,w)){if(_!==null&&ib(w)){if(m=_.start,f=_.end,f===void 0&&(f=m),"selectionStart"in w)w.selectionStart=m,w.selectionEnd=Math.min(f,w.value.length);else if(f=(m=w.ownerDocument||document)&&m.defaultView||window,f.getSelection){f=f.getSelection();var N=w.textContent.length,$=Math.min(_.start,N);_=_.end===void 0?$:Math.min(_.end,N),!f.extend&&$>_&&(N=_,_=$,$=N),N=r4(w,$);var te=r4(w,_);N&&te&&(f.rangeCount!==1||f.anchorNode!==N.node||f.anchorOffset!==N.offset||f.focusNode!==te.node||f.focusOffset!==te.offset)&&(m=m.createRange(),m.setStart(N.node,N.offset),f.removeAllRanges(),$>_?(f.addRange(m),f.extend(te.node,te.offset)):(m.setEnd(te.node,te.offset),f.addRange(m)))}}for(m=[],f=w;f=f.parentNode;)f.nodeType===1&&m.push({element:f,left:f.scrollLeft,top:f.scrollTop});for(typeof w.focus=="function"&&w.focus(),w=0;w<m.length;w++)f=m[w],f.element.scrollLeft=f.left,f.element.scrollTop=f.top}}var E7=a&&"documentMode"in document&&11>=document.documentMode,ih=null,rb=null,hm=null,ob=!1;function l4(f,m,w){var _=w.window===w?w.document:w.nodeType===9?w:w.ownerDocument;ob||ih==null||ih!==nn(_)||(_=ih,"selectionStart"in _&&ib(_)?_={start:_.selectionStart,end:_.selectionEnd}:(_=(_.ownerDocument&&_.ownerDocument.defaultView||window).getSelection(),_={anchorNode:_.anchorNode,anchorOffset:_.anchorOffset,focusNode:_.focusNode,focusOffset:_.focusOffset}),hm&&dm(hm,_)||(hm=_,_=L1(rb,"onSelect"),0<_.length&&(m=new Ti("onSelect","select",null,m,w),f.push({event:m,listeners:_}),m.target=ih)))}function N1(f,m){var w={};return w[f.toLowerCase()]=m.toLowerCase(),w["Webkit"+f]="webkit"+m,w["Moz"+f]="moz"+m,w}var rh={animationend:N1("Animation","AnimationEnd"),animationiteration:N1("Animation","AnimationIteration"),animationstart:N1("Animation","AnimationStart"),transitionend:N1("Transition","TransitionEnd")},ab={},c4={};a&&(c4=document.createElement("div").style,"AnimationEvent"in window||(delete rh.animationend.animation,delete rh.animationiteration.animation,delete rh.animationstart.animation),"TransitionEvent"in window||delete rh.transitionend.transition);function P1(f){if(ab[f])return ab[f];if(!rh[f])return f;var m=rh[f],w;for(w in m)if(m.hasOwnProperty(w)&&w in c4)return ab[f]=m[w];return f}var u4=P1("animationend"),d4=P1("animationiteration"),h4=P1("animationstart"),f4=P1("transitionend"),p4=new Map,m4="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function wc(f,m){p4.set(f,m),r(m,[f])}for(var lb=0;lb<m4.length;lb++){var cb=m4[lb],T7=cb.toLowerCase(),I7=cb[0].toUpperCase()+cb.slice(1);wc(T7,"on"+I7)}wc(u4,"onAnimationEnd"),wc(d4,"onAnimationIteration"),wc(h4,"onAnimationStart"),wc("dblclick","onDoubleClick"),wc("focusin","onFocus"),wc("focusout","onBlur"),wc(f4,"onTransitionEnd"),o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),r("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),r("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),r("onBeforeInput",["compositionend","keypress","textInput","paste"]),r("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),r("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),r("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var fm="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),k7=new Set("cancel close invalid load scroll toggle".split(" ").concat(fm));function g4(f,m,w){var _=f.type||"unknown-event";f.currentTarget=w,so(_,m,void 0,f),f.currentTarget=null}function x4(f,m){m=(m&4)!==0;for(var w=0;w<f.length;w++){var _=f[w],N=_.event;_=_.listeners;e:{var $=void 0;if(m)for(var te=_.length-1;0<=te;te--){var me=_[te],_e=me.instance,et=me.currentTarget;if(me=me.listener,_e!==$&&N.isPropagationStopped())break e;g4(N,me,et),$=_e}else for(te=0;te<_.length;te++){if(me=_[te],_e=me.instance,et=me.currentTarget,me=me.listener,_e!==$&&N.isPropagationStopped())break e;g4(N,me,et),$=_e}}}if(Ri)throw f=fr,Ri=!1,fr=null,f}function ei(f,m){var w=m[xb];w===void 0&&(w=m[xb]=new Set);var _=f+"__bubble";w.has(_)||(v4(m,f,2,!1),w.add(_))}function ub(f,m,w){var _=0;m&&(_|=4),v4(w,f,_,m)}var D1="_reactListening"+Math.random().toString(36).slice(2);function pm(f){if(!f[D1]){f[D1]=!0,s.forEach(function(w){w!=="selectionchange"&&(k7.has(w)||ub(w,!1,f),ub(w,!0,f))});var m=f.nodeType===9?f:f.ownerDocument;m===null||m[D1]||(m[D1]=!0,ub("selectionchange",!1,m))}}function v4(f,m,w,_){switch(Ft(m)){case 1:var N=we;break;case 4:N=Ke;break;default:N=lt}w=N.bind(null,m,w,f),N=void 0,!hs||m!=="touchstart"&&m!=="touchmove"&&m!=="wheel"||(N=!0),_?N!==void 0?f.addEventListener(m,w,{capture:!0,passive:N}):f.addEventListener(m,w,!0):N!==void 0?f.addEventListener(m,w,{passive:N}):f.addEventListener(m,w,!1)}function db(f,m,w,_,N){var $=_;if((m&1)===0&&(m&2)===0&&_!==null)e:for(;;){if(_===null)return;var te=_.tag;if(te===3||te===4){var me=_.stateNode.containerInfo;if(me===N||me.nodeType===8&&me.parentNode===N)break;if(te===4)for(te=_.return;te!==null;){var _e=te.tag;if((_e===3||_e===4)&&(_e=te.stateNode.containerInfo,_e===N||_e.nodeType===8&&_e.parentNode===N))return;te=te.return}for(;me!==null;){if(te=_u(me),te===null)return;if(_e=te.tag,_e===5||_e===6){_=$=te;continue e}me=me.parentNode}}_=_.return}_s(function(){var et=$,_t=ht(w),Nt=[];e:{var Ct=p4.get(f);if(Ct!==void 0){var tn=Ti,hn=f;switch(f){case"keypress":if(Rs(w)===0)break e;case"keydown":case"keyup":tn=i7;break;case"focusin":hn="focus",tn=Jw;break;case"focusout":hn="blur",tn=Jw;break;case"beforeblur":case"afterblur":tn=Jw;break;case"click":if(w.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":tn=GI;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":tn=jV;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":tn=a7;break;case u4:case d4:case h4:tn=KV;break;case f4:tn=c7;break;case"scroll":tn=Ll;break;case"wheel":tn=d7;break;case"copy":case"cut":case"paste":tn=ZV;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":tn=jI}var xn=(m&4)!==0,Ii=!xn&&f==="scroll",He=xn?Ct!==null?Ct+"Capture":null:Ct;xn=[];for(var Me=et,qe;Me!==null;){qe=Me;var Lt=qe.stateNode;if(qe.tag===5&&Lt!==null&&(qe=Lt,He!==null&&(Lt=ns(Me,He),Lt!=null&&xn.push(mm(Me,Lt,qe)))),Ii)break;Me=Me.return}0<xn.length&&(Ct=new tn(Ct,hn,null,w,_t),Nt.push({event:Ct,listeners:xn}))}}if((m&7)===0){e:{if(Ct=f==="mouseover"||f==="pointerover",tn=f==="mouseout"||f==="pointerout",Ct&&w!==Wt&&(hn=w.relatedTarget||w.fromElement)&&(_u(hn)||hn[$l]))break e;if((tn||Ct)&&(Ct=_t.window===_t?_t:(Ct=_t.ownerDocument)?Ct.defaultView||Ct.parentWindow:window,tn?(hn=w.relatedTarget||w.toElement,tn=et,hn=hn?_u(hn):null,hn!==null&&(Ii=pr(hn),hn!==Ii||hn.tag!==5&&hn.tag!==6)&&(hn=null)):(tn=null,hn=et),tn!==hn)){if(xn=GI,Lt="onMouseLeave",He="onMouseEnter",Me="mouse",(f==="pointerout"||f==="pointerover")&&(xn=jI,Lt="onPointerLeave",He="onPointerEnter",Me="pointer"),Ii=tn==null?Ct:lh(tn),qe=hn==null?Ct:lh(hn),Ct=new xn(Lt,Me+"leave",tn,w,_t),Ct.target=Ii,Ct.relatedTarget=qe,Lt=null,_u(_t)===et&&(xn=new xn(He,Me+"enter",hn,w,_t),xn.target=qe,xn.relatedTarget=Ii,Lt=xn),Ii=Lt,tn&&hn)t:{for(xn=tn,He=hn,Me=0,qe=xn;qe;qe=oh(qe))Me++;for(qe=0,Lt=He;Lt;Lt=oh(Lt))qe++;for(;0<Me-qe;)xn=oh(xn),Me--;for(;0<qe-Me;)He=oh(He),qe--;for(;Me--;){if(xn===He||He!==null&&xn===He.alternate)break t;xn=oh(xn),He=oh(He)}xn=null}else xn=null;tn!==null&&y4(Nt,Ct,tn,xn,!1),hn!==null&&Ii!==null&&y4(Nt,Ii,hn,xn,!0)}}e:{if(Ct=et?lh(et):window,tn=Ct.nodeName&&Ct.nodeName.toLowerCase(),tn==="select"||tn==="input"&&Ct.type==="file")var yn=v7;else if(QI(Ct))if(e4)yn=S7;else{yn=w7;var An=y7}else(tn=Ct.nodeName)&&tn.toLowerCase()==="input"&&(Ct.type==="checkbox"||Ct.type==="radio")&&(yn=b7);if(yn&&(yn=yn(f,et))){JI(Nt,yn,w,_t);break e}An&&An(f,Ct,et),f==="focusout"&&(An=Ct._wrapperState)&&An.controlled&&Ct.type==="number"&&zt(Ct,"number",Ct.value)}switch(An=et?lh(et):window,f){case"focusin":(QI(An)||An.contentEditable==="true")&&(ih=An,rb=et,hm=null);break;case"focusout":hm=rb=ih=null;break;case"mousedown":ob=!0;break;case"contextmenu":case"mouseup":case"dragend":ob=!1,l4(Nt,w,_t);break;case"selectionchange":if(E7)break;case"keydown":case"keyup":l4(Nt,w,_t)}var Rn;if(tb)e:{switch(f){case"compositionstart":var Gn="onCompositionStart";break e;case"compositionend":Gn="onCompositionEnd";break e;case"compositionupdate":Gn="onCompositionUpdate";break e}Gn=void 0}else sh?YI(f,w)&&(Gn="onCompositionEnd"):f==="keydown"&&w.keyCode===229&&(Gn="onCompositionStart");Gn&&(XI&&w.locale!=="ko"&&(sh||Gn!=="onCompositionStart"?Gn==="onCompositionEnd"&&sh&&(Rn=As()):(Bt=_t,Ln="value"in Bt?Bt.value:Bt.textContent,sh=!0)),An=L1(et,Gn),0<An.length&&(Gn=new HI(Gn,f,null,w,_t),Nt.push({event:Gn,listeners:An}),Rn?Gn.data=Rn:(Rn=ZI(w),Rn!==null&&(Gn.data=Rn)))),(Rn=f7?p7(f,w):m7(f,w))&&(et=L1(et,"onBeforeInput"),0<et.length&&(_t=new HI("onBeforeInput","beforeinput",null,w,_t),Nt.push({event:_t,listeners:et}),_t.data=Rn))}x4(Nt,m)})}function mm(f,m,w){return{instance:f,listener:m,currentTarget:w}}function L1(f,m){for(var w=m+"Capture",_=[];f!==null;){var N=f,$=N.stateNode;N.tag===5&&$!==null&&(N=$,$=ns(f,w),$!=null&&_.unshift(mm(f,$,N)),$=ns(f,m),$!=null&&_.push(mm(f,$,N))),f=f.return}return _}function oh(f){if(f===null)return null;do f=f.return;while(f&&f.tag!==5);return f||null}function y4(f,m,w,_,N){for(var $=m._reactName,te=[];w!==null&&w!==_;){var me=w,_e=me.alternate,et=me.stateNode;if(_e!==null&&_e===_)break;me.tag===5&&et!==null&&(me=et,N?(_e=ns(w,$),_e!=null&&te.unshift(mm(w,_e,me))):N||(_e=ns(w,$),_e!=null&&te.push(mm(w,_e,me)))),w=w.return}te.length!==0&&f.push({event:m,listeners:te})}var A7=/\r\n?/g,R7=/\u0000|\uFFFD/g;function w4(f){return(typeof f=="string"?f:""+f).replace(A7,`
`).replace(R7,"")}function $1(f,m,w){if(m=w4(m),w4(f)!==m&&w)throw Error(t(425))}function F1(){}var hb=null,fb=null;function pb(f,m){return f==="textarea"||f==="noscript"||typeof m.children=="string"||typeof m.children=="number"||typeof m.dangerouslySetInnerHTML=="object"&&m.dangerouslySetInnerHTML!==null&&m.dangerouslySetInnerHTML.__html!=null}var mb=typeof setTimeout=="function"?setTimeout:void 0,M7=typeof clearTimeout=="function"?clearTimeout:void 0,b4=typeof Promise=="function"?Promise:void 0,N7=typeof queueMicrotask=="function"?queueMicrotask:typeof b4<"u"?function(f){return b4.resolve(null).then(f).catch(P7)}:mb;function P7(f){setTimeout(function(){throw f})}function gb(f,m){var w=m,_=0;do{var N=w.nextSibling;if(f.removeChild(w),N&&N.nodeType===8)if(w=N.data,w==="/$"){if(_===0){f.removeChild(N),de(m);return}_--}else w!=="$"&&w!=="$?"&&w!=="$!"||_++;w=N}while(w);de(m)}function bc(f){for(;f!=null;f=f.nextSibling){var m=f.nodeType;if(m===1||m===3)break;if(m===8){if(m=f.data,m==="$"||m==="$!"||m==="$?")break;if(m==="/$")return null}}return f}function S4(f){f=f.previousSibling;for(var m=0;f;){if(f.nodeType===8){var w=f.data;if(w==="$"||w==="$!"||w==="$?"){if(m===0)return f;m--}else w==="/$"&&m++}f=f.previousSibling}return null}var ah=Math.random().toString(36).slice(2),Xa="__reactFiber$"+ah,gm="__reactProps$"+ah,$l="__reactContainer$"+ah,xb="__reactEvents$"+ah,D7="__reactListeners$"+ah,L7="__reactHandles$"+ah;function _u(f){var m=f[Xa];if(m)return m;for(var w=f.parentNode;w;){if(m=w[$l]||w[Xa]){if(w=m.alternate,m.child!==null||w!==null&&w.child!==null)for(f=S4(f);f!==null;){if(w=f[Xa])return w;f=S4(f)}return m}f=w,w=f.parentNode}return null}function xm(f){return f=f[Xa]||f[$l],!f||f.tag!==5&&f.tag!==6&&f.tag!==13&&f.tag!==3?null:f}function lh(f){if(f.tag===5||f.tag===6)return f.stateNode;throw Error(t(33))}function O1(f){return f[gm]||null}var vb=[],ch=-1;function Sc(f){return{current:f}}function ti(f){0>ch||(f.current=vb[ch],vb[ch]=null,ch--)}function Zs(f,m){ch++,vb[ch]=f.current,f.current=m}var Cc={},_r=Sc(Cc),ro=Sc(!1),Eu=Cc;function uh(f,m){var w=f.type.contextTypes;if(!w)return Cc;var _=f.stateNode;if(_&&_.__reactInternalMemoizedUnmaskedChildContext===m)return _.__reactInternalMemoizedMaskedChildContext;var N={},$;for($ in w)N[$]=m[$];return _&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=m,f.__reactInternalMemoizedMaskedChildContext=N),N}function oo(f){return f=f.childContextTypes,f!=null}function z1(){ti(ro),ti(_r)}function C4(f,m,w){if(_r.current!==Cc)throw Error(t(168));Zs(_r,m),Zs(ro,w)}function _4(f,m,w){var _=f.stateNode;if(m=m.childContextTypes,typeof _.getChildContext!="function")return w;_=_.getChildContext();for(var N in _)if(!(N in m))throw Error(t(108,Xe(f)||"Unknown",N));return ne({},w,_)}function B1(f){return f=(f=f.stateNode)&&f.__reactInternalMemoizedMergedChildContext||Cc,Eu=_r.current,Zs(_r,f),Zs(ro,ro.current),!0}function E4(f,m,w){var _=f.stateNode;if(!_)throw Error(t(169));w?(f=_4(f,m,Eu),_.__reactInternalMemoizedMergedChildContext=f,ti(ro),ti(_r),Zs(_r,f)):ti(ro),Zs(ro,w)}var Fl=null,U1=!1,yb=!1;function T4(f){Fl===null?Fl=[f]:Fl.push(f)}function $7(f){U1=!0,T4(f)}function _c(){if(!yb&&Fl!==null){yb=!0;var f=0,m=jt;try{var w=Fl;for(jt=1;f<w.length;f++){var _=w[f];do _=_(!0);while(_!==null)}Fl=null,U1=!1}catch(N){throw Fl!==null&&(Fl=Fl.slice(f+1)),nt(_n,_c),N}finally{jt=m,yb=!1}}return null}var dh=[],hh=0,V1=null,W1=0,Uo=[],Vo=0,Tu=null,Ol=1,zl="";function Iu(f,m){dh[hh++]=W1,dh[hh++]=V1,V1=f,W1=m}function I4(f,m,w){Uo[Vo++]=Ol,Uo[Vo++]=zl,Uo[Vo++]=Tu,Tu=f;var _=Ol;f=zl;var N=32-Ss(_)-1;_&=~(1<<N),w+=1;var $=32-Ss(m)+N;if(30<$){var te=N-N%5;$=(_&(1<<te)-1).toString(32),_>>=te,N-=te,Ol=1<<32-Ss(m)+N|w<<N|_,zl=$+f}else Ol=1<<$|w<<N|_,zl=f}function wb(f){f.return!==null&&(Iu(f,1),I4(f,1,0))}function bb(f){for(;f===V1;)V1=dh[--hh],dh[hh]=null,W1=dh[--hh],dh[hh]=null;for(;f===Tu;)Tu=Uo[--Vo],Uo[Vo]=null,zl=Uo[--Vo],Uo[Vo]=null,Ol=Uo[--Vo],Uo[Vo]=null}var _o=null,Eo=null,oi=!1,ha=null;function k4(f,m){var w=jo(5,null,null,0);w.elementType="DELETED",w.stateNode=m,w.return=f,m=f.deletions,m===null?(f.deletions=[w],f.flags|=16):m.push(w)}function A4(f,m){switch(f.tag){case 5:var w=f.type;return m=m.nodeType!==1||w.toLowerCase()!==m.nodeName.toLowerCase()?null:m,m!==null?(f.stateNode=m,_o=f,Eo=bc(m.firstChild),!0):!1;case 6:return m=f.pendingProps===""||m.nodeType!==3?null:m,m!==null?(f.stateNode=m,_o=f,Eo=null,!0):!1;case 13:return m=m.nodeType!==8?null:m,m!==null?(w=Tu!==null?{id:Ol,overflow:zl}:null,f.memoizedState={dehydrated:m,treeContext:w,retryLane:1073741824},w=jo(18,null,null,0),w.stateNode=m,w.return=f,f.child=w,_o=f,Eo=null,!0):!1;default:return!1}}function Sb(f){return(f.mode&1)!==0&&(f.flags&128)===0}function Cb(f){if(oi){var m=Eo;if(m){var w=m;if(!A4(f,m)){if(Sb(f))throw Error(t(418));m=bc(w.nextSibling);var _=_o;m&&A4(f,m)?k4(_,w):(f.flags=f.flags&-4097|2,oi=!1,_o=f)}}else{if(Sb(f))throw Error(t(418));f.flags=f.flags&-4097|2,oi=!1,_o=f}}}function R4(f){for(f=f.return;f!==null&&f.tag!==5&&f.tag!==3&&f.tag!==13;)f=f.return;_o=f}function G1(f){if(f!==_o)return!1;if(!oi)return R4(f),oi=!0,!1;var m;if((m=f.tag!==3)&&!(m=f.tag!==5)&&(m=f.type,m=m!=="head"&&m!=="body"&&!pb(f.type,f.memoizedProps)),m&&(m=Eo)){if(Sb(f))throw M4(),Error(t(418));for(;m;)k4(f,m),m=bc(m.nextSibling)}if(R4(f),f.tag===13){if(f=f.memoizedState,f=f!==null?f.dehydrated:null,!f)throw Error(t(317));e:{for(f=f.nextSibling,m=0;f;){if(f.nodeType===8){var w=f.data;if(w==="/$"){if(m===0){Eo=bc(f.nextSibling);break e}m--}else w!=="$"&&w!=="$!"&&w!=="$?"||m++}f=f.nextSibling}Eo=null}}else Eo=_o?bc(f.stateNode.nextSibling):null;return!0}function M4(){for(var f=Eo;f;)f=bc(f.nextSibling)}function fh(){Eo=_o=null,oi=!1}function _b(f){ha===null?ha=[f]:ha.push(f)}var F7=C.ReactCurrentBatchConfig;function vm(f,m,w){if(f=w.ref,f!==null&&typeof f!="function"&&typeof f!="object"){if(w._owner){if(w=w._owner,w){if(w.tag!==1)throw Error(t(309));var _=w.stateNode}if(!_)throw Error(t(147,f));var N=_,$=""+f;return m!==null&&m.ref!==null&&typeof m.ref=="function"&&m.ref._stringRef===$?m.ref:(m=function(te){var me=N.refs;te===null?delete me[$]:me[$]=te},m._stringRef=$,m)}if(typeof f!="string")throw Error(t(284));if(!w._owner)throw Error(t(290,f))}return f}function H1(f,m){throw f=Object.prototype.toString.call(m),Error(t(31,f==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":f))}function N4(f){var m=f._init;return m(f._payload)}function P4(f){function m(He,Me){if(f){var qe=He.deletions;qe===null?(He.deletions=[Me],He.flags|=16):qe.push(Me)}}function w(He,Me){if(!f)return null;for(;Me!==null;)m(He,Me),Me=Me.sibling;return null}function _(He,Me){for(He=new Map;Me!==null;)Me.key!==null?He.set(Me.key,Me):He.set(Me.index,Me),Me=Me.sibling;return He}function N(He,Me){return He=Nc(He,Me),He.index=0,He.sibling=null,He}function $(He,Me,qe){return He.index=qe,f?(qe=He.alternate,qe!==null?(qe=qe.index,qe<Me?(He.flags|=2,Me):qe):(He.flags|=2,Me)):(He.flags|=1048576,Me)}function te(He){return f&&He.alternate===null&&(He.flags|=2),He}function me(He,Me,qe,Lt){return Me===null||Me.tag!==6?(Me=m3(qe,He.mode,Lt),Me.return=He,Me):(Me=N(Me,qe),Me.return=He,Me)}function _e(He,Me,qe,Lt){var yn=qe.type;return yn===R?_t(He,Me,qe.props.children,Lt,qe.key):Me!==null&&(Me.elementType===yn||typeof yn=="object"&&yn!==null&&yn.$$typeof===B&&N4(yn)===Me.type)?(Lt=N(Me,qe.props),Lt.ref=vm(He,Me,qe),Lt.return=He,Lt):(Lt=mx(qe.type,qe.key,qe.props,null,He.mode,Lt),Lt.ref=vm(He,Me,qe),Lt.return=He,Lt)}function et(He,Me,qe,Lt){return Me===null||Me.tag!==4||Me.stateNode.containerInfo!==qe.containerInfo||Me.stateNode.implementation!==qe.implementation?(Me=g3(qe,He.mode,Lt),Me.return=He,Me):(Me=N(Me,qe.children||[]),Me.return=He,Me)}function _t(He,Me,qe,Lt,yn){return Me===null||Me.tag!==7?(Me=Lu(qe,He.mode,Lt,yn),Me.return=He,Me):(Me=N(Me,qe),Me.return=He,Me)}function Nt(He,Me,qe){if(typeof Me=="string"&&Me!==""||typeof Me=="number")return Me=m3(""+Me,He.mode,qe),Me.return=He,Me;if(typeof Me=="object"&&Me!==null){switch(Me.$$typeof){case E:return qe=mx(Me.type,Me.key,Me.props,null,He.mode,qe),qe.ref=vm(He,null,Me),qe.return=He,qe;case k:return Me=g3(Me,He.mode,qe),Me.return=He,Me;case B:var Lt=Me._init;return Nt(He,Lt(Me._payload),qe)}if(Gt(Me)||ee(Me))return Me=Lu(Me,He.mode,qe,null),Me.return=He,Me;H1(He,Me)}return null}function Ct(He,Me,qe,Lt){var yn=Me!==null?Me.key:null;if(typeof qe=="string"&&qe!==""||typeof qe=="number")return yn!==null?null:me(He,Me,""+qe,Lt);if(typeof qe=="object"&&qe!==null){switch(qe.$$typeof){case E:return qe.key===yn?_e(He,Me,qe,Lt):null;case k:return qe.key===yn?et(He,Me,qe,Lt):null;case B:return yn=qe._init,Ct(He,Me,yn(qe._payload),Lt)}if(Gt(qe)||ee(qe))return yn!==null?null:_t(He,Me,qe,Lt,null);H1(He,qe)}return null}function tn(He,Me,qe,Lt,yn){if(typeof Lt=="string"&&Lt!==""||typeof Lt=="number")return He=He.get(qe)||null,me(Me,He,""+Lt,yn);if(typeof Lt=="object"&&Lt!==null){switch(Lt.$$typeof){case E:return He=He.get(Lt.key===null?qe:Lt.key)||null,_e(Me,He,Lt,yn);case k:return He=He.get(Lt.key===null?qe:Lt.key)||null,et(Me,He,Lt,yn);case B:var An=Lt._init;return tn(He,Me,qe,An(Lt._payload),yn)}if(Gt(Lt)||ee(Lt))return He=He.get(qe)||null,_t(Me,He,Lt,yn,null);H1(Me,Lt)}return null}function hn(He,Me,qe,Lt){for(var yn=null,An=null,Rn=Me,Gn=Me=0,ir=null;Rn!==null&&Gn<qe.length;Gn++){Rn.index>Gn?(ir=Rn,Rn=null):ir=Rn.sibling;var Es=Ct(He,Rn,qe[Gn],Lt);if(Es===null){Rn===null&&(Rn=ir);break}f&&Rn&&Es.alternate===null&&m(He,Rn),Me=$(Es,Me,Gn),An===null?yn=Es:An.sibling=Es,An=Es,Rn=ir}if(Gn===qe.length)return w(He,Rn),oi&&Iu(He,Gn),yn;if(Rn===null){for(;Gn<qe.length;Gn++)Rn=Nt(He,qe[Gn],Lt),Rn!==null&&(Me=$(Rn,Me,Gn),An===null?yn=Rn:An.sibling=Rn,An=Rn);return oi&&Iu(He,Gn),yn}for(Rn=_(He,Rn);Gn<qe.length;Gn++)ir=tn(Rn,He,Gn,qe[Gn],Lt),ir!==null&&(f&&ir.alternate!==null&&Rn.delete(ir.key===null?Gn:ir.key),Me=$(ir,Me,Gn),An===null?yn=ir:An.sibling=ir,An=ir);return f&&Rn.forEach(function(Pc){return m(He,Pc)}),oi&&Iu(He,Gn),yn}function xn(He,Me,qe,Lt){var yn=ee(qe);if(typeof yn!="function")throw Error(t(150));if(qe=yn.call(qe),qe==null)throw Error(t(151));for(var An=yn=null,Rn=Me,Gn=Me=0,ir=null,Es=qe.next();Rn!==null&&!Es.done;Gn++,Es=qe.next()){Rn.index>Gn?(ir=Rn,Rn=null):ir=Rn.sibling;var Pc=Ct(He,Rn,Es.value,Lt);if(Pc===null){Rn===null&&(Rn=ir);break}f&&Rn&&Pc.alternate===null&&m(He,Rn),Me=$(Pc,Me,Gn),An===null?yn=Pc:An.sibling=Pc,An=Pc,Rn=ir}if(Es.done)return w(He,Rn),oi&&Iu(He,Gn),yn;if(Rn===null){for(;!Es.done;Gn++,Es=qe.next())Es=Nt(He,Es.value,Lt),Es!==null&&(Me=$(Es,Me,Gn),An===null?yn=Es:An.sibling=Es,An=Es);return oi&&Iu(He,Gn),yn}for(Rn=_(He,Rn);!Es.done;Gn++,Es=qe.next())Es=tn(Rn,He,Gn,Es.value,Lt),Es!==null&&(f&&Es.alternate!==null&&Rn.delete(Es.key===null?Gn:Es.key),Me=$(Es,Me,Gn),An===null?yn=Es:An.sibling=Es,An=Es);return f&&Rn.forEach(function(g9){return m(He,g9)}),oi&&Iu(He,Gn),yn}function Ii(He,Me,qe,Lt){if(typeof qe=="object"&&qe!==null&&qe.type===R&&qe.key===null&&(qe=qe.props.children),typeof qe=="object"&&qe!==null){switch(qe.$$typeof){case E:e:{for(var yn=qe.key,An=Me;An!==null;){if(An.key===yn){if(yn=qe.type,yn===R){if(An.tag===7){w(He,An.sibling),Me=N(An,qe.props.children),Me.return=He,He=Me;break e}}else if(An.elementType===yn||typeof yn=="object"&&yn!==null&&yn.$$typeof===B&&N4(yn)===An.type){w(He,An.sibling),Me=N(An,qe.props),Me.ref=vm(He,An,qe),Me.return=He,He=Me;break e}w(He,An);break}else m(He,An);An=An.sibling}qe.type===R?(Me=Lu(qe.props.children,He.mode,Lt,qe.key),Me.return=He,He=Me):(Lt=mx(qe.type,qe.key,qe.props,null,He.mode,Lt),Lt.ref=vm(He,Me,qe),Lt.return=He,He=Lt)}return te(He);case k:e:{for(An=qe.key;Me!==null;){if(Me.key===An)if(Me.tag===4&&Me.stateNode.containerInfo===qe.containerInfo&&Me.stateNode.implementation===qe.implementation){w(He,Me.sibling),Me=N(Me,qe.children||[]),Me.return=He,He=Me;break e}else{w(He,Me);break}else m(He,Me);Me=Me.sibling}Me=g3(qe,He.mode,Lt),Me.return=He,He=Me}return te(He);case B:return An=qe._init,Ii(He,Me,An(qe._payload),Lt)}if(Gt(qe))return hn(He,Me,qe,Lt);if(ee(qe))return xn(He,Me,qe,Lt);H1(He,qe)}return typeof qe=="string"&&qe!==""||typeof qe=="number"?(qe=""+qe,Me!==null&&Me.tag===6?(w(He,Me.sibling),Me=N(Me,qe),Me.return=He,He=Me):(w(He,Me),Me=m3(qe,He.mode,Lt),Me.return=He,He=Me),te(He)):w(He,Me)}return Ii}var ph=P4(!0),D4=P4(!1),j1=Sc(null),X1=null,mh=null,Eb=null;function Tb(){Eb=mh=X1=null}function Ib(f){var m=j1.current;ti(j1),f._currentValue=m}function kb(f,m,w){for(;f!==null;){var _=f.alternate;if((f.childLanes&m)!==m?(f.childLanes|=m,_!==null&&(_.childLanes|=m)):_!==null&&(_.childLanes&m)!==m&&(_.childLanes|=m),f===w)break;f=f.return}}function gh(f,m){X1=f,Eb=mh=null,f=f.dependencies,f!==null&&f.firstContext!==null&&((f.lanes&m)!==0&&(ao=!0),f.firstContext=null)}function Wo(f){var m=f._currentValue;if(Eb!==f)if(f={context:f,memoizedValue:m,next:null},mh===null){if(X1===null)throw Error(t(308));mh=f,X1.dependencies={lanes:0,firstContext:f}}else mh=mh.next=f;return m}var ku=null;function Ab(f){ku===null?ku=[f]:ku.push(f)}function L4(f,m,w,_){var N=m.interleaved;return N===null?(w.next=w,Ab(m)):(w.next=N.next,N.next=w),m.interleaved=w,Bl(f,_)}function Bl(f,m){f.lanes|=m;var w=f.alternate;for(w!==null&&(w.lanes|=m),w=f,f=f.return;f!==null;)f.childLanes|=m,w=f.alternate,w!==null&&(w.childLanes|=m),w=f,f=f.return;return w.tag===3?w.stateNode:null}var Ec=!1;function Rb(f){f.updateQueue={baseState:f.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function $4(f,m){f=f.updateQueue,m.updateQueue===f&&(m.updateQueue={baseState:f.baseState,firstBaseUpdate:f.firstBaseUpdate,lastBaseUpdate:f.lastBaseUpdate,shared:f.shared,effects:f.effects})}function Ul(f,m){return{eventTime:f,lane:m,tag:0,payload:null,callback:null,next:null}}function Tc(f,m,w){var _=f.updateQueue;if(_===null)return null;if(_=_.shared,(Cs&2)!==0){var N=_.pending;return N===null?m.next=m:(m.next=N.next,N.next=m),_.pending=m,Bl(f,w)}return N=_.interleaved,N===null?(m.next=m,Ab(_)):(m.next=N.next,N.next=m),_.interleaved=m,Bl(f,w)}function q1(f,m,w){if(m=m.updateQueue,m!==null&&(m=m.shared,(w&4194240)!==0)){var _=m.lanes;_&=f.pendingLanes,w|=_,m.lanes=w,sn(f,w)}}function F4(f,m){var w=f.updateQueue,_=f.alternate;if(_!==null&&(_=_.updateQueue,w===_)){var N=null,$=null;if(w=w.firstBaseUpdate,w!==null){do{var te={eventTime:w.eventTime,lane:w.lane,tag:w.tag,payload:w.payload,callback:w.callback,next:null};$===null?N=$=te:$=$.next=te,w=w.next}while(w!==null);$===null?N=$=m:$=$.next=m}else N=$=m;w={baseState:_.baseState,firstBaseUpdate:N,lastBaseUpdate:$,shared:_.shared,effects:_.effects},f.updateQueue=w;return}f=w.lastBaseUpdate,f===null?w.firstBaseUpdate=m:f.next=m,w.lastBaseUpdate=m}function K1(f,m,w,_){var N=f.updateQueue;Ec=!1;var $=N.firstBaseUpdate,te=N.lastBaseUpdate,me=N.shared.pending;if(me!==null){N.shared.pending=null;var _e=me,et=_e.next;_e.next=null,te===null?$=et:te.next=et,te=_e;var _t=f.alternate;_t!==null&&(_t=_t.updateQueue,me=_t.lastBaseUpdate,me!==te&&(me===null?_t.firstBaseUpdate=et:me.next=et,_t.lastBaseUpdate=_e))}if($!==null){var Nt=N.baseState;te=0,_t=et=_e=null,me=$;do{var Ct=me.lane,tn=me.eventTime;if((_&Ct)===Ct){_t!==null&&(_t=_t.next={eventTime:tn,lane:0,tag:me.tag,payload:me.payload,callback:me.callback,next:null});e:{var hn=f,xn=me;switch(Ct=m,tn=w,xn.tag){case 1:if(hn=xn.payload,typeof hn=="function"){Nt=hn.call(tn,Nt,Ct);break e}Nt=hn;break e;case 3:hn.flags=hn.flags&-65537|128;case 0:if(hn=xn.payload,Ct=typeof hn=="function"?hn.call(tn,Nt,Ct):hn,Ct==null)break e;Nt=ne({},Nt,Ct);break e;case 2:Ec=!0}}me.callback!==null&&me.lane!==0&&(f.flags|=64,Ct=N.effects,Ct===null?N.effects=[me]:Ct.push(me))}else tn={eventTime:tn,lane:Ct,tag:me.tag,payload:me.payload,callback:me.callback,next:null},_t===null?(et=_t=tn,_e=Nt):_t=_t.next=tn,te|=Ct;if(me=me.next,me===null){if(me=N.shared.pending,me===null)break;Ct=me,me=Ct.next,Ct.next=null,N.lastBaseUpdate=Ct,N.shared.pending=null}}while(!0);if(_t===null&&(_e=Nt),N.baseState=_e,N.firstBaseUpdate=et,N.lastBaseUpdate=_t,m=N.shared.interleaved,m!==null){N=m;do te|=N.lane,N=N.next;while(N!==m)}else $===null&&(N.shared.lanes=0);Mu|=te,f.lanes=te,f.memoizedState=Nt}}function O4(f,m,w){if(f=m.effects,m.effects=null,f!==null)for(m=0;m<f.length;m++){var _=f[m],N=_.callback;if(N!==null){if(_.callback=null,_=w,typeof N!="function")throw Error(t(191,N));N.call(_)}}}var ym={},qa=Sc(ym),wm=Sc(ym),bm=Sc(ym);function Au(f){if(f===ym)throw Error(t(174));return f}function Mb(f,m){switch(Zs(bm,m),Zs(wm,f),Zs(qa,ym),f=m.nodeType,f){case 9:case 11:m=(m=m.documentElement)?m.namespaceURI:tt(null,"");break;default:f=f===8?m.parentNode:m,m=f.namespaceURI||null,f=f.tagName,m=tt(m,f)}ti(qa),Zs(qa,m)}function xh(){ti(qa),ti(wm),ti(bm)}function z4(f){Au(bm.current);var m=Au(qa.current),w=tt(m,f.type);m!==w&&(Zs(wm,f),Zs(qa,w))}function Nb(f){wm.current===f&&(ti(qa),ti(wm))}var ci=Sc(0);function Y1(f){for(var m=f;m!==null;){if(m.tag===13){var w=m.memoizedState;if(w!==null&&(w=w.dehydrated,w===null||w.data==="$?"||w.data==="$!"))return m}else if(m.tag===19&&m.memoizedProps.revealOrder!==void 0){if((m.flags&128)!==0)return m}else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===f)break;for(;m.sibling===null;){if(m.return===null||m.return===f)return null;m=m.return}m.sibling.return=m.return,m=m.sibling}return null}var Pb=[];function Db(){for(var f=0;f<Pb.length;f++)Pb[f]._workInProgressVersionPrimary=null;Pb.length=0}var Z1=C.ReactCurrentDispatcher,Lb=C.ReactCurrentBatchConfig,Ru=0,ui=null,Hi=null,nr=null,Q1=!1,Sm=!1,Cm=0,O7=0;function Er(){throw Error(t(321))}function $b(f,m){if(m===null)return!1;for(var w=0;w<m.length&&w<f.length;w++)if(!da(f[w],m[w]))return!1;return!0}function Fb(f,m,w,_,N,$){if(Ru=$,ui=m,m.memoizedState=null,m.updateQueue=null,m.lanes=0,Z1.current=f===null||f.memoizedState===null?V7:W7,f=w(_,N),Sm){$=0;do{if(Sm=!1,Cm=0,25<=$)throw Error(t(301));$+=1,nr=Hi=null,m.updateQueue=null,Z1.current=G7,f=w(_,N)}while(Sm)}if(Z1.current=tx,m=Hi!==null&&Hi.next!==null,Ru=0,nr=Hi=ui=null,Q1=!1,m)throw Error(t(300));return f}function Ob(){var f=Cm!==0;return Cm=0,f}function Ka(){var f={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return nr===null?ui.memoizedState=nr=f:nr=nr.next=f,nr}function Go(){if(Hi===null){var f=ui.alternate;f=f!==null?f.memoizedState:null}else f=Hi.next;var m=nr===null?ui.memoizedState:nr.next;if(m!==null)nr=m,Hi=f;else{if(f===null)throw Error(t(310));Hi=f,f={memoizedState:Hi.memoizedState,baseState:Hi.baseState,baseQueue:Hi.baseQueue,queue:Hi.queue,next:null},nr===null?ui.memoizedState=nr=f:nr=nr.next=f}return nr}function _m(f,m){return typeof m=="function"?m(f):m}function zb(f){var m=Go(),w=m.queue;if(w===null)throw Error(t(311));w.lastRenderedReducer=f;var _=Hi,N=_.baseQueue,$=w.pending;if($!==null){if(N!==null){var te=N.next;N.next=$.next,$.next=te}_.baseQueue=N=$,w.pending=null}if(N!==null){$=N.next,_=_.baseState;var me=te=null,_e=null,et=$;do{var _t=et.lane;if((Ru&_t)===_t)_e!==null&&(_e=_e.next={lane:0,action:et.action,hasEagerState:et.hasEagerState,eagerState:et.eagerState,next:null}),_=et.hasEagerState?et.eagerState:f(_,et.action);else{var Nt={lane:_t,action:et.action,hasEagerState:et.hasEagerState,eagerState:et.eagerState,next:null};_e===null?(me=_e=Nt,te=_):_e=_e.next=Nt,ui.lanes|=_t,Mu|=_t}et=et.next}while(et!==null&&et!==$);_e===null?te=_:_e.next=me,da(_,m.memoizedState)||(ao=!0),m.memoizedState=_,m.baseState=te,m.baseQueue=_e,w.lastRenderedState=_}if(f=w.interleaved,f!==null){N=f;do $=N.lane,ui.lanes|=$,Mu|=$,N=N.next;while(N!==f)}else N===null&&(w.lanes=0);return[m.memoizedState,w.dispatch]}function Bb(f){var m=Go(),w=m.queue;if(w===null)throw Error(t(311));w.lastRenderedReducer=f;var _=w.dispatch,N=w.pending,$=m.memoizedState;if(N!==null){w.pending=null;var te=N=N.next;do $=f($,te.action),te=te.next;while(te!==N);da($,m.memoizedState)||(ao=!0),m.memoizedState=$,m.baseQueue===null&&(m.baseState=$),w.lastRenderedState=$}return[$,_]}function B4(){}function U4(f,m){var w=ui,_=Go(),N=m(),$=!da(_.memoizedState,N);if($&&(_.memoizedState=N,ao=!0),_=_.queue,Ub(G4.bind(null,w,_,f),[f]),_.getSnapshot!==m||$||nr!==null&&nr.memoizedState.tag&1){if(w.flags|=2048,Em(9,W4.bind(null,w,_,N,m),void 0,null),sr===null)throw Error(t(349));(Ru&30)!==0||V4(w,m,N)}return N}function V4(f,m,w){f.flags|=16384,f={getSnapshot:m,value:w},m=ui.updateQueue,m===null?(m={lastEffect:null,stores:null},ui.updateQueue=m,m.stores=[f]):(w=m.stores,w===null?m.stores=[f]:w.push(f))}function W4(f,m,w,_){m.value=w,m.getSnapshot=_,H4(m)&&j4(f)}function G4(f,m,w){return w(function(){H4(m)&&j4(f)})}function H4(f){var m=f.getSnapshot;f=f.value;try{var w=m();return!da(f,w)}catch{return!0}}function j4(f){var m=Bl(f,1);m!==null&&ga(m,f,1,-1)}function X4(f){var m=Ka();return typeof f=="function"&&(f=f()),m.memoizedState=m.baseState=f,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:_m,lastRenderedState:f},m.queue=f,f=f.dispatch=U7.bind(null,ui,f),[m.memoizedState,f]}function Em(f,m,w,_){return f={tag:f,create:m,destroy:w,deps:_,next:null},m=ui.updateQueue,m===null?(m={lastEffect:null,stores:null},ui.updateQueue=m,m.lastEffect=f.next=f):(w=m.lastEffect,w===null?m.lastEffect=f.next=f:(_=w.next,w.next=f,f.next=_,m.lastEffect=f)),f}function q4(){return Go().memoizedState}function J1(f,m,w,_){var N=Ka();ui.flags|=f,N.memoizedState=Em(1|m,w,void 0,_===void 0?null:_)}function ex(f,m,w,_){var N=Go();_=_===void 0?null:_;var $=void 0;if(Hi!==null){var te=Hi.memoizedState;if($=te.destroy,_!==null&&$b(_,te.deps)){N.memoizedState=Em(m,w,$,_);return}}ui.flags|=f,N.memoizedState=Em(1|m,w,$,_)}function K4(f,m){return J1(8390656,8,f,m)}function Ub(f,m){return ex(2048,8,f,m)}function Y4(f,m){return ex(4,2,f,m)}function Z4(f,m){return ex(4,4,f,m)}function Q4(f,m){if(typeof m=="function")return f=f(),m(f),function(){m(null)};if(m!=null)return f=f(),m.current=f,function(){m.current=null}}function J4(f,m,w){return w=w!=null?w.concat([f]):null,ex(4,4,Q4.bind(null,m,f),w)}function Vb(){}function ek(f,m){var w=Go();m=m===void 0?null:m;var _=w.memoizedState;return _!==null&&m!==null&&$b(m,_[1])?_[0]:(w.memoizedState=[f,m],f)}function tk(f,m){var w=Go();m=m===void 0?null:m;var _=w.memoizedState;return _!==null&&m!==null&&$b(m,_[1])?_[0]:(f=f(),w.memoizedState=[f,m],f)}function nk(f,m,w){return(Ru&21)===0?(f.baseState&&(f.baseState=!1,ao=!0),f.memoizedState=w):(da(w,m)||(w=Tn(),ui.lanes|=w,Mu|=w,f.baseState=!0),m)}function z7(f,m){var w=jt;jt=w!==0&&4>w?w:4,f(!0);var _=Lb.transition;Lb.transition={};try{f(!1),m()}finally{jt=w,Lb.transition=_}}function sk(){return Go().memoizedState}function B7(f,m,w){var _=Rc(f);if(w={lane:_,action:w,hasEagerState:!1,eagerState:null,next:null},ik(f))rk(m,w);else if(w=L4(f,m,w,_),w!==null){var N=Ur();ga(w,f,_,N),ok(w,m,_)}}function U7(f,m,w){var _=Rc(f),N={lane:_,action:w,hasEagerState:!1,eagerState:null,next:null};if(ik(f))rk(m,N);else{var $=f.alternate;if(f.lanes===0&&($===null||$.lanes===0)&&($=m.lastRenderedReducer,$!==null))try{var te=m.lastRenderedState,me=$(te,w);if(N.hasEagerState=!0,N.eagerState=me,da(me,te)){var _e=m.interleaved;_e===null?(N.next=N,Ab(m)):(N.next=_e.next,_e.next=N),m.interleaved=N;return}}catch{}finally{}w=L4(f,m,N,_),w!==null&&(N=Ur(),ga(w,f,_,N),ok(w,m,_))}}function ik(f){var m=f.alternate;return f===ui||m!==null&&m===ui}function rk(f,m){Sm=Q1=!0;var w=f.pending;w===null?m.next=m:(m.next=w.next,w.next=m),f.pending=m}function ok(f,m,w){if((w&4194240)!==0){var _=m.lanes;_&=f.pendingLanes,w|=_,m.lanes=w,sn(f,w)}}var tx={readContext:Wo,useCallback:Er,useContext:Er,useEffect:Er,useImperativeHandle:Er,useInsertionEffect:Er,useLayoutEffect:Er,useMemo:Er,useReducer:Er,useRef:Er,useState:Er,useDebugValue:Er,useDeferredValue:Er,useTransition:Er,useMutableSource:Er,useSyncExternalStore:Er,useId:Er,unstable_isNewReconciler:!1},V7={readContext:Wo,useCallback:function(f,m){return Ka().memoizedState=[f,m===void 0?null:m],f},useContext:Wo,useEffect:K4,useImperativeHandle:function(f,m,w){return w=w!=null?w.concat([f]):null,J1(4194308,4,Q4.bind(null,m,f),w)},useLayoutEffect:function(f,m){return J1(4194308,4,f,m)},useInsertionEffect:function(f,m){return J1(4,2,f,m)},useMemo:function(f,m){var w=Ka();return m=m===void 0?null:m,f=f(),w.memoizedState=[f,m],f},useReducer:function(f,m,w){var _=Ka();return m=w!==void 0?w(m):m,_.memoizedState=_.baseState=m,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:f,lastRenderedState:m},_.queue=f,f=f.dispatch=B7.bind(null,ui,f),[_.memoizedState,f]},useRef:function(f){var m=Ka();return f={current:f},m.memoizedState=f},useState:X4,useDebugValue:Vb,useDeferredValue:function(f){return Ka().memoizedState=f},useTransition:function(){var f=X4(!1),m=f[0];return f=z7.bind(null,f[1]),Ka().memoizedState=f,[m,f]},useMutableSource:function(){},useSyncExternalStore:function(f,m,w){var _=ui,N=Ka();if(oi){if(w===void 0)throw Error(t(407));w=w()}else{if(w=m(),sr===null)throw Error(t(349));(Ru&30)!==0||V4(_,m,w)}N.memoizedState=w;var $={value:w,getSnapshot:m};return N.queue=$,K4(G4.bind(null,_,$,f),[f]),_.flags|=2048,Em(9,W4.bind(null,_,$,w,m),void 0,null),w},useId:function(){var f=Ka(),m=sr.identifierPrefix;if(oi){var w=zl,_=Ol;w=(_&~(1<<32-Ss(_)-1)).toString(32)+w,m=":"+m+"R"+w,w=Cm++,0<w&&(m+="H"+w.toString(32)),m+=":"}else w=O7++,m=":"+m+"r"+w.toString(32)+":";return f.memoizedState=m},unstable_isNewReconciler:!1},W7={readContext:Wo,useCallback:ek,useContext:Wo,useEffect:Ub,useImperativeHandle:J4,useInsertionEffect:Y4,useLayoutEffect:Z4,useMemo:tk,useReducer:zb,useRef:q4,useState:function(){return zb(_m)},useDebugValue:Vb,useDeferredValue:function(f){var m=Go();return nk(m,Hi.memoizedState,f)},useTransition:function(){var f=zb(_m)[0],m=Go().memoizedState;return[f,m]},useMutableSource:B4,useSyncExternalStore:U4,useId:sk,unstable_isNewReconciler:!1},G7={readContext:Wo,useCallback:ek,useContext:Wo,useEffect:Ub,useImperativeHandle:J4,useInsertionEffect:Y4,useLayoutEffect:Z4,useMemo:tk,useReducer:Bb,useRef:q4,useState:function(){return Bb(_m)},useDebugValue:Vb,useDeferredValue:function(f){var m=Go();return Hi===null?m.memoizedState=f:nk(m,Hi.memoizedState,f)},useTransition:function(){var f=Bb(_m)[0],m=Go().memoizedState;return[f,m]},useMutableSource:B4,useSyncExternalStore:U4,useId:sk,unstable_isNewReconciler:!1};function fa(f,m){if(f&&f.defaultProps){m=ne({},m),f=f.defaultProps;for(var w in f)m[w]===void 0&&(m[w]=f[w]);return m}return m}function Wb(f,m,w,_){m=f.memoizedState,w=w(_,m),w=w==null?m:ne({},m,w),f.memoizedState=w,f.lanes===0&&(f.updateQueue.baseState=w)}var nx={isMounted:function(f){return(f=f._reactInternals)?pr(f)===f:!1},enqueueSetState:function(f,m,w){f=f._reactInternals;var _=Ur(),N=Rc(f),$=Ul(_,N);$.payload=m,w!=null&&($.callback=w),m=Tc(f,$,N),m!==null&&(ga(m,f,N,_),q1(m,f,N))},enqueueReplaceState:function(f,m,w){f=f._reactInternals;var _=Ur(),N=Rc(f),$=Ul(_,N);$.tag=1,$.payload=m,w!=null&&($.callback=w),m=Tc(f,$,N),m!==null&&(ga(m,f,N,_),q1(m,f,N))},enqueueForceUpdate:function(f,m){f=f._reactInternals;var w=Ur(),_=Rc(f),N=Ul(w,_);N.tag=2,m!=null&&(N.callback=m),m=Tc(f,N,_),m!==null&&(ga(m,f,_,w),q1(m,f,_))}};function ak(f,m,w,_,N,$,te){return f=f.stateNode,typeof f.shouldComponentUpdate=="function"?f.shouldComponentUpdate(_,$,te):m.prototype&&m.prototype.isPureReactComponent?!dm(w,_)||!dm(N,$):!0}function lk(f,m,w){var _=!1,N=Cc,$=m.contextType;return typeof $=="object"&&$!==null?$=Wo($):(N=oo(m)?Eu:_r.current,_=m.contextTypes,$=(_=_!=null)?uh(f,N):Cc),m=new m(w,$),f.memoizedState=m.state!==null&&m.state!==void 0?m.state:null,m.updater=nx,f.stateNode=m,m._reactInternals=f,_&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=N,f.__reactInternalMemoizedMaskedChildContext=$),m}function ck(f,m,w,_){f=m.state,typeof m.componentWillReceiveProps=="function"&&m.componentWillReceiveProps(w,_),typeof m.UNSAFE_componentWillReceiveProps=="function"&&m.UNSAFE_componentWillReceiveProps(w,_),m.state!==f&&nx.enqueueReplaceState(m,m.state,null)}function Gb(f,m,w,_){var N=f.stateNode;N.props=w,N.state=f.memoizedState,N.refs={},Rb(f);var $=m.contextType;typeof $=="object"&&$!==null?N.context=Wo($):($=oo(m)?Eu:_r.current,N.context=uh(f,$)),N.state=f.memoizedState,$=m.getDerivedStateFromProps,typeof $=="function"&&(Wb(f,m,$,w),N.state=f.memoizedState),typeof m.getDerivedStateFromProps=="function"||typeof N.getSnapshotBeforeUpdate=="function"||typeof N.UNSAFE_componentWillMount!="function"&&typeof N.componentWillMount!="function"||(m=N.state,typeof N.componentWillMount=="function"&&N.componentWillMount(),typeof N.UNSAFE_componentWillMount=="function"&&N.UNSAFE_componentWillMount(),m!==N.state&&nx.enqueueReplaceState(N,N.state,null),K1(f,w,N,_),N.state=f.memoizedState),typeof N.componentDidMount=="function"&&(f.flags|=4194308)}function vh(f,m){try{var w="",_=m;do w+=be(_),_=_.return;while(_);var N=w}catch($){N=`
Error generating stack: `+$.message+`
`+$.stack}return{value:f,source:m,stack:N,digest:null}}function Hb(f,m,w){return{value:f,source:null,stack:w??null,digest:m??null}}function jb(f,m){try{console.error(m.value)}catch(w){setTimeout(function(){throw w})}}var H7=typeof WeakMap=="function"?WeakMap:Map;function uk(f,m,w){w=Ul(-1,w),w.tag=3,w.payload={element:null};var _=m.value;return w.callback=function(){cx||(cx=!0,a3=_),jb(f,m)},w}function dk(f,m,w){w=Ul(-1,w),w.tag=3;var _=f.type.getDerivedStateFromError;if(typeof _=="function"){var N=m.value;w.payload=function(){return _(N)},w.callback=function(){jb(f,m)}}var $=f.stateNode;return $!==null&&typeof $.componentDidCatch=="function"&&(w.callback=function(){jb(f,m),typeof _!="function"&&(kc===null?kc=new Set([this]):kc.add(this));var te=m.stack;this.componentDidCatch(m.value,{componentStack:te!==null?te:""})}),w}function hk(f,m,w){var _=f.pingCache;if(_===null){_=f.pingCache=new H7;var N=new Set;_.set(m,N)}else N=_.get(m),N===void 0&&(N=new Set,_.set(m,N));N.has(w)||(N.add(w),f=r9.bind(null,f,m,w),m.then(f,f))}function fk(f){do{var m;if((m=f.tag===13)&&(m=f.memoizedState,m=m!==null?m.dehydrated!==null:!0),m)return f;f=f.return}while(f!==null);return null}function pk(f,m,w,_,N){return(f.mode&1)===0?(f===m?f.flags|=65536:(f.flags|=128,w.flags|=131072,w.flags&=-52805,w.tag===1&&(w.alternate===null?w.tag=17:(m=Ul(-1,1),m.tag=2,Tc(w,m,1))),w.lanes|=1),f):(f.flags|=65536,f.lanes=N,f)}var j7=C.ReactCurrentOwner,ao=!1;function Br(f,m,w,_){m.child=f===null?D4(m,null,w,_):ph(m,f.child,w,_)}function mk(f,m,w,_,N){w=w.render;var $=m.ref;return gh(m,N),_=Fb(f,m,w,_,$,N),w=Ob(),f!==null&&!ao?(m.updateQueue=f.updateQueue,m.flags&=-2053,f.lanes&=~N,Vl(f,m,N)):(oi&&w&&wb(m),m.flags|=1,Br(f,m,_,N),m.child)}function gk(f,m,w,_,N){if(f===null){var $=w.type;return typeof $=="function"&&!p3($)&&$.defaultProps===void 0&&w.compare===null&&w.defaultProps===void 0?(m.tag=15,m.type=$,xk(f,m,$,_,N)):(f=mx(w.type,null,_,m,m.mode,N),f.ref=m.ref,f.return=m,m.child=f)}if($=f.child,(f.lanes&N)===0){var te=$.memoizedProps;if(w=w.compare,w=w!==null?w:dm,w(te,_)&&f.ref===m.ref)return Vl(f,m,N)}return m.flags|=1,f=Nc($,_),f.ref=m.ref,f.return=m,m.child=f}function xk(f,m,w,_,N){if(f!==null){var $=f.memoizedProps;if(dm($,_)&&f.ref===m.ref)if(ao=!1,m.pendingProps=_=$,(f.lanes&N)!==0)(f.flags&131072)!==0&&(ao=!0);else return m.lanes=f.lanes,Vl(f,m,N)}return Xb(f,m,w,_,N)}function vk(f,m,w){var _=m.pendingProps,N=_.children,$=f!==null?f.memoizedState:null;if(_.mode==="hidden")if((m.mode&1)===0)m.memoizedState={baseLanes:0,cachePool:null,transitions:null},Zs(wh,To),To|=w;else{if((w&1073741824)===0)return f=$!==null?$.baseLanes|w:w,m.lanes=m.childLanes=1073741824,m.memoizedState={baseLanes:f,cachePool:null,transitions:null},m.updateQueue=null,Zs(wh,To),To|=f,null;m.memoizedState={baseLanes:0,cachePool:null,transitions:null},_=$!==null?$.baseLanes:w,Zs(wh,To),To|=_}else $!==null?(_=$.baseLanes|w,m.memoizedState=null):_=w,Zs(wh,To),To|=_;return Br(f,m,N,w),m.child}function yk(f,m){var w=m.ref;(f===null&&w!==null||f!==null&&f.ref!==w)&&(m.flags|=512,m.flags|=2097152)}function Xb(f,m,w,_,N){var $=oo(w)?Eu:_r.current;return $=uh(m,$),gh(m,N),w=Fb(f,m,w,_,$,N),_=Ob(),f!==null&&!ao?(m.updateQueue=f.updateQueue,m.flags&=-2053,f.lanes&=~N,Vl(f,m,N)):(oi&&_&&wb(m),m.flags|=1,Br(f,m,w,N),m.child)}function wk(f,m,w,_,N){if(oo(w)){var $=!0;B1(m)}else $=!1;if(gh(m,N),m.stateNode===null)ix(f,m),lk(m,w,_),Gb(m,w,_,N),_=!0;else if(f===null){var te=m.stateNode,me=m.memoizedProps;te.props=me;var _e=te.context,et=w.contextType;typeof et=="object"&&et!==null?et=Wo(et):(et=oo(w)?Eu:_r.current,et=uh(m,et));var _t=w.getDerivedStateFromProps,Nt=typeof _t=="function"||typeof te.getSnapshotBeforeUpdate=="function";Nt||typeof te.UNSAFE_componentWillReceiveProps!="function"&&typeof te.componentWillReceiveProps!="function"||(me!==_||_e!==et)&&ck(m,te,_,et),Ec=!1;var Ct=m.memoizedState;te.state=Ct,K1(m,_,te,N),_e=m.memoizedState,me!==_||Ct!==_e||ro.current||Ec?(typeof _t=="function"&&(Wb(m,w,_t,_),_e=m.memoizedState),(me=Ec||ak(m,w,me,_,Ct,_e,et))?(Nt||typeof te.UNSAFE_componentWillMount!="function"&&typeof te.componentWillMount!="function"||(typeof te.componentWillMount=="function"&&te.componentWillMount(),typeof te.UNSAFE_componentWillMount=="function"&&te.UNSAFE_componentWillMount()),typeof te.componentDidMount=="function"&&(m.flags|=4194308)):(typeof te.componentDidMount=="function"&&(m.flags|=4194308),m.memoizedProps=_,m.memoizedState=_e),te.props=_,te.state=_e,te.context=et,_=me):(typeof te.componentDidMount=="function"&&(m.flags|=4194308),_=!1)}else{te=m.stateNode,$4(f,m),me=m.memoizedProps,et=m.type===m.elementType?me:fa(m.type,me),te.props=et,Nt=m.pendingProps,Ct=te.context,_e=w.contextType,typeof _e=="object"&&_e!==null?_e=Wo(_e):(_e=oo(w)?Eu:_r.current,_e=uh(m,_e));var tn=w.getDerivedStateFromProps;(_t=typeof tn=="function"||typeof te.getSnapshotBeforeUpdate=="function")||typeof te.UNSAFE_componentWillReceiveProps!="function"&&typeof te.componentWillReceiveProps!="function"||(me!==Nt||Ct!==_e)&&ck(m,te,_,_e),Ec=!1,Ct=m.memoizedState,te.state=Ct,K1(m,_,te,N);var hn=m.memoizedState;me!==Nt||Ct!==hn||ro.current||Ec?(typeof tn=="function"&&(Wb(m,w,tn,_),hn=m.memoizedState),(et=Ec||ak(m,w,et,_,Ct,hn,_e)||!1)?(_t||typeof te.UNSAFE_componentWillUpdate!="function"&&typeof te.componentWillUpdate!="function"||(typeof te.componentWillUpdate=="function"&&te.componentWillUpdate(_,hn,_e),typeof te.UNSAFE_componentWillUpdate=="function"&&te.UNSAFE_componentWillUpdate(_,hn,_e)),typeof te.componentDidUpdate=="function"&&(m.flags|=4),typeof te.getSnapshotBeforeUpdate=="function"&&(m.flags|=1024)):(typeof te.componentDidUpdate!="function"||me===f.memoizedProps&&Ct===f.memoizedState||(m.flags|=4),typeof te.getSnapshotBeforeUpdate!="function"||me===f.memoizedProps&&Ct===f.memoizedState||(m.flags|=1024),m.memoizedProps=_,m.memoizedState=hn),te.props=_,te.state=hn,te.context=_e,_=et):(typeof te.componentDidUpdate!="function"||me===f.memoizedProps&&Ct===f.memoizedState||(m.flags|=4),typeof te.getSnapshotBeforeUpdate!="function"||me===f.memoizedProps&&Ct===f.memoizedState||(m.flags|=1024),_=!1)}return qb(f,m,w,_,$,N)}function qb(f,m,w,_,N,$){yk(f,m);var te=(m.flags&128)!==0;if(!_&&!te)return N&&E4(m,w,!1),Vl(f,m,$);_=m.stateNode,j7.current=m;var me=te&&typeof w.getDerivedStateFromError!="function"?null:_.render();return m.flags|=1,f!==null&&te?(m.child=ph(m,f.child,null,$),m.child=ph(m,null,me,$)):Br(f,m,me,$),m.memoizedState=_.state,N&&E4(m,w,!0),m.child}function bk(f){var m=f.stateNode;m.pendingContext?C4(f,m.pendingContext,m.pendingContext!==m.context):m.context&&C4(f,m.context,!1),Mb(f,m.containerInfo)}function Sk(f,m,w,_,N){return fh(),_b(N),m.flags|=256,Br(f,m,w,_),m.child}var Kb={dehydrated:null,treeContext:null,retryLane:0};function Yb(f){return{baseLanes:f,cachePool:null,transitions:null}}function Ck(f,m,w){var _=m.pendingProps,N=ci.current,$=!1,te=(m.flags&128)!==0,me;if((me=te)||(me=f!==null&&f.memoizedState===null?!1:(N&2)!==0),me?($=!0,m.flags&=-129):(f===null||f.memoizedState!==null)&&(N|=1),Zs(ci,N&1),f===null)return Cb(m),f=m.memoizedState,f!==null&&(f=f.dehydrated,f!==null)?((m.mode&1)===0?m.lanes=1:f.data==="$!"?m.lanes=8:m.lanes=1073741824,null):(te=_.children,f=_.fallback,$?(_=m.mode,$=m.child,te={mode:"hidden",children:te},(_&1)===0&&$!==null?($.childLanes=0,$.pendingProps=te):$=gx(te,_,0,null),f=Lu(f,_,w,null),$.return=m,f.return=m,$.sibling=f,m.child=$,m.child.memoizedState=Yb(w),m.memoizedState=Kb,f):Zb(m,te));if(N=f.memoizedState,N!==null&&(me=N.dehydrated,me!==null))return X7(f,m,te,_,me,N,w);if($){$=_.fallback,te=m.mode,N=f.child,me=N.sibling;var _e={mode:"hidden",children:_.children};return(te&1)===0&&m.child!==N?(_=m.child,_.childLanes=0,_.pendingProps=_e,m.deletions=null):(_=Nc(N,_e),_.subtreeFlags=N.subtreeFlags&14680064),me!==null?$=Nc(me,$):($=Lu($,te,w,null),$.flags|=2),$.return=m,_.return=m,_.sibling=$,m.child=_,_=$,$=m.child,te=f.child.memoizedState,te=te===null?Yb(w):{baseLanes:te.baseLanes|w,cachePool:null,transitions:te.transitions},$.memoizedState=te,$.childLanes=f.childLanes&~w,m.memoizedState=Kb,_}return $=f.child,f=$.sibling,_=Nc($,{mode:"visible",children:_.children}),(m.mode&1)===0&&(_.lanes=w),_.return=m,_.sibling=null,f!==null&&(w=m.deletions,w===null?(m.deletions=[f],m.flags|=16):w.push(f)),m.child=_,m.memoizedState=null,_}function Zb(f,m){return m=gx({mode:"visible",children:m},f.mode,0,null),m.return=f,f.child=m}function sx(f,m,w,_){return _!==null&&_b(_),ph(m,f.child,null,w),f=Zb(m,m.pendingProps.children),f.flags|=2,m.memoizedState=null,f}function X7(f,m,w,_,N,$,te){if(w)return m.flags&256?(m.flags&=-257,_=Hb(Error(t(422))),sx(f,m,te,_)):m.memoizedState!==null?(m.child=f.child,m.flags|=128,null):($=_.fallback,N=m.mode,_=gx({mode:"visible",children:_.children},N,0,null),$=Lu($,N,te,null),$.flags|=2,_.return=m,$.return=m,_.sibling=$,m.child=_,(m.mode&1)!==0&&ph(m,f.child,null,te),m.child.memoizedState=Yb(te),m.memoizedState=Kb,$);if((m.mode&1)===0)return sx(f,m,te,null);if(N.data==="$!"){if(_=N.nextSibling&&N.nextSibling.dataset,_)var me=_.dgst;return _=me,$=Error(t(419)),_=Hb($,_,void 0),sx(f,m,te,_)}if(me=(te&f.childLanes)!==0,ao||me){if(_=sr,_!==null){switch(te&-te){case 4:N=2;break;case 16:N=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:N=32;break;case 536870912:N=268435456;break;default:N=0}N=(N&(_.suspendedLanes|te))!==0?0:N,N!==0&&N!==$.retryLane&&($.retryLane=N,Bl(f,N),ga(_,f,N,-1))}return f3(),_=Hb(Error(t(421))),sx(f,m,te,_)}return N.data==="$?"?(m.flags|=128,m.child=f.child,m=o9.bind(null,f),N._reactRetry=m,null):(f=$.treeContext,Eo=bc(N.nextSibling),_o=m,oi=!0,ha=null,f!==null&&(Uo[Vo++]=Ol,Uo[Vo++]=zl,Uo[Vo++]=Tu,Ol=f.id,zl=f.overflow,Tu=m),m=Zb(m,_.children),m.flags|=4096,m)}function _k(f,m,w){f.lanes|=m;var _=f.alternate;_!==null&&(_.lanes|=m),kb(f.return,m,w)}function Qb(f,m,w,_,N){var $=f.memoizedState;$===null?f.memoizedState={isBackwards:m,rendering:null,renderingStartTime:0,last:_,tail:w,tailMode:N}:($.isBackwards=m,$.rendering=null,$.renderingStartTime=0,$.last=_,$.tail=w,$.tailMode=N)}function Ek(f,m,w){var _=m.pendingProps,N=_.revealOrder,$=_.tail;if(Br(f,m,_.children,w),_=ci.current,(_&2)!==0)_=_&1|2,m.flags|=128;else{if(f!==null&&(f.flags&128)!==0)e:for(f=m.child;f!==null;){if(f.tag===13)f.memoizedState!==null&&_k(f,w,m);else if(f.tag===19)_k(f,w,m);else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===m)break e;for(;f.sibling===null;){if(f.return===null||f.return===m)break e;f=f.return}f.sibling.return=f.return,f=f.sibling}_&=1}if(Zs(ci,_),(m.mode&1)===0)m.memoizedState=null;else switch(N){case"forwards":for(w=m.child,N=null;w!==null;)f=w.alternate,f!==null&&Y1(f)===null&&(N=w),w=w.sibling;w=N,w===null?(N=m.child,m.child=null):(N=w.sibling,w.sibling=null),Qb(m,!1,N,w,$);break;case"backwards":for(w=null,N=m.child,m.child=null;N!==null;){if(f=N.alternate,f!==null&&Y1(f)===null){m.child=N;break}f=N.sibling,N.sibling=w,w=N,N=f}Qb(m,!0,w,null,$);break;case"together":Qb(m,!1,null,null,void 0);break;default:m.memoizedState=null}return m.child}function ix(f,m){(m.mode&1)===0&&f!==null&&(f.alternate=null,m.alternate=null,m.flags|=2)}function Vl(f,m,w){if(f!==null&&(m.dependencies=f.dependencies),Mu|=m.lanes,(w&m.childLanes)===0)return null;if(f!==null&&m.child!==f.child)throw Error(t(153));if(m.child!==null){for(f=m.child,w=Nc(f,f.pendingProps),m.child=w,w.return=m;f.sibling!==null;)f=f.sibling,w=w.sibling=Nc(f,f.pendingProps),w.return=m;w.sibling=null}return m.child}function q7(f,m,w){switch(m.tag){case 3:bk(m),fh();break;case 5:z4(m);break;case 1:oo(m.type)&&B1(m);break;case 4:Mb(m,m.stateNode.containerInfo);break;case 10:var _=m.type._context,N=m.memoizedProps.value;Zs(j1,_._currentValue),_._currentValue=N;break;case 13:if(_=m.memoizedState,_!==null)return _.dehydrated!==null?(Zs(ci,ci.current&1),m.flags|=128,null):(w&m.child.childLanes)!==0?Ck(f,m,w):(Zs(ci,ci.current&1),f=Vl(f,m,w),f!==null?f.sibling:null);Zs(ci,ci.current&1);break;case 19:if(_=(w&m.childLanes)!==0,(f.flags&128)!==0){if(_)return Ek(f,m,w);m.flags|=128}if(N=m.memoizedState,N!==null&&(N.rendering=null,N.tail=null,N.lastEffect=null),Zs(ci,ci.current),_)break;return null;case 22:case 23:return m.lanes=0,vk(f,m,w)}return Vl(f,m,w)}var Tk,Jb,Ik,kk;Tk=function(f,m){for(var w=m.child;w!==null;){if(w.tag===5||w.tag===6)f.appendChild(w.stateNode);else if(w.tag!==4&&w.child!==null){w.child.return=w,w=w.child;continue}if(w===m)break;for(;w.sibling===null;){if(w.return===null||w.return===m)return;w=w.return}w.sibling.return=w.return,w=w.sibling}},Jb=function(){},Ik=function(f,m,w,_){var N=f.memoizedProps;if(N!==_){f=m.stateNode,Au(qa.current);var $=null;switch(w){case"input":N=gt(f,N),_=gt(f,_),$=[];break;case"select":N=ne({},N,{value:void 0}),_=ne({},_,{value:void 0}),$=[];break;case"textarea":N=vn(f,N),_=vn(f,_),$=[];break;default:typeof N.onClick!="function"&&typeof _.onClick=="function"&&(f.onclick=F1)}Et(w,_);var te;w=null;for(et in N)if(!_.hasOwnProperty(et)&&N.hasOwnProperty(et)&&N[et]!=null)if(et==="style"){var me=N[et];for(te in me)me.hasOwnProperty(te)&&(w||(w={}),w[te]="")}else et!=="dangerouslySetInnerHTML"&&et!=="children"&&et!=="suppressContentEditableWarning"&&et!=="suppressHydrationWarning"&&et!=="autoFocus"&&(i.hasOwnProperty(et)?$||($=[]):($=$||[]).push(et,null));for(et in _){var _e=_[et];if(me=N!=null?N[et]:void 0,_.hasOwnProperty(et)&&_e!==me&&(_e!=null||me!=null))if(et==="style")if(me){for(te in me)!me.hasOwnProperty(te)||_e&&_e.hasOwnProperty(te)||(w||(w={}),w[te]="");for(te in _e)_e.hasOwnProperty(te)&&me[te]!==_e[te]&&(w||(w={}),w[te]=_e[te])}else w||($||($=[]),$.push(et,w)),w=_e;else et==="dangerouslySetInnerHTML"?(_e=_e?_e.__html:void 0,me=me?me.__html:void 0,_e!=null&&me!==_e&&($=$||[]).push(et,_e)):et==="children"?typeof _e!="string"&&typeof _e!="number"||($=$||[]).push(et,""+_e):et!=="suppressContentEditableWarning"&&et!=="suppressHydrationWarning"&&(i.hasOwnProperty(et)?(_e!=null&&et==="onScroll"&&ei("scroll",f),$||me===_e||($=[])):($=$||[]).push(et,_e))}w&&($=$||[]).push("style",w);var et=$;(m.updateQueue=et)&&(m.flags|=4)}},kk=function(f,m,w,_){w!==_&&(m.flags|=4)};function Tm(f,m){if(!oi)switch(f.tailMode){case"hidden":m=f.tail;for(var w=null;m!==null;)m.alternate!==null&&(w=m),m=m.sibling;w===null?f.tail=null:w.sibling=null;break;case"collapsed":w=f.tail;for(var _=null;w!==null;)w.alternate!==null&&(_=w),w=w.sibling;_===null?m||f.tail===null?f.tail=null:f.tail.sibling=null:_.sibling=null}}function Tr(f){var m=f.alternate!==null&&f.alternate.child===f.child,w=0,_=0;if(m)for(var N=f.child;N!==null;)w|=N.lanes|N.childLanes,_|=N.subtreeFlags&14680064,_|=N.flags&14680064,N.return=f,N=N.sibling;else for(N=f.child;N!==null;)w|=N.lanes|N.childLanes,_|=N.subtreeFlags,_|=N.flags,N.return=f,N=N.sibling;return f.subtreeFlags|=_,f.childLanes=w,m}function K7(f,m,w){var _=m.pendingProps;switch(bb(m),m.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Tr(m),null;case 1:return oo(m.type)&&z1(),Tr(m),null;case 3:return _=m.stateNode,xh(),ti(ro),ti(_r),Db(),_.pendingContext&&(_.context=_.pendingContext,_.pendingContext=null),(f===null||f.child===null)&&(G1(m)?m.flags|=4:f===null||f.memoizedState.isDehydrated&&(m.flags&256)===0||(m.flags|=1024,ha!==null&&(u3(ha),ha=null))),Jb(f,m),Tr(m),null;case 5:Nb(m);var N=Au(bm.current);if(w=m.type,f!==null&&m.stateNode!=null)Ik(f,m,w,_,N),f.ref!==m.ref&&(m.flags|=512,m.flags|=2097152);else{if(!_){if(m.stateNode===null)throw Error(t(166));return Tr(m),null}if(f=Au(qa.current),G1(m)){_=m.stateNode,w=m.type;var $=m.memoizedProps;switch(_[Xa]=m,_[gm]=$,f=(m.mode&1)!==0,w){case"dialog":ei("cancel",_),ei("close",_);break;case"iframe":case"object":case"embed":ei("load",_);break;case"video":case"audio":for(N=0;N<fm.length;N++)ei(fm[N],_);break;case"source":ei("error",_);break;case"img":case"image":case"link":ei("error",_),ei("load",_);break;case"details":ei("toggle",_);break;case"input":vt(_,$),ei("invalid",_);break;case"select":_._wrapperState={wasMultiple:!!$.multiple},ei("invalid",_);break;case"textarea":ce(_,$),ei("invalid",_)}Et(w,$),N=null;for(var te in $)if($.hasOwnProperty(te)){var me=$[te];te==="children"?typeof me=="string"?_.textContent!==me&&($.suppressHydrationWarning!==!0&&$1(_.textContent,me,f),N=["children",me]):typeof me=="number"&&_.textContent!==""+me&&($.suppressHydrationWarning!==!0&&$1(_.textContent,me,f),N=["children",""+me]):i.hasOwnProperty(te)&&me!=null&&te==="onScroll"&&ei("scroll",_)}switch(w){case"input":at(_),It(_,$,!0);break;case"textarea":at(_),ye(_);break;case"select":case"option":break;default:typeof $.onClick=="function"&&(_.onclick=F1)}_=N,m.updateQueue=_,_!==null&&(m.flags|=4)}else{te=N.nodeType===9?N:N.ownerDocument,f==="http://www.w3.org/1999/xhtml"&&(f=Qe(w)),f==="http://www.w3.org/1999/xhtml"?w==="script"?(f=te.createElement("div"),f.innerHTML="<script><\/script>",f=f.removeChild(f.firstChild)):typeof _.is=="string"?f=te.createElement(w,{is:_.is}):(f=te.createElement(w),w==="select"&&(te=f,_.multiple?te.multiple=!0:_.size&&(te.size=_.size))):f=te.createElementNS(f,w),f[Xa]=m,f[gm]=_,Tk(f,m,!1,!1),m.stateNode=f;e:{switch(te=bt(w,_),w){case"dialog":ei("cancel",f),ei("close",f),N=_;break;case"iframe":case"object":case"embed":ei("load",f),N=_;break;case"video":case"audio":for(N=0;N<fm.length;N++)ei(fm[N],f);N=_;break;case"source":ei("error",f),N=_;break;case"img":case"image":case"link":ei("error",f),ei("load",f),N=_;break;case"details":ei("toggle",f),N=_;break;case"input":vt(f,_),N=gt(f,_),ei("invalid",f);break;case"option":N=_;break;case"select":f._wrapperState={wasMultiple:!!_.multiple},N=ne({},_,{value:void 0}),ei("invalid",f);break;case"textarea":ce(f,_),N=vn(f,_),ei("invalid",f);break;default:N=_}Et(w,N),me=N;for($ in me)if(me.hasOwnProperty($)){var _e=me[$];$==="style"?Ye(f,_e):$==="dangerouslySetInnerHTML"?(_e=_e?_e.__html:void 0,_e!=null&&Pt(f,_e)):$==="children"?typeof _e=="string"?(w!=="textarea"||_e!=="")&&pt(f,_e):typeof _e=="number"&&pt(f,""+_e):$!=="suppressContentEditableWarning"&&$!=="suppressHydrationWarning"&&$!=="autoFocus"&&(i.hasOwnProperty($)?_e!=null&&$==="onScroll"&&ei("scroll",f):_e!=null&&S(f,$,_e,te))}switch(w){case"input":at(f),It(f,_,!1);break;case"textarea":at(f),ye(f);break;case"option":_.value!=null&&f.setAttribute("value",""+Fe(_.value));break;case"select":f.multiple=!!_.multiple,$=_.value,$!=null?dn(f,!!_.multiple,$,!1):_.defaultValue!=null&&dn(f,!!_.multiple,_.defaultValue,!0);break;default:typeof N.onClick=="function"&&(f.onclick=F1)}switch(w){case"button":case"input":case"select":case"textarea":_=!!_.autoFocus;break e;case"img":_=!0;break e;default:_=!1}}_&&(m.flags|=4)}m.ref!==null&&(m.flags|=512,m.flags|=2097152)}return Tr(m),null;case 6:if(f&&m.stateNode!=null)kk(f,m,f.memoizedProps,_);else{if(typeof _!="string"&&m.stateNode===null)throw Error(t(166));if(w=Au(bm.current),Au(qa.current),G1(m)){if(_=m.stateNode,w=m.memoizedProps,_[Xa]=m,($=_.nodeValue!==w)&&(f=_o,f!==null))switch(f.tag){case 3:$1(_.nodeValue,w,(f.mode&1)!==0);break;case 5:f.memoizedProps.suppressHydrationWarning!==!0&&$1(_.nodeValue,w,(f.mode&1)!==0)}$&&(m.flags|=4)}else _=(w.nodeType===9?w:w.ownerDocument).createTextNode(_),_[Xa]=m,m.stateNode=_}return Tr(m),null;case 13:if(ti(ci),_=m.memoizedState,f===null||f.memoizedState!==null&&f.memoizedState.dehydrated!==null){if(oi&&Eo!==null&&(m.mode&1)!==0&&(m.flags&128)===0)M4(),fh(),m.flags|=98560,$=!1;else if($=G1(m),_!==null&&_.dehydrated!==null){if(f===null){if(!$)throw Error(t(318));if($=m.memoizedState,$=$!==null?$.dehydrated:null,!$)throw Error(t(317));$[Xa]=m}else fh(),(m.flags&128)===0&&(m.memoizedState=null),m.flags|=4;Tr(m),$=!1}else ha!==null&&(u3(ha),ha=null),$=!0;if(!$)return m.flags&65536?m:null}return(m.flags&128)!==0?(m.lanes=w,m):(_=_!==null,_!==(f!==null&&f.memoizedState!==null)&&_&&(m.child.flags|=8192,(m.mode&1)!==0&&(f===null||(ci.current&1)!==0?ji===0&&(ji=3):f3())),m.updateQueue!==null&&(m.flags|=4),Tr(m),null);case 4:return xh(),Jb(f,m),f===null&&pm(m.stateNode.containerInfo),Tr(m),null;case 10:return Ib(m.type._context),Tr(m),null;case 17:return oo(m.type)&&z1(),Tr(m),null;case 19:if(ti(ci),$=m.memoizedState,$===null)return Tr(m),null;if(_=(m.flags&128)!==0,te=$.rendering,te===null)if(_)Tm($,!1);else{if(ji!==0||f!==null&&(f.flags&128)!==0)for(f=m.child;f!==null;){if(te=Y1(f),te!==null){for(m.flags|=128,Tm($,!1),_=te.updateQueue,_!==null&&(m.updateQueue=_,m.flags|=4),m.subtreeFlags=0,_=w,w=m.child;w!==null;)$=w,f=_,$.flags&=14680066,te=$.alternate,te===null?($.childLanes=0,$.lanes=f,$.child=null,$.subtreeFlags=0,$.memoizedProps=null,$.memoizedState=null,$.updateQueue=null,$.dependencies=null,$.stateNode=null):($.childLanes=te.childLanes,$.lanes=te.lanes,$.child=te.child,$.subtreeFlags=0,$.deletions=null,$.memoizedProps=te.memoizedProps,$.memoizedState=te.memoizedState,$.updateQueue=te.updateQueue,$.type=te.type,f=te.dependencies,$.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext}),w=w.sibling;return Zs(ci,ci.current&1|2),m.child}f=f.sibling}$.tail!==null&&Yt()>bh&&(m.flags|=128,_=!0,Tm($,!1),m.lanes=4194304)}else{if(!_)if(f=Y1(te),f!==null){if(m.flags|=128,_=!0,w=f.updateQueue,w!==null&&(m.updateQueue=w,m.flags|=4),Tm($,!0),$.tail===null&&$.tailMode==="hidden"&&!te.alternate&&!oi)return Tr(m),null}else 2*Yt()-$.renderingStartTime>bh&&w!==1073741824&&(m.flags|=128,_=!0,Tm($,!1),m.lanes=4194304);$.isBackwards?(te.sibling=m.child,m.child=te):(w=$.last,w!==null?w.sibling=te:m.child=te,$.last=te)}return $.tail!==null?(m=$.tail,$.rendering=m,$.tail=m.sibling,$.renderingStartTime=Yt(),m.sibling=null,w=ci.current,Zs(ci,_?w&1|2:w&1),m):(Tr(m),null);case 22:case 23:return h3(),_=m.memoizedState!==null,f!==null&&f.memoizedState!==null!==_&&(m.flags|=8192),_&&(m.mode&1)!==0?(To&1073741824)!==0&&(Tr(m),m.subtreeFlags&6&&(m.flags|=8192)):Tr(m),null;case 24:return null;case 25:return null}throw Error(t(156,m.tag))}function Y7(f,m){switch(bb(m),m.tag){case 1:return oo(m.type)&&z1(),f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 3:return xh(),ti(ro),ti(_r),Db(),f=m.flags,(f&65536)!==0&&(f&128)===0?(m.flags=f&-65537|128,m):null;case 5:return Nb(m),null;case 13:if(ti(ci),f=m.memoizedState,f!==null&&f.dehydrated!==null){if(m.alternate===null)throw Error(t(340));fh()}return f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 19:return ti(ci),null;case 4:return xh(),null;case 10:return Ib(m.type._context),null;case 22:case 23:return h3(),null;case 24:return null;default:return null}}var rx=!1,Ir=!1,Z7=typeof WeakSet=="function"?WeakSet:Set,an=null;function yh(f,m){var w=f.ref;if(w!==null)if(typeof w=="function")try{w(null)}catch(_){gi(f,m,_)}else w.current=null}function e3(f,m,w){try{w()}catch(_){gi(f,m,_)}}var Ak=!1;function Q7(f,m){if(hb=fe,f=a4(),ib(f)){if("selectionStart"in f)var w={start:f.selectionStart,end:f.selectionEnd};else e:{w=(w=f.ownerDocument)&&w.defaultView||window;var _=w.getSelection&&w.getSelection();if(_&&_.rangeCount!==0){w=_.anchorNode;var N=_.anchorOffset,$=_.focusNode;_=_.focusOffset;try{w.nodeType,$.nodeType}catch{w=null;break e}var te=0,me=-1,_e=-1,et=0,_t=0,Nt=f,Ct=null;t:for(;;){for(var tn;Nt!==w||N!==0&&Nt.nodeType!==3||(me=te+N),Nt!==$||_!==0&&Nt.nodeType!==3||(_e=te+_),Nt.nodeType===3&&(te+=Nt.nodeValue.length),(tn=Nt.firstChild)!==null;)Ct=Nt,Nt=tn;for(;;){if(Nt===f)break t;if(Ct===w&&++et===N&&(me=te),Ct===$&&++_t===_&&(_e=te),(tn=Nt.nextSibling)!==null)break;Nt=Ct,Ct=Nt.parentNode}Nt=tn}w=me===-1||_e===-1?null:{start:me,end:_e}}else w=null}w=w||{start:0,end:0}}else w=null;for(fb={focusedElem:f,selectionRange:w},fe=!1,an=m;an!==null;)if(m=an,f=m.child,(m.subtreeFlags&1028)!==0&&f!==null)f.return=m,an=f;else for(;an!==null;){m=an;try{var hn=m.alternate;if((m.flags&1024)!==0)switch(m.tag){case 0:case 11:case 15:break;case 1:if(hn!==null){var xn=hn.memoizedProps,Ii=hn.memoizedState,He=m.stateNode,Me=He.getSnapshotBeforeUpdate(m.elementType===m.type?xn:fa(m.type,xn),Ii);He.__reactInternalSnapshotBeforeUpdate=Me}break;case 3:var qe=m.stateNode.containerInfo;qe.nodeType===1?qe.textContent="":qe.nodeType===9&&qe.documentElement&&qe.removeChild(qe.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(Lt){gi(m,m.return,Lt)}if(f=m.sibling,f!==null){f.return=m.return,an=f;break}an=m.return}return hn=Ak,Ak=!1,hn}function Im(f,m,w){var _=m.updateQueue;if(_=_!==null?_.lastEffect:null,_!==null){var N=_=_.next;do{if((N.tag&f)===f){var $=N.destroy;N.destroy=void 0,$!==void 0&&e3(m,w,$)}N=N.next}while(N!==_)}}function ox(f,m){if(m=m.updateQueue,m=m!==null?m.lastEffect:null,m!==null){var w=m=m.next;do{if((w.tag&f)===f){var _=w.create;w.destroy=_()}w=w.next}while(w!==m)}}function t3(f){var m=f.ref;if(m!==null){var w=f.stateNode;switch(f.tag){case 5:f=w;break;default:f=w}typeof m=="function"?m(f):m.current=f}}function Rk(f){var m=f.alternate;m!==null&&(f.alternate=null,Rk(m)),f.child=null,f.deletions=null,f.sibling=null,f.tag===5&&(m=f.stateNode,m!==null&&(delete m[Xa],delete m[gm],delete m[xb],delete m[D7],delete m[L7])),f.stateNode=null,f.return=null,f.dependencies=null,f.memoizedProps=null,f.memoizedState=null,f.pendingProps=null,f.stateNode=null,f.updateQueue=null}function Mk(f){return f.tag===5||f.tag===3||f.tag===4}function Nk(f){e:for(;;){for(;f.sibling===null;){if(f.return===null||Mk(f.return))return null;f=f.return}for(f.sibling.return=f.return,f=f.sibling;f.tag!==5&&f.tag!==6&&f.tag!==18;){if(f.flags&2||f.child===null||f.tag===4)continue e;f.child.return=f,f=f.child}if(!(f.flags&2))return f.stateNode}}function n3(f,m,w){var _=f.tag;if(_===5||_===6)f=f.stateNode,m?w.nodeType===8?w.parentNode.insertBefore(f,m):w.insertBefore(f,m):(w.nodeType===8?(m=w.parentNode,m.insertBefore(f,w)):(m=w,m.appendChild(f)),w=w._reactRootContainer,w!=null||m.onclick!==null||(m.onclick=F1));else if(_!==4&&(f=f.child,f!==null))for(n3(f,m,w),f=f.sibling;f!==null;)n3(f,m,w),f=f.sibling}function s3(f,m,w){var _=f.tag;if(_===5||_===6)f=f.stateNode,m?w.insertBefore(f,m):w.appendChild(f);else if(_!==4&&(f=f.child,f!==null))for(s3(f,m,w),f=f.sibling;f!==null;)s3(f,m,w),f=f.sibling}var mr=null,pa=!1;function Ic(f,m,w){for(w=w.child;w!==null;)Pk(f,m,w),w=w.sibling}function Pk(f,m,w){if(ss&&typeof ss.onCommitFiberUnmount=="function")try{ss.onCommitFiberUnmount(Mi,w)}catch{}switch(w.tag){case 5:Ir||yh(w,m);case 6:var _=mr,N=pa;mr=null,Ic(f,m,w),mr=_,pa=N,mr!==null&&(pa?(f=mr,w=w.stateNode,f.nodeType===8?f.parentNode.removeChild(w):f.removeChild(w)):mr.removeChild(w.stateNode));break;case 18:mr!==null&&(pa?(f=mr,w=w.stateNode,f.nodeType===8?gb(f.parentNode,w):f.nodeType===1&&gb(f,w),de(f)):gb(mr,w.stateNode));break;case 4:_=mr,N=pa,mr=w.stateNode.containerInfo,pa=!0,Ic(f,m,w),mr=_,pa=N;break;case 0:case 11:case 14:case 15:if(!Ir&&(_=w.updateQueue,_!==null&&(_=_.lastEffect,_!==null))){N=_=_.next;do{var $=N,te=$.destroy;$=$.tag,te!==void 0&&(($&2)!==0||($&4)!==0)&&e3(w,m,te),N=N.next}while(N!==_)}Ic(f,m,w);break;case 1:if(!Ir&&(yh(w,m),_=w.stateNode,typeof _.componentWillUnmount=="function"))try{_.props=w.memoizedProps,_.state=w.memoizedState,_.componentWillUnmount()}catch(me){gi(w,m,me)}Ic(f,m,w);break;case 21:Ic(f,m,w);break;case 22:w.mode&1?(Ir=(_=Ir)||w.memoizedState!==null,Ic(f,m,w),Ir=_):Ic(f,m,w);break;default:Ic(f,m,w)}}function Dk(f){var m=f.updateQueue;if(m!==null){f.updateQueue=null;var w=f.stateNode;w===null&&(w=f.stateNode=new Z7),m.forEach(function(_){var N=a9.bind(null,f,_);w.has(_)||(w.add(_),_.then(N,N))})}}function ma(f,m){var w=m.deletions;if(w!==null)for(var _=0;_<w.length;_++){var N=w[_];try{var $=f,te=m,me=te;e:for(;me!==null;){switch(me.tag){case 5:mr=me.stateNode,pa=!1;break e;case 3:mr=me.stateNode.containerInfo,pa=!0;break e;case 4:mr=me.stateNode.containerInfo,pa=!0;break e}me=me.return}if(mr===null)throw Error(t(160));Pk($,te,N),mr=null,pa=!1;var _e=N.alternate;_e!==null&&(_e.return=null),N.return=null}catch(et){gi(N,m,et)}}if(m.subtreeFlags&12854)for(m=m.child;m!==null;)Lk(m,f),m=m.sibling}function Lk(f,m){var w=f.alternate,_=f.flags;switch(f.tag){case 0:case 11:case 14:case 15:if(ma(m,f),Ya(f),_&4){try{Im(3,f,f.return),ox(3,f)}catch(xn){gi(f,f.return,xn)}try{Im(5,f,f.return)}catch(xn){gi(f,f.return,xn)}}break;case 1:ma(m,f),Ya(f),_&512&&w!==null&&yh(w,w.return);break;case 5:if(ma(m,f),Ya(f),_&512&&w!==null&&yh(w,w.return),f.flags&32){var N=f.stateNode;try{pt(N,"")}catch(xn){gi(f,f.return,xn)}}if(_&4&&(N=f.stateNode,N!=null)){var $=f.memoizedProps,te=w!==null?w.memoizedProps:$,me=f.type,_e=f.updateQueue;if(f.updateQueue=null,_e!==null)try{me==="input"&&$.type==="radio"&&$.name!=null&&wt(N,$),bt(me,te);var et=bt(me,$);for(te=0;te<_e.length;te+=2){var _t=_e[te],Nt=_e[te+1];_t==="style"?Ye(N,Nt):_t==="dangerouslySetInnerHTML"?Pt(N,Nt):_t==="children"?pt(N,Nt):S(N,_t,Nt,et)}switch(me){case"input":Vt(N,$);break;case"textarea":Y(N,$);break;case"select":var Ct=N._wrapperState.wasMultiple;N._wrapperState.wasMultiple=!!$.multiple;var tn=$.value;tn!=null?dn(N,!!$.multiple,tn,!1):Ct!==!!$.multiple&&($.defaultValue!=null?dn(N,!!$.multiple,$.defaultValue,!0):dn(N,!!$.multiple,$.multiple?[]:"",!1))}N[gm]=$}catch(xn){gi(f,f.return,xn)}}break;case 6:if(ma(m,f),Ya(f),_&4){if(f.stateNode===null)throw Error(t(162));N=f.stateNode,$=f.memoizedProps;try{N.nodeValue=$}catch(xn){gi(f,f.return,xn)}}break;case 3:if(ma(m,f),Ya(f),_&4&&w!==null&&w.memoizedState.isDehydrated)try{de(m.containerInfo)}catch(xn){gi(f,f.return,xn)}break;case 4:ma(m,f),Ya(f);break;case 13:ma(m,f),Ya(f),N=f.child,N.flags&8192&&($=N.memoizedState!==null,N.stateNode.isHidden=$,!$||N.alternate!==null&&N.alternate.memoizedState!==null||(o3=Yt())),_&4&&Dk(f);break;case 22:if(_t=w!==null&&w.memoizedState!==null,f.mode&1?(Ir=(et=Ir)||_t,ma(m,f),Ir=et):ma(m,f),Ya(f),_&8192){if(et=f.memoizedState!==null,(f.stateNode.isHidden=et)&&!_t&&(f.mode&1)!==0)for(an=f,_t=f.child;_t!==null;){for(Nt=an=_t;an!==null;){switch(Ct=an,tn=Ct.child,Ct.tag){case 0:case 11:case 14:case 15:Im(4,Ct,Ct.return);break;case 1:yh(Ct,Ct.return);var hn=Ct.stateNode;if(typeof hn.componentWillUnmount=="function"){_=Ct,w=Ct.return;try{m=_,hn.props=m.memoizedProps,hn.state=m.memoizedState,hn.componentWillUnmount()}catch(xn){gi(_,w,xn)}}break;case 5:yh(Ct,Ct.return);break;case 22:if(Ct.memoizedState!==null){Ok(Nt);continue}}tn!==null?(tn.return=Ct,an=tn):Ok(Nt)}_t=_t.sibling}e:for(_t=null,Nt=f;;){if(Nt.tag===5){if(_t===null){_t=Nt;try{N=Nt.stateNode,et?($=N.style,typeof $.setProperty=="function"?$.setProperty("display","none","important"):$.display="none"):(me=Nt.stateNode,_e=Nt.memoizedProps.style,te=_e!=null&&_e.hasOwnProperty("display")?_e.display:null,me.style.display=xt("display",te))}catch(xn){gi(f,f.return,xn)}}}else if(Nt.tag===6){if(_t===null)try{Nt.stateNode.nodeValue=et?"":Nt.memoizedProps}catch(xn){gi(f,f.return,xn)}}else if((Nt.tag!==22&&Nt.tag!==23||Nt.memoizedState===null||Nt===f)&&Nt.child!==null){Nt.child.return=Nt,Nt=Nt.child;continue}if(Nt===f)break e;for(;Nt.sibling===null;){if(Nt.return===null||Nt.return===f)break e;_t===Nt&&(_t=null),Nt=Nt.return}_t===Nt&&(_t=null),Nt.sibling.return=Nt.return,Nt=Nt.sibling}}break;case 19:ma(m,f),Ya(f),_&4&&Dk(f);break;case 21:break;default:ma(m,f),Ya(f)}}function Ya(f){var m=f.flags;if(m&2){try{e:{for(var w=f.return;w!==null;){if(Mk(w)){var _=w;break e}w=w.return}throw Error(t(160))}switch(_.tag){case 5:var N=_.stateNode;_.flags&32&&(pt(N,""),_.flags&=-33);var $=Nk(f);s3(f,$,N);break;case 3:case 4:var te=_.stateNode.containerInfo,me=Nk(f);n3(f,me,te);break;default:throw Error(t(161))}}catch(_e){gi(f,f.return,_e)}f.flags&=-3}m&4096&&(f.flags&=-4097)}function J7(f,m,w){an=f,$k(f)}function $k(f,m,w){for(var _=(f.mode&1)!==0;an!==null;){var N=an,$=N.child;if(N.tag===22&&_){var te=N.memoizedState!==null||rx;if(!te){var me=N.alternate,_e=me!==null&&me.memoizedState!==null||Ir;me=rx;var et=Ir;if(rx=te,(Ir=_e)&&!et)for(an=N;an!==null;)te=an,_e=te.child,te.tag===22&&te.memoizedState!==null?zk(N):_e!==null?(_e.return=te,an=_e):zk(N);for(;$!==null;)an=$,$k($),$=$.sibling;an=N,rx=me,Ir=et}Fk(f)}else(N.subtreeFlags&8772)!==0&&$!==null?($.return=N,an=$):Fk(f)}}function Fk(f){for(;an!==null;){var m=an;if((m.flags&8772)!==0){var w=m.alternate;try{if((m.flags&8772)!==0)switch(m.tag){case 0:case 11:case 15:Ir||ox(5,m);break;case 1:var _=m.stateNode;if(m.flags&4&&!Ir)if(w===null)_.componentDidMount();else{var N=m.elementType===m.type?w.memoizedProps:fa(m.type,w.memoizedProps);_.componentDidUpdate(N,w.memoizedState,_.__reactInternalSnapshotBeforeUpdate)}var $=m.updateQueue;$!==null&&O4(m,$,_);break;case 3:var te=m.updateQueue;if(te!==null){if(w=null,m.child!==null)switch(m.child.tag){case 5:w=m.child.stateNode;break;case 1:w=m.child.stateNode}O4(m,te,w)}break;case 5:var me=m.stateNode;if(w===null&&m.flags&4){w=me;var _e=m.memoizedProps;switch(m.type){case"button":case"input":case"select":case"textarea":_e.autoFocus&&w.focus();break;case"img":_e.src&&(w.src=_e.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(m.memoizedState===null){var et=m.alternate;if(et!==null){var _t=et.memoizedState;if(_t!==null){var Nt=_t.dehydrated;Nt!==null&&de(Nt)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}Ir||m.flags&512&&t3(m)}catch(Ct){gi(m,m.return,Ct)}}if(m===f){an=null;break}if(w=m.sibling,w!==null){w.return=m.return,an=w;break}an=m.return}}function Ok(f){for(;an!==null;){var m=an;if(m===f){an=null;break}var w=m.sibling;if(w!==null){w.return=m.return,an=w;break}an=m.return}}function zk(f){for(;an!==null;){var m=an;try{switch(m.tag){case 0:case 11:case 15:var w=m.return;try{ox(4,m)}catch(_e){gi(m,w,_e)}break;case 1:var _=m.stateNode;if(typeof _.componentDidMount=="function"){var N=m.return;try{_.componentDidMount()}catch(_e){gi(m,N,_e)}}var $=m.return;try{t3(m)}catch(_e){gi(m,$,_e)}break;case 5:var te=m.return;try{t3(m)}catch(_e){gi(m,te,_e)}}}catch(_e){gi(m,m.return,_e)}if(m===f){an=null;break}var me=m.sibling;if(me!==null){me.return=m.return,an=me;break}an=m.return}}var e9=Math.ceil,ax=C.ReactCurrentDispatcher,i3=C.ReactCurrentOwner,Ho=C.ReactCurrentBatchConfig,Cs=0,sr=null,Pi=null,gr=0,To=0,wh=Sc(0),ji=0,km=null,Mu=0,lx=0,r3=0,Am=null,lo=null,o3=0,bh=1/0,Wl=null,cx=!1,a3=null,kc=null,ux=!1,Ac=null,dx=0,Rm=0,l3=null,hx=-1,fx=0;function Ur(){return(Cs&6)!==0?Yt():hx!==-1?hx:hx=Yt()}function Rc(f){return(f.mode&1)===0?1:(Cs&2)!==0&&gr!==0?gr&-gr:F7.transition!==null?(fx===0&&(fx=Tn()),fx):(f=jt,f!==0||(f=window.event,f=f===void 0?16:Ft(f.type)),f)}function ga(f,m,w,_){if(50<Rm)throw Rm=0,l3=null,Error(t(185));Dn(f,w,_),((Cs&2)===0||f!==sr)&&(f===sr&&((Cs&2)===0&&(lx|=w),ji===4&&Mc(f,gr)),co(f,_),w===1&&Cs===0&&(m.mode&1)===0&&(bh=Yt()+500,U1&&_c()))}function co(f,m){var w=f.callbackNode;mt(f,m);var _=Ue(f,f===sr?gr:0);if(_===0)w!==null&&Kt(w),f.callbackNode=null,f.callbackPriority=0;else if(m=_&-_,f.callbackPriority!==m){if(w!=null&&Kt(w),m===1)f.tag===0?$7(Uk.bind(null,f)):T4(Uk.bind(null,f)),N7(function(){(Cs&6)===0&&_c()}),w=null;else{switch(Un(_)){case 1:w=_n;break;case 4:w=En;break;case 16:w=fs;break;case 536870912:w=Ws;break;default:w=fs}w=Kk(w,Bk.bind(null,f))}f.callbackPriority=m,f.callbackNode=w}}function Bk(f,m){if(hx=-1,fx=0,(Cs&6)!==0)throw Error(t(327));var w=f.callbackNode;if(Sh()&&f.callbackNode!==w)return null;var _=Ue(f,f===sr?gr:0);if(_===0)return null;if((_&30)!==0||(_&f.expiredLanes)!==0||m)m=px(f,_);else{m=_;var N=Cs;Cs|=2;var $=Wk();(sr!==f||gr!==m)&&(Wl=null,bh=Yt()+500,Pu(f,m));do try{s9();break}catch(me){Vk(f,me)}while(!0);Tb(),ax.current=$,Cs=N,Pi!==null?m=0:(sr=null,gr=0,m=ji)}if(m!==0){if(m===2&&(N=qt(f),N!==0&&(_=N,m=c3(f,N))),m===1)throw w=km,Pu(f,0),Mc(f,_),co(f,Yt()),w;if(m===6)Mc(f,_);else{if(N=f.current.alternate,(_&30)===0&&!t9(N)&&(m=px(f,_),m===2&&($=qt(f),$!==0&&(_=$,m=c3(f,$))),m===1))throw w=km,Pu(f,0),Mc(f,_),co(f,Yt()),w;switch(f.finishedWork=N,f.finishedLanes=_,m){case 0:case 1:throw Error(t(345));case 2:Du(f,lo,Wl);break;case 3:if(Mc(f,_),(_&130023424)===_&&(m=o3+500-Yt(),10<m)){if(Ue(f,0)!==0)break;if(N=f.suspendedLanes,(N&_)!==_){Ur(),f.pingedLanes|=f.suspendedLanes&N;break}f.timeoutHandle=mb(Du.bind(null,f,lo,Wl),m);break}Du(f,lo,Wl);break;case 4:if(Mc(f,_),(_&4194240)===_)break;for(m=f.eventTimes,N=-1;0<_;){var te=31-Ss(_);$=1<<te,te=m[te],te>N&&(N=te),_&=~$}if(_=N,_=Yt()-_,_=(120>_?120:480>_?480:1080>_?1080:1920>_?1920:3e3>_?3e3:4320>_?4320:1960*e9(_/1960))-_,10<_){f.timeoutHandle=mb(Du.bind(null,f,lo,Wl),_);break}Du(f,lo,Wl);break;case 5:Du(f,lo,Wl);break;default:throw Error(t(329))}}}return co(f,Yt()),f.callbackNode===w?Bk.bind(null,f):null}function c3(f,m){var w=Am;return f.current.memoizedState.isDehydrated&&(Pu(f,m).flags|=256),f=px(f,m),f!==2&&(m=lo,lo=w,m!==null&&u3(m)),f}function u3(f){lo===null?lo=f:lo.push.apply(lo,f)}function t9(f){for(var m=f;;){if(m.flags&16384){var w=m.updateQueue;if(w!==null&&(w=w.stores,w!==null))for(var _=0;_<w.length;_++){var N=w[_],$=N.getSnapshot;N=N.value;try{if(!da($(),N))return!1}catch{return!1}}}if(w=m.child,m.subtreeFlags&16384&&w!==null)w.return=m,m=w;else{if(m===f)break;for(;m.sibling===null;){if(m.return===null||m.return===f)return!0;m=m.return}m.sibling.return=m.return,m=m.sibling}}return!0}function Mc(f,m){for(m&=~r3,m&=~lx,f.suspendedLanes|=m,f.pingedLanes&=~m,f=f.expirationTimes;0<m;){var w=31-Ss(m),_=1<<w;f[w]=-1,m&=~_}}function Uk(f){if((Cs&6)!==0)throw Error(t(327));Sh();var m=Ue(f,0);if((m&1)===0)return co(f,Yt()),null;var w=px(f,m);if(f.tag!==0&&w===2){var _=qt(f);_!==0&&(m=_,w=c3(f,_))}if(w===1)throw w=km,Pu(f,0),Mc(f,m),co(f,Yt()),w;if(w===6)throw Error(t(345));return f.finishedWork=f.current.alternate,f.finishedLanes=m,Du(f,lo,Wl),co(f,Yt()),null}function d3(f,m){var w=Cs;Cs|=1;try{return f(m)}finally{Cs=w,Cs===0&&(bh=Yt()+500,U1&&_c())}}function Nu(f){Ac!==null&&Ac.tag===0&&(Cs&6)===0&&Sh();var m=Cs;Cs|=1;var w=Ho.transition,_=jt;try{if(Ho.transition=null,jt=1,f)return f()}finally{jt=_,Ho.transition=w,Cs=m,(Cs&6)===0&&_c()}}function h3(){To=wh.current,ti(wh)}function Pu(f,m){f.finishedWork=null,f.finishedLanes=0;var w=f.timeoutHandle;if(w!==-1&&(f.timeoutHandle=-1,M7(w)),Pi!==null)for(w=Pi.return;w!==null;){var _=w;switch(bb(_),_.tag){case 1:_=_.type.childContextTypes,_!=null&&z1();break;case 3:xh(),ti(ro),ti(_r),Db();break;case 5:Nb(_);break;case 4:xh();break;case 13:ti(ci);break;case 19:ti(ci);break;case 10:Ib(_.type._context);break;case 22:case 23:h3()}w=w.return}if(sr=f,Pi=f=Nc(f.current,null),gr=To=m,ji=0,km=null,r3=lx=Mu=0,lo=Am=null,ku!==null){for(m=0;m<ku.length;m++)if(w=ku[m],_=w.interleaved,_!==null){w.interleaved=null;var N=_.next,$=w.pending;if($!==null){var te=$.next;$.next=N,_.next=te}w.pending=_}ku=null}return f}function Vk(f,m){do{var w=Pi;try{if(Tb(),Z1.current=tx,Q1){for(var _=ui.memoizedState;_!==null;){var N=_.queue;N!==null&&(N.pending=null),_=_.next}Q1=!1}if(Ru=0,nr=Hi=ui=null,Sm=!1,Cm=0,i3.current=null,w===null||w.return===null){ji=1,km=m,Pi=null;break}e:{var $=f,te=w.return,me=w,_e=m;if(m=gr,me.flags|=32768,_e!==null&&typeof _e=="object"&&typeof _e.then=="function"){var et=_e,_t=me,Nt=_t.tag;if((_t.mode&1)===0&&(Nt===0||Nt===11||Nt===15)){var Ct=_t.alternate;Ct?(_t.updateQueue=Ct.updateQueue,_t.memoizedState=Ct.memoizedState,_t.lanes=Ct.lanes):(_t.updateQueue=null,_t.memoizedState=null)}var tn=fk(te);if(tn!==null){tn.flags&=-257,pk(tn,te,me,$,m),tn.mode&1&&hk($,et,m),m=tn,_e=et;var hn=m.updateQueue;if(hn===null){var xn=new Set;xn.add(_e),m.updateQueue=xn}else hn.add(_e);break e}else{if((m&1)===0){hk($,et,m),f3();break e}_e=Error(t(426))}}else if(oi&&me.mode&1){var Ii=fk(te);if(Ii!==null){(Ii.flags&65536)===0&&(Ii.flags|=256),pk(Ii,te,me,$,m),_b(vh(_e,me));break e}}$=_e=vh(_e,me),ji!==4&&(ji=2),Am===null?Am=[$]:Am.push($),$=te;do{switch($.tag){case 3:$.flags|=65536,m&=-m,$.lanes|=m;var He=uk($,_e,m);F4($,He);break e;case 1:me=_e;var Me=$.type,qe=$.stateNode;if(($.flags&128)===0&&(typeof Me.getDerivedStateFromError=="function"||qe!==null&&typeof qe.componentDidCatch=="function"&&(kc===null||!kc.has(qe)))){$.flags|=65536,m&=-m,$.lanes|=m;var Lt=dk($,me,m);F4($,Lt);break e}}$=$.return}while($!==null)}Hk(w)}catch(yn){m=yn,Pi===w&&w!==null&&(Pi=w=w.return);continue}break}while(!0)}function Wk(){var f=ax.current;return ax.current=tx,f===null?tx:f}function f3(){(ji===0||ji===3||ji===2)&&(ji=4),sr===null||(Mu&268435455)===0&&(lx&268435455)===0||Mc(sr,gr)}function px(f,m){var w=Cs;Cs|=2;var _=Wk();(sr!==f||gr!==m)&&(Wl=null,Pu(f,m));do try{n9();break}catch(N){Vk(f,N)}while(!0);if(Tb(),Cs=w,ax.current=_,Pi!==null)throw Error(t(261));return sr=null,gr=0,ji}function n9(){for(;Pi!==null;)Gk(Pi)}function s9(){for(;Pi!==null&&!on();)Gk(Pi)}function Gk(f){var m=qk(f.alternate,f,To);f.memoizedProps=f.pendingProps,m===null?Hk(f):Pi=m,i3.current=null}function Hk(f){var m=f;do{var w=m.alternate;if(f=m.return,(m.flags&32768)===0){if(w=K7(w,m,To),w!==null){Pi=w;return}}else{if(w=Y7(w,m),w!==null){w.flags&=32767,Pi=w;return}if(f!==null)f.flags|=32768,f.subtreeFlags=0,f.deletions=null;else{ji=6,Pi=null;return}}if(m=m.sibling,m!==null){Pi=m;return}Pi=m=f}while(m!==null);ji===0&&(ji=5)}function Du(f,m,w){var _=jt,N=Ho.transition;try{Ho.transition=null,jt=1,i9(f,m,w,_)}finally{Ho.transition=N,jt=_}return null}function i9(f,m,w,_){do Sh();while(Ac!==null);if((Cs&6)!==0)throw Error(t(327));w=f.finishedWork;var N=f.finishedLanes;if(w===null)return null;if(f.finishedWork=null,f.finishedLanes=0,w===f.current)throw Error(t(177));f.callbackNode=null,f.callbackPriority=0;var $=w.lanes|w.childLanes;if(Nn(f,$),f===sr&&(Pi=sr=null,gr=0),(w.subtreeFlags&2064)===0&&(w.flags&2064)===0||ux||(ux=!0,Kk(fs,function(){return Sh(),null})),$=(w.flags&15990)!==0,(w.subtreeFlags&15990)!==0||$){$=Ho.transition,Ho.transition=null;var te=jt;jt=1;var me=Cs;Cs|=4,i3.current=null,Q7(f,w),Lk(w,f),_7(fb),fe=!!hb,fb=hb=null,f.current=w,J7(w),bn(),Cs=me,jt=te,Ho.transition=$}else f.current=w;if(ux&&(ux=!1,Ac=f,dx=N),$=f.pendingLanes,$===0&&(kc=null),Vn(w.stateNode),co(f,Yt()),m!==null)for(_=f.onRecoverableError,w=0;w<m.length;w++)N=m[w],_(N.value,{componentStack:N.stack,digest:N.digest});if(cx)throw cx=!1,f=a3,a3=null,f;return(dx&1)!==0&&f.tag!==0&&Sh(),$=f.pendingLanes,($&1)!==0?f===l3?Rm++:(Rm=0,l3=f):Rm=0,_c(),null}function Sh(){if(Ac!==null){var f=Un(dx),m=Ho.transition,w=jt;try{if(Ho.transition=null,jt=16>f?16:f,Ac===null)var _=!1;else{if(f=Ac,Ac=null,dx=0,(Cs&6)!==0)throw Error(t(331));var N=Cs;for(Cs|=4,an=f.current;an!==null;){var $=an,te=$.child;if((an.flags&16)!==0){var me=$.deletions;if(me!==null){for(var _e=0;_e<me.length;_e++){var et=me[_e];for(an=et;an!==null;){var _t=an;switch(_t.tag){case 0:case 11:case 15:Im(8,_t,$)}var Nt=_t.child;if(Nt!==null)Nt.return=_t,an=Nt;else for(;an!==null;){_t=an;var Ct=_t.sibling,tn=_t.return;if(Rk(_t),_t===et){an=null;break}if(Ct!==null){Ct.return=tn,an=Ct;break}an=tn}}}var hn=$.alternate;if(hn!==null){var xn=hn.child;if(xn!==null){hn.child=null;do{var Ii=xn.sibling;xn.sibling=null,xn=Ii}while(xn!==null)}}an=$}}if(($.subtreeFlags&2064)!==0&&te!==null)te.return=$,an=te;else e:for(;an!==null;){if($=an,($.flags&2048)!==0)switch($.tag){case 0:case 11:case 15:Im(9,$,$.return)}var He=$.sibling;if(He!==null){He.return=$.return,an=He;break e}an=$.return}}var Me=f.current;for(an=Me;an!==null;){te=an;var qe=te.child;if((te.subtreeFlags&2064)!==0&&qe!==null)qe.return=te,an=qe;else e:for(te=Me;an!==null;){if(me=an,(me.flags&2048)!==0)try{switch(me.tag){case 0:case 11:case 15:ox(9,me)}}catch(yn){gi(me,me.return,yn)}if(me===te){an=null;break e}var Lt=me.sibling;if(Lt!==null){Lt.return=me.return,an=Lt;break e}an=me.return}}if(Cs=N,_c(),ss&&typeof ss.onPostCommitFiberRoot=="function")try{ss.onPostCommitFiberRoot(Mi,f)}catch{}_=!0}return _}finally{jt=w,Ho.transition=m}}return!1}function jk(f,m,w){m=vh(w,m),m=uk(f,m,1),f=Tc(f,m,1),m=Ur(),f!==null&&(Dn(f,1,m),co(f,m))}function gi(f,m,w){if(f.tag===3)jk(f,f,w);else for(;m!==null;){if(m.tag===3){jk(m,f,w);break}else if(m.tag===1){var _=m.stateNode;if(typeof m.type.getDerivedStateFromError=="function"||typeof _.componentDidCatch=="function"&&(kc===null||!kc.has(_))){f=vh(w,f),f=dk(m,f,1),m=Tc(m,f,1),f=Ur(),m!==null&&(Dn(m,1,f),co(m,f));break}}m=m.return}}function r9(f,m,w){var _=f.pingCache;_!==null&&_.delete(m),m=Ur(),f.pingedLanes|=f.suspendedLanes&w,sr===f&&(gr&w)===w&&(ji===4||ji===3&&(gr&130023424)===gr&&500>Yt()-o3?Pu(f,0):r3|=w),co(f,m)}function Xk(f,m){m===0&&((f.mode&1)===0?m=1:(m=Oe,Oe<<=1,(Oe&130023424)===0&&(Oe=4194304)));var w=Ur();f=Bl(f,m),f!==null&&(Dn(f,m,w),co(f,w))}function o9(f){var m=f.memoizedState,w=0;m!==null&&(w=m.retryLane),Xk(f,w)}function a9(f,m){var w=0;switch(f.tag){case 13:var _=f.stateNode,N=f.memoizedState;N!==null&&(w=N.retryLane);break;case 19:_=f.stateNode;break;default:throw Error(t(314))}_!==null&&_.delete(m),Xk(f,w)}var qk;qk=function(f,m,w){if(f!==null)if(f.memoizedProps!==m.pendingProps||ro.current)ao=!0;else{if((f.lanes&w)===0&&(m.flags&128)===0)return ao=!1,q7(f,m,w);ao=(f.flags&131072)!==0}else ao=!1,oi&&(m.flags&1048576)!==0&&I4(m,W1,m.index);switch(m.lanes=0,m.tag){case 2:var _=m.type;ix(f,m),f=m.pendingProps;var N=uh(m,_r.current);gh(m,w),N=Fb(null,m,_,f,N,w);var $=Ob();return m.flags|=1,typeof N=="object"&&N!==null&&typeof N.render=="function"&&N.$$typeof===void 0?(m.tag=1,m.memoizedState=null,m.updateQueue=null,oo(_)?($=!0,B1(m)):$=!1,m.memoizedState=N.state!==null&&N.state!==void 0?N.state:null,Rb(m),N.updater=nx,m.stateNode=N,N._reactInternals=m,Gb(m,_,f,w),m=qb(null,m,_,!0,$,w)):(m.tag=0,oi&&$&&wb(m),Br(null,m,N,w),m=m.child),m;case 16:_=m.elementType;e:{switch(ix(f,m),f=m.pendingProps,N=_._init,_=N(_._payload),m.type=_,N=m.tag=c9(_),f=fa(_,f),N){case 0:m=Xb(null,m,_,f,w);break e;case 1:m=wk(null,m,_,f,w);break e;case 11:m=mk(null,m,_,f,w);break e;case 14:m=gk(null,m,_,fa(_.type,f),w);break e}throw Error(t(306,_,""))}return m;case 0:return _=m.type,N=m.pendingProps,N=m.elementType===_?N:fa(_,N),Xb(f,m,_,N,w);case 1:return _=m.type,N=m.pendingProps,N=m.elementType===_?N:fa(_,N),wk(f,m,_,N,w);case 3:e:{if(bk(m),f===null)throw Error(t(387));_=m.pendingProps,$=m.memoizedState,N=$.element,$4(f,m),K1(m,_,null,w);var te=m.memoizedState;if(_=te.element,$.isDehydrated)if($={element:_,isDehydrated:!1,cache:te.cache,pendingSuspenseBoundaries:te.pendingSuspenseBoundaries,transitions:te.transitions},m.updateQueue.baseState=$,m.memoizedState=$,m.flags&256){N=vh(Error(t(423)),m),m=Sk(f,m,_,w,N);break e}else if(_!==N){N=vh(Error(t(424)),m),m=Sk(f,m,_,w,N);break e}else for(Eo=bc(m.stateNode.containerInfo.firstChild),_o=m,oi=!0,ha=null,w=D4(m,null,_,w),m.child=w;w;)w.flags=w.flags&-3|4096,w=w.sibling;else{if(fh(),_===N){m=Vl(f,m,w);break e}Br(f,m,_,w)}m=m.child}return m;case 5:return z4(m),f===null&&Cb(m),_=m.type,N=m.pendingProps,$=f!==null?f.memoizedProps:null,te=N.children,pb(_,N)?te=null:$!==null&&pb(_,$)&&(m.flags|=32),yk(f,m),Br(f,m,te,w),m.child;case 6:return f===null&&Cb(m),null;case 13:return Ck(f,m,w);case 4:return Mb(m,m.stateNode.containerInfo),_=m.pendingProps,f===null?m.child=ph(m,null,_,w):Br(f,m,_,w),m.child;case 11:return _=m.type,N=m.pendingProps,N=m.elementType===_?N:fa(_,N),mk(f,m,_,N,w);case 7:return Br(f,m,m.pendingProps,w),m.child;case 8:return Br(f,m,m.pendingProps.children,w),m.child;case 12:return Br(f,m,m.pendingProps.children,w),m.child;case 10:e:{if(_=m.type._context,N=m.pendingProps,$=m.memoizedProps,te=N.value,Zs(j1,_._currentValue),_._currentValue=te,$!==null)if(da($.value,te)){if($.children===N.children&&!ro.current){m=Vl(f,m,w);break e}}else for($=m.child,$!==null&&($.return=m);$!==null;){var me=$.dependencies;if(me!==null){te=$.child;for(var _e=me.firstContext;_e!==null;){if(_e.context===_){if($.tag===1){_e=Ul(-1,w&-w),_e.tag=2;var et=$.updateQueue;if(et!==null){et=et.shared;var _t=et.pending;_t===null?_e.next=_e:(_e.next=_t.next,_t.next=_e),et.pending=_e}}$.lanes|=w,_e=$.alternate,_e!==null&&(_e.lanes|=w),kb($.return,w,m),me.lanes|=w;break}_e=_e.next}}else if($.tag===10)te=$.type===m.type?null:$.child;else if($.tag===18){if(te=$.return,te===null)throw Error(t(341));te.lanes|=w,me=te.alternate,me!==null&&(me.lanes|=w),kb(te,w,m),te=$.sibling}else te=$.child;if(te!==null)te.return=$;else for(te=$;te!==null;){if(te===m){te=null;break}if($=te.sibling,$!==null){$.return=te.return,te=$;break}te=te.return}$=te}Br(f,m,N.children,w),m=m.child}return m;case 9:return N=m.type,_=m.pendingProps.children,gh(m,w),N=Wo(N),_=_(N),m.flags|=1,Br(f,m,_,w),m.child;case 14:return _=m.type,N=fa(_,m.pendingProps),N=fa(_.type,N),gk(f,m,_,N,w);case 15:return xk(f,m,m.type,m.pendingProps,w);case 17:return _=m.type,N=m.pendingProps,N=m.elementType===_?N:fa(_,N),ix(f,m),m.tag=1,oo(_)?(f=!0,B1(m)):f=!1,gh(m,w),lk(m,_,N),Gb(m,_,N,w),qb(null,m,_,!0,f,w);case 19:return Ek(f,m,w);case 22:return vk(f,m,w)}throw Error(t(156,m.tag))};function Kk(f,m){return nt(f,m)}function l9(f,m,w,_){this.tag=f,this.key=w,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=m,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=_,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function jo(f,m,w,_){return new l9(f,m,w,_)}function p3(f){return f=f.prototype,!(!f||!f.isReactComponent)}function c9(f){if(typeof f=="function")return p3(f)?1:0;if(f!=null){if(f=f.$$typeof,f===j)return 11;if(f===X)return 14}return 2}function Nc(f,m){var w=f.alternate;return w===null?(w=jo(f.tag,m,f.key,f.mode),w.elementType=f.elementType,w.type=f.type,w.stateNode=f.stateNode,w.alternate=f,f.alternate=w):(w.pendingProps=m,w.type=f.type,w.flags=0,w.subtreeFlags=0,w.deletions=null),w.flags=f.flags&14680064,w.childLanes=f.childLanes,w.lanes=f.lanes,w.child=f.child,w.memoizedProps=f.memoizedProps,w.memoizedState=f.memoizedState,w.updateQueue=f.updateQueue,m=f.dependencies,w.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext},w.sibling=f.sibling,w.index=f.index,w.ref=f.ref,w}function mx(f,m,w,_,N,$){var te=2;if(_=f,typeof f=="function")p3(f)&&(te=1);else if(typeof f=="string")te=5;else e:switch(f){case R:return Lu(w.children,N,$,m);case L:te=8,N|=8;break;case I:return f=jo(12,w,m,N|2),f.elementType=I,f.lanes=$,f;case W:return f=jo(13,w,m,N),f.elementType=W,f.lanes=$,f;case z:return f=jo(19,w,m,N),f.elementType=z,f.lanes=$,f;case J:return gx(w,N,$,m);default:if(typeof f=="object"&&f!==null)switch(f.$$typeof){case T:te=10;break e;case M:te=9;break e;case j:te=11;break e;case X:te=14;break e;case B:te=16,_=null;break e}throw Error(t(130,f==null?f:typeof f,""))}return m=jo(te,w,m,N),m.elementType=f,m.type=_,m.lanes=$,m}function Lu(f,m,w,_){return f=jo(7,f,_,m),f.lanes=w,f}function gx(f,m,w,_){return f=jo(22,f,_,m),f.elementType=J,f.lanes=w,f.stateNode={isHidden:!1},f}function m3(f,m,w){return f=jo(6,f,null,m),f.lanes=w,f}function g3(f,m,w){return m=jo(4,f.children!==null?f.children:[],f.key,m),m.lanes=w,m.stateNode={containerInfo:f.containerInfo,pendingChildren:null,implementation:f.implementation},m}function u9(f,m,w,_,N){this.tag=m,this.containerInfo=f,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Jn(0),this.expirationTimes=Jn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Jn(0),this.identifierPrefix=_,this.onRecoverableError=N,this.mutableSourceEagerHydrationData=null}function x3(f,m,w,_,N,$,te,me,_e){return f=new u9(f,m,w,me,_e),m===1?(m=1,$===!0&&(m|=8)):m=0,$=jo(3,null,null,m),f.current=$,$.stateNode=f,$.memoizedState={element:_,isDehydrated:w,cache:null,transitions:null,pendingSuspenseBoundaries:null},Rb($),f}function d9(f,m,w){var _=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:k,key:_==null?null:""+_,children:f,containerInfo:m,implementation:w}}function Yk(f){if(!f)return Cc;f=f._reactInternals;e:{if(pr(f)!==f||f.tag!==1)throw Error(t(170));var m=f;do{switch(m.tag){case 3:m=m.stateNode.context;break e;case 1:if(oo(m.type)){m=m.stateNode.__reactInternalMemoizedMergedChildContext;break e}}m=m.return}while(m!==null);throw Error(t(171))}if(f.tag===1){var w=f.type;if(oo(w))return _4(f,w,m)}return m}function Zk(f,m,w,_,N,$,te,me,_e){return f=x3(w,_,!0,f,N,$,te,me,_e),f.context=Yk(null),w=f.current,_=Ur(),N=Rc(w),$=Ul(_,N),$.callback=m??null,Tc(w,$,N),f.current.lanes=N,Dn(f,N,_),co(f,_),f}function xx(f,m,w,_){var N=m.current,$=Ur(),te=Rc(N);return w=Yk(w),m.context===null?m.context=w:m.pendingContext=w,m=Ul($,te),m.payload={element:f},_=_===void 0?null:_,_!==null&&(m.callback=_),f=Tc(N,m,te),f!==null&&(ga(f,N,te,$),q1(f,N,te)),te}function vx(f){if(f=f.current,!f.child)return null;switch(f.child.tag){case 5:return f.child.stateNode;default:return f.child.stateNode}}function Qk(f,m){if(f=f.memoizedState,f!==null&&f.dehydrated!==null){var w=f.retryLane;f.retryLane=w!==0&&w<m?w:m}}function v3(f,m){Qk(f,m),(f=f.alternate)&&Qk(f,m)}function h9(){return null}var Jk=typeof reportError=="function"?reportError:function(f){console.error(f)};function y3(f){this._internalRoot=f}yx.prototype.render=y3.prototype.render=function(f){var m=this._internalRoot;if(m===null)throw Error(t(409));xx(f,m,null,null)},yx.prototype.unmount=y3.prototype.unmount=function(){var f=this._internalRoot;if(f!==null){this._internalRoot=null;var m=f.containerInfo;Nu(function(){xx(null,f,null,null)}),m[$l]=null}};function yx(f){this._internalRoot=f}yx.prototype.unstable_scheduleHydration=function(f){if(f){var m=P();f={blockedOn:null,target:f,priority:m};for(var w=0;w<Tt.length&&m!==0&&m<Tt[w].priority;w++);Tt.splice(w,0,f),w===0&&ln(f)}};function w3(f){return!(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11)}function wx(f){return!(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11&&(f.nodeType!==8||f.nodeValue!==" react-mount-point-unstable "))}function eA(){}function f9(f,m,w,_,N){if(N){if(typeof _=="function"){var $=_;_=function(){var et=vx(te);$.call(et)}}var te=Zk(m,_,f,0,null,!1,!1,"",eA);return f._reactRootContainer=te,f[$l]=te.current,pm(f.nodeType===8?f.parentNode:f),Nu(),te}for(;N=f.lastChild;)f.removeChild(N);if(typeof _=="function"){var me=_;_=function(){var et=vx(_e);me.call(et)}}var _e=x3(f,0,!1,null,null,!1,!1,"",eA);return f._reactRootContainer=_e,f[$l]=_e.current,pm(f.nodeType===8?f.parentNode:f),Nu(function(){xx(m,_e,w,_)}),_e}function bx(f,m,w,_,N){var $=w._reactRootContainer;if($){var te=$;if(typeof N=="function"){var me=N;N=function(){var _e=vx(te);me.call(_e)}}xx(m,te,f,N)}else te=f9(w,m,f,N,_);return vx(te)}Qn=function(f){switch(f.tag){case 3:var m=f.stateNode;if(m.current.memoizedState.isDehydrated){var w=st(m.pendingLanes);w!==0&&(sn(m,w|1),co(m,Yt()),(Cs&6)===0&&(bh=Yt()+500,_c()))}break;case 13:Nu(function(){var _=Bl(f,1);if(_!==null){var N=Ur();ga(_,f,1,N)}}),v3(f,1)}},Gs=function(f){if(f.tag===13){var m=Bl(f,134217728);if(m!==null){var w=Ur();ga(m,f,134217728,w)}v3(f,134217728)}},ps=function(f){if(f.tag===13){var m=Rc(f),w=Bl(f,m);if(w!==null){var _=Ur();ga(w,f,m,_)}v3(f,m)}},P=function(){return jt},F=function(f,m){var w=jt;try{return jt=f,m()}finally{jt=w}},Ht=function(f,m,w){switch(m){case"input":if(Vt(f,w),m=w.name,w.type==="radio"&&m!=null){for(w=f;w.parentNode;)w=w.parentNode;for(w=w.querySelectorAll("input[name="+JSON.stringify(""+m)+'][type="radio"]'),m=0;m<w.length;m++){var _=w[m];if(_!==f&&_.form===f.form){var N=O1(_);if(!N)throw Error(t(90));Ee(_),Vt(_,N)}}}break;case"textarea":Y(f,w);break;case"select":m=w.value,m!=null&&dn(f,!!w.multiple,m,!1)}},rn=d3,In=Nu;var p9={usingClientEntryPoint:!1,Events:[xm,lh,O1,Be,Rt,d3]},Mm={findFiberByHostInstance:_u,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},m9={bundleType:Mm.bundleType,version:Mm.version,rendererPackageName:Mm.rendererPackageName,rendererConfig:Mm.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:C.ReactCurrentDispatcher,findHostInstanceByFiber:function(f){return f=Ze(f),f===null?null:f.stateNode},findFiberByHostInstance:Mm.findFiberByHostInstance||h9,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Sx=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Sx.isDisabled&&Sx.supportsFiber)try{Mi=Sx.inject(m9),ss=Sx}catch{}}return uo.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=p9,uo.createPortal=function(f,m){var w=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!w3(m))throw Error(t(200));return d9(f,m,null,w)},uo.createRoot=function(f,m){if(!w3(f))throw Error(t(299));var w=!1,_="",N=Jk;return m!=null&&(m.unstable_strictMode===!0&&(w=!0),m.identifierPrefix!==void 0&&(_=m.identifierPrefix),m.onRecoverableError!==void 0&&(N=m.onRecoverableError)),m=x3(f,1,!1,null,null,w,!1,_,N),f[$l]=m.current,pm(f.nodeType===8?f.parentNode:f),new y3(m)},uo.findDOMNode=function(f){if(f==null)return null;if(f.nodeType===1)return f;var m=f._reactInternals;if(m===void 0)throw typeof f.render=="function"?Error(t(188)):(f=Object.keys(f).join(","),Error(t(268,f)));return f=Ze(m),f=f===null?null:f.stateNode,f},uo.flushSync=function(f){return Nu(f)},uo.hydrate=function(f,m,w){if(!wx(m))throw Error(t(200));return bx(null,f,m,!0,w)},uo.hydrateRoot=function(f,m,w){if(!w3(f))throw Error(t(405));var _=w!=null&&w.hydratedSources||null,N=!1,$="",te=Jk;if(w!=null&&(w.unstable_strictMode===!0&&(N=!0),w.identifierPrefix!==void 0&&($=w.identifierPrefix),w.onRecoverableError!==void 0&&(te=w.onRecoverableError)),m=Zk(m,null,f,1,w??null,N,!1,$,te),f[$l]=m.current,pm(f),_)for(f=0;f<_.length;f++)w=_[f],N=w._getVersion,N=N(w._source),m.mutableSourceEagerHydrationData==null?m.mutableSourceEagerHydrationData=[w,N]:m.mutableSourceEagerHydrationData.push(w,N);return new yx(m)},uo.render=function(f,m,w){if(!wx(m))throw Error(t(200));return bx(null,f,m,!1,w)},uo.unmountComponentAtNode=function(f){if(!wx(f))throw Error(t(40));return f._reactRootContainer?(Nu(function(){bx(null,null,f,!1,function(){f._reactRootContainer=null,f[$l]=null})}),!0):!1},uo.unstable_batchedUpdates=d3,uo.unstable_renderSubtreeIntoContainer=function(f,m,w,_){if(!wx(w))throw Error(t(200));if(f==null||f._reactInternals===void 0)throw Error(t(38));return bx(f,m,w,!1,_)},uo.version="18.3.1-next-f1338f8080-20240426",uo}var lA;function E9(){if(lA)return C3.exports;lA=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),C3.exports=_9(),C3.exports}var cA;function T9(){if(cA)return Cx;cA=1;var n=E9();return Cx.createRoot=n.createRoot,Cx.hydrateRoot=n.hydrateRoot,Cx}var I9=T9();const k9=Zg(I9),z_=le.createContext({});function Bf(n){const e=le.useRef(null);return e.current===null&&(e.current=n()),e.current}const H2=le.createContext(null),j2=le.createContext({transformPagePoint:n=>n,isStatic:!1,reducedMotion:"never"});class A9 extends le.Component{getSnapshotBeforeUpdate(e){const t=this.props.childRef.current;if(t&&e.isPresent&&!this.props.isPresent){const s=this.props.sizeRef.current;s.height=t.offsetHeight||0,s.width=t.offsetWidth||0,s.top=t.offsetTop,s.left=t.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function R9({children:n,isPresent:e}){const t=le.useId(),s=le.useRef(null),i=le.useRef({width:0,height:0,top:0,left:0}),{nonce:r}=le.useContext(j2);return le.useInsertionEffect(()=>{const{width:o,height:a,top:l,left:c}=i.current;if(e||!s.current||!o||!a)return;s.current.dataset.motionPopId=t;const u=document.createElement("style");return r&&(u.nonce=r),document.head.appendChild(u),u.sheet&&u.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `),()=>{document.head.removeChild(u)}},[e]),G.jsx(A9,{isPresent:e,childRef:s,sizeRef:i,children:le.cloneElement(n,{ref:s})})}const M9=({children:n,initial:e,isPresent:t,onExitComplete:s,custom:i,presenceAffectsLayout:r,mode:o})=>{const a=Bf(N9),l=le.useId(),c=le.useCallback(d=>{a.set(d,!0);for(const h of a.values())if(!h)return;s&&s()},[a,s]),u=le.useMemo(()=>({id:l,initial:e,isPresent:t,custom:i,onExitComplete:c,register:d=>(a.set(d,!1),()=>a.delete(d))}),r?[Math.random(),c]:[t,c]);return le.useMemo(()=>{a.forEach((d,h)=>a.set(h,!1))},[t]),le.useEffect(()=>{!t&&!a.size&&s&&s()},[t]),o==="popLayout"&&(n=G.jsx(R9,{isPresent:t,children:n})),G.jsx(H2.Provider,{value:u,children:n})};function N9(){return new Map}function RL(n=!0){const e=le.useContext(H2);if(e===null)return[!0,null];const{isPresent:t,onExitComplete:s,register:i}=e,r=le.useId();le.useEffect(()=>{n&&i(r)},[n]);const o=le.useCallback(()=>n&&s&&s(r),[r,s,n]);return!t&&s?[!1,o]:[!0]}const _x=n=>n.key||"";function uA(n){const e=[];return le.Children.forEach(n,t=>{le.isValidElement(t)&&e.push(t)}),e}const B_=typeof window<"u",X2=B_?le.useLayoutEffect:le.useEffect,Xv=({children:n,custom:e,initial:t=!0,onExitComplete:s,presenceAffectsLayout:i=!0,mode:r="sync",propagate:o=!1})=>{const[a,l]=RL(o),c=le.useMemo(()=>uA(n),[n]),u=o&&!a?[]:c.map(_x),d=le.useRef(!0),h=le.useRef(c),p=Bf(()=>new Map),[g,y]=le.useState(c),[x,v]=le.useState(c);X2(()=>{d.current=!1,h.current=c;for(let C=0;C<x.length;C++){const E=_x(x[C]);u.includes(E)?p.delete(E):p.get(E)!==!0&&p.set(E,!1)}},[x,u.length,u.join("-")]);const b=[];if(c!==g){let C=[...c];for(let E=0;E<x.length;E++){const k=x[E],R=_x(k);u.includes(R)||(C.splice(E,0,k),b.push(k))}r==="wait"&&b.length&&(C=b),v(uA(C)),y(c);return}const{forceRender:S}=le.useContext(z_);return G.jsx(G.Fragment,{children:x.map(C=>{const E=_x(C),k=o&&!a?!1:c===x||u.includes(E),R=()=>{if(p.has(E))p.set(E,!0);else return;let L=!0;p.forEach(I=>{I||(L=!1)}),L&&(S==null||S(),v(h.current),o&&(l==null||l()),s&&s())};return G.jsx(M9,{isPresent:k,initial:!d.current||t?void 0:!1,custom:k?void 0:e,presenceAffectsLayout:i,mode:r,onExitComplete:k?void 0:R,children:C},E)})})},qr=n=>n;let P9=qr,ML=qr;function U_(n){let e;return()=>(e===void 0&&(e=n()),e)}const iu=(n,e,t)=>{const s=e-n;return s===0?1:(t-n)/s},dl=n=>n*1e3,hl=n=>n/1e3,D9={useManualTiming:!1};function L9(n){let e=new Set,t=new Set,s=!1,i=!1;const r=new WeakSet;let o={delta:0,timestamp:0,isProcessing:!1};function a(c){r.has(c)&&(l.schedule(c),n()),c(o)}const l={schedule:(c,u=!1,d=!1)=>{const p=d&&s?e:t;return u&&r.add(c),p.has(c)||p.add(c),c},cancel:c=>{t.delete(c),r.delete(c)},process:c=>{if(o=c,s){i=!0;return}s=!0,[e,t]=[t,e],e.forEach(a),e.clear(),s=!1,i&&(i=!1,l.process(c))}};return l}const Ex=["read","resolveKeyframes","update","preRender","render","postRender"],$9=40;function NL(n,e){let t=!1,s=!0;const i={delta:0,timestamp:0,isProcessing:!1},r=()=>t=!0,o=Ex.reduce((v,b)=>(v[b]=L9(r),v),{}),{read:a,resolveKeyframes:l,update:c,preRender:u,render:d,postRender:h}=o,p=()=>{const v=performance.now();t=!1,i.delta=s?1e3/60:Math.max(Math.min(v-i.timestamp,$9),1),i.timestamp=v,i.isProcessing=!0,a.process(i),l.process(i),c.process(i),u.process(i),d.process(i),h.process(i),i.isProcessing=!1,t&&e&&(s=!1,n(p))},g=()=>{t=!0,s=!0,i.isProcessing||n(p)};return{schedule:Ex.reduce((v,b)=>{const S=o[b];return v[b]=(C,E=!1,k=!1)=>(t||g(),S.schedule(C,E,k)),v},{}),cancel:v=>{for(let b=0;b<Ex.length;b++)o[Ex[b]].cancel(v)},state:i,steps:o}}const{schedule:Ms,cancel:Da,state:or,steps:T3}=NL(typeof requestAnimationFrame<"u"?requestAnimationFrame:qr,!0),PL=le.createContext({strict:!1}),dA={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},pf={};for(const n in dA)pf[n]={isEnabled:e=>dA[n].some(t=>!!e[t])};function F9(n){for(const e in n)pf[e]={...pf[e],...n[e]}}const O9=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function qv(n){return n.startsWith("while")||n.startsWith("drag")&&n!=="draggable"||n.startsWith("layout")||n.startsWith("onTap")||n.startsWith("onPan")||n.startsWith("onLayout")||O9.has(n)}let DL=n=>!qv(n);function z9(n){n&&(DL=e=>e.startsWith("on")?!qv(e):n(e))}try{z9(require("@emotion/is-prop-valid").default)}catch{}function B9(n,e,t){const s={};for(const i in n)i==="values"&&typeof n.values=="object"||(DL(i)||t===!0&&qv(i)||!e&&!qv(i)||n.draggable&&i.startsWith("onDrag"))&&(s[i]=n[i]);return s}function U9(n){if(typeof Proxy>"u")return n;const e=new Map,t=(...s)=>n(...s);return new Proxy(t,{get:(s,i)=>i==="create"?n:(e.has(i)||e.set(i,n(i)),e.get(i))})}const q2=le.createContext({});function Eg(n){return typeof n=="string"||Array.isArray(n)}function K2(n){return n!==null&&typeof n=="object"&&typeof n.start=="function"}const V_=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],W_=["initial",...V_];function Y2(n){return K2(n.animate)||W_.some(e=>Eg(n[e]))}function LL(n){return!!(Y2(n)||n.variants)}function V9(n,e){if(Y2(n)){const{initial:t,animate:s}=n;return{initial:t===!1||Eg(t)?t:void 0,animate:Eg(s)?s:void 0}}return n.inherit!==!1?e:{}}function W9(n){const{initial:e,animate:t}=V9(n,le.useContext(q2));return le.useMemo(()=>({initial:e,animate:t}),[hA(e),hA(t)])}function hA(n){return Array.isArray(n)?n.join(" "):n}const G9=Symbol.for("motionComponentSymbol");function Qh(n){return n&&typeof n=="object"&&Object.prototype.hasOwnProperty.call(n,"current")}function H9(n,e,t){return le.useCallback(s=>{s&&n.onMount&&n.onMount(s),e&&(s?e.mount(s):e.unmount()),t&&(typeof t=="function"?t(s):Qh(t)&&(t.current=s))},[e])}const G_=n=>n.replace(/([a-z])([A-Z])/gu,"$1-$2").toLowerCase(),j9="framerAppearId",$L="data-"+G_(j9),{schedule:H_}=NL(queueMicrotask,!1),FL=le.createContext({});function X9(n,e,t,s,i){var r,o;const{visualElement:a}=le.useContext(q2),l=le.useContext(PL),c=le.useContext(H2),u=le.useContext(j2).reducedMotion,d=le.useRef(null);s=s||l.renderer,!d.current&&s&&(d.current=s(n,{visualState:e,parent:a,props:t,presenceContext:c,blockInitialAnimation:c?c.initial===!1:!1,reducedMotionConfig:u}));const h=d.current,p=le.useContext(FL);h&&!h.projection&&i&&(h.type==="html"||h.type==="svg")&&q9(d.current,t,i,p);const g=le.useRef(!1);le.useInsertionEffect(()=>{h&&g.current&&h.update(t,c)});const y=t[$L],x=le.useRef(!!y&&!(!((r=window.MotionHandoffIsComplete)===null||r===void 0)&&r.call(window,y))&&((o=window.MotionHasOptimisedAnimation)===null||o===void 0?void 0:o.call(window,y)));return X2(()=>{h&&(g.current=!0,window.MotionIsMounted=!0,h.updateFeatures(),H_.render(h.render),x.current&&h.animationState&&h.animationState.animateChanges())}),le.useEffect(()=>{h&&(!x.current&&h.animationState&&h.animationState.animateChanges(),x.current&&(queueMicrotask(()=>{var v;(v=window.MotionHandoffMarkAsComplete)===null||v===void 0||v.call(window,y)}),x.current=!1))}),h}function q9(n,e,t,s){const{layoutId:i,layout:r,drag:o,dragConstraints:a,layoutScroll:l,layoutRoot:c}=e;n.projection=new t(n.latestValues,e["data-framer-portal-id"]?void 0:OL(n.parent)),n.projection.setOptions({layoutId:i,layout:r,alwaysMeasureLayout:!!o||a&&Qh(a),visualElement:n,animationType:typeof r=="string"?r:"both",initialPromotionConfig:s,layoutScroll:l,layoutRoot:c})}function OL(n){if(n)return n.options.allowProjection!==!1?n.projection:OL(n.parent)}function K9({preloadedFeatures:n,createVisualElement:e,useRender:t,useVisualState:s,Component:i}){var r,o;n&&F9(n);function a(c,u){let d;const h={...le.useContext(j2),...c,layoutId:Y9(c)},{isStatic:p}=h,g=W9(c),y=s(c,p);if(!p&&B_){Z9();const x=Q9(h);d=x.MeasureLayout,g.visualElement=X9(i,y,h,e,x.ProjectionNode)}return G.jsxs(q2.Provider,{value:g,children:[d&&g.visualElement?G.jsx(d,{visualElement:g.visualElement,...h}):null,t(i,c,H9(y,g.visualElement,u),y,p,g.visualElement)]})}a.displayName=`motion.${typeof i=="string"?i:`create(${(o=(r=i.displayName)!==null&&r!==void 0?r:i.name)!==null&&o!==void 0?o:""})`}`;const l=le.forwardRef(a);return l[G9]=i,l}function Y9({layoutId:n}){const e=le.useContext(z_).id;return e&&n!==void 0?e+"-"+n:n}function Z9(n,e){le.useContext(PL).strict}function Q9(n){const{drag:e,layout:t}=pf;if(!e&&!t)return{};const s={...e,...t};return{MeasureLayout:e!=null&&e.isEnabled(n)||t!=null&&t.isEnabled(n)?s.MeasureLayout:void 0,ProjectionNode:s.ProjectionNode}}const J9=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function j_(n){return typeof n!="string"||n.includes("-")?!1:!!(J9.indexOf(n)>-1||/[A-Z]/u.test(n))}function fA(n){const e=[{},{}];return n==null||n.values.forEach((t,s)=>{e[0][s]=t.get(),e[1][s]=t.getVelocity()}),e}function X_(n,e,t,s){if(typeof e=="function"){const[i,r]=fA(s);e=e(t!==void 0?t:n.custom,i,r)}if(typeof e=="string"&&(e=n.variants&&n.variants[e]),typeof e=="function"){const[i,r]=fA(s);e=e(t!==void 0?t:n.custom,i,r)}return e}const dC=n=>Array.isArray(n),eW=n=>!!(n&&typeof n=="object"&&n.mix&&n.toValue),tW=n=>dC(n)?n[n.length-1]||0:n,cr=n=>!!(n&&n.getVelocity);function Ev(n){const e=cr(n)?n.get():n;return eW(e)?e.toValue():e}function nW({scrapeMotionValuesFromProps:n,createRenderState:e,onUpdate:t},s,i,r){const o={latestValues:sW(s,i,r,n),renderState:e()};return t&&(o.onMount=a=>t({props:s,current:a,...o}),o.onUpdate=a=>t(a)),o}const zL=n=>(e,t)=>{const s=le.useContext(q2),i=le.useContext(H2),r=()=>nW(n,e,s,i);return t?r():Bf(r)};function sW(n,e,t,s){const i={},r=s(n,{});for(const h in r)i[h]=Ev(r[h]);let{initial:o,animate:a}=n;const l=Y2(n),c=LL(n);e&&c&&!l&&n.inherit!==!1&&(o===void 0&&(o=e.initial),a===void 0&&(a=e.animate));let u=t?t.initial===!1:!1;u=u||o===!1;const d=u?a:o;if(d&&typeof d!="boolean"&&!K2(d)){const h=Array.isArray(d)?d:[d];for(let p=0;p<h.length;p++){const g=X_(n,h[p]);if(g){const{transitionEnd:y,transition:x,...v}=g;for(const b in v){let S=v[b];if(Array.isArray(S)){const C=u?S.length-1:0;S=S[C]}S!==null&&(i[b]=S)}for(const b in y)i[b]=y[b]}}}return i}const Uf=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Ld=new Set(Uf),BL=n=>e=>typeof e=="string"&&e.startsWith(n),UL=BL("--"),iW=BL("var(--"),q_=n=>iW(n)?rW.test(n.split("/*")[0].trim()):!1,rW=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,VL=(n,e)=>e&&typeof n=="number"?e.transform(n):n,wl=(n,e,t)=>t>e?e:t<n?n:t,Vf={test:n=>typeof n=="number",parse:parseFloat,transform:n=>n},Tg={...Vf,transform:n=>wl(0,1,n)},Tx={...Vf,default:1},Qg=n=>({test:e=>typeof e=="string"&&e.endsWith(n)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${n}`}),Vc=Qg("deg"),fl=Qg("%"),$n=Qg("px"),oW=Qg("vh"),aW=Qg("vw"),pA={...fl,parse:n=>fl.parse(n)/100,transform:n=>fl.transform(n*100)},lW={borderWidth:$n,borderTopWidth:$n,borderRightWidth:$n,borderBottomWidth:$n,borderLeftWidth:$n,borderRadius:$n,radius:$n,borderTopLeftRadius:$n,borderTopRightRadius:$n,borderBottomRightRadius:$n,borderBottomLeftRadius:$n,width:$n,maxWidth:$n,height:$n,maxHeight:$n,top:$n,right:$n,bottom:$n,left:$n,padding:$n,paddingTop:$n,paddingRight:$n,paddingBottom:$n,paddingLeft:$n,margin:$n,marginTop:$n,marginRight:$n,marginBottom:$n,marginLeft:$n,backgroundPositionX:$n,backgroundPositionY:$n},cW={rotate:Vc,rotateX:Vc,rotateY:Vc,rotateZ:Vc,scale:Tx,scaleX:Tx,scaleY:Tx,scaleZ:Tx,skew:Vc,skewX:Vc,skewY:Vc,distance:$n,translateX:$n,translateY:$n,translateZ:$n,x:$n,y:$n,z:$n,perspective:$n,transformPerspective:$n,opacity:Tg,originX:pA,originY:pA,originZ:$n},mA={...Vf,transform:Math.round},K_={...lW,...cW,zIndex:mA,size:$n,fillOpacity:Tg,strokeOpacity:Tg,numOctaves:mA},uW={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},dW=Uf.length;function hW(n,e,t){let s="",i=!0;for(let r=0;r<dW;r++){const o=Uf[r],a=n[o];if(a===void 0)continue;let l=!0;if(typeof a=="number"?l=a===(o.startsWith("scale")?1:0):l=parseFloat(a)===0,!l||t){const c=VL(a,K_[o]);if(!l){i=!1;const u=uW[o]||o;s+=`${u}(${c}) `}t&&(e[o]=c)}}return s=s.trim(),t?s=t(e,i?"":s):i&&(s="none"),s}function Y_(n,e,t){const{style:s,vars:i,transformOrigin:r}=n;let o=!1,a=!1;for(const l in e){const c=e[l];if(Ld.has(l)){o=!0;continue}else if(UL(l)){i[l]=c;continue}else{const u=VL(c,K_[l]);l.startsWith("origin")?(a=!0,r[l]=u):s[l]=u}}if(e.transform||(o||t?s.transform=hW(e,n.transform,t):s.transform&&(s.transform="none")),a){const{originX:l="50%",originY:c="50%",originZ:u=0}=r;s.transformOrigin=`${l} ${c} ${u}`}}const fW={offset:"stroke-dashoffset",array:"stroke-dasharray"},pW={offset:"strokeDashoffset",array:"strokeDasharray"};function mW(n,e,t=1,s=0,i=!0){n.pathLength=1;const r=i?fW:pW;n[r.offset]=$n.transform(-s);const o=$n.transform(e),a=$n.transform(t);n[r.array]=`${o} ${a}`}function gA(n,e,t){return typeof n=="string"?n:$n.transform(e+t*n)}function gW(n,e,t){const s=gA(e,n.x,n.width),i=gA(t,n.y,n.height);return`${s} ${i}`}function Z_(n,{attrX:e,attrY:t,attrScale:s,originX:i,originY:r,pathLength:o,pathSpacing:a=1,pathOffset:l=0,...c},u,d){if(Y_(n,c,d),u){n.style.viewBox&&(n.attrs.viewBox=n.style.viewBox);return}n.attrs=n.style,n.style={};const{attrs:h,style:p,dimensions:g}=n;h.transform&&(g&&(p.transform=h.transform),delete h.transform),g&&(i!==void 0||r!==void 0||p.transform)&&(p.transformOrigin=gW(g,i!==void 0?i:.5,r!==void 0?r:.5)),e!==void 0&&(h.x=e),t!==void 0&&(h.y=t),s!==void 0&&(h.scale=s),o!==void 0&&mW(h,o,a,l,!1)}const Q_=()=>({style:{},transform:{},transformOrigin:{},vars:{}}),WL=()=>({...Q_(),attrs:{}}),J_=n=>typeof n=="string"&&n.toLowerCase()==="svg";function GL(n,{style:e,vars:t},s,i){Object.assign(n.style,e,i&&i.getProjectionStyles(s));for(const r in t)n.style.setProperty(r,t[r])}const HL=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function jL(n,e,t,s){GL(n,e,void 0,s);for(const i in e.attrs)n.setAttribute(HL.has(i)?i:G_(i),e.attrs[i])}const Kv={};function xW(n){Object.assign(Kv,n)}function XL(n,{layout:e,layoutId:t}){return Ld.has(n)||n.startsWith("origin")||(e||t!==void 0)&&(!!Kv[n]||n==="opacity")}function eE(n,e,t){var s;const{style:i}=n,r={};for(const o in i)(cr(i[o])||e.style&&cr(e.style[o])||XL(o,n)||((s=t==null?void 0:t.getValue(o))===null||s===void 0?void 0:s.liveStyle)!==void 0)&&(r[o]=i[o]);return r}function qL(n,e,t){const s=eE(n,e,t);for(const i in n)if(cr(n[i])||cr(e[i])){const r=Uf.indexOf(i)!==-1?"attr"+i.charAt(0).toUpperCase()+i.substring(1):i;s[r]=n[i]}return s}function vW(n,e){try{e.dimensions=typeof n.getBBox=="function"?n.getBBox():n.getBoundingClientRect()}catch{e.dimensions={x:0,y:0,width:0,height:0}}}const xA=["x","y","width","height","cx","cy","r"],yW={useVisualState:zL({scrapeMotionValuesFromProps:qL,createRenderState:WL,onUpdate:({props:n,prevProps:e,current:t,renderState:s,latestValues:i})=>{if(!t)return;let r=!!n.drag;if(!r){for(const a in i)if(Ld.has(a)){r=!0;break}}if(!r)return;let o=!e;if(e)for(let a=0;a<xA.length;a++){const l=xA[a];n[l]!==e[l]&&(o=!0)}o&&Ms.read(()=>{vW(t,s),Ms.render(()=>{Z_(s,i,J_(t.tagName),n.transformTemplate),jL(t,s)})})}})},wW={useVisualState:zL({scrapeMotionValuesFromProps:eE,createRenderState:Q_})};function KL(n,e,t){for(const s in e)!cr(e[s])&&!XL(s,t)&&(n[s]=e[s])}function bW({transformTemplate:n},e){return le.useMemo(()=>{const t=Q_();return Y_(t,e,n),Object.assign({},t.vars,t.style)},[e])}function SW(n,e){const t=n.style||{},s={};return KL(s,t,n),Object.assign(s,bW(n,e)),s}function CW(n,e){const t={},s=SW(n,e);return n.drag&&n.dragListener!==!1&&(t.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=n.drag===!0?"none":`pan-${n.drag==="x"?"y":"x"}`),n.tabIndex===void 0&&(n.onTap||n.onTapStart||n.whileTap)&&(t.tabIndex=0),t.style=s,t}function _W(n,e,t,s){const i=le.useMemo(()=>{const r=WL();return Z_(r,e,J_(s),n.transformTemplate),{...r.attrs,style:{...r.style}}},[e]);if(n.style){const r={};KL(r,n.style,n),i.style={...r,...i.style}}return i}function EW(n=!1){return(t,s,i,{latestValues:r},o)=>{const l=(j_(t)?_W:CW)(s,r,o,t),c=B9(s,typeof t=="string",n),u=t!==le.Fragment?{...c,...l,ref:i}:{},{children:d}=s,h=le.useMemo(()=>cr(d)?d.get():d,[d]);return le.createElement(t,{...u,children:h})}}function TW(n,e){return function(s,{forwardMotionProps:i}={forwardMotionProps:!1}){const o={...j_(s)?yW:wW,preloadedFeatures:n,useRender:EW(i),createVisualElement:e,Component:s};return K9(o)}}function YL(n,e){if(!Array.isArray(e))return!1;const t=e.length;if(t!==n.length)return!1;for(let s=0;s<t;s++)if(e[s]!==n[s])return!1;return!0}function Z2(n,e,t){const s=n.getProps();return X_(s,e,t!==void 0?t:s.custom,n)}const ZL=U_(()=>window.ScrollTimeline!==void 0);class IW{constructor(e){this.stop=()=>this.runAll("stop"),this.animations=e.filter(Boolean)}get finished(){return Promise.all(this.animations.map(e=>"finished"in e?e.finished:e))}getAll(e){return this.animations[0][e]}setAll(e,t){for(let s=0;s<this.animations.length;s++)this.animations[s][e]=t}attachTimeline(e,t){const s=this.animations.map(i=>{if(ZL()&&i.attachTimeline)return i.attachTimeline(e);if(typeof t=="function")return t(i)});return()=>{s.forEach((i,r)=>{i&&i(),this.animations[r].stop()})}}get time(){return this.getAll("time")}set time(e){this.setAll("time",e)}get speed(){return this.getAll("speed")}set speed(e){this.setAll("speed",e)}get startTime(){return this.getAll("startTime")}get duration(){let e=0;for(let t=0;t<this.animations.length;t++)e=Math.max(e,this.animations[t].duration);return e}runAll(e){this.animations.forEach(t=>t[e]())}flatten(){this.runAll("flatten")}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}class QL extends IW{then(e,t){return Promise.all(this.animations).then(e).catch(t)}}function tE(n,e){return n?n[e]||n.default||n:void 0}const Yv=2e4;function nE(n){let e=0;const t=50;let s=n.next(e);for(;!s.done&&e<Yv;)e+=t,s=n.next(e);return e>=Yv?1/0:e}function kW(n,e=100,t){const s=t({...n,keyframes:[0,e]}),i=Math.min(nE(s),Yv);return{type:"keyframes",ease:r=>s.next(i*r).value/e,duration:hl(i)}}function Q2(n){return typeof n=="function"}function vA(n,e){n.timeline=e,n.onfinish=null}const sE=n=>Array.isArray(n)&&typeof n[0]=="number",AW={linearEasing:void 0};function RW(n,e){const t=U_(n);return()=>{var s;return(s=AW[e])!==null&&s!==void 0?s:t()}}const Zv=RW(()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch{return!1}return!0},"linearEasing"),JL=(n,e,t=10)=>{let s="";const i=Math.max(Math.round(e/t),2);for(let r=0;r<i;r++)s+=n(iu(0,i-1,r))+", ";return`linear(${s.substring(0,s.length-2)})`};function e$(n){return!!(typeof n=="function"&&Zv()||!n||typeof n=="string"&&(n in hC||Zv())||sE(n)||Array.isArray(n)&&n.every(e$))}const Jm=([n,e,t,s])=>`cubic-bezier(${n}, ${e}, ${t}, ${s})`,hC={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:Jm([0,.65,.55,1]),circOut:Jm([.55,0,1,.45]),backIn:Jm([.31,.01,.66,-.59]),backOut:Jm([.33,1.53,.69,.99])};function t$(n,e){if(n)return typeof n=="function"&&Zv()?JL(n,e):sE(n)?Jm(n):Array.isArray(n)?n.map(t=>t$(t,e)||hC.easeOut):hC[n]}const Sa={x:!1,y:!1};function n$(){return Sa.x||Sa.y}function iE(n,e,t){var s;if(n instanceof Element)return[n];if(typeof n=="string"){let i=document;const r=(s=t==null?void 0:t[n])!==null&&s!==void 0?s:i.querySelectorAll(n);return r?Array.from(r):[]}return Array.from(n)}function s$(n,e){const t=iE(n),s=new AbortController,i={passive:!0,...e,signal:s.signal};return[t,i,()=>s.abort()]}function yA(n){return e=>{e.pointerType==="touch"||n$()||n(e)}}function MW(n,e,t={}){const[s,i,r]=s$(n,t),o=yA(a=>{const{target:l}=a,c=e(a);if(typeof c!="function"||!l)return;const u=yA(d=>{c(d),l.removeEventListener("pointerleave",u)});l.addEventListener("pointerleave",u,i)});return s.forEach(a=>{a.addEventListener("pointerenter",o,i)}),r}const i$=(n,e)=>e?n===e?!0:i$(n,e.parentElement):!1,rE=n=>n.pointerType==="mouse"?typeof n.button!="number"||n.button<=0:n.isPrimary!==!1,NW=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function PW(n){return NW.has(n.tagName)||n.tabIndex!==-1}const eg=new WeakSet;function wA(n){return e=>{e.key==="Enter"&&n(e)}}function I3(n,e){n.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:!0,bubbles:!0}))}const DW=(n,e)=>{const t=n.currentTarget;if(!t)return;const s=wA(()=>{if(eg.has(t))return;I3(t,"down");const i=wA(()=>{I3(t,"up")}),r=()=>I3(t,"cancel");t.addEventListener("keyup",i,e),t.addEventListener("blur",r,e)});t.addEventListener("keydown",s,e),t.addEventListener("blur",()=>t.removeEventListener("keydown",s),e)};function bA(n){return rE(n)&&!n$()}function LW(n,e,t={}){const[s,i,r]=s$(n,t),o=a=>{const l=a.currentTarget;if(!bA(a)||eg.has(l))return;eg.add(l);const c=e(a),u=(p,g)=>{window.removeEventListener("pointerup",d),window.removeEventListener("pointercancel",h),!(!bA(p)||!eg.has(l))&&(eg.delete(l),typeof c=="function"&&c(p,{success:g}))},d=p=>{u(p,t.useGlobalTarget||i$(l,p.target))},h=p=>{u(p,!1)};window.addEventListener("pointerup",d,i),window.addEventListener("pointercancel",h,i)};return s.forEach(a=>{!PW(a)&&a.getAttribute("tabindex")===null&&(a.tabIndex=0),(t.useGlobalTarget?window:a).addEventListener("pointerdown",o,i),a.addEventListener("focus",c=>DW(c,i),i)}),r}function $W(n){return n==="x"||n==="y"?Sa[n]?null:(Sa[n]=!0,()=>{Sa[n]=!1}):Sa.x||Sa.y?null:(Sa.x=Sa.y=!0,()=>{Sa.x=Sa.y=!1})}const r$=new Set(["width","height","top","left","right","bottom",...Uf]);let Tv;function FW(){Tv=void 0}const pl={now:()=>(Tv===void 0&&pl.set(or.isProcessing||D9.useManualTiming?or.timestamp:performance.now()),Tv),set:n=>{Tv=n,queueMicrotask(FW)}};function oE(n,e){n.indexOf(e)===-1&&n.push(e)}function J2(n,e){const t=n.indexOf(e);t>-1&&n.splice(t,1)}class aE{constructor(){this.subscriptions=[]}add(e){return oE(this.subscriptions,e),()=>J2(this.subscriptions,e)}notify(e,t,s){const i=this.subscriptions.length;if(i)if(i===1)this.subscriptions[0](e,t,s);else for(let r=0;r<i;r++){const o=this.subscriptions[r];o&&o(e,t,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}function lE(n,e){return e?n*(1e3/e):0}const SA=30,OW=n=>!isNaN(parseFloat(n)),dg={current:void 0};class zW{constructor(e,t={}){this.version="11.18.2",this.canTrackVelocity=null,this.events={},this.updateAndNotify=(s,i=!0)=>{const r=pl.now();this.updatedAt!==r&&this.setPrevFrameValue(),this.prev=this.current,this.setCurrent(s),this.current!==this.prev&&this.events.change&&this.events.change.notify(this.current),i&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.hasAnimated=!1,this.setCurrent(e),this.owner=t.owner}setCurrent(e){this.current=e,this.updatedAt=pl.now(),this.canTrackVelocity===null&&e!==void 0&&(this.canTrackVelocity=OW(this.current))}setPrevFrameValue(e=this.current){this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt}onChange(e){return this.on("change",e)}on(e,t){this.events[e]||(this.events[e]=new aE);const s=this.events[e].add(t);return e==="change"?()=>{s(),Ms.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,t){this.passiveEffect=e,this.stopPassiveEffect=t}set(e,t=!0){!t||!this.passiveEffect?this.updateAndNotify(e,t):this.passiveEffect(e,this.updateAndNotify)}setWithVelocity(e,t,s){this.set(t),this.prev=void 0,this.prevFrameValue=e,this.prevUpdatedAt=this.updatedAt-s}jump(e,t=!0){this.updateAndNotify(e),this.prev=e,this.prevUpdatedAt=this.prevFrameValue=void 0,t&&this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return dg.current&&dg.current.push(this),this.current}getPrevious(){return this.prev}getVelocity(){const e=pl.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||e-this.updatedAt>SA)return 0;const t=Math.min(this.updatedAt-this.prevUpdatedAt,SA);return lE(parseFloat(this.current)-parseFloat(this.prevFrameValue),t)}start(e){return this.stop(),new Promise(t=>{this.hasAnimated=!0,this.animation=e(t),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function cl(n,e){return new zW(n,e)}function BW(n,e,t){n.hasValue(e)?n.getValue(e).set(t):n.addValue(e,cl(t))}function UW(n,e){const t=Z2(n,e);let{transitionEnd:s={},transition:i={},...r}=t||{};r={...r,...s};for(const o in r){const a=tW(r[o]);BW(n,o,a)}}function VW(n){return!!(cr(n)&&n.add)}function fC(n,e){const t=n.getValue("willChange");if(VW(t))return t.add(e)}function o$(n){return n.props[$L]}const a$=(n,e,t)=>(((1-3*t+3*e)*n+(3*t-6*e))*n+3*e)*n,WW=1e-7,GW=12;function HW(n,e,t,s,i){let r,o,a=0;do o=e+(t-e)/2,r=a$(o,s,i)-n,r>0?t=o:e=o;while(Math.abs(r)>WW&&++a<GW);return o}function Jg(n,e,t,s){if(n===e&&t===s)return qr;const i=r=>HW(r,0,1,n,t);return r=>r===0||r===1?r:a$(i(r),e,s)}const l$=n=>e=>e<=.5?n(2*e)/2:(2-n(2*(1-e)))/2,c$=n=>e=>1-n(1-e),u$=Jg(.33,1.53,.69,.99),cE=c$(u$),d$=l$(cE),h$=n=>(n*=2)<1?.5*cE(n):.5*(2-Math.pow(2,-10*(n-1))),uE=n=>1-Math.sin(Math.acos(n)),f$=c$(uE),p$=l$(uE),m$=n=>/^0[^.\s]+$/u.test(n);function jW(n){return typeof n=="number"?n===0:n!==null?n==="none"||n==="0"||m$(n):!0}const hg=n=>Math.round(n*1e5)/1e5,dE=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function XW(n){return n==null}const qW=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,hE=(n,e)=>t=>!!(typeof t=="string"&&qW.test(t)&&t.startsWith(n)||e&&!XW(t)&&Object.prototype.hasOwnProperty.call(t,e)),g$=(n,e,t)=>s=>{if(typeof s!="string")return s;const[i,r,o,a]=s.match(dE);return{[n]:parseFloat(i),[e]:parseFloat(r),[t]:parseFloat(o),alpha:a!==void 0?parseFloat(a):1}},KW=n=>wl(0,255,n),k3={...Vf,transform:n=>Math.round(KW(n))},id={test:hE("rgb","red"),parse:g$("red","green","blue"),transform:({red:n,green:e,blue:t,alpha:s=1})=>"rgba("+k3.transform(n)+", "+k3.transform(e)+", "+k3.transform(t)+", "+hg(Tg.transform(s))+")"};function YW(n){let e="",t="",s="",i="";return n.length>5?(e=n.substring(1,3),t=n.substring(3,5),s=n.substring(5,7),i=n.substring(7,9)):(e=n.substring(1,2),t=n.substring(2,3),s=n.substring(3,4),i=n.substring(4,5),e+=e,t+=t,s+=s,i+=i),{red:parseInt(e,16),green:parseInt(t,16),blue:parseInt(s,16),alpha:i?parseInt(i,16)/255:1}}const pC={test:hE("#"),parse:YW,transform:id.transform},Jh={test:hE("hsl","hue"),parse:g$("hue","saturation","lightness"),transform:({hue:n,saturation:e,lightness:t,alpha:s=1})=>"hsla("+Math.round(n)+", "+fl.transform(hg(e))+", "+fl.transform(hg(t))+", "+hg(Tg.transform(s))+")"},Rr={test:n=>id.test(n)||pC.test(n)||Jh.test(n),parse:n=>id.test(n)?id.parse(n):Jh.test(n)?Jh.parse(n):pC.parse(n),transform:n=>typeof n=="string"?n:n.hasOwnProperty("red")?id.transform(n):Jh.transform(n)},ZW=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function QW(n){var e,t;return isNaN(n)&&typeof n=="string"&&(((e=n.match(dE))===null||e===void 0?void 0:e.length)||0)+(((t=n.match(ZW))===null||t===void 0?void 0:t.length)||0)>0}const x$="number",v$="color",JW="var",eG="var(",CA="${}",tG=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function Ig(n){const e=n.toString(),t=[],s={color:[],number:[],var:[]},i=[];let r=0;const a=e.replace(tG,l=>(Rr.test(l)?(s.color.push(r),i.push(v$),t.push(Rr.parse(l))):l.startsWith(eG)?(s.var.push(r),i.push(JW),t.push(l)):(s.number.push(r),i.push(x$),t.push(parseFloat(l))),++r,CA)).split(CA);return{values:t,split:a,indexes:s,types:i}}function y$(n){return Ig(n).values}function w$(n){const{split:e,types:t}=Ig(n),s=e.length;return i=>{let r="";for(let o=0;o<s;o++)if(r+=e[o],i[o]!==void 0){const a=t[o];a===x$?r+=hg(i[o]):a===v$?r+=Rr.transform(i[o]):r+=i[o]}return r}}const nG=n=>typeof n=="number"?0:n;function sG(n){const e=y$(n);return w$(n)(e.map(nG))}const ru={test:QW,parse:y$,createTransformer:w$,getAnimatableNone:sG},iG=new Set(["brightness","contrast","saturate","opacity"]);function rG(n){const[e,t]=n.slice(0,-1).split("(");if(e==="drop-shadow")return n;const[s]=t.match(dE)||[];if(!s)return n;const i=t.replace(s,"");let r=iG.has(e)?1:0;return s!==t&&(r*=100),e+"("+r+i+")"}const oG=/\b([a-z-]*)\(.*?\)/gu,mC={...ru,getAnimatableNone:n=>{const e=n.match(oG);return e?e.map(rG).join(" "):n}},aG={...K_,color:Rr,backgroundColor:Rr,outlineColor:Rr,fill:Rr,stroke:Rr,borderColor:Rr,borderTopColor:Rr,borderRightColor:Rr,borderBottomColor:Rr,borderLeftColor:Rr,filter:mC,WebkitFilter:mC},fE=n=>aG[n];function b$(n,e){let t=fE(n);return t!==mC&&(t=ru),t.getAnimatableNone?t.getAnimatableNone(e):void 0}const lG=new Set(["auto","none","0"]);function cG(n,e,t){let s=0,i;for(;s<n.length&&!i;){const r=n[s];typeof r=="string"&&!lG.has(r)&&Ig(r).values.length&&(i=n[s]),s++}if(i&&t)for(const r of e)n[r]=b$(t,i)}const _A=n=>n===Vf||n===$n,EA=(n,e)=>parseFloat(n.split(", ")[e]),TA=(n,e)=>(t,{transform:s})=>{if(s==="none"||!s)return 0;const i=s.match(/^matrix3d\((.+)\)$/u);if(i)return EA(i[1],e);{const r=s.match(/^matrix\((.+)\)$/u);return r?EA(r[1],n):0}},uG=new Set(["x","y","z"]),dG=Uf.filter(n=>!uG.has(n));function hG(n){const e=[];return dG.forEach(t=>{const s=n.getValue(t);s!==void 0&&(e.push([t,s.get()]),s.set(t.startsWith("scale")?1:0))}),e}const mf={width:({x:n},{paddingLeft:e="0",paddingRight:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),height:({y:n},{paddingTop:e="0",paddingBottom:t="0"})=>n.max-n.min-parseFloat(e)-parseFloat(t),top:(n,{top:e})=>parseFloat(e),left:(n,{left:e})=>parseFloat(e),bottom:({y:n},{top:e})=>parseFloat(e)+(n.max-n.min),right:({x:n},{left:e})=>parseFloat(e)+(n.max-n.min),x:TA(4,13),y:TA(5,14)};mf.translateX=mf.x;mf.translateY=mf.y;const ld=new Set;let gC=!1,xC=!1;function S$(){if(xC){const n=Array.from(ld).filter(s=>s.needsMeasurement),e=new Set(n.map(s=>s.element)),t=new Map;e.forEach(s=>{const i=hG(s);i.length&&(t.set(s,i),s.render())}),n.forEach(s=>s.measureInitialState()),e.forEach(s=>{s.render();const i=t.get(s);i&&i.forEach(([r,o])=>{var a;(a=s.getValue(r))===null||a===void 0||a.set(o)})}),n.forEach(s=>s.measureEndState()),n.forEach(s=>{s.suspendedScrollY!==void 0&&window.scrollTo(0,s.suspendedScrollY)})}xC=!1,gC=!1,ld.forEach(n=>n.complete()),ld.clear()}function C$(){ld.forEach(n=>{n.readKeyframes(),n.needsMeasurement&&(xC=!0)})}function fG(){C$(),S$()}class pE{constructor(e,t,s,i,r,o=!1){this.isComplete=!1,this.isAsync=!1,this.needsMeasurement=!1,this.isScheduled=!1,this.unresolvedKeyframes=[...e],this.onComplete=t,this.name=s,this.motionValue=i,this.element=r,this.isAsync=o}scheduleResolve(){this.isScheduled=!0,this.isAsync?(ld.add(this),gC||(gC=!0,Ms.read(C$),Ms.resolveKeyframes(S$))):(this.readKeyframes(),this.complete())}readKeyframes(){const{unresolvedKeyframes:e,name:t,element:s,motionValue:i}=this;for(let r=0;r<e.length;r++)if(e[r]===null)if(r===0){const o=i==null?void 0:i.get(),a=e[e.length-1];if(o!==void 0)e[0]=o;else if(s&&t){const l=s.readValue(t,a);l!=null&&(e[0]=l)}e[0]===void 0&&(e[0]=a),i&&o===void 0&&i.set(e[0])}else e[r]=e[r-1]}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(){this.isComplete=!0,this.onComplete(this.unresolvedKeyframes,this.finalKeyframe),ld.delete(this)}cancel(){this.isComplete||(this.isScheduled=!1,ld.delete(this))}resume(){this.isComplete||this.scheduleResolve()}}const _$=n=>/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n),pG=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function mG(n){const e=pG.exec(n);if(!e)return[,];const[,t,s,i]=e;return[`--${t??s}`,i]}function E$(n,e,t=1){const[s,i]=mG(n);if(!s)return;const r=window.getComputedStyle(e).getPropertyValue(s);if(r){const o=r.trim();return _$(o)?parseFloat(o):o}return q_(i)?E$(i,e,t+1):i}const T$=n=>e=>e.test(n),gG={test:n=>n==="auto",parse:n=>n},I$=[Vf,$n,fl,Vc,aW,oW,gG],IA=n=>I$.find(T$(n));class k$ extends pE{constructor(e,t,s,i,r){super(e,t,s,i,r,!0)}readKeyframes(){const{unresolvedKeyframes:e,element:t,name:s}=this;if(!t||!t.current)return;super.readKeyframes();for(let l=0;l<e.length;l++){let c=e[l];if(typeof c=="string"&&(c=c.trim(),q_(c))){const u=E$(c,t.current);u!==void 0&&(e[l]=u),l===e.length-1&&(this.finalKeyframe=c)}}if(this.resolveNoneKeyframes(),!r$.has(s)||e.length!==2)return;const[i,r]=e,o=IA(i),a=IA(r);if(o!==a)if(_A(o)&&_A(a))for(let l=0;l<e.length;l++){const c=e[l];typeof c=="string"&&(e[l]=parseFloat(c))}else this.needsMeasurement=!0}resolveNoneKeyframes(){const{unresolvedKeyframes:e,name:t}=this,s=[];for(let i=0;i<e.length;i++)jW(e[i])&&s.push(i);s.length&&cG(e,s,t)}measureInitialState(){const{element:e,unresolvedKeyframes:t,name:s}=this;if(!e||!e.current)return;s==="height"&&(this.suspendedScrollY=window.pageYOffset),this.measuredOrigin=mf[s](e.measureViewportBox(),window.getComputedStyle(e.current)),t[0]=this.measuredOrigin;const i=t[t.length-1];i!==void 0&&e.getValue(s,i).jump(i,!1)}measureEndState(){var e;const{element:t,name:s,unresolvedKeyframes:i}=this;if(!t||!t.current)return;const r=t.getValue(s);r&&r.jump(this.measuredOrigin,!1);const o=i.length-1,a=i[o];i[o]=mf[s](t.measureViewportBox(),window.getComputedStyle(t.current)),a!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=a),!((e=this.removedTransforms)===null||e===void 0)&&e.length&&this.removedTransforms.forEach(([l,c])=>{t.getValue(l).set(c)}),this.resolveNoneKeyframes()}}const kA=(n,e)=>e==="zIndex"?!1:!!(typeof n=="number"||Array.isArray(n)||typeof n=="string"&&(ru.test(n)||n==="0")&&!n.startsWith("url("));function xG(n){const e=n[0];if(n.length===1)return!0;for(let t=0;t<n.length;t++)if(n[t]!==e)return!0}function vG(n,e,t,s){const i=n[0];if(i===null)return!1;if(e==="display"||e==="visibility")return!0;const r=n[n.length-1],o=kA(i,e),a=kA(r,e);return!o||!a?!1:xG(n)||(t==="spring"||Q2(t))&&s}const yG=n=>n!==null;function ey(n,{repeat:e,repeatType:t="loop"},s){const i=n.filter(yG),r=e&&t!=="loop"&&e%2===1?0:i.length-1;return!r||s===void 0?i[r]:s}const wG=40;class A${constructor({autoplay:e=!0,delay:t=0,type:s="keyframes",repeat:i=0,repeatDelay:r=0,repeatType:o="loop",...a}){this.isStopped=!1,this.hasAttemptedResolve=!1,this.createdAt=pl.now(),this.options={autoplay:e,delay:t,type:s,repeat:i,repeatDelay:r,repeatType:o,...a},this.updateFinishedPromise()}calcStartTime(){return this.resolvedAt?this.resolvedAt-this.createdAt>wG?this.resolvedAt:this.createdAt:this.createdAt}get resolved(){return!this._resolved&&!this.hasAttemptedResolve&&fG(),this._resolved}onKeyframesResolved(e,t){this.resolvedAt=pl.now(),this.hasAttemptedResolve=!0;const{name:s,type:i,velocity:r,delay:o,onComplete:a,onUpdate:l,isGenerator:c}=this.options;if(!c&&!vG(e,s,i,r))if(o)this.options.duration=0;else{l&&l(ey(e,this.options,t)),a&&a(),this.resolveFinishedPromise();return}const u=this.initPlayback(e,t);u!==!1&&(this._resolved={keyframes:e,finalKeyframe:t,...u},this.onPostResolved())}onPostResolved(){}then(e,t){return this.currentFinishedPromise.then(e,t)}flatten(){this.options.type="keyframes",this.options.ease="linear"}updateFinishedPromise(){this.currentFinishedPromise=new Promise(e=>{this.resolveFinishedPromise=e})}}const ai=(n,e,t)=>n+(e-n)*t;function A3(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*(2/3-t)*6:n}function bG({hue:n,saturation:e,lightness:t,alpha:s}){n/=360,e/=100,t/=100;let i=0,r=0,o=0;if(!e)i=r=o=t;else{const a=t<.5?t*(1+e):t+e-t*e,l=2*t-a;i=A3(l,a,n+1/3),r=A3(l,a,n),o=A3(l,a,n-1/3)}return{red:Math.round(i*255),green:Math.round(r*255),blue:Math.round(o*255),alpha:s}}function Qv(n,e){return t=>t>0?e:n}const R3=(n,e,t)=>{const s=n*n,i=t*(e*e-s)+s;return i<0?0:Math.sqrt(i)},SG=[pC,id,Jh],CG=n=>SG.find(e=>e.test(n));function AA(n){const e=CG(n);if(!e)return!1;let t=e.parse(n);return e===Jh&&(t=bG(t)),t}const RA=(n,e)=>{const t=AA(n),s=AA(e);if(!t||!s)return Qv(n,e);const i={...t};return r=>(i.red=R3(t.red,s.red,r),i.green=R3(t.green,s.green,r),i.blue=R3(t.blue,s.blue,r),i.alpha=ai(t.alpha,s.alpha,r),id.transform(i))},_G=(n,e)=>t=>e(n(t)),e0=(...n)=>n.reduce(_G),vC=new Set(["none","hidden"]);function EG(n,e){return vC.has(n)?t=>t<=0?n:e:t=>t>=1?e:n}function TG(n,e){return t=>ai(n,e,t)}function mE(n){return typeof n=="number"?TG:typeof n=="string"?q_(n)?Qv:Rr.test(n)?RA:AG:Array.isArray(n)?R$:typeof n=="object"?Rr.test(n)?RA:IG:Qv}function R$(n,e){const t=[...n],s=t.length,i=n.map((r,o)=>mE(r)(r,e[o]));return r=>{for(let o=0;o<s;o++)t[o]=i[o](r);return t}}function IG(n,e){const t={...n,...e},s={};for(const i in t)n[i]!==void 0&&e[i]!==void 0&&(s[i]=mE(n[i])(n[i],e[i]));return i=>{for(const r in s)t[r]=s[r](i);return t}}function kG(n,e){var t;const s=[],i={color:0,var:0,number:0};for(let r=0;r<e.values.length;r++){const o=e.types[r],a=n.indexes[o][i[o]],l=(t=n.values[a])!==null&&t!==void 0?t:0;s[r]=l,i[o]++}return s}const AG=(n,e)=>{const t=ru.createTransformer(e),s=Ig(n),i=Ig(e);return s.indexes.var.length===i.indexes.var.length&&s.indexes.color.length===i.indexes.color.length&&s.indexes.number.length>=i.indexes.number.length?vC.has(n)&&!i.values.length||vC.has(e)&&!s.values.length?EG(n,e):e0(R$(kG(s,i),i.values),t):Qv(n,e)};function M$(n,e,t){return typeof n=="number"&&typeof e=="number"&&typeof t=="number"?ai(n,e,t):mE(n)(n,e)}const RG=5;function N$(n,e,t){const s=Math.max(e-RG,0);return lE(t-n(s),e-s)}const vi={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1},M3=.001;function MG({duration:n=vi.duration,bounce:e=vi.bounce,velocity:t=vi.velocity,mass:s=vi.mass}){let i,r,o=1-e;o=wl(vi.minDamping,vi.maxDamping,o),n=wl(vi.minDuration,vi.maxDuration,hl(n)),o<1?(i=c=>{const u=c*o,d=u*n,h=u-t,p=yC(c,o),g=Math.exp(-d);return M3-h/p*g},r=c=>{const d=c*o*n,h=d*t+t,p=Math.pow(o,2)*Math.pow(c,2)*n,g=Math.exp(-d),y=yC(Math.pow(c,2),o);return(-i(c)+M3>0?-1:1)*((h-p)*g)/y}):(i=c=>{const u=Math.exp(-c*n),d=(c-t)*n+1;return-M3+u*d},r=c=>{const u=Math.exp(-c*n),d=(t-c)*(n*n);return u*d});const a=5/n,l=PG(i,r,a);if(n=dl(n),isNaN(l))return{stiffness:vi.stiffness,damping:vi.damping,duration:n};{const c=Math.pow(l,2)*s;return{stiffness:c,damping:o*2*Math.sqrt(s*c),duration:n}}}const NG=12;function PG(n,e,t){let s=t;for(let i=1;i<NG;i++)s=s-n(s)/e(s);return s}function yC(n,e){return n*Math.sqrt(1-e*e)}const DG=["duration","bounce"],LG=["stiffness","damping","mass"];function MA(n,e){return e.some(t=>n[t]!==void 0)}function $G(n){let e={velocity:vi.velocity,stiffness:vi.stiffness,damping:vi.damping,mass:vi.mass,isResolvedFromDuration:!1,...n};if(!MA(n,LG)&&MA(n,DG))if(n.visualDuration){const t=n.visualDuration,s=2*Math.PI/(t*1.2),i=s*s,r=2*wl(.05,1,1-(n.bounce||0))*Math.sqrt(i);e={...e,mass:vi.mass,stiffness:i,damping:r}}else{const t=MG(n);e={...e,...t,mass:vi.mass},e.isResolvedFromDuration=!0}return e}function gE(n=vi.visualDuration,e=vi.bounce){const t=typeof n!="object"?{visualDuration:n,keyframes:[0,1],bounce:e}:n;let{restSpeed:s,restDelta:i}=t;const r=t.keyframes[0],o=t.keyframes[t.keyframes.length-1],a={done:!1,value:r},{stiffness:l,damping:c,mass:u,duration:d,velocity:h,isResolvedFromDuration:p}=$G({...t,velocity:-hl(t.velocity||0)}),g=h||0,y=c/(2*Math.sqrt(l*u)),x=o-r,v=hl(Math.sqrt(l/u)),b=Math.abs(x)<5;s||(s=b?vi.restSpeed.granular:vi.restSpeed.default),i||(i=b?vi.restDelta.granular:vi.restDelta.default);let S;if(y<1){const E=yC(v,y);S=k=>{const R=Math.exp(-y*v*k);return o-R*((g+y*v*x)/E*Math.sin(E*k)+x*Math.cos(E*k))}}else if(y===1)S=E=>o-Math.exp(-v*E)*(x+(g+v*x)*E);else{const E=v*Math.sqrt(y*y-1);S=k=>{const R=Math.exp(-y*v*k),L=Math.min(E*k,300);return o-R*((g+y*v*x)*Math.sinh(L)+E*x*Math.cosh(L))/E}}const C={calculatedDuration:p&&d||null,next:E=>{const k=S(E);if(p)a.done=E>=d;else{let R=0;y<1&&(R=E===0?dl(g):N$(S,E,k));const L=Math.abs(R)<=s,I=Math.abs(o-k)<=i;a.done=L&&I}return a.value=a.done?o:k,a},toString:()=>{const E=Math.min(nE(C),Yv),k=JL(R=>C.next(E*R).value,E,30);return E+"ms "+k}};return C}function NA({keyframes:n,velocity:e=0,power:t=.8,timeConstant:s=325,bounceDamping:i=10,bounceStiffness:r=500,modifyTarget:o,min:a,max:l,restDelta:c=.5,restSpeed:u}){const d=n[0],h={done:!1,value:d},p=L=>a!==void 0&&L<a||l!==void 0&&L>l,g=L=>a===void 0?l:l===void 0||Math.abs(a-L)<Math.abs(l-L)?a:l;let y=t*e;const x=d+y,v=o===void 0?x:o(x);v!==x&&(y=v-d);const b=L=>-y*Math.exp(-L/s),S=L=>v+b(L),C=L=>{const I=b(L),T=S(L);h.done=Math.abs(I)<=c,h.value=h.done?v:T};let E,k;const R=L=>{p(h.value)&&(E=L,k=gE({keyframes:[h.value,g(h.value)],velocity:N$(S,L,h.value),damping:i,stiffness:r,restDelta:c,restSpeed:u}))};return R(0),{calculatedDuration:null,next:L=>{let I=!1;return!k&&E===void 0&&(I=!0,C(L),R(L)),E!==void 0&&L>=E?k.next(L-E):(!I&&C(L),h)}}}const FG=Jg(.42,0,1,1),OG=Jg(0,0,.58,1),P$=Jg(.42,0,.58,1),D$=n=>Array.isArray(n)&&typeof n[0]!="number",zG={linear:qr,easeIn:FG,easeInOut:P$,easeOut:OG,circIn:uE,circInOut:p$,circOut:f$,backIn:cE,backInOut:d$,backOut:u$,anticipate:h$},PA=n=>{if(sE(n)){ML(n.length===4);const[e,t,s,i]=n;return Jg(e,t,s,i)}else if(typeof n=="string")return zG[n];return n};function BG(n,e,t){const s=[],i=t||M$,r=n.length-1;for(let o=0;o<r;o++){let a=i(n[o],n[o+1]);if(e){const l=Array.isArray(e)?e[o]||qr:e;a=e0(l,a)}s.push(a)}return s}function xE(n,e,{clamp:t=!0,ease:s,mixer:i}={}){const r=n.length;if(ML(r===e.length),r===1)return()=>e[0];if(r===2&&e[0]===e[1])return()=>e[1];const o=n[0]===n[1];n[0]>n[r-1]&&(n=[...n].reverse(),e=[...e].reverse());const a=BG(e,s,i),l=a.length,c=u=>{if(o&&u<n[0])return e[0];let d=0;if(l>1)for(;d<n.length-2&&!(u<n[d+1]);d++);const h=iu(n[d],n[d+1],u);return a[d](h)};return t?u=>c(wl(n[0],n[r-1],u)):c}function L$(n,e){const t=n[n.length-1];for(let s=1;s<=e;s++){const i=iu(0,e,s);n.push(ai(t,1,i))}}function vE(n){const e=[0];return L$(e,n.length-1),e}function UG(n,e){return n.map(t=>t*e)}function VG(n,e){return n.map(()=>e||P$).splice(0,n.length-1)}function Jv({duration:n=300,keyframes:e,times:t,ease:s="easeInOut"}){const i=D$(s)?s.map(PA):PA(s),r={done:!1,value:e[0]},o=UG(t&&t.length===e.length?t:vE(e),n),a=xE(o,e,{ease:Array.isArray(i)?i:VG(e,i)});return{calculatedDuration:n,next:l=>(r.value=a(l),r.done=l>=n,r)}}const WG=n=>{const e=({timestamp:t})=>n(t);return{start:()=>Ms.update(e,!0),stop:()=>Da(e),now:()=>or.isProcessing?or.timestamp:pl.now()}},GG={decay:NA,inertia:NA,tween:Jv,keyframes:Jv,spring:gE},HG=n=>n/100;class yE extends A${constructor(e){super(e),this.holdTime=null,this.cancelTime=null,this.currentTime=0,this.playbackSpeed=1,this.pendingPlayState="running",this.startTime=null,this.state="idle",this.stop=()=>{if(this.resolver.cancel(),this.isStopped=!0,this.state==="idle")return;this.teardown();const{onStop:l}=this.options;l&&l()};const{name:t,motionValue:s,element:i,keyframes:r}=this.options,o=(i==null?void 0:i.KeyframeResolver)||pE,a=(l,c)=>this.onKeyframesResolved(l,c);this.resolver=new o(r,a,t,s,i),this.resolver.scheduleResolve()}flatten(){super.flatten(),this._resolved&&Object.assign(this._resolved,this.initPlayback(this._resolved.keyframes))}initPlayback(e){const{type:t="keyframes",repeat:s=0,repeatDelay:i=0,repeatType:r,velocity:o=0}=this.options,a=Q2(t)?t:GG[t]||Jv;let l,c;a!==Jv&&typeof e[0]!="number"&&(l=e0(HG,M$(e[0],e[1])),e=[0,100]);const u=a({...this.options,keyframes:e});r==="mirror"&&(c=a({...this.options,keyframes:[...e].reverse(),velocity:-o})),u.calculatedDuration===null&&(u.calculatedDuration=nE(u));const{calculatedDuration:d}=u,h=d+i,p=h*(s+1)-i;return{generator:u,mirroredGenerator:c,mapPercentToKeyframes:l,calculatedDuration:d,resolvedDuration:h,totalDuration:p}}onPostResolved(){const{autoplay:e=!0}=this.options;this.play(),this.pendingPlayState==="paused"||!e?this.pause():this.state=this.pendingPlayState}tick(e,t=!1){const{resolved:s}=this;if(!s){const{keyframes:L}=this.options;return{done:!0,value:L[L.length-1]}}const{finalKeyframe:i,generator:r,mirroredGenerator:o,mapPercentToKeyframes:a,keyframes:l,calculatedDuration:c,totalDuration:u,resolvedDuration:d}=s;if(this.startTime===null)return r.next(0);const{delay:h,repeat:p,repeatType:g,repeatDelay:y,onUpdate:x}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,e):this.speed<0&&(this.startTime=Math.min(e-u/this.speed,this.startTime)),t?this.currentTime=e:this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=Math.round(e-this.startTime)*this.speed;const v=this.currentTime-h*(this.speed>=0?1:-1),b=this.speed>=0?v<0:v>u;this.currentTime=Math.max(v,0),this.state==="finished"&&this.holdTime===null&&(this.currentTime=u);let S=this.currentTime,C=r;if(p){const L=Math.min(this.currentTime,u)/d;let I=Math.floor(L),T=L%1;!T&&L>=1&&(T=1),T===1&&I--,I=Math.min(I,p+1),!!(I%2)&&(g==="reverse"?(T=1-T,y&&(T-=y/d)):g==="mirror"&&(C=o)),S=wl(0,1,T)*d}const E=b?{done:!1,value:l[0]}:C.next(S);a&&(E.value=a(E.value));let{done:k}=E;!b&&c!==null&&(k=this.speed>=0?this.currentTime>=u:this.currentTime<=0);const R=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&k);return R&&i!==void 0&&(E.value=ey(l,this.options,i)),x&&x(E.value),R&&this.finish(),E}get duration(){const{resolved:e}=this;return e?hl(e.calculatedDuration):0}get time(){return hl(this.currentTime)}set time(e){e=dl(e),this.currentTime=e,this.holdTime!==null||this.speed===0?this.holdTime=e:this.driver&&(this.startTime=this.driver.now()-e/this.speed)}get speed(){return this.playbackSpeed}set speed(e){const t=this.playbackSpeed!==e;this.playbackSpeed=e,t&&(this.time=hl(this.currentTime))}play(){if(this.resolver.isScheduled||this.resolver.resume(),!this._resolved){this.pendingPlayState="running";return}if(this.isStopped)return;const{driver:e=WG,onPlay:t,startTime:s}=this.options;this.driver||(this.driver=e(r=>this.tick(r))),t&&t();const i=this.driver.now();this.holdTime!==null?this.startTime=i-this.holdTime:this.startTime?this.state==="finished"&&(this.startTime=i):this.startTime=s??this.calcStartTime(),this.state==="finished"&&this.updateFinishedPromise(),this.cancelTime=this.startTime,this.holdTime=null,this.state="running",this.driver.start()}pause(){var e;if(!this._resolved){this.pendingPlayState="paused";return}this.state="paused",this.holdTime=(e=this.currentTime)!==null&&e!==void 0?e:0}complete(){this.state!=="running"&&this.play(),this.pendingPlayState=this.state="finished",this.holdTime=null}finish(){this.teardown(),this.state="finished";const{onComplete:e}=this.options;e&&e()}cancel(){this.cancelTime!==null&&this.tick(this.cancelTime),this.teardown(),this.updateFinishedPromise()}teardown(){this.state="idle",this.stopDriver(),this.resolveFinishedPromise(),this.updateFinishedPromise(),this.startTime=this.cancelTime=null,this.resolver.cancel()}stopDriver(){this.driver&&(this.driver.stop(),this.driver=void 0)}sample(e){return this.startTime=0,this.tick(e,!0)}}const jG=new Set(["opacity","clipPath","filter","transform"]);function XG(n,e,t,{delay:s=0,duration:i=300,repeat:r=0,repeatType:o="loop",ease:a="easeInOut",times:l}={}){const c={[e]:t};l&&(c.offset=l);const u=t$(a,i);return Array.isArray(u)&&(c.easing=u),n.animate(c,{delay:s,duration:i,easing:Array.isArray(u)?"linear":u,fill:"both",iterations:r+1,direction:o==="reverse"?"alternate":"normal"})}const qG=U_(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),e2=10,KG=2e4;function YG(n){return Q2(n.type)||n.type==="spring"||!e$(n.ease)}function ZG(n,e){const t=new yE({...e,keyframes:n,repeat:0,delay:0,isGenerator:!0});let s={done:!1,value:n[0]};const i=[];let r=0;for(;!s.done&&r<KG;)s=t.sample(r),i.push(s.value),r+=e2;return{times:void 0,keyframes:i,duration:r-e2,ease:"linear"}}const $$={anticipate:h$,backInOut:d$,circInOut:p$};function QG(n){return n in $$}class DA extends A${constructor(e){super(e);const{name:t,motionValue:s,element:i,keyframes:r}=this.options;this.resolver=new k$(r,(o,a)=>this.onKeyframesResolved(o,a),t,s,i),this.resolver.scheduleResolve()}initPlayback(e,t){let{duration:s=300,times:i,ease:r,type:o,motionValue:a,name:l,startTime:c}=this.options;if(!a.owner||!a.owner.current)return!1;if(typeof r=="string"&&Zv()&&QG(r)&&(r=$$[r]),YG(this.options)){const{onComplete:d,onUpdate:h,motionValue:p,element:g,...y}=this.options,x=ZG(e,y);e=x.keyframes,e.length===1&&(e[1]=e[0]),s=x.duration,i=x.times,r=x.ease,o="keyframes"}const u=XG(a.owner.current,l,e,{...this.options,duration:s,times:i,ease:r});return u.startTime=c??this.calcStartTime(),this.pendingTimeline?(vA(u,this.pendingTimeline),this.pendingTimeline=void 0):u.onfinish=()=>{const{onComplete:d}=this.options;a.set(ey(e,this.options,t)),d&&d(),this.cancel(),this.resolveFinishedPromise()},{animation:u,duration:s,times:i,type:o,ease:r,keyframes:e}}get duration(){const{resolved:e}=this;if(!e)return 0;const{duration:t}=e;return hl(t)}get time(){const{resolved:e}=this;if(!e)return 0;const{animation:t}=e;return hl(t.currentTime||0)}set time(e){const{resolved:t}=this;if(!t)return;const{animation:s}=t;s.currentTime=dl(e)}get speed(){const{resolved:e}=this;if(!e)return 1;const{animation:t}=e;return t.playbackRate}set speed(e){const{resolved:t}=this;if(!t)return;const{animation:s}=t;s.playbackRate=e}get state(){const{resolved:e}=this;if(!e)return"idle";const{animation:t}=e;return t.playState}get startTime(){const{resolved:e}=this;if(!e)return null;const{animation:t}=e;return t.startTime}attachTimeline(e){if(!this._resolved)this.pendingTimeline=e;else{const{resolved:t}=this;if(!t)return qr;const{animation:s}=t;vA(s,e)}return qr}play(){if(this.isStopped)return;const{resolved:e}=this;if(!e)return;const{animation:t}=e;t.playState==="finished"&&this.updateFinishedPromise(),t.play()}pause(){const{resolved:e}=this;if(!e)return;const{animation:t}=e;t.pause()}stop(){if(this.resolver.cancel(),this.isStopped=!0,this.state==="idle")return;this.resolveFinishedPromise(),this.updateFinishedPromise();const{resolved:e}=this;if(!e)return;const{animation:t,keyframes:s,duration:i,type:r,ease:o,times:a}=e;if(t.playState==="idle"||t.playState==="finished")return;if(this.time){const{motionValue:c,onUpdate:u,onComplete:d,element:h,...p}=this.options,g=new yE({...p,keyframes:s,duration:i,type:r,ease:o,times:a,isGenerator:!0}),y=dl(this.time);c.setWithVelocity(g.sample(y-e2).value,g.sample(y).value,e2)}const{onStop:l}=this.options;l&&l(),this.cancel()}complete(){const{resolved:e}=this;e&&e.animation.finish()}cancel(){const{resolved:e}=this;e&&e.animation.cancel()}static supports(e){const{motionValue:t,name:s,repeatDelay:i,repeatType:r,damping:o,type:a}=e;if(!t||!t.owner||!(t.owner.current instanceof HTMLElement))return!1;const{onUpdate:l,transformTemplate:c}=t.owner.getProps();return qG()&&s&&jG.has(s)&&!l&&!c&&!i&&r!=="mirror"&&o!==0&&a!=="inertia"}}const JG={type:"spring",stiffness:500,damping:25,restSpeed:10},eH=n=>({type:"spring",stiffness:550,damping:n===0?2*Math.sqrt(550):30,restSpeed:10}),tH={type:"keyframes",duration:.8},nH={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},sH=(n,{keyframes:e})=>e.length>2?tH:Ld.has(n)?n.startsWith("scale")?eH(e[1]):JG:nH;function iH({when:n,delay:e,delayChildren:t,staggerChildren:s,staggerDirection:i,repeat:r,repeatType:o,repeatDelay:a,from:l,elapsed:c,...u}){return!!Object.keys(u).length}const wE=(n,e,t,s={},i,r)=>o=>{const a=tE(s,n)||{},l=a.delay||s.delay||0;let{elapsed:c=0}=s;c=c-dl(l);let u={keyframes:Array.isArray(t)?t:[null,t],ease:"easeOut",velocity:e.getVelocity(),...a,delay:-c,onUpdate:h=>{e.set(h),a.onUpdate&&a.onUpdate(h)},onComplete:()=>{o(),a.onComplete&&a.onComplete()},name:n,motionValue:e,element:r?void 0:i};iH(a)||(u={...u,...sH(n,u)}),u.duration&&(u.duration=dl(u.duration)),u.repeatDelay&&(u.repeatDelay=dl(u.repeatDelay)),u.from!==void 0&&(u.keyframes[0]=u.from);let d=!1;if((u.type===!1||u.duration===0&&!u.repeatDelay)&&(u.duration=0,u.delay===0&&(d=!0)),d&&!r&&e.get()!==void 0){const h=ey(u.keyframes,a);if(h!==void 0)return Ms.update(()=>{u.onUpdate(h),u.onComplete()}),new QL([])}return!r&&DA.supports(u)?new DA(u):new yE(u)};function rH({protectedKeys:n,needsAnimating:e},t){const s=n.hasOwnProperty(t)&&e[t]!==!0;return e[t]=!1,s}function bE(n,e,{delay:t=0,transitionOverride:s,type:i}={}){var r;let{transition:o=n.getDefaultTransition(),transitionEnd:a,...l}=e;s&&(o=s);const c=[],u=i&&n.animationState&&n.animationState.getState()[i];for(const d in l){const h=n.getValue(d,(r=n.latestValues[d])!==null&&r!==void 0?r:null),p=l[d];if(p===void 0||u&&rH(u,d))continue;const g={delay:t,...tE(o||{},d)};let y=!1;if(window.MotionHandoffAnimation){const v=o$(n);if(v){const b=window.MotionHandoffAnimation(v,d,Ms);b!==null&&(g.startTime=b,y=!0)}}fC(n,d),h.start(wE(d,h,p,n.shouldReduceMotion&&r$.has(d)?{type:!1}:g,n,y));const x=h.animation;x&&c.push(x)}return a&&Promise.all(c).then(()=>{Ms.update(()=>{a&&UW(n,a)})}),c}function wC(n,e,t={}){var s;const i=Z2(n,e,t.type==="exit"?(s=n.presenceContext)===null||s===void 0?void 0:s.custom:void 0);let{transition:r=n.getDefaultTransition()||{}}=i||{};t.transitionOverride&&(r=t.transitionOverride);const o=i?()=>Promise.all(bE(n,i,t)):()=>Promise.resolve(),a=n.variantChildren&&n.variantChildren.size?(c=0)=>{const{delayChildren:u=0,staggerChildren:d,staggerDirection:h}=r;return oH(n,e,u+c,d,h,t)}:()=>Promise.resolve(),{when:l}=r;if(l){const[c,u]=l==="beforeChildren"?[o,a]:[a,o];return c().then(()=>u())}else return Promise.all([o(),a(t.delay)])}function oH(n,e,t=0,s=0,i=1,r){const o=[],a=(n.variantChildren.size-1)*s,l=i===1?(c=0)=>c*s:(c=0)=>a-c*s;return Array.from(n.variantChildren).sort(aH).forEach((c,u)=>{c.notify("AnimationStart",e),o.push(wC(c,e,{...r,delay:t+l(u)}).then(()=>c.notify("AnimationComplete",e)))}),Promise.all(o)}function aH(n,e){return n.sortNodePosition(e)}function lH(n,e,t={}){n.notify("AnimationStart",e);let s;if(Array.isArray(e)){const i=e.map(r=>wC(n,r,t));s=Promise.all(i)}else if(typeof e=="string")s=wC(n,e,t);else{const i=typeof e=="function"?Z2(n,e,t.custom):e;s=Promise.all(bE(n,i,t))}return s.then(()=>{n.notify("AnimationComplete",e)})}const cH=W_.length;function F$(n){if(!n)return;if(!n.isControllingVariants){const t=n.parent?F$(n.parent)||{}:{};return n.props.initial!==void 0&&(t.initial=n.props.initial),t}const e={};for(let t=0;t<cH;t++){const s=W_[t],i=n.props[s];(Eg(i)||i===!1)&&(e[s]=i)}return e}const uH=[...V_].reverse(),dH=V_.length;function hH(n){return e=>Promise.all(e.map(({animation:t,options:s})=>lH(n,t,s)))}function fH(n){let e=hH(n),t=LA(),s=!0;const i=l=>(c,u)=>{var d;const h=Z2(n,u,l==="exit"?(d=n.presenceContext)===null||d===void 0?void 0:d.custom:void 0);if(h){const{transition:p,transitionEnd:g,...y}=h;c={...c,...y,...g}}return c};function r(l){e=l(n)}function o(l){const{props:c}=n,u=F$(n.parent)||{},d=[],h=new Set;let p={},g=1/0;for(let x=0;x<dH;x++){const v=uH[x],b=t[v],S=c[v]!==void 0?c[v]:u[v],C=Eg(S),E=v===l?b.isActive:null;E===!1&&(g=x);let k=S===u[v]&&S!==c[v]&&C;if(k&&s&&n.manuallyAnimateOnMount&&(k=!1),b.protectedKeys={...p},!b.isActive&&E===null||!S&&!b.prevProp||K2(S)||typeof S=="boolean")continue;const R=pH(b.prevProp,S);let L=R||v===l&&b.isActive&&!k&&C||x>g&&C,I=!1;const T=Array.isArray(S)?S:[S];let M=T.reduce(i(v),{});E===!1&&(M={});const{prevResolvedValues:j={}}=b,W={...j,...M},z=J=>{L=!0,h.has(J)&&(I=!0,h.delete(J)),b.needsAnimating[J]=!0;const K=n.getValue(J);K&&(K.liveStyle=!1)};for(const J in W){const K=M[J],ee=j[J];if(p.hasOwnProperty(J))continue;let ne=!1;dC(K)&&dC(ee)?ne=!YL(K,ee):ne=K!==ee,ne?K!=null?z(J):h.add(J):K!==void 0&&h.has(J)?z(J):b.protectedKeys[J]=!0}b.prevProp=S,b.prevResolvedValues=M,b.isActive&&(p={...p,...M}),s&&n.blockInitialAnimation&&(L=!1),L&&(!(k&&R)||I)&&d.push(...T.map(J=>({animation:J,options:{type:v}})))}if(h.size){const x={};h.forEach(v=>{const b=n.getBaseTarget(v),S=n.getValue(v);S&&(S.liveStyle=!0),x[v]=b??null}),d.push({animation:x})}let y=!!d.length;return s&&(c.initial===!1||c.initial===c.animate)&&!n.manuallyAnimateOnMount&&(y=!1),s=!1,y?e(d):Promise.resolve()}function a(l,c){var u;if(t[l].isActive===c)return Promise.resolve();(u=n.variantChildren)===null||u===void 0||u.forEach(h=>{var p;return(p=h.animationState)===null||p===void 0?void 0:p.setActive(l,c)}),t[l].isActive=c;const d=o(l);for(const h in t)t[h].protectedKeys={};return d}return{animateChanges:o,setActive:a,setAnimateFunction:r,getState:()=>t,reset:()=>{t=LA(),s=!0}}}function pH(n,e){return typeof e=="string"?e!==n:Array.isArray(e)?!YL(e,n):!1}function $u(n=!1){return{isActive:n,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function LA(){return{animate:$u(!0),whileInView:$u(),whileHover:$u(),whileTap:$u(),whileDrag:$u(),whileFocus:$u(),exit:$u()}}class hu{constructor(e){this.isMounted=!1,this.node=e}update(){}}class mH extends hu{constructor(e){super(e),e.animationState||(e.animationState=fH(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();K2(e)&&(this.unmountControls=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:t}=this.node.prevProps||{};e!==t&&this.updateAnimationControlsSubscription()}unmount(){var e;this.node.animationState.reset(),(e=this.unmountControls)===null||e===void 0||e.call(this)}}let gH=0;class xH extends hu{constructor(){super(...arguments),this.id=gH++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:t}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===s)return;const i=this.node.animationState.setActive("exit",!e);t&&!e&&i.then(()=>t(this.id))}mount(){const{register:e}=this.node.presenceContext||{};e&&(this.unmount=e(this.id))}unmount(){}}const vH={animation:{Feature:mH},exit:{Feature:xH}};function kg(n,e,t,s={passive:!0}){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t)}function t0(n){return{point:{x:n.pageX,y:n.pageY}}}const yH=n=>e=>rE(e)&&n(e,t0(e));function fg(n,e,t,s){return kg(n,e,yH(t),s)}const $A=(n,e)=>Math.abs(n-e);function wH(n,e){const t=$A(n.x,e.x),s=$A(n.y,e.y);return Math.sqrt(t**2+s**2)}class O${constructor(e,t,{transformPagePoint:s,contextWindow:i,dragSnapToOrigin:r=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const d=P3(this.lastMoveEventInfo,this.history),h=this.startEvent!==null,p=wH(d.offset,{x:0,y:0})>=3;if(!h&&!p)return;const{point:g}=d,{timestamp:y}=or;this.history.push({...g,timestamp:y});const{onStart:x,onMove:v}=this.handlers;h||(x&&x(this.lastMoveEvent,d),this.startEvent=this.lastMoveEvent),v&&v(this.lastMoveEvent,d)},this.handlePointerMove=(d,h)=>{this.lastMoveEvent=d,this.lastMoveEventInfo=N3(h,this.transformPagePoint),Ms.update(this.updatePoint,!0)},this.handlePointerUp=(d,h)=>{this.end();const{onEnd:p,onSessionEnd:g,resumeAnimation:y}=this.handlers;if(this.dragSnapToOrigin&&y&&y(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const x=P3(d.type==="pointercancel"?this.lastMoveEventInfo:N3(h,this.transformPagePoint),this.history);this.startEvent&&p&&p(d,x),g&&g(d,x)},!rE(e))return;this.dragSnapToOrigin=r,this.handlers=t,this.transformPagePoint=s,this.contextWindow=i||window;const o=t0(e),a=N3(o,this.transformPagePoint),{point:l}=a,{timestamp:c}=or;this.history=[{...l,timestamp:c}];const{onSessionStart:u}=t;u&&u(e,P3(a,this.history)),this.removeListeners=e0(fg(this.contextWindow,"pointermove",this.handlePointerMove),fg(this.contextWindow,"pointerup",this.handlePointerUp),fg(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),Da(this.updatePoint)}}function N3(n,e){return e?{point:e(n.point)}:n}function FA(n,e){return{x:n.x-e.x,y:n.y-e.y}}function P3({point:n},e){return{point:n,delta:FA(n,z$(e)),offset:FA(n,bH(e)),velocity:SH(e,.1)}}function bH(n){return n[0]}function z$(n){return n[n.length-1]}function SH(n,e){if(n.length<2)return{x:0,y:0};let t=n.length-1,s=null;const i=z$(n);for(;t>=0&&(s=n[t],!(i.timestamp-s.timestamp>dl(e)));)t--;if(!s)return{x:0,y:0};const r=hl(i.timestamp-s.timestamp);if(r===0)return{x:0,y:0};const o={x:(i.x-s.x)/r,y:(i.y-s.y)/r};return o.x===1/0&&(o.x=0),o.y===1/0&&(o.y=0),o}const B$=1e-4,CH=1-B$,_H=1+B$,U$=.01,EH=0-U$,TH=0+U$;function Do(n){return n.max-n.min}function IH(n,e,t){return Math.abs(n-e)<=t}function OA(n,e,t,s=.5){n.origin=s,n.originPoint=ai(e.min,e.max,n.origin),n.scale=Do(t)/Do(e),n.translate=ai(t.min,t.max,n.origin)-n.originPoint,(n.scale>=CH&&n.scale<=_H||isNaN(n.scale))&&(n.scale=1),(n.translate>=EH&&n.translate<=TH||isNaN(n.translate))&&(n.translate=0)}function pg(n,e,t,s){OA(n.x,e.x,t.x,s?s.originX:void 0),OA(n.y,e.y,t.y,s?s.originY:void 0)}function zA(n,e,t){n.min=t.min+e.min,n.max=n.min+Do(e)}function kH(n,e,t){zA(n.x,e.x,t.x),zA(n.y,e.y,t.y)}function BA(n,e,t){n.min=e.min-t.min,n.max=n.min+Do(e)}function mg(n,e,t){BA(n.x,e.x,t.x),BA(n.y,e.y,t.y)}function AH(n,{min:e,max:t},s){return e!==void 0&&n<e?n=s?ai(e,n,s.min):Math.max(n,e):t!==void 0&&n>t&&(n=s?ai(t,n,s.max):Math.min(n,t)),n}function UA(n,e,t){return{min:e!==void 0?n.min+e:void 0,max:t!==void 0?n.max+t-(n.max-n.min):void 0}}function RH(n,{top:e,left:t,bottom:s,right:i}){return{x:UA(n.x,t,i),y:UA(n.y,e,s)}}function VA(n,e){let t=e.min-n.min,s=e.max-n.max;return e.max-e.min<n.max-n.min&&([t,s]=[s,t]),{min:t,max:s}}function MH(n,e){return{x:VA(n.x,e.x),y:VA(n.y,e.y)}}function NH(n,e){let t=.5;const s=Do(n),i=Do(e);return i>s?t=iu(e.min,e.max-s,n.min):s>i&&(t=iu(n.min,n.max-i,e.min)),wl(0,1,t)}function PH(n,e){const t={};return e.min!==void 0&&(t.min=e.min-n.min),e.max!==void 0&&(t.max=e.max-n.min),t}const bC=.35;function DH(n=bC){return n===!1?n=0:n===!0&&(n=bC),{x:WA(n,"left","right"),y:WA(n,"top","bottom")}}function WA(n,e,t){return{min:GA(n,e),max:GA(n,t)}}function GA(n,e){return typeof n=="number"?n:n[e]||0}const HA=()=>({translate:0,scale:1,origin:0,originPoint:0}),ef=()=>({x:HA(),y:HA()}),jA=()=>({min:0,max:0}),xi=()=>({x:jA(),y:jA()});function Zo(n){return[n("x"),n("y")]}function V$({top:n,left:e,right:t,bottom:s}){return{x:{min:e,max:t},y:{min:n,max:s}}}function LH({x:n,y:e}){return{top:e.min,right:n.max,bottom:e.max,left:n.min}}function $H(n,e){if(!e)return n;const t=e({x:n.left,y:n.top}),s=e({x:n.right,y:n.bottom});return{top:t.y,left:t.x,bottom:s.y,right:s.x}}function D3(n){return n===void 0||n===1}function SC({scale:n,scaleX:e,scaleY:t}){return!D3(n)||!D3(e)||!D3(t)}function Hu(n){return SC(n)||W$(n)||n.z||n.rotate||n.rotateX||n.rotateY||n.skewX||n.skewY}function W$(n){return XA(n.x)||XA(n.y)}function XA(n){return n&&n!=="0%"}function t2(n,e,t){const s=n-t,i=e*s;return t+i}function qA(n,e,t,s,i){return i!==void 0&&(n=t2(n,i,s)),t2(n,t,s)+e}function CC(n,e=0,t=1,s,i){n.min=qA(n.min,e,t,s,i),n.max=qA(n.max,e,t,s,i)}function G$(n,{x:e,y:t}){CC(n.x,e.translate,e.scale,e.originPoint),CC(n.y,t.translate,t.scale,t.originPoint)}const KA=.999999999999,YA=1.0000000000001;function FH(n,e,t,s=!1){const i=t.length;if(!i)return;e.x=e.y=1;let r,o;for(let a=0;a<i;a++){r=t[a],o=r.projectionDelta;const{visualElement:l}=r.options;l&&l.props.style&&l.props.style.display==="contents"||(s&&r.options.layoutScroll&&r.scroll&&r!==r.root&&nf(n,{x:-r.scroll.offset.x,y:-r.scroll.offset.y}),o&&(e.x*=o.x.scale,e.y*=o.y.scale,G$(n,o)),s&&Hu(r.latestValues)&&nf(n,r.latestValues))}e.x<YA&&e.x>KA&&(e.x=1),e.y<YA&&e.y>KA&&(e.y=1)}function tf(n,e){n.min=n.min+e,n.max=n.max+e}function ZA(n,e,t,s,i=.5){const r=ai(n.min,n.max,i);CC(n,e,t,r,s)}function nf(n,e){ZA(n.x,e.x,e.scaleX,e.scale,e.originX),ZA(n.y,e.y,e.scaleY,e.scale,e.originY)}function H$(n,e){return V$($H(n.getBoundingClientRect(),e))}function OH(n,e,t){const s=H$(n,t),{scroll:i}=e;return i&&(tf(s.x,i.offset.x),tf(s.y,i.offset.y)),s}const j$=({current:n})=>n?n.ownerDocument.defaultView:null,zH=new WeakMap;class BH{constructor(e){this.openDragLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=xi(),this.visualElement=e}start(e,{snapToCursor:t=!1}={}){const{presenceContext:s}=this.visualElement;if(s&&s.isPresent===!1)return;const i=u=>{const{dragSnapToOrigin:d}=this.getProps();d?this.pauseAnimation():this.stopAnimation(),t&&this.snapToCursor(t0(u).point)},r=(u,d)=>{const{drag:h,dragPropagation:p,onDragStart:g}=this.getProps();if(h&&!p&&(this.openDragLock&&this.openDragLock(),this.openDragLock=$W(h),!this.openDragLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Zo(x=>{let v=this.getAxisMotionValue(x).get()||0;if(fl.test(v)){const{projection:b}=this.visualElement;if(b&&b.layout){const S=b.layout.layoutBox[x];S&&(v=Do(S)*(parseFloat(v)/100))}}this.originPoint[x]=v}),g&&Ms.postRender(()=>g(u,d)),fC(this.visualElement,"transform");const{animationState:y}=this.visualElement;y&&y.setActive("whileDrag",!0)},o=(u,d)=>{const{dragPropagation:h,dragDirectionLock:p,onDirectionLock:g,onDrag:y}=this.getProps();if(!h&&!this.openDragLock)return;const{offset:x}=d;if(p&&this.currentDirection===null){this.currentDirection=UH(x),this.currentDirection!==null&&g&&g(this.currentDirection);return}this.updateAxis("x",d.point,x),this.updateAxis("y",d.point,x),this.visualElement.render(),y&&y(u,d)},a=(u,d)=>this.stop(u,d),l=()=>Zo(u=>{var d;return this.getAnimationState(u)==="paused"&&((d=this.getAxisMotionValue(u).animation)===null||d===void 0?void 0:d.play())}),{dragSnapToOrigin:c}=this.getProps();this.panSession=new O$(e,{onSessionStart:i,onStart:r,onMove:o,onSessionEnd:a,resumeAnimation:l},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:c,contextWindow:j$(this.visualElement)})}stop(e,t){const s=this.isDragging;if(this.cancel(),!s)return;const{velocity:i}=t;this.startAnimation(i);const{onDragEnd:r}=this.getProps();r&&Ms.postRender(()=>r(e,t))}cancel(){this.isDragging=!1;const{projection:e,animationState:t}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openDragLock&&(this.openDragLock(),this.openDragLock=null),t&&t.setActive("whileDrag",!1)}updateAxis(e,t,s){const{drag:i}=this.getProps();if(!s||!Ix(e,i,this.currentDirection))return;const r=this.getAxisMotionValue(e);let o=this.originPoint[e]+s[e];this.constraints&&this.constraints[e]&&(o=AH(o,this.constraints[e],this.elastic[e])),r.set(o)}resolveConstraints(){var e;const{dragConstraints:t,dragElastic:s}=this.getProps(),i=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):(e=this.visualElement.projection)===null||e===void 0?void 0:e.layout,r=this.constraints;t&&Qh(t)?this.constraints||(this.constraints=this.resolveRefConstraints()):t&&i?this.constraints=RH(i.layoutBox,t):this.constraints=!1,this.elastic=DH(s),r!==this.constraints&&i&&this.constraints&&!this.hasMutatedConstraints&&Zo(o=>{this.constraints!==!1&&this.getAxisMotionValue(o)&&(this.constraints[o]=PH(i.layoutBox[o],this.constraints[o]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:t}=this.getProps();if(!e||!Qh(e))return!1;const s=e.current,{projection:i}=this.visualElement;if(!i||!i.layout)return!1;const r=OH(s,i.root,this.visualElement.getTransformPagePoint());let o=MH(i.layout.layoutBox,r);if(t){const a=t(LH(o));this.hasMutatedConstraints=!!a,a&&(o=V$(a))}return o}startAnimation(e){const{drag:t,dragMomentum:s,dragElastic:i,dragTransition:r,dragSnapToOrigin:o,onDragTransitionEnd:a}=this.getProps(),l=this.constraints||{},c=Zo(u=>{if(!Ix(u,t,this.currentDirection))return;let d=l&&l[u]||{};o&&(d={min:0,max:0});const h=i?200:1e6,p=i?40:1e7,g={type:"inertia",velocity:s?e[u]:0,bounceStiffness:h,bounceDamping:p,timeConstant:750,restDelta:1,restSpeed:10,...r,...d};return this.startAxisValueAnimation(u,g)});return Promise.all(c).then(a)}startAxisValueAnimation(e,t){const s=this.getAxisMotionValue(e);return fC(this.visualElement,e),s.start(wE(e,s,0,t,this.visualElement,!1))}stopAnimation(){Zo(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){Zo(e=>{var t;return(t=this.getAxisMotionValue(e).animation)===null||t===void 0?void 0:t.pause()})}getAnimationState(e){var t;return(t=this.getAxisMotionValue(e).animation)===null||t===void 0?void 0:t.state}getAxisMotionValue(e){const t=`_drag${e.toUpperCase()}`,s=this.visualElement.getProps(),i=s[t];return i||this.visualElement.getValue(e,(s.initial?s.initial[e]:void 0)||0)}snapToCursor(e){Zo(t=>{const{drag:s}=this.getProps();if(!Ix(t,s,this.currentDirection))return;const{projection:i}=this.visualElement,r=this.getAxisMotionValue(t);if(i&&i.layout){const{min:o,max:a}=i.layout.layoutBox[t];r.set(e[t]-ai(o,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:t}=this.getProps(),{projection:s}=this.visualElement;if(!Qh(t)||!s||!this.constraints)return;this.stopAnimation();const i={x:0,y:0};Zo(o=>{const a=this.getAxisMotionValue(o);if(a&&this.constraints!==!1){const l=a.get();i[o]=NH({min:l,max:l},this.constraints[o])}});const{transformTemplate:r}=this.visualElement.getProps();this.visualElement.current.style.transform=r?r({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),Zo(o=>{if(!Ix(o,e,null))return;const a=this.getAxisMotionValue(o),{min:l,max:c}=this.constraints[o];a.set(ai(l,c,i[o]))})}addListeners(){if(!this.visualElement.current)return;zH.set(this.visualElement,this);const e=this.visualElement.current,t=fg(e,"pointerdown",l=>{const{drag:c,dragListener:u=!0}=this.getProps();c&&u&&this.start(l)}),s=()=>{const{dragConstraints:l}=this.getProps();Qh(l)&&l.current&&(this.constraints=this.resolveRefConstraints())},{projection:i}=this.visualElement,r=i.addEventListener("measure",s);i&&!i.layout&&(i.root&&i.root.updateScroll(),i.updateLayout()),Ms.read(s);const o=kg(window,"resize",()=>this.scalePositionWithinConstraints()),a=i.addEventListener("didUpdate",({delta:l,hasLayoutChanged:c})=>{this.isDragging&&c&&(Zo(u=>{const d=this.getAxisMotionValue(u);d&&(this.originPoint[u]+=l[u].translate,d.set(d.get()+l[u].translate))}),this.visualElement.render())});return()=>{o(),t(),r(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:t=!1,dragDirectionLock:s=!1,dragPropagation:i=!1,dragConstraints:r=!1,dragElastic:o=bC,dragMomentum:a=!0}=e;return{...e,drag:t,dragDirectionLock:s,dragPropagation:i,dragConstraints:r,dragElastic:o,dragMomentum:a}}}function Ix(n,e,t){return(e===!0||e===n)&&(t===null||t===n)}function UH(n,e=10){let t=null;return Math.abs(n.y)>e?t="y":Math.abs(n.x)>e&&(t="x"),t}class VH extends hu{constructor(e){super(e),this.removeGroupControls=qr,this.removeListeners=qr,this.controls=new BH(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||qr}unmount(){this.removeGroupControls(),this.removeListeners()}}const QA=n=>(e,t)=>{n&&Ms.postRender(()=>n(e,t))};class WH extends hu{constructor(){super(...arguments),this.removePointerDownListener=qr}onPointerDown(e){this.session=new O$(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:j$(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:t,onPan:s,onPanEnd:i}=this.node.getProps();return{onSessionStart:QA(e),onStart:QA(t),onMove:s,onEnd:(r,o)=>{delete this.session,i&&Ms.postRender(()=>i(r,o))}}}mount(){this.removePointerDownListener=fg(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}const Iv={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function JA(n,e){return e.max===e.min?0:n/(e.max-e.min)*100}const Pm={correct:(n,e)=>{if(!e.target)return n;if(typeof n=="string")if($n.test(n))n=parseFloat(n);else return n;const t=JA(n,e.target.x),s=JA(n,e.target.y);return`${t}% ${s}%`}},GH={correct:(n,{treeScale:e,projectionDelta:t})=>{const s=n,i=ru.parse(n);if(i.length>5)return s;const r=ru.createTransformer(n),o=typeof i[0]!="number"?1:0,a=t.x.scale*e.x,l=t.y.scale*e.y;i[0+o]/=a,i[1+o]/=l;const c=ai(a,l,.5);return typeof i[2+o]=="number"&&(i[2+o]/=c),typeof i[3+o]=="number"&&(i[3+o]/=c),r(i)}};class HH extends le.Component{componentDidMount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s,layoutId:i}=this.props,{projection:r}=e;xW(jH),r&&(t.group&&t.group.add(r),s&&s.register&&i&&s.register(r),r.root.didUpdate(),r.addEventListener("animationComplete",()=>{this.safeToRemove()}),r.setOptions({...r.options,onExitComplete:()=>this.safeToRemove()})),Iv.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:t,visualElement:s,drag:i,isPresent:r}=this.props,o=s.projection;return o&&(o.isPresent=r,i||e.layoutDependency!==t||t===void 0?o.willUpdate():this.safeToRemove(),e.isPresent!==r&&(r?o.promote():o.relegate()||Ms.postRender(()=>{const a=o.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),H_.postRender(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:t,switchLayoutGroup:s}=this.props,{projection:i}=e;i&&(i.scheduleCheckAfterUnmount(),t&&t.group&&t.group.remove(i),s&&s.deregister&&s.deregister(i))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function X$(n){const[e,t]=RL(),s=le.useContext(z_);return G.jsx(HH,{...n,layoutGroup:s,switchLayoutGroup:le.useContext(FL),isPresent:e,safeToRemove:t})}const jH={borderRadius:{...Pm,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:Pm,borderTopRightRadius:Pm,borderBottomLeftRadius:Pm,borderBottomRightRadius:Pm,boxShadow:GH};function q$(n,e,t){const s=cr(n)?n:cl(n);return s.start(wE("",s,e,t)),s.animation}function K$(n){return n instanceof SVGElement&&n.tagName!=="svg"}const XH=(n,e)=>n.depth-e.depth;class qH{constructor(){this.children=[],this.isDirty=!1}add(e){oE(this.children,e),this.isDirty=!0}remove(e){J2(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(XH),this.isDirty=!1,this.children.forEach(e)}}function KH(n,e){const t=pl.now(),s=({timestamp:i})=>{const r=i-t;r>=e&&(Da(s),n(r-e))};return Ms.read(s,!0),()=>Da(s)}const Y$=["TopLeft","TopRight","BottomLeft","BottomRight"],YH=Y$.length,eR=n=>typeof n=="string"?parseFloat(n):n,tR=n=>typeof n=="number"||$n.test(n);function ZH(n,e,t,s,i,r){i?(n.opacity=ai(0,t.opacity!==void 0?t.opacity:1,QH(s)),n.opacityExit=ai(e.opacity!==void 0?e.opacity:1,0,JH(s))):r&&(n.opacity=ai(e.opacity!==void 0?e.opacity:1,t.opacity!==void 0?t.opacity:1,s));for(let o=0;o<YH;o++){const a=`border${Y$[o]}Radius`;let l=nR(e,a),c=nR(t,a);if(l===void 0&&c===void 0)continue;l||(l=0),c||(c=0),l===0||c===0||tR(l)===tR(c)?(n[a]=Math.max(ai(eR(l),eR(c),s),0),(fl.test(c)||fl.test(l))&&(n[a]+="%")):n[a]=c}(e.rotate||t.rotate)&&(n.rotate=ai(e.rotate||0,t.rotate||0,s))}function nR(n,e){return n[e]!==void 0?n[e]:n.borderRadius}const QH=Z$(0,.5,f$),JH=Z$(.5,.95,qr);function Z$(n,e,t){return s=>s<n?0:s>e?1:t(iu(n,e,s))}function sR(n,e){n.min=e.min,n.max=e.max}function Xo(n,e){sR(n.x,e.x),sR(n.y,e.y)}function iR(n,e){n.translate=e.translate,n.scale=e.scale,n.originPoint=e.originPoint,n.origin=e.origin}function rR(n,e,t,s,i){return n-=e,n=t2(n,1/t,s),i!==void 0&&(n=t2(n,1/i,s)),n}function ej(n,e=0,t=1,s=.5,i,r=n,o=n){if(fl.test(e)&&(e=parseFloat(e),e=ai(o.min,o.max,e/100)-o.min),typeof e!="number")return;let a=ai(r.min,r.max,s);n===r&&(a-=e),n.min=rR(n.min,e,t,a,i),n.max=rR(n.max,e,t,a,i)}function oR(n,e,[t,s,i],r,o){ej(n,e[t],e[s],e[i],e.scale,r,o)}const tj=["x","scaleX","originX"],nj=["y","scaleY","originY"];function aR(n,e,t,s){oR(n.x,e,tj,t?t.x:void 0,s?s.x:void 0),oR(n.y,e,nj,t?t.y:void 0,s?s.y:void 0)}function lR(n){return n.translate===0&&n.scale===1}function Q$(n){return lR(n.x)&&lR(n.y)}function cR(n,e){return n.min===e.min&&n.max===e.max}function sj(n,e){return cR(n.x,e.x)&&cR(n.y,e.y)}function uR(n,e){return Math.round(n.min)===Math.round(e.min)&&Math.round(n.max)===Math.round(e.max)}function J$(n,e){return uR(n.x,e.x)&&uR(n.y,e.y)}function dR(n){return Do(n.x)/Do(n.y)}function hR(n,e){return n.translate===e.translate&&n.scale===e.scale&&n.originPoint===e.originPoint}class ij{constructor(){this.members=[]}add(e){oE(this.members,e),e.scheduleRender()}remove(e){if(J2(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const t=this.members[this.members.length-1];t&&this.promote(t)}}relegate(e){const t=this.members.findIndex(i=>e===i);if(t===0)return!1;let s;for(let i=t;i>=0;i--){const r=this.members[i];if(r.isPresent!==!1){s=r;break}}return s?(this.promote(s),!0):!1}promote(e,t){const s=this.lead;if(e!==s&&(this.prevLead=s,this.lead=e,e.show(),s)){s.instance&&s.scheduleRender(),e.scheduleRender(),e.resumeFrom=s,t&&(e.resumeFrom.preserveOpacity=!0),s.snapshot&&(e.snapshot=s.snapshot,e.snapshot.latestValues=s.animationValues||s.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:i}=e.options;i===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:t,resumingFrom:s}=e;t.onExitComplete&&t.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function rj(n,e,t){let s="";const i=n.x.translate/e.x,r=n.y.translate/e.y,o=(t==null?void 0:t.z)||0;if((i||r||o)&&(s=`translate3d(${i}px, ${r}px, ${o}px) `),(e.x!==1||e.y!==1)&&(s+=`scale(${1/e.x}, ${1/e.y}) `),t){const{transformPerspective:c,rotate:u,rotateX:d,rotateY:h,skewX:p,skewY:g}=t;c&&(s=`perspective(${c}px) ${s}`),u&&(s+=`rotate(${u}deg) `),d&&(s+=`rotateX(${d}deg) `),h&&(s+=`rotateY(${h}deg) `),p&&(s+=`skewX(${p}deg) `),g&&(s+=`skewY(${g}deg) `)}const a=n.x.scale*e.x,l=n.y.scale*e.y;return(a!==1||l!==1)&&(s+=`scale(${a}, ${l})`),s||"none"}const ju={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0},tg=typeof window<"u"&&window.MotionDebug!==void 0,L3=["","X","Y","Z"],oj={visibility:"hidden"},fR=1e3;let aj=0;function $3(n,e,t,s){const{latestValues:i}=e;i[n]&&(t[n]=i[n],e.setStaticValue(n,0),s&&(s[n]=0))}function eF(n){if(n.hasCheckedOptimisedAppear=!0,n.root===n)return;const{visualElement:e}=n.options;if(!e)return;const t=o$(e);if(window.MotionHasOptimisedAnimation(t,"transform")){const{layout:i,layoutId:r}=n.options;window.MotionCancelOptimisedAnimation(t,"transform",Ms,!(i||r))}const{parent:s}=n;s&&!s.hasCheckedOptimisedAppear&&eF(s)}function tF({attachResizeListener:n,defaultParent:e,measureScroll:t,checkIsScrollRoot:s,resetTransform:i}){return class{constructor(o={},a=e==null?void 0:e()){this.id=aj++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.hasCheckedOptimisedAppear=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.scheduleUpdate=()=>this.update(),this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,tg&&(ju.totalNodes=ju.resolvedTargetDeltas=ju.recalculatedProjection=0),this.nodes.forEach(uj),this.nodes.forEach(mj),this.nodes.forEach(gj),this.nodes.forEach(dj),tg&&window.MotionDebug.record(ju)},this.resolvedRelativeTargetAt=0,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=o,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let l=0;l<this.path.length;l++)this.path[l].shouldResetTransform=!0;this.root===this&&(this.nodes=new qH)}addEventListener(o,a){return this.eventHandlers.has(o)||this.eventHandlers.set(o,new aE),this.eventHandlers.get(o).add(a)}notifyListeners(o,...a){const l=this.eventHandlers.get(o);l&&l.notify(...a)}hasListeners(o){return this.eventHandlers.has(o)}mount(o,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=K$(o),this.instance=o;const{layoutId:l,layout:c,visualElement:u}=this.options;if(u&&!u.current&&u.mount(o),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(c||l)&&(this.isLayoutDirty=!0),n){let d;const h=()=>this.root.updateBlockedByResize=!1;n(o,()=>{this.root.updateBlockedByResize=!0,d&&d(),d=KH(h,250),Iv.hasAnimatedSinceResize&&(Iv.hasAnimatedSinceResize=!1,this.nodes.forEach(mR))})}l&&this.root.registerSharedNode(l,this),this.options.animate!==!1&&u&&(l||c)&&this.addEventListener("didUpdate",({delta:d,hasLayoutChanged:h,hasRelativeTargetChanged:p,layout:g})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const y=this.options.transition||u.getDefaultTransition()||bj,{onLayoutAnimationStart:x,onLayoutAnimationComplete:v}=u.getProps(),b=!this.targetLayout||!J$(this.targetLayout,g)||p,S=!h&&p;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||S||h&&(b||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(d,S);const C={...tE(y,"layout"),onPlay:x,onComplete:v};(u.shouldReduceMotion||this.options.layoutRoot)&&(C.delay=0,C.type=!1),this.startAnimation(C)}else h||mR(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=g})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const o=this.getStack();o&&o.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,Da(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(xj),this.animationId++)}getTransformTemplate(){const{visualElement:o}=this.options;return o&&o.getProps().transformTemplate}willUpdate(o=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(window.MotionCancelOptimisedAnimation&&!this.hasCheckedOptimisedAppear&&eF(this),!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let u=0;u<this.path.length;u++){const d=this.path[u];d.shouldResetTransform=!0,d.updateScroll("snapshot"),d.options.layoutRoot&&d.willUpdate(!1)}const{layoutId:a,layout:l}=this.options;if(a===void 0&&!l)return;const c=this.getTransformTemplate();this.prevTransformTemplateValue=c?c(this.latestValues,""):void 0,this.updateSnapshot(),o&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(pR);return}this.isUpdating||this.nodes.forEach(fj),this.isUpdating=!1,this.nodes.forEach(pj),this.nodes.forEach(lj),this.nodes.forEach(cj),this.clearAllSnapshots();const a=pl.now();or.delta=wl(0,1e3/60,a-or.timestamp),or.timestamp=a,or.isProcessing=!0,T3.update.process(or),T3.preRender.process(or),T3.render.process(or),or.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,H_.read(this.scheduleUpdate))}clearAllSnapshots(){this.nodes.forEach(hj),this.sharedNodes.forEach(vj)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,Ms.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){Ms.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure())}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let l=0;l<this.path.length;l++)this.path[l].updateScroll();const o=this.layout;this.layout=this.measure(!1),this.layoutCorrected=xi(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,o?o.layoutBox:void 0)}updateScroll(o="measure"){let a=!!(this.options.layoutScroll&&this.instance);if(this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===o&&(a=!1),a){const l=s(this.instance);this.scroll={animationId:this.root.animationId,phase:o,isRoot:l,offset:t(this.instance),wasRoot:this.scroll?this.scroll.isRoot:l}}}resetTransform(){if(!i)return;const o=this.isLayoutDirty||this.shouldResetTransform||this.options.alwaysMeasureLayout,a=this.projectionDelta&&!Q$(this.projectionDelta),l=this.getTransformTemplate(),c=l?l(this.latestValues,""):void 0,u=c!==this.prevTransformTemplateValue;o&&(a||Hu(this.latestValues)||u)&&(i(this.instance,c),this.shouldResetTransform=!1,this.scheduleRender())}measure(o=!0){const a=this.measurePageBox();let l=this.removeElementScroll(a);return o&&(l=this.removeTransform(l)),Sj(l),{animationId:this.root.animationId,measuredBox:a,layoutBox:l,latestValues:{},source:this.id}}measurePageBox(){var o;const{visualElement:a}=this.options;if(!a)return xi();const l=a.measureViewportBox();if(!(((o=this.scroll)===null||o===void 0?void 0:o.wasRoot)||this.path.some(Cj))){const{scroll:u}=this.root;u&&(tf(l.x,u.offset.x),tf(l.y,u.offset.y))}return l}removeElementScroll(o){var a;const l=xi();if(Xo(l,o),!((a=this.scroll)===null||a===void 0)&&a.wasRoot)return l;for(let c=0;c<this.path.length;c++){const u=this.path[c],{scroll:d,options:h}=u;u!==this.root&&d&&h.layoutScroll&&(d.wasRoot&&Xo(l,o),tf(l.x,d.offset.x),tf(l.y,d.offset.y))}return l}applyTransform(o,a=!1){const l=xi();Xo(l,o);for(let c=0;c<this.path.length;c++){const u=this.path[c];!a&&u.options.layoutScroll&&u.scroll&&u!==u.root&&nf(l,{x:-u.scroll.offset.x,y:-u.scroll.offset.y}),Hu(u.latestValues)&&nf(l,u.latestValues)}return Hu(this.latestValues)&&nf(l,this.latestValues),l}removeTransform(o){const a=xi();Xo(a,o);for(let l=0;l<this.path.length;l++){const c=this.path[l];if(!c.instance||!Hu(c.latestValues))continue;SC(c.latestValues)&&c.updateSnapshot();const u=xi(),d=c.measurePageBox();Xo(u,d),aR(a,c.latestValues,c.snapshot?c.snapshot.layoutBox:void 0,u)}return Hu(this.latestValues)&&aR(a,this.latestValues),a}setTargetDelta(o){this.targetDelta=o,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(o){this.options={...this.options,...o,crossfade:o.crossfade!==void 0?o.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==or.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(o=!1){var a;const l=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=l.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=l.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=l.isSharedProjectionDirty);const c=!!this.resumingFrom||this!==l;if(!(o||c&&this.isSharedProjectionDirty||this.isProjectionDirty||!((a=this.parent)===null||a===void 0)&&a.isProjectionDirty||this.attemptToResolveRelativeTarget||this.root.updateBlockedByResize))return;const{layout:d,layoutId:h}=this.options;if(!(!this.layout||!(d||h))){if(this.resolvedRelativeTargetAt=or.timestamp,!this.targetDelta&&!this.relativeTarget){const p=this.getClosestProjectingParent();p&&p.layout&&this.animationProgress!==1?(this.relativeParent=p,this.forceRelativeParentToResolveTarget(),this.relativeTarget=xi(),this.relativeTargetOrigin=xi(),mg(this.relativeTargetOrigin,this.layout.layoutBox,p.layout.layoutBox),Xo(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)){if(this.target||(this.target=xi(),this.targetWithTransforms=xi()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),kH(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Xo(this.target,this.layout.layoutBox),G$(this.target,this.targetDelta)):Xo(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const p=this.getClosestProjectingParent();p&&!!p.resumingFrom==!!this.resumingFrom&&!p.options.layoutScroll&&p.target&&this.animationProgress!==1?(this.relativeParent=p,this.forceRelativeParentToResolveTarget(),this.relativeTarget=xi(),this.relativeTargetOrigin=xi(),mg(this.relativeTargetOrigin,this.target,p.target),Xo(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}tg&&ju.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(!(!this.parent||SC(this.parent.latestValues)||W$(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var o;const a=this.getLead(),l=!!this.resumingFrom||this!==a;let c=!0;if((this.isProjectionDirty||!((o=this.parent)===null||o===void 0)&&o.isProjectionDirty)&&(c=!1),l&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(c=!1),this.resolvedRelativeTargetAt===or.timestamp&&(c=!1),c)return;const{layout:u,layoutId:d}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(u||d))return;Xo(this.layoutCorrected,this.layout.layoutBox);const h=this.treeScale.x,p=this.treeScale.y;FH(this.layoutCorrected,this.treeScale,this.path,l),a.layout&&!a.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(a.target=a.layout.layoutBox,a.targetWithTransforms=xi());const{target:g}=a;if(!g){this.prevProjectionDelta&&(this.createProjectionDeltas(),this.scheduleRender());return}!this.projectionDelta||!this.prevProjectionDelta?this.createProjectionDeltas():(iR(this.prevProjectionDelta.x,this.projectionDelta.x),iR(this.prevProjectionDelta.y,this.projectionDelta.y)),pg(this.projectionDelta,this.layoutCorrected,g,this.latestValues),(this.treeScale.x!==h||this.treeScale.y!==p||!hR(this.projectionDelta.x,this.prevProjectionDelta.x)||!hR(this.projectionDelta.y,this.prevProjectionDelta.y))&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",g)),tg&&ju.recalculatedProjection++}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(o=!0){var a;if((a=this.options.visualElement)===null||a===void 0||a.scheduleRender(),o){const l=this.getStack();l&&l.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}createProjectionDeltas(){this.prevProjectionDelta=ef(),this.projectionDelta=ef(),this.projectionDeltaWithTransform=ef()}setAnimationOrigin(o,a=!1){const l=this.snapshot,c=l?l.latestValues:{},u={...this.latestValues},d=ef();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const h=xi(),p=l?l.source:void 0,g=this.layout?this.layout.source:void 0,y=p!==g,x=this.getStack(),v=!x||x.members.length<=1,b=!!(y&&!v&&this.options.crossfade===!0&&!this.path.some(wj));this.animationProgress=0;let S;this.mixTargetDelta=C=>{const E=C/1e3;gR(d.x,o.x,E),gR(d.y,o.y,E),this.setTargetDelta(d),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(mg(h,this.layout.layoutBox,this.relativeParent.layout.layoutBox),yj(this.relativeTarget,this.relativeTargetOrigin,h,E),S&&sj(this.relativeTarget,S)&&(this.isProjectionDirty=!1),S||(S=xi()),Xo(S,this.relativeTarget)),y&&(this.animationValues=u,ZH(u,c,this.latestValues,E,b,v)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=E},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(o){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(Da(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=Ms.update(()=>{Iv.hasAnimatedSinceResize=!0,this.currentAnimation=q$(0,fR,{...o,onUpdate:a=>{this.mixTargetDelta(a),o.onUpdate&&o.onUpdate(a)},onComplete:()=>{o.onComplete&&o.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const o=this.getStack();o&&o.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(fR),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const o=this.getLead();let{targetWithTransforms:a,target:l,layout:c,latestValues:u}=o;if(!(!a||!l||!c)){if(this!==o&&this.layout&&c&&nF(this.options.animationType,this.layout.layoutBox,c.layoutBox)){l=this.target||xi();const d=Do(this.layout.layoutBox.x);l.x.min=o.target.x.min,l.x.max=l.x.min+d;const h=Do(this.layout.layoutBox.y);l.y.min=o.target.y.min,l.y.max=l.y.min+h}Xo(a,l),nf(a,u),pg(this.projectionDeltaWithTransform,this.layoutCorrected,a,u)}}registerSharedNode(o,a){this.sharedNodes.has(o)||this.sharedNodes.set(o,new ij),this.sharedNodes.get(o).add(a);const c=a.options.initialPromotionConfig;a.promote({transition:c?c.transition:void 0,preserveFollowOpacity:c&&c.shouldPreserveFollowOpacity?c.shouldPreserveFollowOpacity(a):void 0})}isLead(){const o=this.getStack();return o?o.lead===this:!0}getLead(){var o;const{layoutId:a}=this.options;return a?((o=this.getStack())===null||o===void 0?void 0:o.lead)||this:this}getPrevLead(){var o;const{layoutId:a}=this.options;return a?(o=this.getStack())===null||o===void 0?void 0:o.prevLead:void 0}getStack(){const{layoutId:o}=this.options;if(o)return this.root.sharedNodes.get(o)}promote({needsReset:o,transition:a,preserveFollowOpacity:l}={}){const c=this.getStack();c&&c.promote(this,l),o&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const o=this.getStack();return o?o.relegate(this):!1}resetSkewAndRotation(){const{visualElement:o}=this.options;if(!o)return;let a=!1;const{latestValues:l}=o;if((l.z||l.rotate||l.rotateX||l.rotateY||l.rotateZ||l.skewX||l.skewY)&&(a=!0),!a)return;const c={};l.z&&$3("z",o,c,this.animationValues);for(let u=0;u<L3.length;u++)$3(`rotate${L3[u]}`,o,c,this.animationValues),$3(`skew${L3[u]}`,o,c,this.animationValues);o.render();for(const u in c)o.setStaticValue(u,c[u]),this.animationValues&&(this.animationValues[u]=c[u]);o.scheduleRender()}getProjectionStyles(o){var a,l;if(!this.instance||this.isSVG)return;if(!this.isVisible)return oj;const c={visibility:""},u=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,c.opacity="",c.pointerEvents=Ev(o==null?void 0:o.pointerEvents)||"",c.transform=u?u(this.latestValues,""):"none",c;const d=this.getLead();if(!this.projectionDelta||!this.layout||!d.target){const y={};return this.options.layoutId&&(y.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,y.pointerEvents=Ev(o==null?void 0:o.pointerEvents)||""),this.hasProjected&&!Hu(this.latestValues)&&(y.transform=u?u({},""):"none",this.hasProjected=!1),y}const h=d.animationValues||d.latestValues;this.applyTransformsToTarget(),c.transform=rj(this.projectionDeltaWithTransform,this.treeScale,h),u&&(c.transform=u(h,c.transform));const{x:p,y:g}=this.projectionDelta;c.transformOrigin=`${p.origin*100}% ${g.origin*100}% 0`,d.animationValues?c.opacity=d===this?(l=(a=h.opacity)!==null&&a!==void 0?a:this.latestValues.opacity)!==null&&l!==void 0?l:1:this.preserveOpacity?this.latestValues.opacity:h.opacityExit:c.opacity=d===this?h.opacity!==void 0?h.opacity:"":h.opacityExit!==void 0?h.opacityExit:0;for(const y in Kv){if(h[y]===void 0)continue;const{correct:x,applyTo:v}=Kv[y],b=c.transform==="none"?h[y]:x(h[y],d);if(v){const S=v.length;for(let C=0;C<S;C++)c[v[C]]=b}else c[y]=b}return this.options.layoutId&&(c.pointerEvents=d===this?Ev(o==null?void 0:o.pointerEvents)||"":"none"),c}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(o=>{var a;return(a=o.currentAnimation)===null||a===void 0?void 0:a.stop()}),this.root.nodes.forEach(pR),this.root.sharedNodes.clear()}}}function lj(n){n.updateLayout()}function cj(n){var e;const t=((e=n.resumeFrom)===null||e===void 0?void 0:e.snapshot)||n.snapshot;if(n.isLead()&&n.layout&&t&&n.hasListeners("didUpdate")){const{layoutBox:s,measuredBox:i}=n.layout,{animationType:r}=n.options,o=t.source!==n.layout.source;r==="size"?Zo(d=>{const h=o?t.measuredBox[d]:t.layoutBox[d],p=Do(h);h.min=s[d].min,h.max=h.min+p}):nF(r,t.layoutBox,s)&&Zo(d=>{const h=o?t.measuredBox[d]:t.layoutBox[d],p=Do(s[d]);h.max=h.min+p,n.relativeTarget&&!n.currentAnimation&&(n.isProjectionDirty=!0,n.relativeTarget[d].max=n.relativeTarget[d].min+p)});const a=ef();pg(a,s,t.layoutBox);const l=ef();o?pg(l,n.applyTransform(i,!0),t.measuredBox):pg(l,s,t.layoutBox);const c=!Q$(a);let u=!1;if(!n.resumeFrom){const d=n.getClosestProjectingParent();if(d&&!d.resumeFrom){const{snapshot:h,layout:p}=d;if(h&&p){const g=xi();mg(g,t.layoutBox,h.layoutBox);const y=xi();mg(y,s,p.layoutBox),J$(g,y)||(u=!0),d.options.layoutRoot&&(n.relativeTarget=y,n.relativeTargetOrigin=g,n.relativeParent=d)}}}n.notifyListeners("didUpdate",{layout:s,snapshot:t,delta:l,layoutDelta:a,hasLayoutChanged:c,hasRelativeTargetChanged:u})}else if(n.isLead()){const{onExitComplete:s}=n.options;s&&s()}n.options.transition=void 0}function uj(n){tg&&ju.totalNodes++,n.parent&&(n.isProjecting()||(n.isProjectionDirty=n.parent.isProjectionDirty),n.isSharedProjectionDirty||(n.isSharedProjectionDirty=!!(n.isProjectionDirty||n.parent.isProjectionDirty||n.parent.isSharedProjectionDirty)),n.isTransformDirty||(n.isTransformDirty=n.parent.isTransformDirty))}function dj(n){n.isProjectionDirty=n.isSharedProjectionDirty=n.isTransformDirty=!1}function hj(n){n.clearSnapshot()}function pR(n){n.clearMeasurements()}function fj(n){n.isLayoutDirty=!1}function pj(n){const{visualElement:e}=n.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),n.resetTransform()}function mR(n){n.finishAnimation(),n.targetDelta=n.relativeTarget=n.target=void 0,n.isProjectionDirty=!0}function mj(n){n.resolveTargetDelta()}function gj(n){n.calcProjection()}function xj(n){n.resetSkewAndRotation()}function vj(n){n.removeLeadSnapshot()}function gR(n,e,t){n.translate=ai(e.translate,0,t),n.scale=ai(e.scale,1,t),n.origin=e.origin,n.originPoint=e.originPoint}function xR(n,e,t,s){n.min=ai(e.min,t.min,s),n.max=ai(e.max,t.max,s)}function yj(n,e,t,s){xR(n.x,e.x,t.x,s),xR(n.y,e.y,t.y,s)}function wj(n){return n.animationValues&&n.animationValues.opacityExit!==void 0}const bj={duration:.45,ease:[.4,0,.1,1]},vR=n=>typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().includes(n),yR=vR("applewebkit/")&&!vR("chrome/")?Math.round:qr;function wR(n){n.min=yR(n.min),n.max=yR(n.max)}function Sj(n){wR(n.x),wR(n.y)}function nF(n,e,t){return n==="position"||n==="preserve-aspect"&&!IH(dR(e),dR(t),.2)}function Cj(n){var e;return n!==n.root&&((e=n.scroll)===null||e===void 0?void 0:e.wasRoot)}const _j=tF({attachResizeListener:(n,e)=>kg(n,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),F3={current:void 0},sF=tF({measureScroll:n=>({x:n.scrollLeft,y:n.scrollTop}),defaultParent:()=>{if(!F3.current){const n=new _j({});n.mount(window),n.setOptions({layoutScroll:!0}),F3.current=n}return F3.current},resetTransform:(n,e)=>{n.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:n=>window.getComputedStyle(n).position==="fixed"}),Ej={pan:{Feature:WH},drag:{Feature:VH,ProjectionNode:sF,MeasureLayout:X$}};function bR(n,e,t){const{props:s}=n;n.animationState&&s.whileHover&&n.animationState.setActive("whileHover",t==="Start");const i="onHover"+t,r=s[i];r&&Ms.postRender(()=>r(e,t0(e)))}class Tj extends hu{mount(){const{current:e}=this.node;e&&(this.unmount=MW(e,t=>(bR(this.node,t,"Start"),s=>bR(this.node,s,"End"))))}unmount(){}}class Ij extends hu{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=e0(kg(this.node.current,"focus",()=>this.onFocus()),kg(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function SR(n,e,t){const{props:s}=n;n.animationState&&s.whileTap&&n.animationState.setActive("whileTap",t==="Start");const i="onTap"+(t==="End"?"":t),r=s[i];r&&Ms.postRender(()=>r(e,t0(e)))}class kj extends hu{mount(){const{current:e}=this.node;e&&(this.unmount=LW(e,t=>(SR(this.node,t,"Start"),(s,{success:i})=>SR(this.node,s,i?"End":"Cancel")),{useGlobalTarget:this.node.props.globalTapTarget}))}unmount(){}}const _C=new WeakMap,O3=new WeakMap,Aj=n=>{const e=_C.get(n.target);e&&e(n)},Rj=n=>{n.forEach(Aj)};function Mj({root:n,...e}){const t=n||document;O3.has(t)||O3.set(t,{});const s=O3.get(t),i=JSON.stringify(e);return s[i]||(s[i]=new IntersectionObserver(Rj,{root:n,...e})),s[i]}function Nj(n,e,t){const s=Mj(e);return _C.set(n,t),s.observe(n),()=>{_C.delete(n),s.unobserve(n)}}const Pj={some:0,all:1};class Dj extends hu{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:t,margin:s,amount:i="some",once:r}=e,o={root:t?t.current:void 0,rootMargin:s,threshold:typeof i=="number"?i:Pj[i]},a=l=>{const{isIntersecting:c}=l;if(this.isInView===c||(this.isInView=c,r&&!c&&this.hasEnteredView))return;c&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",c);const{onViewportEnter:u,onViewportLeave:d}=this.node.getProps(),h=c?u:d;h&&h(l)};return Nj(this.node.current,o,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:t}=this.node;["amount","margin","root"].some(Lj(e,t))&&this.startObserver()}unmount(){}}function Lj({viewport:n={}},{viewport:e={}}={}){return t=>n[t]!==e[t]}const $j={inView:{Feature:Dj},tap:{Feature:kj},focus:{Feature:Ij},hover:{Feature:Tj}},Fj={layout:{ProjectionNode:sF,MeasureLayout:X$}},EC={current:null},iF={current:!1};function Oj(){if(iF.current=!0,!!B_)if(window.matchMedia){const n=window.matchMedia("(prefers-reduced-motion)"),e=()=>EC.current=n.matches;n.addListener(e),e()}else EC.current=!1}const zj=[...I$,Rr,ru],Bj=n=>zj.find(T$(n)),gf=new WeakMap;function Uj(n,e,t){for(const s in e){const i=e[s],r=t[s];if(cr(i))n.addValue(s,i);else if(cr(r))n.addValue(s,cl(i,{owner:n}));else if(r!==i)if(n.hasValue(s)){const o=n.getValue(s);o.liveStyle===!0?o.jump(i):o.hasAnimated||o.set(i)}else{const o=n.getStaticValue(s);n.addValue(s,cl(o!==void 0?o:i,{owner:n}))}}for(const s in t)e[s]===void 0&&n.removeValue(s);return e}const CR=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"];class rF{scrapeMotionValuesFromProps(e,t,s){return{}}constructor({parent:e,props:t,presenceContext:s,reducedMotionConfig:i,blockInitialAnimation:r,visualState:o},a={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.KeyframeResolver=pE,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.renderScheduledAt=0,this.scheduleRender=()=>{const p=pl.now();this.renderScheduledAt<p&&(this.renderScheduledAt=p,Ms.render(this.render,!1,!0))};const{latestValues:l,renderState:c,onUpdate:u}=o;this.onUpdate=u,this.latestValues=l,this.baseTarget={...l},this.initialValues=t.initial?{...l}:{},this.renderState=c,this.parent=e,this.props=t,this.presenceContext=s,this.depth=e?e.depth+1:0,this.reducedMotionConfig=i,this.options=a,this.blockInitialAnimation=!!r,this.isControllingVariants=Y2(t),this.isVariantNode=LL(t),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:d,...h}=this.scrapeMotionValuesFromProps(t,{},this);for(const p in h){const g=h[p];l[p]!==void 0&&cr(g)&&g.set(l[p],!1)}}mount(e){this.current=e,gf.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((t,s)=>this.bindToMotionValue(s,t)),iF.current||Oj(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:EC.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){gf.delete(this.current),this.projection&&this.projection.unmount(),Da(this.notifyUpdate),Da(this.render),this.valueSubscriptions.forEach(e=>e()),this.valueSubscriptions.clear(),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features){const t=this.features[e];t&&(t.unmount(),t.isMounted=!1)}this.current=null}bindToMotionValue(e,t){this.valueSubscriptions.has(e)&&this.valueSubscriptions.get(e)();const s=Ld.has(e),i=t.on("change",a=>{this.latestValues[e]=a,this.props.onUpdate&&Ms.preRender(this.notifyUpdate),s&&this.projection&&(this.projection.isTransformDirty=!0)}),r=t.on("renderRequest",this.scheduleRender);let o;window.MotionCheckAppearSync&&(o=window.MotionCheckAppearSync(this,e,t)),this.valueSubscriptions.set(e,()=>{i(),r(),o&&o(),t.owner&&t.stop()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}updateFeatures(){let e="animation";for(e in pf){const t=pf[e];if(!t)continue;const{isEnabled:s,Feature:i}=t;if(!this.features[e]&&i&&s(this.props)&&(this.features[e]=new i(this)),this.features[e]){const r=this.features[e];r.isMounted?r.update():(r.mount(),r.isMounted=!0)}}}triggerBuild(){this.build(this.renderState,this.latestValues,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):xi()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,t){this.latestValues[e]=t}update(e,t){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=t;for(let s=0;s<CR.length;s++){const i=CR[s];this.propEventSubscriptions[i]&&(this.propEventSubscriptions[i](),delete this.propEventSubscriptions[i]);const r="on"+i,o=e[r];o&&(this.propEventSubscriptions[i]=this.on(i,o))}this.prevMotionValues=Uj(this,this.scrapeMotionValuesFromProps(e,this.prevProps,this),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue(),this.onUpdate&&this.onUpdate(this)}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}addVariantChild(e){const t=this.getClosestVariantNode();if(t)return t.variantChildren&&t.variantChildren.add(e),()=>t.variantChildren.delete(e)}addValue(e,t){const s=this.values.get(e);t!==s&&(s&&this.removeValue(e),this.bindToMotionValue(e,t),this.values.set(e,t),this.latestValues[e]=t.get())}removeValue(e){this.values.delete(e);const t=this.valueSubscriptions.get(e);t&&(t(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,t){if(this.props.values&&this.props.values[e])return this.props.values[e];let s=this.values.get(e);return s===void 0&&t!==void 0&&(s=cl(t===null?void 0:t,{owner:this}),this.addValue(e,s)),s}readValue(e,t){var s;let i=this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:(s=this.getBaseTargetFromProps(this.props,e))!==null&&s!==void 0?s:this.readValueFromInstance(this.current,e,this.options);return i!=null&&(typeof i=="string"&&(_$(i)||m$(i))?i=parseFloat(i):!Bj(i)&&ru.test(t)&&(i=b$(e,t)),this.setBaseTarget(e,cr(i)?i.get():i)),cr(i)?i.get():i}setBaseTarget(e,t){this.baseTarget[e]=t}getBaseTarget(e){var t;const{initial:s}=this.props;let i;if(typeof s=="string"||typeof s=="object"){const o=X_(this.props,s,(t=this.presenceContext)===null||t===void 0?void 0:t.custom);o&&(i=o[e])}if(s&&i!==void 0)return i;const r=this.getBaseTargetFromProps(this.props,e);return r!==void 0&&!cr(r)?r:this.initialValues[e]!==void 0&&i===void 0?void 0:this.baseTarget[e]}on(e,t){return this.events[e]||(this.events[e]=new aE),this.events[e].add(t)}notify(e,...t){this.events[e]&&this.events[e].notify(...t)}}class oF extends rF{constructor(){super(...arguments),this.KeyframeResolver=k$}sortInstanceNodePosition(e,t){return e.compareDocumentPosition(t)&2?1:-1}getBaseTargetFromProps(e,t){return e.style?e.style[t]:void 0}removeValueFromRenderState(e,{vars:t,style:s}){delete t[e],delete s[e]}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;cr(e)&&(this.childSubscription=e.on("change",t=>{this.current&&(this.current.textContent=`${t}`)}))}}function Vj(n){return window.getComputedStyle(n)}class aF extends oF{constructor(){super(...arguments),this.type="html",this.renderInstance=GL}readValueFromInstance(e,t){if(Ld.has(t)){const s=fE(t);return s&&s.default||0}else{const s=Vj(e),i=(UL(t)?s.getPropertyValue(t):s[t])||0;return typeof i=="string"?i.trim():i}}measureInstanceViewportBox(e,{transformPagePoint:t}){return H$(e,t)}build(e,t,s){Y_(e,t,s.transformTemplate)}scrapeMotionValuesFromProps(e,t,s){return eE(e,t,s)}}class lF extends oF{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1,this.measureInstanceViewportBox=xi}getBaseTargetFromProps(e,t){return e[t]}readValueFromInstance(e,t){if(Ld.has(t)){const s=fE(t);return s&&s.default||0}return t=HL.has(t)?t:G_(t),e.getAttribute(t)}scrapeMotionValuesFromProps(e,t,s){return qL(e,t,s)}build(e,t,s){Z_(e,t,this.isSVGTag,s.transformTemplate)}renderInstance(e,t,s,i){jL(e,t,s,i)}mount(e){this.isSVGTag=J_(e.tagName),super.mount(e)}}const Wj=(n,e)=>j_(n)?new lF(e):new aF(e,{allowProjection:n!==le.Fragment}),Gj=TW({...vH,...$j,...Ej,...Fj},Wj),wn=U9(Gj);function cF(n,e){let t;const s=()=>{const{currentTime:i}=e,o=(i===null?0:i.value)/100;t!==o&&n(o),t=o};return Ms.update(s,!0),()=>Da(s)}const kv=new WeakMap;let Wc;function Hj(n,e){if(e){const{inlineSize:t,blockSize:s}=e[0];return{width:t,height:s}}else return n instanceof SVGElement&&"getBBox"in n?n.getBBox():{width:n.offsetWidth,height:n.offsetHeight}}function jj({target:n,contentRect:e,borderBoxSize:t}){var s;(s=kv.get(n))===null||s===void 0||s.forEach(i=>{i({target:n,contentSize:e,get size(){return Hj(n,t)}})})}function Xj(n){n.forEach(jj)}function qj(){typeof ResizeObserver>"u"||(Wc=new ResizeObserver(Xj))}function Kj(n,e){Wc||qj();const t=iE(n);return t.forEach(s=>{let i=kv.get(s);i||(i=new Set,kv.set(s,i)),i.add(e),Wc==null||Wc.observe(s)}),()=>{t.forEach(s=>{const i=kv.get(s);i==null||i.delete(e),i!=null&&i.size||Wc==null||Wc.unobserve(s)})}}const Av=new Set;let gg;function Yj(){gg=()=>{const n={width:window.innerWidth,height:window.innerHeight},e={target:window,size:n,contentSize:n};Av.forEach(t=>t(e))},window.addEventListener("resize",gg)}function Zj(n){return Av.add(n),gg||Yj(),()=>{Av.delete(n),!Av.size&&gg&&(gg=void 0)}}function Qj(n,e){return typeof n=="function"?Zj(n):Kj(n,e)}const Jj=50,_R=()=>({current:0,offset:[],progress:0,scrollLength:0,targetOffset:0,targetLength:0,containerLength:0,velocity:0}),eX=()=>({time:0,x:_R(),y:_R()}),tX={x:{length:"Width",position:"Left"},y:{length:"Height",position:"Top"}};function ER(n,e,t,s){const i=t[e],{length:r,position:o}=tX[e],a=i.current,l=t.time;i.current=n[`scroll${o}`],i.scrollLength=n[`scroll${r}`]-n[`client${r}`],i.offset.length=0,i.offset[0]=0,i.offset[1]=i.scrollLength,i.progress=iu(0,i.scrollLength,i.current);const c=s-l;i.velocity=c>Jj?0:lE(i.current-a,c)}function nX(n,e,t){ER(n,"x",e,t),ER(n,"y",e,t),e.time=t}function sX(n,e){const t={x:0,y:0};let s=n;for(;s&&s!==e;)if(s instanceof HTMLElement)t.x+=s.offsetLeft,t.y+=s.offsetTop,s=s.offsetParent;else if(s.tagName==="svg"){const i=s.getBoundingClientRect();s=s.parentElement;const r=s.getBoundingClientRect();t.x+=i.left-r.left,t.y+=i.top-r.top}else if(s instanceof SVGGraphicsElement){const{x:i,y:r}=s.getBBox();t.x+=i,t.y+=r;let o=null,a=s.parentNode;for(;!o;)a.tagName==="svg"&&(o=a),a=s.parentNode;s=o}else break;return t}const TC={start:0,center:.5,end:1};function TR(n,e,t=0){let s=0;if(n in TC&&(n=TC[n]),typeof n=="string"){const i=parseFloat(n);n.endsWith("px")?s=i:n.endsWith("%")?n=i/100:n.endsWith("vw")?s=i/100*document.documentElement.clientWidth:n.endsWith("vh")?s=i/100*document.documentElement.clientHeight:n=i}return typeof n=="number"&&(s=e*n),t+s}const iX=[0,0];function rX(n,e,t,s){let i=Array.isArray(n)?n:iX,r=0,o=0;return typeof n=="number"?i=[n,n]:typeof n=="string"&&(n=n.trim(),n.includes(" ")?i=n.split(" "):i=[n,TC[n]?n:"0"]),r=TR(i[0],t,s),o=TR(i[1],e),r-o}const oX={All:[[0,0],[1,1]]},aX={x:0,y:0};function lX(n){return"getBBox"in n&&n.tagName!=="svg"?n.getBBox():{width:n.clientWidth,height:n.clientHeight}}function cX(n,e,t){const{offset:s=oX.All}=t,{target:i=n,axis:r="y"}=t,o=r==="y"?"height":"width",a=i!==n?sX(i,n):aX,l=i===n?{width:n.scrollWidth,height:n.scrollHeight}:lX(i),c={width:n.clientWidth,height:n.clientHeight};e[r].offset.length=0;let u=!e[r].interpolate;const d=s.length;for(let h=0;h<d;h++){const p=rX(s[h],c[o],l[o],a[r]);!u&&p!==e[r].interpolatorOffsets[h]&&(u=!0),e[r].offset[h]=p}u&&(e[r].interpolate=xE(e[r].offset,vE(s),{clamp:!1}),e[r].interpolatorOffsets=[...e[r].offset]),e[r].progress=wl(0,1,e[r].interpolate(e[r].current))}function uX(n,e=n,t){if(t.x.targetOffset=0,t.y.targetOffset=0,e!==n){let s=e;for(;s&&s!==n;)t.x.targetOffset+=s.offsetLeft,t.y.targetOffset+=s.offsetTop,s=s.offsetParent}t.x.targetLength=e===n?e.scrollWidth:e.clientWidth,t.y.targetLength=e===n?e.scrollHeight:e.clientHeight,t.x.containerLength=n.clientWidth,t.y.containerLength=n.clientHeight}function dX(n,e,t,s={}){return{measure:()=>uX(n,s.target,t),update:i=>{nX(n,t,i),(s.offset||s.target)&&cX(n,t,s)},notify:()=>e(t)}}const Dm=new WeakMap,IR=new WeakMap,z3=new WeakMap,kR=n=>n===document.documentElement?window:n;function SE(n,{container:e=document.documentElement,...t}={}){let s=z3.get(e);s||(s=new Set,z3.set(e,s));const i=eX(),r=dX(e,n,i,t);if(s.add(r),!Dm.has(e)){const a=()=>{for(const h of s)h.measure()},l=()=>{for(const h of s)h.update(or.timestamp)},c=()=>{for(const h of s)h.notify()},u=()=>{Ms.read(a,!1,!0),Ms.read(l,!1,!0),Ms.update(c,!1,!0)};Dm.set(e,u);const d=kR(e);window.addEventListener("resize",u,{passive:!0}),e!==document.documentElement&&IR.set(e,Qj(e,u)),d.addEventListener("scroll",u,{passive:!0})}const o=Dm.get(e);return Ms.read(o,!1,!0),()=>{var a;Da(o);const l=z3.get(e);if(!l||(l.delete(r),l.size))return;const c=Dm.get(e);Dm.delete(e),c&&(kR(e).removeEventListener("scroll",c),(a=IR.get(e))===null||a===void 0||a(),window.removeEventListener("resize",c))}}function hX({source:n,container:e,axis:t="y"}){n&&(e=n);const s={value:0},i=SE(r=>{s.value=r[t].progress*100},{container:e,axis:t});return{currentTime:s,cancel:i}}const B3=new Map;function uF({source:n,container:e=document.documentElement,axis:t="y"}={}){n&&(e=n),B3.has(e)||B3.set(e,{});const s=B3.get(e);return s[t]||(s[t]=ZL()?new ScrollTimeline({source:e,axis:t}):hX({source:e,axis:t})),s[t]}function fX(n){return n.length===2}function dF(n){return n&&(n.target||n.offset)}function pX(n,e){return fX(n)||dF(e)?SE(t=>{n(t[e.axis].progress,t)},e):cF(n,uF(e))}function mX(n,e){if(n.flatten(),dF(e))return n.pause(),SE(t=>{n.time=n.duration*t[e.axis].progress},e);{const t=uF(e);return n.attachTimeline?n.attachTimeline(t,s=>(s.pause(),cF(i=>{s.time=s.duration*i},t))):qr}}function gX(n,{axis:e="y",...t}={}){const s={axis:e,...t};return typeof n=="function"?pX(n,s):mX(n,s)}function AR(n,e){P9(!!(!e||e.current))}const xX=()=>({scrollX:cl(0),scrollY:cl(0),scrollXProgress:cl(0),scrollYProgress:cl(0)});function hF({container:n,target:e,layoutEffect:t=!0,...s}={}){const i=Bf(xX);return(t?X2:le.useEffect)(()=>(AR("target",e),AR("container",n),gX((o,{x:a,y:l})=>{i.scrollX.set(a.current),i.scrollXProgress.set(a.progress),i.scrollY.set(l.current),i.scrollYProgress.set(l.progress)},{...s,container:(n==null?void 0:n.current)||void 0,target:(e==null?void 0:e.current)||void 0})),[n,e,JSON.stringify(s.offset)]),i}function vX(n){const e=Bf(()=>cl(n)),{isStatic:t}=le.useContext(j2);if(t){const[,s]=le.useState(n);le.useEffect(()=>e.on("change",s),[])}return e}function fF(n,e){const t=vX(e()),s=()=>t.set(e());return s(),X2(()=>{const i=()=>Ms.preRender(s,!1,!0),r=n.map(o=>o.on("change",i));return()=>{r.forEach(o=>o()),Da(s)}}),t}const yX=n=>n&&typeof n=="object"&&n.mix,wX=n=>yX(n)?n.mix:void 0;function bX(...n){const e=!Array.isArray(n[0]),t=e?0:-1,s=n[0+t],i=n[1+t],r=n[2+t],o=n[3+t],a=xE(i,r,{mixer:wX(r[0]),...o});return e?a(s):a}function SX(n){dg.current=[],n();const e=fF(dg.current,n);return dg.current=void 0,e}function pF(n,e,t,s){if(typeof n=="function")return SX(n);const i=typeof e=="function"?e:bX(e,t,s);return Array.isArray(n)?RR(n,i):RR([n],([r])=>i(r))}function RR(n,e){const t=Bf(()=>[]);return fF(n,()=>{t.length=0;const s=n.length;for(let i=0;i<s;i++)t[i]=n[i].get();return e(t)})}const CX=(n,e,t)=>{const s=e-n;return((t-n)%s+s)%s+n};function mF(n,e){return D$(n)?n[CX(0,n.length,e)]:n}function CE(n){return typeof n=="object"&&!Array.isArray(n)}function gF(n,e,t,s){return typeof n=="string"&&CE(e)?iE(n,t,s):n instanceof NodeList?Array.from(n):Array.isArray(n)?n:[n]}function _X(n,e,t){return n*(e+1)}function MR(n,e,t,s){var i;return typeof e=="number"?e:e.startsWith("-")||e.startsWith("+")?Math.max(0,n+parseFloat(e)):e==="<"?t:(i=s.get(e))!==null&&i!==void 0?i:n}function EX(n,e,t){for(let s=0;s<n.length;s++){const i=n[s];i.at>e&&i.at<t&&(J2(n,i),s--)}}function TX(n,e,t,s,i,r){EX(n,i,r);for(let o=0;o<e.length;o++)n.push({value:e[o],at:ai(i,r,s[o]),easing:mF(t,o)})}function IX(n,e){for(let t=0;t<n.length;t++)n[t]=n[t]/(e+1)}function kX(n,e){return n.at===e.at?n.value===null?1:e.value===null?-1:0:n.at-e.at}const AX="easeInOut";function RX(n,{defaultTransition:e={},...t}={},s,i){const r=e.duration||.3,o=new Map,a=new Map,l={},c=new Map;let u=0,d=0,h=0;for(let p=0;p<n.length;p++){const g=n[p];if(typeof g=="string"){c.set(g,d);continue}else if(!Array.isArray(g)){c.set(g.name,MR(d,g.at,u,c));continue}let[y,x,v={}]=g;v.at!==void 0&&(d=MR(d,v.at,u,c));let b=0;const S=(C,E,k,R=0,L=0)=>{const I=MX(C),{delay:T=0,times:M=vE(I),type:j="keyframes",repeat:W,repeatType:z,repeatDelay:X=0,...B}=E;let{ease:J=e.ease||"easeOut",duration:K}=E;const ee=typeof T=="function"?T(R,L):T,ne=I.length,V=Q2(j)?j:i==null?void 0:i[j];if(ne<=2&&V){let be=100;if(ne===2&&DX(I)){const Fe=I[1]-I[0];be=Math.abs(Fe)}const Ie={...B};K!==void 0&&(Ie.duration=dl(K));const Xe=kW(Ie,be,V);J=Xe.ease,K=Xe.duration}K??(K=r);const Z=d+ee;M.length===1&&M[0]===0&&(M[1]=1);const he=M.length-I.length;if(he>0&&L$(M,he),I.length===1&&I.unshift(null),W){K=_X(K,W);const be=[...I],Ie=[...M];J=Array.isArray(J)?[...J]:[J];const Xe=[...J];for(let Fe=0;Fe<W;Fe++){I.push(...be);for(let Pe=0;Pe<be.length;Pe++)M.push(Ie[Pe]+(Fe+1)),J.push(Pe===0?"linear":mF(Xe,Pe-1))}IX(M,W)}const ve=Z+K;TX(k,I,J,M,Z,ve),b=Math.max(ee+K,b),h=Math.max(ve,h)};if(cr(y)){const C=NR(y,a);S(x,v,PR("default",C))}else{const C=gF(y,x,s,l),E=C.length;for(let k=0;k<E;k++){x=x,v=v;const R=C[k],L=NR(R,a);for(const I in x)S(x[I],NX(v,I),PR(I,L),k,E)}}u=d,d+=b}return a.forEach((p,g)=>{for(const y in p){const x=p[y];x.sort(kX);const v=[],b=[],S=[];for(let E=0;E<x.length;E++){const{at:k,value:R,easing:L}=x[E];v.push(R),b.push(iu(0,h,k)),S.push(L||"easeOut")}b[0]!==0&&(b.unshift(0),v.unshift(v[0]),S.unshift(AX)),b[b.length-1]!==1&&(b.push(1),v.push(null)),o.has(g)||o.set(g,{keyframes:{},transition:{}});const C=o.get(g);C.keyframes[y]=v,C.transition[y]={...e,duration:h,ease:S,times:b,...t}}}),o}function NR(n,e){return!e.has(n)&&e.set(n,{}),e.get(n)}function PR(n,e){return e[n]||(e[n]=[]),e[n]}function MX(n){return Array.isArray(n)?n:[n]}function NX(n,e){return n&&n[e]?{...n,...n[e]}:{...n}}const PX=n=>typeof n=="number",DX=n=>n.every(PX);function LX(n,e){return n in e}class $X extends rF{constructor(){super(...arguments),this.type="object"}readValueFromInstance(e,t){if(LX(t,e)){const s=e[t];if(typeof s=="string"||typeof s=="number")return s}}getBaseTargetFromProps(){}removeValueFromRenderState(e,t){delete t.output[e]}measureInstanceViewportBox(){return xi()}build(e,t){Object.assign(e.output,t)}renderInstance(e,{output:t}){Object.assign(e,t)}sortInstanceNodePosition(){return 0}}function FX(n){const e={presenceContext:null,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},t=K$(n)?new lF(e):new aF(e);t.mount(n),gf.set(n,t)}function OX(n){const e={presenceContext:null,props:{},visualState:{renderState:{output:{}},latestValues:{}}},t=new $X(e);t.mount(n),gf.set(n,t)}function zX(n,e){return cr(n)||typeof n=="number"||typeof n=="string"&&!CE(e)}function xF(n,e,t,s){const i=[];if(zX(n,e))i.push(q$(n,CE(e)&&e.default||e,t&&(t.default||t)));else{const r=gF(n,e,s),o=r.length;for(let a=0;a<o;a++){const l=r[a],c=l instanceof Element?FX:OX;gf.has(l)||c(l);const u=gf.get(l),d={...t};"delay"in d&&typeof d.delay=="function"&&(d.delay=d.delay(a,o)),i.push(...bE(u,{...e,transition:d},{}))}}return i}function BX(n,e,t){const s=[];return RX(n,e,t,{spring:gE}).forEach(({keyframes:r,transition:o},a)=>{s.push(...xF(a,r,o))}),s}function UX(n){return Array.isArray(n)&&n.some(Array.isArray)}function VX(n){function e(t,s,i){let r=[];return UX(t)?r=BX(t,s,n):r=xF(t,s,i,n),new QL(r)}return e}const WX=VX();var Lm={},DR;function GX(){if(DR)return Lm;DR=1,Object.defineProperty(Lm,"__esModule",{value:!0}),Lm.parse=o,Lm.serialize=c;const n=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,e=/^[\u0021-\u003A\u003C-\u007E]*$/,t=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,s=/^[\u0020-\u003A\u003D-\u007E]*$/,i=Object.prototype.toString,r=(()=>{const h=function(){};return h.prototype=Object.create(null),h})();function o(h,p){const g=new r,y=h.length;if(y<2)return g;const x=(p==null?void 0:p.decode)||u;let v=0;do{const b=h.indexOf("=",v);if(b===-1)break;const S=h.indexOf(";",v),C=S===-1?y:S;if(b>C){v=h.lastIndexOf(";",b-1)+1;continue}const E=a(h,v,b),k=l(h,b,E),R=h.slice(E,k);if(g[R]===void 0){let L=a(h,b+1,C),I=l(h,C,L);const T=x(h.slice(L,I));g[R]=T}v=C+1}while(v<y);return g}function a(h,p,g){do{const y=h.charCodeAt(p);if(y!==32&&y!==9)return p}while(++p<g);return g}function l(h,p,g){for(;p>g;){const y=h.charCodeAt(--p);if(y!==32&&y!==9)return p+1}return g}function c(h,p,g){const y=(g==null?void 0:g.encode)||encodeURIComponent;if(!n.test(h))throw new TypeError(`argument name is invalid: ${h}`);const x=y(p);if(!e.test(x))throw new TypeError(`argument val is invalid: ${p}`);let v=h+"="+x;if(!g)return v;if(g.maxAge!==void 0){if(!Number.isInteger(g.maxAge))throw new TypeError(`option maxAge is invalid: ${g.maxAge}`);v+="; Max-Age="+g.maxAge}if(g.domain){if(!t.test(g.domain))throw new TypeError(`option domain is invalid: ${g.domain}`);v+="; Domain="+g.domain}if(g.path){if(!s.test(g.path))throw new TypeError(`option path is invalid: ${g.path}`);v+="; Path="+g.path}if(g.expires){if(!d(g.expires)||!Number.isFinite(g.expires.valueOf()))throw new TypeError(`option expires is invalid: ${g.expires}`);v+="; Expires="+g.expires.toUTCString()}if(g.httpOnly&&(v+="; HttpOnly"),g.secure&&(v+="; Secure"),g.partitioned&&(v+="; Partitioned"),g.priority)switch(typeof g.priority=="string"?g.priority.toLowerCase():void 0){case"low":v+="; Priority=Low";break;case"medium":v+="; Priority=Medium";break;case"high":v+="; Priority=High";break;default:throw new TypeError(`option priority is invalid: ${g.priority}`)}if(g.sameSite)switch(typeof g.sameSite=="string"?g.sameSite.toLowerCase():g.sameSite){case!0:case"strict":v+="; SameSite=Strict";break;case"lax":v+="; SameSite=Lax";break;case"none":v+="; SameSite=None";break;default:throw new TypeError(`option sameSite is invalid: ${g.sameSite}`)}return v}function u(h){if(h.indexOf("%")===-1)return h;try{return decodeURIComponent(h)}catch{return h}}function d(h){return i.call(h)==="[object Date]"}return Lm}GX();var LR="popstate";function HX(n={}){function e(s,i){let{pathname:r,search:o,hash:a}=s.location;return IC("",{pathname:r,search:o,hash:a},i.state&&i.state.usr||null,i.state&&i.state.key||"default")}function t(s,i){return typeof i=="string"?i:Ag(i)}return XX(e,t,null,n)}function pi(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}function bl(n,e){if(!n){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function jX(){return Math.random().toString(36).substring(2,10)}function $R(n,e){return{usr:n.state,key:n.key,idx:e}}function IC(n,e,t=null,s){return{pathname:typeof n=="string"?n:n.pathname,search:"",hash:"",...typeof e=="string"?Wf(e):e,state:t,key:e&&e.key||s||jX()}}function Ag({pathname:n="/",search:e="",hash:t=""}){return e&&e!=="?"&&(n+=e.charAt(0)==="?"?e:"?"+e),t&&t!=="#"&&(n+=t.charAt(0)==="#"?t:"#"+t),n}function Wf(n){let e={};if(n){let t=n.indexOf("#");t>=0&&(e.hash=n.substring(t),n=n.substring(0,t));let s=n.indexOf("?");s>=0&&(e.search=n.substring(s),n=n.substring(0,s)),n&&(e.pathname=n)}return e}function XX(n,e,t,s={}){let{window:i=document.defaultView,v5Compat:r=!1}=s,o=i.history,a="POP",l=null,c=u();c==null&&(c=0,o.replaceState({...o.state,idx:c},""));function u(){return(o.state||{idx:null}).idx}function d(){a="POP";let x=u(),v=x==null?null:x-c;c=x,l&&l({action:a,location:y.location,delta:v})}function h(x,v){a="PUSH";let b=IC(y.location,x,v);c=u()+1;let S=$R(b,c),C=y.createHref(b);try{o.pushState(S,"",C)}catch(E){if(E instanceof DOMException&&E.name==="DataCloneError")throw E;i.location.assign(C)}r&&l&&l({action:a,location:y.location,delta:1})}function p(x,v){a="REPLACE";let b=IC(y.location,x,v);c=u();let S=$R(b,c),C=y.createHref(b);o.replaceState(S,"",C),r&&l&&l({action:a,location:y.location,delta:0})}function g(x){return qX(x)}let y={get action(){return a},get location(){return n(i,o)},listen(x){if(l)throw new Error("A history only accepts one active listener");return i.addEventListener(LR,d),l=x,()=>{i.removeEventListener(LR,d),l=null}},createHref(x){return e(i,x)},createURL:g,encodeLocation(x){let v=g(x);return{pathname:v.pathname,search:v.search,hash:v.hash}},push:h,replace:p,go(x){return o.go(x)}};return y}function qX(n,e=!1){let t="http://localhost";typeof window<"u"&&(t=window.location.origin!=="null"?window.location.origin:window.location.href),pi(t,"No window.location.(origin|href) available to create URL");let s=typeof n=="string"?n:Ag(n);return s=s.replace(/ $/,"%20"),!e&&s.startsWith("//")&&(s=t+s),new URL(s,t)}function vF(n,e,t="/"){return KX(n,e,t,!1)}function KX(n,e,t,s){let i=typeof e=="string"?Wf(e):e,r=uc(i.pathname||"/",t);if(r==null)return null;let o=yF(n);YX(o);let a=null;for(let l=0;a==null&&l<o.length;++l){let c=aq(r);a=rq(o[l],c,s)}return a}function yF(n,e=[],t=[],s=""){let i=(r,o,a)=>{let l={relativePath:a===void 0?r.path||"":a,caseSensitive:r.caseSensitive===!0,childrenIndex:o,route:r};l.relativePath.startsWith("/")&&(pi(l.relativePath.startsWith(s),`Absolute route path "${l.relativePath}" nested under path "${s}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),l.relativePath=l.relativePath.slice(s.length));let c=oc([s,l.relativePath]),u=t.concat(l);r.children&&r.children.length>0&&(pi(r.index!==!0,`Index routes must not have child routes. Please remove all child routes from route path "${c}".`),yF(r.children,e,u,c)),!(r.path==null&&!r.index)&&e.push({path:c,score:sq(c,r.index),routesMeta:u})};return n.forEach((r,o)=>{var a;if(r.path===""||!((a=r.path)!=null&&a.includes("?")))i(r,o);else for(let l of wF(r.path))i(r,o,l)}),e}function wF(n){let e=n.split("/");if(e.length===0)return[];let[t,...s]=e,i=t.endsWith("?"),r=t.replace(/\?$/,"");if(s.length===0)return i?[r,""]:[r];let o=wF(s.join("/")),a=[];return a.push(...o.map(l=>l===""?r:[r,l].join("/"))),i&&a.push(...o),a.map(l=>n.startsWith("/")&&l===""?"/":l)}function YX(n){n.sort((e,t)=>e.score!==t.score?t.score-e.score:iq(e.routesMeta.map(s=>s.childrenIndex),t.routesMeta.map(s=>s.childrenIndex)))}var ZX=/^:[\w-]+$/,QX=3,JX=2,eq=1,tq=10,nq=-2,FR=n=>n==="*";function sq(n,e){let t=n.split("/"),s=t.length;return t.some(FR)&&(s+=nq),e&&(s+=JX),t.filter(i=>!FR(i)).reduce((i,r)=>i+(ZX.test(r)?QX:r===""?eq:tq),s)}function iq(n,e){return n.length===e.length&&n.slice(0,-1).every((s,i)=>s===e[i])?n[n.length-1]-e[e.length-1]:0}function rq(n,e,t=!1){let{routesMeta:s}=n,i={},r="/",o=[];for(let a=0;a<s.length;++a){let l=s[a],c=a===s.length-1,u=r==="/"?e:e.slice(r.length)||"/",d=n2({path:l.relativePath,caseSensitive:l.caseSensitive,end:c},u),h=l.route;if(!d&&c&&t&&!s[s.length-1].route.index&&(d=n2({path:l.relativePath,caseSensitive:l.caseSensitive,end:!1},u)),!d)return null;Object.assign(i,d.params),o.push({params:i,pathname:oc([r,d.pathname]),pathnameBase:dq(oc([r,d.pathnameBase])),route:h}),d.pathnameBase!=="/"&&(r=oc([r,d.pathnameBase]))}return o}function n2(n,e){typeof n=="string"&&(n={path:n,caseSensitive:!1,end:!0});let[t,s]=oq(n.path,n.caseSensitive,n.end),i=e.match(t);if(!i)return null;let r=i[0],o=r.replace(/(.)\/+$/,"$1"),a=i.slice(1);return{params:s.reduce((c,{paramName:u,isOptional:d},h)=>{if(u==="*"){let g=a[h]||"";o=r.slice(0,r.length-g.length).replace(/(.)\/+$/,"$1")}const p=a[h];return d&&!p?c[u]=void 0:c[u]=(p||"").replace(/%2F/g,"/"),c},{}),pathname:r,pathnameBase:o,pattern:n}}function oq(n,e=!1,t=!0){bl(n==="*"||!n.endsWith("*")||n.endsWith("/*"),`Route path "${n}" will be treated as if it were "${n.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/,"/*")}".`);let s=[],i="^"+n.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(o,a,l)=>(s.push({paramName:a,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return n.endsWith("*")?(s.push({paramName:"*"}),i+=n==="*"||n==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):t?i+="\\/*$":n!==""&&n!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,e?void 0:"i"),s]}function aq(n){try{return n.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return bl(!1,`The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),n}}function uc(n,e){if(e==="/")return n;if(!n.toLowerCase().startsWith(e.toLowerCase()))return null;let t=e.endsWith("/")?e.length-1:e.length,s=n.charAt(t);return s&&s!=="/"?null:n.slice(t)||"/"}function lq(n,e="/"){let{pathname:t,search:s="",hash:i=""}=typeof n=="string"?Wf(n):n;return{pathname:t?t.startsWith("/")?t:cq(t,e):e,search:hq(s),hash:fq(i)}}function cq(n,e){let t=e.replace(/\/+$/,"").split("/");return n.split("/").forEach(i=>{i===".."?t.length>1&&t.pop():i!=="."&&t.push(i)}),t.length>1?t.join("/"):"/"}function U3(n,e,t,s){return`Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(s)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function uq(n){return n.filter((e,t)=>t===0||e.route.path&&e.route.path.length>0)}function bF(n){let e=uq(n);return e.map((t,s)=>s===e.length-1?t.pathname:t.pathnameBase)}function SF(n,e,t,s=!1){let i;typeof n=="string"?i=Wf(n):(i={...n},pi(!i.pathname||!i.pathname.includes("?"),U3("?","pathname","search",i)),pi(!i.pathname||!i.pathname.includes("#"),U3("#","pathname","hash",i)),pi(!i.search||!i.search.includes("#"),U3("#","search","hash",i)));let r=n===""||i.pathname==="",o=r?"/":i.pathname,a;if(o==null)a=t;else{let d=e.length-1;if(!s&&o.startsWith("..")){let h=o.split("/");for(;h[0]==="..";)h.shift(),d-=1;i.pathname=h.join("/")}a=d>=0?e[d]:"/"}let l=lq(i,a),c=o&&o!=="/"&&o.endsWith("/"),u=(r||o===".")&&t.endsWith("/");return!l.pathname.endsWith("/")&&(c||u)&&(l.pathname+="/"),l}var oc=n=>n.join("/").replace(/\/\/+/g,"/"),dq=n=>n.replace(/\/+$/,"").replace(/^\/*/,"/"),hq=n=>!n||n==="?"?"":n.startsWith("?")?n:"?"+n,fq=n=>!n||n==="#"?"":n.startsWith("#")?n:"#"+n;function pq(n){return n!=null&&typeof n.status=="number"&&typeof n.statusText=="string"&&typeof n.internal=="boolean"&&"data"in n}var CF=["POST","PUT","PATCH","DELETE"];new Set(CF);var mq=["GET",...CF];new Set(mq);var Gf=le.createContext(null);Gf.displayName="DataRouter";var ty=le.createContext(null);ty.displayName="DataRouterState";var _F=le.createContext({isTransitioning:!1});_F.displayName="ViewTransition";var gq=le.createContext(new Map);gq.displayName="Fetchers";var xq=le.createContext(null);xq.displayName="Await";var Al=le.createContext(null);Al.displayName="Navigation";var n0=le.createContext(null);n0.displayName="Location";var mc=le.createContext({outlet:null,matches:[],isDataRoute:!1});mc.displayName="Route";var _E=le.createContext(null);_E.displayName="RouteError";function vq(n,{relative:e}={}){pi(s0(),"useHref() may be used only in the context of a <Router> component.");let{basename:t,navigator:s}=le.useContext(Al),{hash:i,pathname:r,search:o}=i0(n,{relative:e}),a=r;return t!=="/"&&(a=r==="/"?t:oc([t,r])),s.createHref({pathname:a,search:o,hash:i})}function s0(){return le.useContext(n0)!=null}function $d(){return pi(s0(),"useLocation() may be used only in the context of a <Router> component."),le.useContext(n0).location}var EF="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function TF(n){le.useContext(Al).static||le.useLayoutEffect(n)}function yq(){let{isDataRoute:n}=le.useContext(mc);return n?Nq():wq()}function wq(){pi(s0(),"useNavigate() may be used only in the context of a <Router> component.");let n=le.useContext(Gf),{basename:e,navigator:t}=le.useContext(Al),{matches:s}=le.useContext(mc),{pathname:i}=$d(),r=JSON.stringify(bF(s)),o=le.useRef(!1);return TF(()=>{o.current=!0}),le.useCallback((l,c={})=>{if(bl(o.current,EF),!o.current)return;if(typeof l=="number"){t.go(l);return}let u=SF(l,JSON.parse(r),i,c.relative==="path");n==null&&e!=="/"&&(u.pathname=u.pathname==="/"?e:oc([e,u.pathname])),(c.replace?t.replace:t.push)(u,c.state,c)},[e,t,r,i,n])}le.createContext(null);function i0(n,{relative:e}={}){let{matches:t}=le.useContext(mc),{pathname:s}=$d(),i=JSON.stringify(bF(t));return le.useMemo(()=>SF(n,JSON.parse(i),s,e==="path"),[n,i,s,e])}function bq(n,e){return IF(n,e)}function IF(n,e,t,s){var v;pi(s0(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:i}=le.useContext(Al),{matches:r}=le.useContext(mc),o=r[r.length-1],a=o?o.params:{},l=o?o.pathname:"/",c=o?o.pathnameBase:"/",u=o&&o.route;{let b=u&&u.path||"";kF(l,!u||b.endsWith("*")||b.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${l}" (under <Route path="${b}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${b}"> to <Route path="${b==="/"?"*":`${b}/*`}">.`)}let d=$d(),h;if(e){let b=typeof e=="string"?Wf(e):e;pi(c==="/"||((v=b.pathname)==null?void 0:v.startsWith(c)),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${b.pathname}" was given in the \`location\` prop.`),h=b}else h=d;let p=h.pathname||"/",g=p;if(c!=="/"){let b=c.replace(/^\//,"").split("/");g="/"+p.replace(/^\//,"").split("/").slice(b.length).join("/")}let y=vF(n,{pathname:g});bl(u||y!=null,`No routes matched location "${h.pathname}${h.search}${h.hash}" `),bl(y==null||y[y.length-1].route.element!==void 0||y[y.length-1].route.Component!==void 0||y[y.length-1].route.lazy!==void 0,`Matched leaf route at location "${h.pathname}${h.search}${h.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let x=Tq(y&&y.map(b=>Object.assign({},b,{params:Object.assign({},a,b.params),pathname:oc([c,i.encodeLocation?i.encodeLocation(b.pathname).pathname:b.pathname]),pathnameBase:b.pathnameBase==="/"?c:oc([c,i.encodeLocation?i.encodeLocation(b.pathnameBase).pathname:b.pathnameBase])})),r,t,s);return e&&x?le.createElement(n0.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...h},navigationType:"POP"}},x):x}function Sq(){let n=Mq(),e=pq(n)?`${n.status} ${n.statusText}`:n instanceof Error?n.message:JSON.stringify(n),t=n instanceof Error?n.stack:null,s="rgba(200,200,200, 0.5)",i={padding:"0.5rem",backgroundColor:s},r={padding:"2px 4px",backgroundColor:s},o=null;return console.error("Error handled by React Router default ErrorBoundary:",n),o=le.createElement(le.Fragment,null,le.createElement("p",null,"💿 Hey developer 👋"),le.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",le.createElement("code",{style:r},"ErrorBoundary")," or"," ",le.createElement("code",{style:r},"errorElement")," prop on your route.")),le.createElement(le.Fragment,null,le.createElement("h2",null,"Unexpected Application Error!"),le.createElement("h3",{style:{fontStyle:"italic"}},e),t?le.createElement("pre",{style:i},t):null,o)}var Cq=le.createElement(Sq,null),_q=class extends le.Component{constructor(n){super(n),this.state={location:n.location,revalidation:n.revalidation,error:n.error}}static getDerivedStateFromError(n){return{error:n}}static getDerivedStateFromProps(n,e){return e.location!==n.location||e.revalidation!=="idle"&&n.revalidation==="idle"?{error:n.error,location:n.location,revalidation:n.revalidation}:{error:n.error!==void 0?n.error:e.error,location:e.location,revalidation:n.revalidation||e.revalidation}}componentDidCatch(n,e){console.error("React Router caught the following error during render",n,e)}render(){return this.state.error!==void 0?le.createElement(mc.Provider,{value:this.props.routeContext},le.createElement(_E.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function Eq({routeContext:n,match:e,children:t}){let s=le.useContext(Gf);return s&&s.static&&s.staticContext&&(e.route.errorElement||e.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=e.route.id),le.createElement(mc.Provider,{value:n},t)}function Tq(n,e=[],t=null,s=null){if(n==null){if(!t)return null;if(t.errors)n=t.matches;else if(e.length===0&&!t.initialized&&t.matches.length>0)n=t.matches;else return null}let i=n,r=t==null?void 0:t.errors;if(r!=null){let l=i.findIndex(c=>c.route.id&&(r==null?void 0:r[c.route.id])!==void 0);pi(l>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(r).join(",")}`),i=i.slice(0,Math.min(i.length,l+1))}let o=!1,a=-1;if(t)for(let l=0;l<i.length;l++){let c=i[l];if((c.route.HydrateFallback||c.route.hydrateFallbackElement)&&(a=l),c.route.id){let{loaderData:u,errors:d}=t,h=c.route.loader&&!u.hasOwnProperty(c.route.id)&&(!d||d[c.route.id]===void 0);if(c.route.lazy||h){o=!0,a>=0?i=i.slice(0,a+1):i=[i[0]];break}}}return i.reduceRight((l,c,u)=>{let d,h=!1,p=null,g=null;t&&(d=r&&c.route.id?r[c.route.id]:void 0,p=c.route.errorElement||Cq,o&&(a<0&&u===0?(kF("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),h=!0,g=null):a===u&&(h=!0,g=c.route.hydrateFallbackElement||null)));let y=e.concat(i.slice(0,u+1)),x=()=>{let v;return d?v=p:h?v=g:c.route.Component?v=le.createElement(c.route.Component,null):c.route.element?v=c.route.element:v=l,le.createElement(Eq,{match:c,routeContext:{outlet:l,matches:y,isDataRoute:t!=null},children:v})};return t&&(c.route.ErrorBoundary||c.route.errorElement||u===0)?le.createElement(_q,{location:t.location,revalidation:t.revalidation,component:p,error:d,children:x(),routeContext:{outlet:null,matches:y,isDataRoute:!0}}):x()},null)}function EE(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Iq(n){let e=le.useContext(Gf);return pi(e,EE(n)),e}function kq(n){let e=le.useContext(ty);return pi(e,EE(n)),e}function Aq(n){let e=le.useContext(mc);return pi(e,EE(n)),e}function TE(n){let e=Aq(n),t=e.matches[e.matches.length-1];return pi(t.route.id,`${n} can only be used on routes that contain a unique "id"`),t.route.id}function Rq(){return TE("useRouteId")}function Mq(){var s;let n=le.useContext(_E),e=kq("useRouteError"),t=TE("useRouteError");return n!==void 0?n:(s=e.errors)==null?void 0:s[t]}function Nq(){let{router:n}=Iq("useNavigate"),e=TE("useNavigate"),t=le.useRef(!1);return TF(()=>{t.current=!0}),le.useCallback(async(i,r={})=>{bl(t.current,EF),t.current&&(typeof i=="number"?n.navigate(i):await n.navigate(i,{fromRouteId:e,...r}))},[n,e])}var OR={};function kF(n,e,t){!e&&!OR[n]&&(OR[n]=!0,bl(!1,t))}le.memo(Pq);function Pq({routes:n,future:e,state:t}){return IF(n,void 0,t,e)}function Rv(n){pi(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function Dq({basename:n="/",children:e=null,location:t,navigationType:s="POP",navigator:i,static:r=!1}){pi(!s0(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let o=n.replace(/^\/*/,"/"),a=le.useMemo(()=>({basename:o,navigator:i,static:r,future:{}}),[o,i,r]);typeof t=="string"&&(t=Wf(t));let{pathname:l="/",search:c="",hash:u="",state:d=null,key:h="default"}=t,p=le.useMemo(()=>{let g=uc(l,o);return g==null?null:{location:{pathname:g,search:c,hash:u,state:d,key:h},navigationType:s}},[o,l,c,u,d,h,s]);return bl(p!=null,`<Router basename="${o}"> is not able to match the URL "${l}${c}${u}" because it does not start with the basename, so the <Router> won't render anything.`),p==null?null:le.createElement(Al.Provider,{value:a},le.createElement(n0.Provider,{children:e,value:p}))}function Lq({children:n,location:e}){return bq(kC(n),e)}function kC(n,e=[]){let t=[];return le.Children.forEach(n,(s,i)=>{if(!le.isValidElement(s))return;let r=[...e,i];if(s.type===le.Fragment){t.push.apply(t,kC(s.props.children,r));return}pi(s.type===Rv,`[${typeof s.type=="string"?s.type:s.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),pi(!s.props.index||!s.props.children,"An index route cannot have child routes.");let o={id:s.props.id||r.join("-"),caseSensitive:s.props.caseSensitive,element:s.props.element,Component:s.props.Component,index:s.props.index,path:s.props.path,loader:s.props.loader,action:s.props.action,hydrateFallbackElement:s.props.hydrateFallbackElement,HydrateFallback:s.props.HydrateFallback,errorElement:s.props.errorElement,ErrorBoundary:s.props.ErrorBoundary,hasErrorBoundary:s.props.hasErrorBoundary===!0||s.props.ErrorBoundary!=null||s.props.errorElement!=null,shouldRevalidate:s.props.shouldRevalidate,handle:s.props.handle,lazy:s.props.lazy};s.props.children&&(o.children=kC(s.props.children,r)),t.push(o)}),t}var Mv="get",Nv="application/x-www-form-urlencoded";function ny(n){return n!=null&&typeof n.tagName=="string"}function $q(n){return ny(n)&&n.tagName.toLowerCase()==="button"}function Fq(n){return ny(n)&&n.tagName.toLowerCase()==="form"}function Oq(n){return ny(n)&&n.tagName.toLowerCase()==="input"}function zq(n){return!!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)}function Bq(n,e){return n.button===0&&(!e||e==="_self")&&!zq(n)}var kx=null;function Uq(){if(kx===null)try{new FormData(document.createElement("form"),0),kx=!1}catch{kx=!0}return kx}var Vq=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function V3(n){return n!=null&&!Vq.has(n)?(bl(!1,`"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Nv}"`),null):n}function Wq(n,e){let t,s,i,r,o;if(Fq(n)){let a=n.getAttribute("action");s=a?uc(a,e):null,t=n.getAttribute("method")||Mv,i=V3(n.getAttribute("enctype"))||Nv,r=new FormData(n)}else if($q(n)||Oq(n)&&(n.type==="submit"||n.type==="image")){let a=n.form;if(a==null)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let l=n.getAttribute("formaction")||a.getAttribute("action");if(s=l?uc(l,e):null,t=n.getAttribute("formmethod")||a.getAttribute("method")||Mv,i=V3(n.getAttribute("formenctype"))||V3(a.getAttribute("enctype"))||Nv,r=new FormData(a,n),!Uq()){let{name:c,type:u,value:d}=n;if(u==="image"){let h=c?`${c}.`:"";r.append(`${h}x`,"0"),r.append(`${h}y`,"0")}else c&&r.append(c,d)}}else{if(ny(n))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');t=Mv,s=null,i=Nv,o=n}return r&&i==="text/plain"&&(o=r,r=void 0),{action:s,method:t.toLowerCase(),encType:i,formData:r,body:o}}function IE(n,e){if(n===!1||n===null||typeof n>"u")throw new Error(e)}async function Gq(n,e){if(n.id in e)return e[n.id];try{let t=await import(n.module);return e[n.id]=t,t}catch(t){return console.error(`Error loading route module \`${n.module}\`, reloading page...`),console.error(t),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise(()=>{})}}function Hq(n){return n==null?!1:n.href==null?n.rel==="preload"&&typeof n.imageSrcSet=="string"&&typeof n.imageSizes=="string":typeof n.rel=="string"&&typeof n.href=="string"}async function jq(n,e,t){let s=await Promise.all(n.map(async i=>{let r=e.routes[i.route.id];if(r){let o=await Gq(r,t);return o.links?o.links():[]}return[]}));return Yq(s.flat(1).filter(Hq).filter(i=>i.rel==="stylesheet"||i.rel==="preload").map(i=>i.rel==="stylesheet"?{...i,rel:"prefetch",as:"style"}:{...i,rel:"prefetch"}))}function zR(n,e,t,s,i,r){let o=(l,c)=>t[c]?l.route.id!==t[c].route.id:!0,a=(l,c)=>{var u;return t[c].pathname!==l.pathname||((u=t[c].route.path)==null?void 0:u.endsWith("*"))&&t[c].params["*"]!==l.params["*"]};return r==="assets"?e.filter((l,c)=>o(l,c)||a(l,c)):r==="data"?e.filter((l,c)=>{var d;let u=s.routes[l.route.id];if(!u||!u.hasLoader)return!1;if(o(l,c)||a(l,c))return!0;if(l.route.shouldRevalidate){let h=l.route.shouldRevalidate({currentUrl:new URL(i.pathname+i.search+i.hash,window.origin),currentParams:((d=t[0])==null?void 0:d.params)||{},nextUrl:new URL(n,window.origin),nextParams:l.params,defaultShouldRevalidate:!0});if(typeof h=="boolean")return h}return!0}):[]}function Xq(n,e,{includeHydrateFallback:t}={}){return qq(n.map(s=>{let i=e.routes[s.route.id];if(!i)return[];let r=[i.module];return i.clientActionModule&&(r=r.concat(i.clientActionModule)),i.clientLoaderModule&&(r=r.concat(i.clientLoaderModule)),t&&i.hydrateFallbackModule&&(r=r.concat(i.hydrateFallbackModule)),i.imports&&(r=r.concat(i.imports)),r}).flat(1))}function qq(n){return[...new Set(n)]}function Kq(n){let e={},t=Object.keys(n).sort();for(let s of t)e[s]=n[s];return e}function Yq(n,e){let t=new Set;return new Set(e),n.reduce((s,i)=>{let r=JSON.stringify(Kq(i));return t.has(r)||(t.add(r),s.push({key:r,link:i})),s},[])}Object.getOwnPropertyNames(Object.prototype).sort().join("\0");var Zq=new Set([100,101,204,205]);function Qq(n,e){let t=typeof n=="string"?new URL(n,typeof window>"u"?"server://singlefetch/":window.location.origin):n;return t.pathname==="/"?t.pathname="_root.data":e&&uc(t.pathname,e)==="/"?t.pathname=`${e.replace(/\/$/,"")}/_root.data`:t.pathname=`${t.pathname.replace(/\/$/,"")}.data`,t}function AF(){let n=le.useContext(Gf);return IE(n,"You must render this element inside a <DataRouterContext.Provider> element"),n}function Jq(){let n=le.useContext(ty);return IE(n,"You must render this element inside a <DataRouterStateContext.Provider> element"),n}var kE=le.createContext(void 0);kE.displayName="FrameworkContext";function RF(){let n=le.useContext(kE);return IE(n,"You must render this element inside a <HydratedRouter> element"),n}function eK(n,e){let t=le.useContext(kE),[s,i]=le.useState(!1),[r,o]=le.useState(!1),{onFocus:a,onBlur:l,onMouseEnter:c,onMouseLeave:u,onTouchStart:d}=e,h=le.useRef(null);le.useEffect(()=>{if(n==="render"&&o(!0),n==="viewport"){let y=v=>{v.forEach(b=>{o(b.isIntersecting)})},x=new IntersectionObserver(y,{threshold:.5});return h.current&&x.observe(h.current),()=>{x.disconnect()}}},[n]),le.useEffect(()=>{if(s){let y=setTimeout(()=>{o(!0)},100);return()=>{clearTimeout(y)}}},[s]);let p=()=>{i(!0)},g=()=>{i(!1),o(!1)};return t?n!=="intent"?[r,h,{}]:[r,h,{onFocus:$m(a,p),onBlur:$m(l,g),onMouseEnter:$m(c,p),onMouseLeave:$m(u,g),onTouchStart:$m(d,p)}]:[!1,h,{}]}function $m(n,e){return t=>{n&&n(t),t.defaultPrevented||e(t)}}function tK({page:n,...e}){let{router:t}=AF(),s=le.useMemo(()=>vF(t.routes,n,t.basename),[t.routes,n,t.basename]);return s?le.createElement(sK,{page:n,matches:s,...e}):null}function nK(n){let{manifest:e,routeModules:t}=RF(),[s,i]=le.useState([]);return le.useEffect(()=>{let r=!1;return jq(n,e,t).then(o=>{r||i(o)}),()=>{r=!0}},[n,e,t]),s}function sK({page:n,matches:e,...t}){let s=$d(),{manifest:i,routeModules:r}=RF(),{basename:o}=AF(),{loaderData:a,matches:l}=Jq(),c=le.useMemo(()=>zR(n,e,l,i,s,"data"),[n,e,l,i,s]),u=le.useMemo(()=>zR(n,e,l,i,s,"assets"),[n,e,l,i,s]),d=le.useMemo(()=>{if(n===s.pathname+s.search+s.hash)return[];let g=new Set,y=!1;if(e.forEach(v=>{var S;let b=i.routes[v.route.id];!b||!b.hasLoader||(!c.some(C=>C.route.id===v.route.id)&&v.route.id in a&&((S=r[v.route.id])!=null&&S.shouldRevalidate)||b.hasClientLoader?y=!0:g.add(v.route.id))}),g.size===0)return[];let x=Qq(n,o);return y&&g.size>0&&x.searchParams.set("_routes",e.filter(v=>g.has(v.route.id)).map(v=>v.route.id).join(",")),[x.pathname+x.search]},[o,a,s,i,c,e,n,r]),h=le.useMemo(()=>Xq(u,i),[u,i]),p=nK(u);return le.createElement(le.Fragment,null,d.map(g=>le.createElement("link",{key:g,rel:"prefetch",as:"fetch",href:g,...t})),h.map(g=>le.createElement("link",{key:g,rel:"modulepreload",href:g,...t})),p.map(({key:g,link:y})=>le.createElement("link",{key:g,...y})))}function iK(...n){return e=>{n.forEach(t=>{typeof t=="function"?t(e):t!=null&&(t.current=e)})}}var MF=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u";try{MF&&(window.__reactRouterVersion="7.6.3")}catch{}function rK({basename:n,children:e,window:t}){let s=le.useRef();s.current==null&&(s.current=HX({window:t,v5Compat:!0}));let i=s.current,[r,o]=le.useState({action:i.action,location:i.location}),a=le.useCallback(l=>{le.startTransition(()=>o(l))},[o]);return le.useLayoutEffect(()=>i.listen(a),[i,a]),le.createElement(Dq,{basename:n,children:e,location:r.location,navigationType:r.action,navigator:i})}var NF=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,cd=le.forwardRef(function({onClick:e,discover:t="render",prefetch:s="none",relative:i,reloadDocument:r,replace:o,state:a,target:l,to:c,preventScrollReset:u,viewTransition:d,...h},p){let{basename:g}=le.useContext(Al),y=typeof c=="string"&&NF.test(c),x,v=!1;if(typeof c=="string"&&y&&(x=c,MF))try{let I=new URL(window.location.href),T=c.startsWith("//")?new URL(I.protocol+c):new URL(c),M=uc(T.pathname,g);T.origin===I.origin&&M!=null?c=M+T.search+T.hash:v=!0}catch{bl(!1,`<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let b=vq(c,{relative:i}),[S,C,E]=eK(s,h),k=cK(c,{replace:o,state:a,target:l,preventScrollReset:u,relative:i,viewTransition:d});function R(I){e&&e(I),I.defaultPrevented||k(I)}let L=le.createElement("a",{...h,...E,href:x||b,onClick:v||r?e:R,ref:iK(p,C),target:l,"data-discover":!y&&t==="render"?"true":void 0});return S&&!y?le.createElement(le.Fragment,null,L,le.createElement(tK,{page:b})):L});cd.displayName="Link";var oK=le.forwardRef(function({"aria-current":e="page",caseSensitive:t=!1,className:s="",end:i=!1,style:r,to:o,viewTransition:a,children:l,...c},u){let d=i0(o,{relative:c.relative}),h=$d(),p=le.useContext(ty),{navigator:g,basename:y}=le.useContext(Al),x=p!=null&&pK(d)&&a===!0,v=g.encodeLocation?g.encodeLocation(d).pathname:d.pathname,b=h.pathname,S=p&&p.navigation&&p.navigation.location?p.navigation.location.pathname:null;t||(b=b.toLowerCase(),S=S?S.toLowerCase():null,v=v.toLowerCase()),S&&y&&(S=uc(S,y)||S);const C=v!=="/"&&v.endsWith("/")?v.length-1:v.length;let E=b===v||!i&&b.startsWith(v)&&b.charAt(C)==="/",k=S!=null&&(S===v||!i&&S.startsWith(v)&&S.charAt(v.length)==="/"),R={isActive:E,isPending:k,isTransitioning:x},L=E?e:void 0,I;typeof s=="function"?I=s(R):I=[s,E?"active":null,k?"pending":null,x?"transitioning":null].filter(Boolean).join(" ");let T=typeof r=="function"?r(R):r;return le.createElement(cd,{...c,"aria-current":L,className:I,ref:u,style:T,to:o,viewTransition:a},typeof l=="function"?l(R):l)});oK.displayName="NavLink";var aK=le.forwardRef(({discover:n="render",fetcherKey:e,navigate:t,reloadDocument:s,replace:i,state:r,method:o=Mv,action:a,onSubmit:l,relative:c,preventScrollReset:u,viewTransition:d,...h},p)=>{let g=hK(),y=fK(a,{relative:c}),x=o.toLowerCase()==="get"?"get":"post",v=typeof a=="string"&&NF.test(a),b=S=>{if(l&&l(S),S.defaultPrevented)return;S.preventDefault();let C=S.nativeEvent.submitter,E=(C==null?void 0:C.getAttribute("formmethod"))||o;g(C||S.currentTarget,{fetcherKey:e,method:E,navigate:t,replace:i,state:r,relative:c,preventScrollReset:u,viewTransition:d})};return le.createElement("form",{ref:p,method:x,action:y,onSubmit:s?l:b,...h,"data-discover":!v&&n==="render"?"true":void 0})});aK.displayName="Form";function lK(n){return`${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function PF(n){let e=le.useContext(Gf);return pi(e,lK(n)),e}function cK(n,{target:e,replace:t,state:s,preventScrollReset:i,relative:r,viewTransition:o}={}){let a=yq(),l=$d(),c=i0(n,{relative:r});return le.useCallback(u=>{if(Bq(u,e)){u.preventDefault();let d=t!==void 0?t:Ag(l)===Ag(c);a(n,{replace:d,state:s,preventScrollReset:i,relative:r,viewTransition:o})}},[l,a,c,t,s,e,n,i,r,o])}var uK=0,dK=()=>`__${String(++uK)}__`;function hK(){let{router:n}=PF("useSubmit"),{basename:e}=le.useContext(Al),t=Rq();return le.useCallback(async(s,i={})=>{let{action:r,method:o,encType:a,formData:l,body:c}=Wq(s,e);if(i.navigate===!1){let u=i.fetcherKey||dK();await n.fetch(u,t,i.action||r,{preventScrollReset:i.preventScrollReset,formData:l,body:c,formMethod:i.method||o,formEncType:i.encType||a,flushSync:i.flushSync})}else await n.navigate(i.action||r,{preventScrollReset:i.preventScrollReset,formData:l,body:c,formMethod:i.method||o,formEncType:i.encType||a,replace:i.replace,state:i.state,fromRouteId:t,flushSync:i.flushSync,viewTransition:i.viewTransition})},[n,e,t])}function fK(n,{relative:e}={}){let{basename:t}=le.useContext(Al),s=le.useContext(mc);pi(s,"useFormAction must be used inside a RouteContext");let[i]=s.matches.slice(-1),r={...i0(n||".",{relative:e})},o=$d();if(n==null){r.search=o.search;let a=new URLSearchParams(r.search),l=a.getAll("index");if(l.some(u=>u==="")){a.delete("index"),l.filter(d=>d).forEach(d=>a.append("index",d));let u=a.toString();r.search=u?`?${u}`:""}}return(!n||n===".")&&i.route.index&&(r.search=r.search?r.search.replace(/^\?/,"?index&"):"?index"),t!=="/"&&(r.pathname=r.pathname==="/"?t:oc([t,r.pathname])),Ag(r)}function pK(n,e={}){let t=le.useContext(_F);pi(t!=null,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:s}=PF("useViewTransitionState"),i=i0(n,{relative:e.relative});if(!t.isTransitioning)return!1;let r=uc(t.currentLocation.pathname,s)||t.currentLocation.pathname,o=uc(t.nextLocation.pathname,s)||t.nextLocation.pathname;return n2(i.pathname,o)!=null||n2(i.pathname,r)!=null}[...Zq];const mK=({children:n,onClick:e,className:t="",href:s})=>{const i=G.jsx("div",{className:`rotating-button ${t}`,children:G.jsxs("div",{children:[G.jsx("div",{children:n}),G.jsx("div",{children:n})]})});return s?G.jsx("a",{href:s,className:"inline-block",children:i}):G.jsx("button",{onClick:e,type:"button",className:"inline-block",children:i})},Ax=[{id:1,title:"Intelligence Artificielle de pointe",features:["Détection précise des points de repère faciaux","Analyse en temps réel de la morphologie du cou et des épaules","Technologie basée sur MediaPipe et des modèles personnalisés"]},{id:2,title:"Essayage virtuel innovant",features:["Rendu photoréaliste des colliers avec gestion des ombres","Ajustement automatique basé sur la largeur des épaules","Support de multiples angles de vue (jusqu'à 180°)","Interface utilisateur intuitive inspirée de bleu-reflet.com"]},{id:3,title:"Solution professionnelle complète",features:["Développé en collaboration avec BleuReflet","Base de données enrichie de centaines d'images de morphologies","Architecture full-stack React et deep learning","Engineering Project Efrei 24/25"]}],gK=()=>{const n=le.useRef(null),[e,t]=le.useState(0),{scrollYProgress:s}=hF({target:n,offset:["start start","end end"]});return pF(s,[0,.7],[0,Ax.length-1]).onChange(r=>{t(Math.min(Math.floor(r),Ax.length-1))}),G.jsx("div",{ref:n,className:"min-h-[200vh]",children:G.jsx("div",{className:"sticky top-0 min-h-screen flex items-center bg-white",children:G.jsx("div",{className:"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 w-full py-20",children:G.jsxs("div",{className:"grid lg:grid-cols-2 gap-16 items-center",children:[G.jsxs(wn.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.8},className:"space-y-12",children:[G.jsxs(wn.h1,{className:"font-['TT_Ramillas'] text-6xl leading-tight",children:["BleuReflet Collier",G.jsx("span",{className:"text-[#64ffa2]",children:" nouvelle génération"})]}),G.jsx("p",{className:"font-['Atyp_Display'] text-2xl text-gray-600 leading-relaxed",children:"Une solution de essayage virtuel innovante pour les colliers, développée en collaboration avec BleuReflet."}),G.jsx(mK,{href:"#demo",className:"px-10 py-5 bg-[#64ffa2] text-black rounded-full text-xl font-medium",children:"Découvrir maintenant"})]}),G.jsx("div",{className:"relative",children:G.jsxs("div",{className:"p-8",children:[G.jsx("div",{className:"flex items-center mb-12",children:G.jsxs("div",{className:"text-gray-500",children:[G.jsx("span",{className:"font-['TT_Ramillas'] text-2xl",children:String(e+1).padStart(2,"0")}),G.jsx("span",{className:"mx-3 text-xl",children:"/"}),G.jsx("span",{className:"font-['Atyp_Display'] text-xl",children:String(Ax.length).padStart(2,"0")})]})}),G.jsx("div",{className:"relative h-[500px]",children:Ax.map((r,o)=>G.jsxs(wn.div,{initial:{opacity:0,x:20},animate:{opacity:e===o?1:0,x:e===o?0:20},className:"absolute inset-0",style:{pointerEvents:e===o?"auto":"none",display:e===o?"block":"none"},children:[G.jsx("h2",{className:"font-['TT_Ramillas'] text-4xl mb-12 text-gray-800 leading-tight",children:r.title}),G.jsx("div",{className:"space-y-8",children:r.features.map((a,l)=>G.jsxs(wn.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},transition:{delay:l*.1},className:"flex items-start space-x-6",children:[G.jsx("div",{className:"flex-shrink-0 w-6 h-6 mt-1",children:G.jsx("svg",{className:"w-full h-full text-[#64ffa2]",fill:"currentColor",viewBox:"0 0 20 20",children:G.jsx("path",{fillRule:"evenodd",d:"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",clipRule:"evenodd"})})}),G.jsx("p",{className:"font-['Atyp_Display'] text-xl text-gray-600 leading-relaxed",children:a})]},l))})]},r.id))})]})})]})})})})},DF="data:image/webp;base64,UklGRqoIAABXRUJQVlA4WAoAAAAQAAAApgAARQAAQUxQSHcFAAABoIZa2+M2evgYhBFGGCFC7z1RmknvvZi07bvpVRhjjDDGmPTeuzBOF0OqMUIYYZRkS4q3N7N9jdH2NIIQQhgjhuH5oWmSh/m5RMQE4P/pumYtM93bkbhbaX6FIzlG00pQOBFX0lSqDI50HM0m/HCmk8w88cERXS2CE1KqBZxQegV0Jecg1hw4pHndQGIcdBfsdgxCpnllErRFRdcFx7CZVjZpuUIqnUO7JWkNb5x0ELQ0mzPyN5KsswdhZ0uSJJWdwhautv/QGo/HP2z9pq2tVd7ss5VKhWRqBexx0c5wkmS6pbHpiwyZCflsw3WZJH8bDfs8RvIIAHi2vyb/LLUJ5WOSbPECwm8XQZJVOYA/Sb4abg+56ikX4L55wYCvVHvC4BI9MbgyUiiVJCu0UEXygbCgJHjz6lrftMoCy2wE0LOVRgYGWkgmfkikO3/Y68spPZdkulDKSQZ0vClS8Zsb2bFx6CN2qZ8V1t9TAIxL0BBQlOLrIsCzIsFn45C7vbDKdfAxya2mXG2tQN+2Tj6yQlj3WW8AZSmawQ98JgHA0Aw/0ygrrAq9myRrTZWxAYDYaUmPnZYpRQCqsjT3nQ6aSV+BBUhWGguYOsVjAFBrhRS7blkWcIWoaVU9ObwbVOl9RiqjTTVyr2VHmI+SOPPTwmyxiTmhmPy+AHrXnTixFphz5MSJjeaCOqOzZDNyZ12IyWslAHO2/sTo1q1btzbpiCUNsetrBCCdIr/bvXugRYN/YX5mZdkAQ9L16Ko1D9haAri+YiMAbxuj5qq1XB+SLwYCkMKxVWvi/MwHLChPsKm8vLw8qlUcuV32ditbitGz5jd+UVPT3xr1FS17PWnStDX1nckjLmMX4hJQ1M4ogAYN1JvZSrJGw32bTM4AgHMfS0DRb2wGgM8YBIBardt3BeB5wcsAYmwAYI1hU0pHxwuFmUO9YWiCugQATlHtD9Tnybu5nfzBDwB+tQwAjlEZbG6JOgkAwuwqyTnXDZ5JcPV49wumK4WRejbJsix/Ra7Iz99ffNGeIZ8F3MgNMSLLsvwVucZco3JXlmX5B3JGNwIgRclKIz+ocyZpe/Pz1eXLj0im+kPzO86ZpO0z9yw9a5K2p3uhlPxbGHjFgTBo1UaStYD0gGSTyBF/cyiMGivKZH0w2K3cJIsN/Ms387deC0MzpPq+RoLvWialOccmvGSXy8CHbNISgfwhSPJFTwCIM6IltptCGxu0XFu72SryEQxUUVmmsTMAhBjLuWyZ9IhkRACooLpCo7bC3AF2zdA49S4QZajgEnyhMbSD2Wk5K5gRgOcZO4Me9A09koBapgYC7//JNmNr9TA0Q3IzAPe/7Ap60PfCIxeAr1ids5NPAPRMMhUoxsBwRABhfgzMyFudEVGmUj2ydm11pIu/zQEAEaIyAcCiTlLN8CsvgP5JJuO/3AySzSONvG8AVSTTfgBzMqTaya+8AHokGZUA6QGfuQG8mSWVTn5cDGAj1camjflSJxmYFJJ1G2pmCAAYfkiW5asVAMY1/v3qm2o3ckdHEk82ircPjRSwSHpEsq0YgP/u36++q3UDWHRZluUjw/sfk2X53CQA06L/vvqqQgIA6UzHo1XIVxwFK0kwKGChIQxPkbwqAEBIsF6SoC+APKVPlRRO3teTrNPBVpVUt+YUcj6SJ3rCPgMkd+uJZpKZeTbxercXNipCJMOSDnq2k8wEPTbwrNYLG62Mdagk1T9jdVrofbOTZPLDtd1MDRbDVmvCZ/burNu591T4gA7Qd1XNmes33+5mWThQa/50Succ0i8+R5Q64IEDylzoCWdqoquhP5yqoWx4OJyrAeXmcDhZVUuJ+OFsj+Wo0VI4XVHRoURL4XwBAFZQOCAMAwAAMBYAnQEqpwBGAAAAACWcAdwXw/8Hv2Z/1XOGbMdsf20/tOYp8G/0T8bvYB/XOcA/qP5Y7yr/gPbV6QD9M+AA/Ub0kv2A+EP9iP9v7gn6bXb79i57Xvr67ZOF7f+O3pn+gG5A/Hf8gMuA0W7I4s8fzv/pfcA/Ur/KfmVxgH7SHZrcNc7aMfLDjJoD70HCsejZ/IkxpdYeungWbce2s2Ed/YWDy1HuAnzniSAjDYm/1hwZN0Vk7nDaMfIAAP7//74sqP//3LS/H/n2wDH/3XfiHLx2sh5oSscQPEx8p7Rr/BsXi4aGyvGc4u0/Iee+qrnm4M///wQe7XTlwS8fnvoFFv//8RvE5OSdrEZ7yUeL/Ls1bUowIR9RU2/8YM4WLNiAJuYjMwqEETtkt0sXs9/glAA36XXRwD+l8zhhenZDXZ93zhcVx7FqfQLTS+Q5wdAnnCuLWp2eDIxrDm+cB8XS3a5ysLsS7EvW3g+MnUcvNN6lsRaN/02fJRAM4j46DMZ2YVLFK//2AaDlSOyfriAtmVosyjE/FU2SIsP/tpc1Q9LkOppCRHIJ8Wh5PeVpPJt+jzYe5Cxdc+4TrjgfpZ139+7Y8DLtSAbsLpnIXO27VDHDzeKdr+80qhM/57UBgGV8DOD/20jcyUBuUDpLtj7eY7+w6//EbJfGbx//gokLnlIQdCQSdEAQmVHOjiQbT67xxhY70PkPbWnFgbKtxfeK6vQjoE/EYwFZ4r7bdpGC9aT412RqmE7XbiGTneKX+nm/8bRU3yXbQcx4229R/JYX7y8MHxc8/k+sob0lTcsQmM7KNkl8CN+apvpvFfr1n5qUvH/ccwYxVL0Jy6BcO53yD+zjs55KbTJRWF6GX5KAci6Hm+9fQ8ZSP/ux//2UA+Btptcm1V1+FhgMrwli5QazNWAtOsfs5R2ZzvZqKEUYHIdeY/Kmgbn6O2xwEJ76RkTrjyXHZT15dGdFhOJiW9DFZAirb1jLVtAyfw69WmD3/9EX5nOMxPyL18ePcv/3Z9YSwg/Lb1WTNGxcAAAA",xK=()=>{const[n,e]=le.useState(!1),{scrollY:t}=hF(),s=pF(t,[0,100],["rgba(20, 3, 8, 0)","rgba(20, 3, 8, 0.95)"]),i=r=>{const o=document.getElementById(r);o&&(o.scrollIntoView({behavior:"smooth"}),e(!1))};return G.jsx(wn.header,{style:{backgroundColor:s},className:"fixed top-0 left-0 right-0 z-50 backdrop-blur-sm",children:G.jsxs("nav",{className:"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",children:[G.jsxs("div",{className:"flex justify-between items-center h-20",children:[G.jsx(wn.div,{initial:{opacity:0,x:-20},animate:{opacity:1,x:0},className:"flex-shrink-0 flex items-center",children:G.jsx("img",{src:DF,alt:"BleuReflet Logo",className:"h-12"})}),G.jsxs("div",{className:"hidden md:flex items-center space-x-8",children:[G.jsxs("button",{onClick:()=>i("shop"),className:"text-white/80 hover:text-[#64ffa2] transition-colors font-display flex items-center gap-2",children:[G.jsx("svg",{className:"w-4 h-4",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"})}),G.jsx("span",{children:"Magasin"})]}),G.jsxs("button",{onClick:()=>i("test"),className:"text-white/80 hover:text-[#64ffa2] transition-colors font-display flex items-center gap-2",children:[G.jsx("svg",{className:"w-4 h-4",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"})}),G.jsx("span",{children:"Zone de Test"})]}),G.jsxs("button",{onClick:()=>i("demo"),className:"text-white/80 hover:text-[#64ffa2] transition-colors font-display flex items-center gap-2",children:[G.jsxs("svg",{className:"w-4 h-4",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:[G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"}),G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15 13a3 3 0 11-6 0 3 3 0 016 0z"})]}),G.jsx("span",{children:"Essai Caméra"})]}),G.jsx(cd,{to:"/test",className:"p-1.5",children:G.jsx("svg",{className:"w-4 h-4 text-[#64ffa2]",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"})})})]}),G.jsx("div",{className:"md:hidden",children:G.jsxs("button",{onClick:()=>e(!n),className:"text-white/70 hover:text-white transition-colors",children:[G.jsx("span",{className:"sr-only",children:"Menu principal"}),G.jsx("svg",{className:"h-6 w-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:n?"M6 18L18 6M6 6l12 12":"M4 6h16M4 12h16M4 18h16"})})]})})]}),n&&G.jsx(wn.div,{initial:{opacity:0,y:-20},animate:{opacity:1,y:0},exit:{opacity:0,y:-20},className:"absolute top-full left-0 right-0 bg-black/95 backdrop-blur-xl border-t border-white/10 py-6 px-4 md:hidden",children:G.jsxs("div",{className:"flex flex-col space-y-4",children:[G.jsxs("button",{onClick:()=>{i("shop"),e(!1)},className:"text-white/80 hover:text-[#64ffa2] transition-colors font-display text-left flex items-center gap-2",children:[G.jsx("svg",{className:"w-4 h-4",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"})}),G.jsx("span",{children:"Magasin"})]}),G.jsxs("button",{onClick:()=>{i("test"),e(!1)},className:"text-white/80 hover:text-[#64ffa2] transition-colors font-display text-left flex items-center gap-2",children:[G.jsx("svg",{className:"w-4 h-4",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"})}),G.jsx("span",{children:"Zone de Test"})]}),G.jsxs("button",{onClick:()=>{i("demo"),e(!1)},className:"text-white/80 hover:text-[#64ffa2] transition-colors font-display text-left flex items-center gap-2",children:[G.jsxs("svg",{className:"w-4 h-4",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:[G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"}),G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15 13a3 3 0 11-6 0 3 3 0 016 0z"})]}),G.jsx("span",{children:"Essai Caméra"})]})]})})]})})},vK=({imageUrl:n="",title:e="Mon essayage virtuel de collier"})=>{const t=window.location.href,s=[{name:"Instagram",icon:G.jsx("svg",{className:"w-4 h-4",fill:"currentColor",viewBox:"0 0 24 24",children:G.jsx("path",{d:"M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"})}),onClick:()=>window.open(`https://www.instagram.com/share?url=${encodeURIComponent(t)}`)},{name:"Pinterest",icon:G.jsx("svg",{className:"w-4 h-4",fill:"currentColor",viewBox:"0 0 24 24",children:G.jsx("path",{d:"M12.017 0C5.396 0 .029 5.367.029 11.987c0 5.079 3.158 9.417 7.618 11.162-.105-.949-.199-2.403.041-3.439.219-.937 1.406-5.957 1.406-5.957s-.359-.72-.359-1.781c0-1.663.967-2.911 2.168-2.911 1.024 0 1.518.769 1.518 1.688 0 1.029-.653 2.567-.992 3.992-.285 1.193.6 2.165 1.775 2.165 2.128 0 3.768-2.245 3.768-5.487 0-2.861-2.063-4.869-5.008-4.869-3.41 0-5.409 2.562-5.409 5.199 0 1.033.394 2.143.889 2.741.099.12.112.225.085.345-.09.375-.293 1.199-.334 1.363-.053.225-.172.271-.401.165-1.495-.69-2.433-2.878-2.433-4.646 0-3.776 2.748-7.252 7.92-7.252 4.158 0 7.392 2.967 7.392 6.923 0 4.135-2.607 7.462-6.233 7.462-1.214 0-2.354-.629-2.758-1.379l-.749 2.848c-.269 1.045-1.004 2.352-1.498 3.146 1.123.345 2.306.535 3.55.535 6.607 0 11.985-5.365 11.985-11.987C23.97 5.39 18.592.026 11.985.026L12.017 0z"})}),onClick:()=>window.open(`https://pinterest.com/pin/create/button/?url=${encodeURIComponent(t)}&media=${encodeURIComponent(n)}&description=${encodeURIComponent(e)}`)}];return G.jsx(wn.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},className:"flex space-x-2",children:s.map(i=>G.jsx(wn.button,{whileHover:{scale:1.05},whileTap:{scale:.95},onClick:i.onClick,className:"p-2 bg-black/10 backdrop-blur-sm rounded-full hover:bg-black/20 transition-all duration-300",children:G.jsx("span",{className:"text-white/60",children:i.icon})},i.name))})};var W3={},BR;function yK(){return BR||(BR=1,(function(){var n;function e(P){var F=0;return function(){return F<P.length?{done:!1,value:P[F++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(P,F,O){return P==Array.prototype||P==Object.prototype||(P[F]=O.value),P};function s(P){P=[typeof globalThis=="object"&&globalThis,P,typeof window=="object"&&window,typeof self=="object"&&self,typeof ff=="object"&&ff];for(var F=0;F<P.length;++F){var O=P[F];if(O&&O.Math==Math)return O}throw Error("Cannot find global object")}var i=s(this);function r(P,F){if(F)e:{var O=i;P=P.split(".");for(var ae=0;ae<P.length-1;ae++){var Se=P[ae];if(!(Se in O))break e;O=O[Se]}P=P[P.length-1],ae=O[P],F=F(ae),F!=ae&&F!=null&&t(O,P,{configurable:!0,writable:!0,value:F})}}r("Symbol",function(P){function F(Ve){if(this instanceof F)throw new TypeError("Symbol is not a constructor");return new O(ae+(Ve||"")+"_"+Se++,Ve)}function O(Ve,Ae){this.g=Ve,t(this,"description",{configurable:!0,writable:!0,value:Ae})}if(P)return P;O.prototype.toString=function(){return this.g};var ae="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",Se=0;return F}),r("Symbol.iterator",function(P){if(P)return P;P=Symbol("Symbol.iterator");for(var F="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),O=0;O<F.length;O++){var ae=i[F[O]];typeof ae=="function"&&typeof ae.prototype[P]!="function"&&t(ae.prototype,P,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return P});function o(P){return P={next:P},P[Symbol.iterator]=function(){return this},P}function a(P){var F=typeof Symbol<"u"&&Symbol.iterator&&P[Symbol.iterator];return F?F.call(P):{next:e(P)}}function l(P){if(!(P instanceof Array)){P=a(P);for(var F,O=[];!(F=P.next()).done;)O.push(F.value);P=O}return P}var c=typeof Object.create=="function"?Object.create:function(P){function F(){}return F.prototype=P,new F},u;if(typeof Object.setPrototypeOf=="function")u=Object.setPrototypeOf;else{var d;e:{var h={a:!0},p={};try{p.__proto__=h,d=p.a;break e}catch{}d=!1}u=d?function(P,F){if(P.__proto__=F,P.__proto__!==F)throw new TypeError(P+" is not extensible");return P}:null}var g=u;function y(P,F){if(P.prototype=c(F.prototype),P.prototype.constructor=P,g)g(P,F);else for(var O in F)if(O!="prototype")if(Object.defineProperties){var ae=Object.getOwnPropertyDescriptor(F,O);ae&&Object.defineProperty(P,O,ae)}else P[O]=F[O];P.ea=F.prototype}function x(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function v(P){if(P.l)throw new TypeError("Generator is already running");P.l=!0}x.prototype.o=function(P){this.h=P};function b(P,F){P.j={U:F,V:!0},P.g=P.m||P.s}x.prototype.return=function(P){this.j={return:P},this.g=this.s};function S(P,F,O){return P.g=O,{value:F}}function C(P){this.g=new x,this.h=P}function E(P,F){v(P.g);var O=P.g.i;return O?k(P,"return"in O?O.return:function(ae){return{value:ae,done:!0}},F,P.g.return):(P.g.return(F),R(P))}function k(P,F,O,ae){try{var Se=F.call(P.g.i,O);if(!(Se instanceof Object))throw new TypeError("Iterator result "+Se+" is not an object");if(!Se.done)return P.g.l=!1,Se;var Ve=Se.value}catch(Ae){return P.g.i=null,b(P.g,Ae),R(P)}return P.g.i=null,ae.call(P.g,Ve),R(P)}function R(P){for(;P.g.g;)try{var F=P.h(P.g);if(F)return P.g.l=!1,{value:F.value,done:!1}}catch(O){P.g.h=void 0,b(P.g,O)}if(P.g.l=!1,P.g.j){if(F=P.g.j,P.g.j=null,F.V)throw F.U;return{value:F.return,done:!0}}return{value:void 0,done:!0}}function L(P){this.next=function(F){return v(P.g),P.g.i?F=k(P,P.g.i.next,F,P.g.o):(P.g.o(F),F=R(P)),F},this.throw=function(F){return v(P.g),P.g.i?F=k(P,P.g.i.throw,F,P.g.o):(b(P.g,F),F=R(P)),F},this.return=function(F){return E(P,F)},this[Symbol.iterator]=function(){return this}}function I(P,F){return F=new L(new C(F)),g&&P.prototype&&g(F,P.prototype),F}function T(P,F){P instanceof String&&(P+="");var O=0,ae=!1,Se={next:function(){if(!ae&&O<P.length){var Ve=O++;return{value:F(Ve,P[Ve]),done:!1}}return ae=!0,{done:!0,value:void 0}}};return Se[Symbol.iterator]=function(){return Se},Se}var M=typeof Object.assign=="function"?Object.assign:function(P,F){for(var O=1;O<arguments.length;O++){var ae=arguments[O];if(ae)for(var Se in ae)Object.prototype.hasOwnProperty.call(ae,Se)&&(P[Se]=ae[Se])}return P};r("Object.assign",function(P){return P||M}),r("Promise",function(P){function F(Ae){this.h=0,this.i=void 0,this.g=[],this.o=!1;var Ge=this.j();try{Ae(Ge.resolve,Ge.reject)}catch(ut){Ge.reject(ut)}}function O(){this.g=null}function ae(Ae){return Ae instanceof F?Ae:new F(function(Ge){Ge(Ae)})}if(P)return P;O.prototype.h=function(Ae){if(this.g==null){this.g=[];var Ge=this;this.i(function(){Ge.l()})}this.g.push(Ae)};var Se=i.setTimeout;O.prototype.i=function(Ae){Se(Ae,0)},O.prototype.l=function(){for(;this.g&&this.g.length;){var Ae=this.g;this.g=[];for(var Ge=0;Ge<Ae.length;++Ge){var ut=Ae[Ge];Ae[Ge]=null;try{ut()}catch(Tt){this.j(Tt)}}}this.g=null},O.prototype.j=function(Ae){this.i(function(){throw Ae})},F.prototype.j=function(){function Ae(Tt){return function(kn){ut||(ut=!0,Tt.call(Ge,kn))}}var Ge=this,ut=!1;return{resolve:Ae(this.C),reject:Ae(this.l)}},F.prototype.C=function(Ae){if(Ae===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(Ae instanceof F)this.F(Ae);else{e:switch(typeof Ae){case"object":var Ge=Ae!=null;break e;case"function":Ge=!0;break e;default:Ge=!1}Ge?this.u(Ae):this.m(Ae)}},F.prototype.u=function(Ae){var Ge=void 0;try{Ge=Ae.then}catch(ut){this.l(ut);return}typeof Ge=="function"?this.G(Ge,Ae):this.m(Ae)},F.prototype.l=function(Ae){this.s(2,Ae)},F.prototype.m=function(Ae){this.s(1,Ae)},F.prototype.s=function(Ae,Ge){if(this.h!=0)throw Error("Cannot settle("+Ae+", "+Ge+"): Promise already settled in state"+this.h);this.h=Ae,this.i=Ge,this.h===2&&this.D(),this.A()},F.prototype.D=function(){var Ae=this;Se(function(){if(Ae.B()){var Ge=i.console;typeof Ge<"u"&&Ge.error(Ae.i)}},1)},F.prototype.B=function(){if(this.o)return!1;var Ae=i.CustomEvent,Ge=i.Event,ut=i.dispatchEvent;return typeof ut>"u"?!0:(typeof Ae=="function"?Ae=new Ae("unhandledrejection",{cancelable:!0}):typeof Ge=="function"?Ae=new Ge("unhandledrejection",{cancelable:!0}):(Ae=i.document.createEvent("CustomEvent"),Ae.initCustomEvent("unhandledrejection",!1,!0,Ae)),Ae.promise=this,Ae.reason=this.i,ut(Ae))},F.prototype.A=function(){if(this.g!=null){for(var Ae=0;Ae<this.g.length;++Ae)Ve.h(this.g[Ae]);this.g=null}};var Ve=new O;return F.prototype.F=function(Ae){var Ge=this.j();Ae.J(Ge.resolve,Ge.reject)},F.prototype.G=function(Ae,Ge){var ut=this.j();try{Ae.call(Ge,ut.resolve,ut.reject)}catch(Tt){ut.reject(Tt)}},F.prototype.then=function(Ae,Ge){function ut(Xn,Wn){return typeof Xn=="function"?function(ln){try{Tt(Xn(ln))}catch(A){kn(A)}}:Wn}var Tt,kn,jn=new F(function(Xn,Wn){Tt=Xn,kn=Wn});return this.J(ut(Ae,Tt),ut(Ge,kn)),jn},F.prototype.catch=function(Ae){return this.then(void 0,Ae)},F.prototype.J=function(Ae,Ge){function ut(){switch(Tt.h){case 1:Ae(Tt.i);break;case 2:Ge(Tt.i);break;default:throw Error("Unexpected state: "+Tt.h)}}var Tt=this;this.g==null?Ve.h(ut):this.g.push(ut),this.o=!0},F.resolve=ae,F.reject=function(Ae){return new F(function(Ge,ut){ut(Ae)})},F.race=function(Ae){return new F(function(Ge,ut){for(var Tt=a(Ae),kn=Tt.next();!kn.done;kn=Tt.next())ae(kn.value).J(Ge,ut)})},F.all=function(Ae){var Ge=a(Ae),ut=Ge.next();return ut.done?ae([]):new F(function(Tt,kn){function jn(ln){return function(A){Xn[ln]=A,Wn--,Wn==0&&Tt(Xn)}}var Xn=[],Wn=0;do Xn.push(void 0),Wn++,ae(ut.value).J(jn(Xn.length-1),kn),ut=Ge.next();while(!ut.done)})},F}),r("Object.is",function(P){return P||function(F,O){return F===O?F!==0||1/F===1/O:F!==F&&O!==O}}),r("Array.prototype.includes",function(P){return P||function(F,O){var ae=this;ae instanceof String&&(ae=String(ae));var Se=ae.length;for(O=O||0,0>O&&(O=Math.max(O+Se,0));O<Se;O++){var Ve=ae[O];if(Ve===F||Object.is(Ve,F))return!0}return!1}}),r("String.prototype.includes",function(P){return P||function(F,O){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(F instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(F,O||0)!==-1}}),r("Array.prototype.keys",function(P){return P||function(){return T(this,function(F){return F})}});var j=this||self;function W(P,F){P=P.split(".");var O=j;P[0]in O||typeof O.execScript>"u"||O.execScript("var "+P[0]);for(var ae;P.length&&(ae=P.shift());)P.length||F===void 0?O[ae]&&O[ae]!==Object.prototype[ae]?O=O[ae]:O=O[ae]={}:O[ae]=F}function z(P,F){return F=String.fromCharCode.apply(null,F),P==null?F:P+F}var X,B=typeof TextDecoder<"u",J,K=typeof TextEncoder<"u";function ee(P){if(K)P=(J||(J=new TextEncoder)).encode(P);else{var F=void 0;F=F===void 0?!1:F;for(var O=0,ae=new Uint8Array(3*P.length),Se=0;Se<P.length;Se++){var Ve=P.charCodeAt(Se);if(128>Ve)ae[O++]=Ve;else{if(2048>Ve)ae[O++]=Ve>>6|192;else{if(55296<=Ve&&57343>=Ve){if(56319>=Ve&&Se<P.length){var Ae=P.charCodeAt(++Se);if(56320<=Ae&&57343>=Ae){Ve=1024*(Ve-55296)+Ae-56320+65536,ae[O++]=Ve>>18|240,ae[O++]=Ve>>12&63|128,ae[O++]=Ve>>6&63|128,ae[O++]=Ve&63|128;continue}else Se--}if(F)throw Error("Found an unpaired surrogate");Ve=65533}ae[O++]=Ve>>12|224,ae[O++]=Ve>>6&63|128}ae[O++]=Ve&63|128}}P=ae.subarray(0,O)}return P}var ne={},V=null;function Z(P,F){F===void 0&&(F=0),be(),F=ne[F];for(var O=Array(Math.floor(P.length/3)),ae=F[64]||"",Se=0,Ve=0;Se<P.length-2;Se+=3){var Ae=P[Se],Ge=P[Se+1],ut=P[Se+2],Tt=F[Ae>>2];Ae=F[(Ae&3)<<4|Ge>>4],Ge=F[(Ge&15)<<2|ut>>6],ut=F[ut&63],O[Ve++]=Tt+Ae+Ge+ut}switch(Tt=0,ut=ae,P.length-Se){case 2:Tt=P[Se+1],ut=F[(Tt&15)<<2]||ae;case 1:P=P[Se],O[Ve]=F[P>>2]+F[(P&3)<<4|Tt>>4]+ut+ae}return O.join("")}function he(P){var F=P.length,O=3*F/4;O%3?O=Math.floor(O):"=.".indexOf(P[F-1])!=-1&&(O="=.".indexOf(P[F-2])!=-1?O-2:O-1);var ae=new Uint8Array(O),Se=0;return ve(P,function(Ve){ae[Se++]=Ve}),ae.subarray(0,Se)}function ve(P,F){function O(ut){for(;ae<P.length;){var Tt=P.charAt(ae++),kn=V[Tt];if(kn!=null)return kn;if(!/^[\s\xa0]*$/.test(Tt))throw Error("Unknown base64 encoding at char: "+Tt)}return ut}be();for(var ae=0;;){var Se=O(-1),Ve=O(0),Ae=O(64),Ge=O(64);if(Ge===64&&Se===-1)break;F(Se<<2|Ve>>4),Ae!=64&&(F(Ve<<4&240|Ae>>2),Ge!=64&&F(Ae<<6&192|Ge))}}function be(){if(!V){V={};for(var P="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),F=["+/=","+/","-_=","-_.","-_"],O=0;5>O;O++){var ae=P.concat(F[O].split(""));ne[O]=ae;for(var Se=0;Se<ae.length;Se++){var Ve=ae[Se];V[Ve]===void 0&&(V[Ve]=Se)}}}}var Ie=typeof Uint8Array.prototype.slice=="function",Xe;function Fe(P,F,O){return F===O?Xe||(Xe=new Uint8Array(0)):Ie?P.slice(F,O):new Uint8Array(P.subarray(F,O))}var Pe=0,ct=0;function at(P,F){F=F===void 0?{}:F,F=F.v===void 0?!1:F.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=F,P&&Ee(this,P)}function Ee(P,F){F=F.constructor===Uint8Array?F:F.constructor===ArrayBuffer?new Uint8Array(F):F.constructor===Array?new Uint8Array(F):F.constructor===String?he(F):F instanceof Uint8Array?new Uint8Array(F.buffer,F.byteOffset,F.byteLength):new Uint8Array(0),P.h=F,P.l=0,P.j=P.h.length,P.g=P.l}at.prototype.reset=function(){this.g=this.l};function nn(P){for(var F=128,O=0,ae=0,Se=0;4>Se&&128<=F;Se++)F=P.h[P.g++],O|=(F&127)<<7*Se;if(128<=F&&(F=P.h[P.g++],O|=(F&127)<<28,ae|=(F&127)>>4),128<=F)for(Se=0;5>Se&&128<=F;Se++)F=P.h[P.g++],ae|=(F&127)<<7*Se+3;if(128>F)return P=O>>>0,F=ae>>>0,(ae=F&2147483648)&&(P=~P+1>>>0,F=~F>>>0,P==0&&(F=F+1>>>0)),P=4294967296*F+(P>>>0),ae?-P:P;P.m=!0}at.prototype.i=function(){var P=this.h,F=P[this.g],O=F&127;return 128>F?(this.g+=1,O):(F=P[this.g+1],O|=(F&127)<<7,128>F?(this.g+=2,O):(F=P[this.g+2],O|=(F&127)<<14,128>F?(this.g+=3,O):(F=P[this.g+3],O|=(F&127)<<21,128>F?(this.g+=4,O):(F=P[this.g+4],O|=(F&15)<<28,128>F?(this.g+=5,O>>>0):(this.g+=5,128<=P[this.g++]&&128<=P[this.g++]&&128<=P[this.g++]&&128<=P[this.g++]&&this.g++,O)))))},at.prototype.o=function(){var P=this.h[this.g],F=this.h[this.g+1],O=this.h[this.g+2],ae=this.h[this.g+3];return this.g+=4,O=(P<<0|F<<8|O<<16|ae<<24)>>>0,P=2*(O>>31)+1,F=O>>>23&255,O&=8388607,F==255?O?NaN:1/0*P:F==0?P*Math.pow(2,-149)*O:P*Math.pow(2,F-150)*(O+Math.pow(2,23))};var gt=[];function vt(){this.g=new Uint8Array(64),this.h=0}vt.prototype.push=function(P){if(!(this.h+1<this.g.length)){var F=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(F)}this.g[this.h++]=P},vt.prototype.length=function(){return this.h},vt.prototype.end=function(){var P=this.g,F=this.h;return this.h=0,Fe(P,0,F)};function wt(P,F){for(;127<F;)P.push(F&127|128),F>>>=7;P.push(F)}function Vt(P){var F={},O=F.N===void 0?!1:F.N;this.o={v:F.v===void 0?!1:F.v},this.N=O,F=this.o,gt.length?(O=gt.pop(),F&&(O.v=F.v),P&&Ee(O,P),P=O):P=new at(P,F),this.g=P,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}Vt.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function It(P){var F=P.g;if((F=F.g==F.j)||(F=P.j)||(F=P.g,F=F.m||0>F.g||F.g>F.j),F)return!1;P.m=P.g.g,F=P.g.i();var O=F&7;return O!=0&&O!=5&&O!=1&&O!=2&&O!=3&&O!=4?(P.j=!0,!1):(P.i=F,P.l=F>>>3,P.h=O,!0)}function zt(P){switch(P.h){case 0:if(P.h!=0)zt(P);else{for(P=P.g;P.h[P.g]&128;)P.g++;P.g++}break;case 1:P.h!=1?zt(P):(P=P.g,P.g+=8);break;case 2:if(P.h!=2)zt(P);else{var F=P.g.i();P=P.g,P.g+=F}break;case 5:P.h!=5?zt(P):(P=P.g,P.g+=4);break;case 3:F=P.l;do{if(!It(P)){P.j=!0;break}if(P.h==4){P.l!=F&&(P.j=!0);break}zt(P)}while(!0);break;default:P.j=!0}}function Gt(P,F,O){var ae=P.g.j,Se=P.g.i(),Ve=P.g.g+Se;if(P.g.j=Ve,O(F,P),O=Ve-P.g.g,O!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+Se+" bytes, instead read "+(Se-O)+" bytes, either the data ended unexpectedly or the message misreported its own length");return P.g.g=Ve,P.g.j=ae,F}function dn(P){return P.g.o()}function vn(P){var F=P.g.i();P=P.g;var O=P.g;P.g+=F,P=P.h;var ae;if(B)(ae=X)||(ae=X=new TextDecoder("utf-8",{fatal:!1})),ae=ae.decode(P.subarray(O,O+F));else{F=O+F;for(var Se=[],Ve=null,Ae,Ge,ut;O<F;)Ae=P[O++],128>Ae?Se.push(Ae):224>Ae?O>=F?Se.push(65533):(Ge=P[O++],194>Ae||(Ge&192)!==128?(O--,Se.push(65533)):Se.push((Ae&31)<<6|Ge&63)):240>Ae?O>=F-1?Se.push(65533):(Ge=P[O++],(Ge&192)!==128||Ae===224&&160>Ge||Ae===237&&160<=Ge||((ae=P[O++])&192)!==128?(O--,Se.push(65533)):Se.push((Ae&15)<<12|(Ge&63)<<6|ae&63)):244>=Ae?O>=F-2?Se.push(65533):(Ge=P[O++],(Ge&192)!==128||(Ae<<28)+(Ge-144)>>30!==0||((ae=P[O++])&192)!==128||((ut=P[O++])&192)!==128?(O--,Se.push(65533)):(Ae=(Ae&7)<<18|(Ge&63)<<12|(ae&63)<<6|ut&63,Ae-=65536,Se.push((Ae>>10&1023)+55296,(Ae&1023)+56320))):Se.push(65533),8192<=Se.length&&(Ve=z(Ve,Se),Se.length=0);ae=z(Ve,Se)}return ae}function ce(P,F,O){var ae=P.g.i();for(ae=P.g.g+ae;P.g.g<ae;)O.push(F.call(P.g))}function Y(P,F){P.h==2?ce(P,at.prototype.o,F):F.push(dn(P))}function ye(){this.h=[],this.i=0,this.g=new vt}function Qe(P,F){F.length!==0&&(P.h.push(F),P.i+=F.length)}function tt(P){var F=P.i+P.g.length();if(F===0)return new Uint8Array(0);F=new Uint8Array(F);for(var O=P.h,ae=O.length,Se=0,Ve=0;Ve<ae;Ve++){var Ae=O[Ve];Ae.length!==0&&(F.set(Ae,Se),Se+=Ae.length)}return O=P.g,ae=O.h,ae!==0&&(F.set(O.g.subarray(0,ae),Se),O.h=0),P.h=[F],F}function rt(P,F,O){if(O!=null){wt(P.g,8*F+5),P=P.g;var ae=O;ae=(O=0>ae?1:0)?-ae:ae,ae===0?0<1/ae?Pe=ct=0:(ct=0,Pe=2147483648):isNaN(ae)?(ct=0,Pe=2147483647):34028234663852886e22<ae?(ct=0,Pe=(O<<31|2139095040)>>>0):11754943508222875e-54>ae?(ae=Math.round(ae/Math.pow(2,-149)),ct=0,Pe=(O<<31|ae)>>>0):(F=Math.floor(Math.log(ae)/Math.LN2),ae*=Math.pow(2,-F),ae=Math.round(8388608*ae),16777216<=ae&&++F,ct=0,Pe=(O<<31|F+127<<23|ae&8388607)>>>0),O=Pe,P.push(O>>>0&255),P.push(O>>>8&255),P.push(O>>>16&255),P.push(O>>>24&255)}}var Pt=typeof Uint8Array=="function";function pt(P,F,O){if(P!=null)return typeof P=="object"?Pt&&P instanceof Uint8Array?O(P):At(P,F,O):F(P)}function At(P,F,O){if(Array.isArray(P)){for(var ae=Array(P.length),Se=0;Se<P.length;Se++)ae[Se]=pt(P[Se],F,O);return Array.isArray(P)&&P.W&&Ye(ae),ae}ae={};for(Se in P)ae[Se]=pt(P[Se],F,O);return ae}function xe(P){return typeof P=="number"?isFinite(P)?P:String(P):P}var xt={W:{value:!0,configurable:!0}};function Ye(P){return Array.isArray(P)&&!Object.isFrozen(P)&&Object.defineProperties(P,xt),P}var kt;function Et(P,F,O){var ae=kt;kt=null,P||(P=ae),ae=this.constructor.ca,P||(P=ae?[ae]:[]),this.j=ae?0:-1,this.m=this.g=null,this.h=P;e:{if(ae=this.h.length,P=ae-1,ae&&(ae=this.h[P],!(ae===null||typeof ae!="object"||Array.isArray(ae)||Pt&&ae instanceof Uint8Array))){this.l=P-this.j,this.i=ae;break e}F!==void 0&&-1<F?(this.l=Math.max(F,P+1-this.j),this.i=null):this.l=Number.MAX_VALUE}if(O)for(F=0;F<O.length;F++)P=O[F],P<this.l?(P+=this.j,(ae=this.h[P])?Ye(ae):this.h[P]=bt):(Wt(this),(ae=this.i[P])?Ye(ae):this.i[P]=bt)}var bt=Object.freeze(Ye([]));function Wt(P){var F=P.l+P.j;P.h[F]||(P.i=P.h[F]={})}function ht(P,F,O){return F===-1?null:O!==void 0&&O||F>=P.l?P.i?P.i[F]:void 0:P.h[F+P.j]}function Ht(P,F){var O=O===void 0?!1:O,ae=ht(P,F,O);return ae==null&&(ae=bt),ae===bt&&(ae=Ye([]),Be(P,F,ae,O)),ae}function Ce(P){var F=Ht(P,3);if(P.m||(P.m={}),!P.m[3]){for(var O=0;O<F.length;O++)F[O]=+F[O];P.m[3]=!0}return F}function St(P,F,O){return P=ht(P,F),P??O}function dt(P,F,O){return P=ht(P,F),P=P==null?P:+P,P??(O===void 0?0:O)}function Be(P,F,O,ae){ae!==void 0&&ae||F>=P.l?(Wt(P),P.i[F]=O):P.h[F+P.j]=O}function Rt(P,F,O){if(O===-1)return null;if(P.g||(P.g={}),!P.g[O]){var ae=ht(P,O,!1);ae&&(P.g[O]=new F(ae))}return P.g[O]}function rn(P,F){P.g||(P.g={});var O=P.g[1];if(!O){var ae=Ht(P,1);O=[];for(var Se=0;Se<ae.length;Se++)O[Se]=new F(ae[Se]);P.g[1]=O}return O}function In(P,F,O){var ae=ae===void 0?!1:ae;P.g||(P.g={});var Se=O&&_s(O);P.g[F]=O,Be(P,F,Se,ae)}function zn(P,F,O,ae){var Se=rn(P,O);F=F||new O,P=Ht(P,1),ae!=null?(Se.splice(ae,0,F),P.splice(ae,0,_s(F))):(Se.push(F),P.push(_s(F)))}Et.prototype.toJSON=function(){var P=_s(this);return At(P,xe,Z)};function _s(P,F){if(P.g)for(var O in P.g){var ae=P.g[O];if(Array.isArray(ae))for(var Se=0;Se<ae.length;Se++)ae[Se]&&_s(ae[Se]);else ae&&_s(ae)}return P.h}Et.prototype.toString=function(){return _s(this).toString()};function ns(P,F){if(P=P.o){Qe(F,F.g.end());for(var O=0;O<P.length;O++)Qe(F,P[O])}}function hs(P,F){if(F.h==4)return!1;var O=F.m;return zt(F),F.N||(F=Fe(F.g.h,O,F.g.g),(O=P.o)?O.push(F):P.o=[F]),!0}function Ls(P){Et.call(this,P,-1,So)}y(Ls,Et),Ls.prototype.getRows=function(){return ht(this,1)},Ls.prototype.getCols=function(){return ht(this,2)},Ls.prototype.getPackedDataList=function(){return Ce(this)},Ls.prototype.getLayout=function(){return St(this,4,0)};function Or(P,F){for(;It(F);)switch(F.i){case 8:var O=F.g.i();Be(P,1,O);break;case 16:O=F.g.i(),Be(P,2,O);break;case 29:case 26:Y(F,P.getPackedDataList());break;case 32:O=nn(F.g),Be(P,4,O);break;default:if(!hs(P,F))return P}return P}var So=[3];function ks(P,F){var O=void 0;return new(O||(O=Promise))(function(ae,Se){function Ve(ut){try{Ge(F.next(ut))}catch(Tt){Se(Tt)}}function Ae(ut){try{Ge(F.throw(ut))}catch(Tt){Se(Tt)}}function Ge(ut){ut.done?ae(ut.value):new O(function(Tt){Tt(ut.value)}).then(Ve,Ae)}Ge((F=F.apply(P,void 0)).next())})}function Ri(P){Et.call(this,P)}y(Ri,Et);function fr(P,F){for(;It(F);)switch(F.i){case 8:var O=F.g.i();Be(P,1,O);break;case 21:O=dn(F),Be(P,2,O);break;case 26:O=vn(F),Be(P,3,O);break;case 34:O=vn(F),Be(P,4,O);break;default:if(!hs(P,F))return P}return P}function no(P){Et.call(this,P,-1,ua)}y(no,Et),no.prototype.addClassification=function(P,F){return zn(this,P,Ri,F),this};var ua=[1];function so(P){Et.call(this,P)}y(so,Et);function pr(P,F){for(;It(F);)switch(F.i){case 13:var O=dn(F);Be(P,1,O);break;case 21:O=dn(F),Be(P,2,O);break;case 29:O=dn(F),Be(P,3,O);break;case 37:O=dn(F),Be(P,4,O);break;case 45:O=dn(F),Be(P,5,O);break;default:if(!hs(P,F))return P}return P}function Co(P){Et.call(this,P,-1,We)}y(Co,Et);function oe(P){e:{var F=new Co;for(P=new Vt(P);It(P);)switch(P.i){case 10:var O=Gt(P,new so,pr);zn(F,O,so,void 0);break;default:if(!hs(F,P))break e}}return F}var We=[1];function Ze(P){Et.call(this,P)}y(Ze,Et);function Je(P){Et.call(this,P,-1,Kt)}y(Je,Et),Je.prototype.getVertexType=function(){return St(this,1,0)},Je.prototype.getPrimitiveType=function(){return St(this,2,0)},Je.prototype.getVertexBufferList=function(){return Ce(this)},Je.prototype.getIndexBufferList=function(){return Ht(this,4)};function nt(P,F){for(;It(F);)switch(F.i){case 8:var O=nn(F.g);Be(P,1,O);break;case 16:O=nn(F.g),Be(P,2,O);break;case 29:case 26:Y(F,P.getVertexBufferList());break;case 32:case 34:O=F;var ae=P.getIndexBufferList();O.h==2?ce(O,at.prototype.i,ae):ae.push(O.g.i());break;default:if(!hs(P,F))return P}return P}var Kt=[3,4];function on(P){Et.call(this,P)}y(on,Et),on.prototype.getMesh=function(){return Rt(this,Je,1)},on.prototype.getPoseTransformMatrix=function(){return Rt(this,Ls,2)};function bn(P){e:{var F=new on;for(P=new Vt(P);It(P);)switch(P.i){case 10:var O=Gt(P,new Je,nt);In(F,1,O);break;case 18:O=Gt(P,new Ls,Or),In(F,2,O);break;default:if(!hs(F,P))break e}}return F}function Yt(P,F,O){if(O=P.createShader(O===0?P.VERTEX_SHADER:P.FRAGMENT_SHADER),P.shaderSource(O,F),P.compileShader(O),!P.getShaderParameter(O,P.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+P.getShaderInfoLog(O));return O}function Bn(P){return rn(P,Ri).map(function(F){return{index:St(F,1,0),Y:dt(F,2),label:ht(F,3)!=null?St(F,3,""):void 0,displayName:ht(F,4)!=null?St(F,4,""):void 0}})}function _n(P){return{x:dt(P,1),y:dt(P,2),z:dt(P,3),visibility:ht(P,4)!=null?dt(P,4):void 0}}function En(P,F){this.h=P,this.g=F,this.l=0}function fs(P,F,O){return ws(P,F),typeof P.g.canvas.transferToImageBitmap=="function"?Promise.resolve(P.g.canvas.transferToImageBitmap()):O?Promise.resolve(P.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(P.g.canvas):(P.i===void 0&&(P.i=document.createElement("canvas")),new Promise(function(ae){P.i.height=P.g.canvas.height,P.i.width=P.g.canvas.width,P.i.getContext("2d",{}).drawImage(P.g.canvas,0,0,P.g.canvas.width,P.g.canvas.height),ae(P.i)}))}function ws(P,F){var O=P.g;if(P.m===void 0){var ae=Yt(O,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),Se=Yt(O,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),Ve=O.createProgram();if(O.attachShader(Ve,ae),O.attachShader(Ve,Se),O.linkProgram(Ve),!O.getProgramParameter(Ve,O.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+O.getProgramInfoLog(Ve));ae=P.m=Ve,O.useProgram(ae),Se=O.getUniformLocation(ae,"sampler0"),P.j={I:O.getAttribLocation(ae,"aVertex"),H:O.getAttribLocation(ae,"aTex"),da:Se},P.s=O.createBuffer(),O.bindBuffer(O.ARRAY_BUFFER,P.s),O.enableVertexAttribArray(P.j.I),O.vertexAttribPointer(P.j.I,2,O.FLOAT,!1,0,0),O.bufferData(O.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),O.STATIC_DRAW),O.bindBuffer(O.ARRAY_BUFFER,null),P.o=O.createBuffer(),O.bindBuffer(O.ARRAY_BUFFER,P.o),O.enableVertexAttribArray(P.j.H),O.vertexAttribPointer(P.j.H,2,O.FLOAT,!1,0,0),O.bufferData(O.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),O.STATIC_DRAW),O.bindBuffer(O.ARRAY_BUFFER,null),O.uniform1i(Se,0)}ae=P.j,O.useProgram(P.m),O.canvas.width=F.width,O.canvas.height=F.height,O.viewport(0,0,F.width,F.height),O.activeTexture(O.TEXTURE0),P.h.bindTexture2d(F.glName),O.enableVertexAttribArray(ae.I),O.bindBuffer(O.ARRAY_BUFFER,P.s),O.vertexAttribPointer(ae.I,2,O.FLOAT,!1,0,0),O.enableVertexAttribArray(ae.H),O.bindBuffer(O.ARRAY_BUFFER,P.o),O.vertexAttribPointer(ae.H,2,O.FLOAT,!1,0,0),O.bindFramebuffer(O.DRAW_FRAMEBUFFER?O.DRAW_FRAMEBUFFER:O.FRAMEBUFFER,null),O.clearColor(0,0,0,0),O.clear(O.COLOR_BUFFER_BIT),O.colorMask(!0,!0,!0,!0),O.drawArrays(O.TRIANGLE_FAN,0,4),O.disableVertexAttribArray(ae.I),O.disableVertexAttribArray(ae.H),O.bindBuffer(O.ARRAY_BUFFER,null),P.h.bindTexture2d(0)}function Ws(P){this.g=P}var Mi=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ss(P,F){return F+P}function Vn(P,F){window[P]=F}function Ss(P){var F=document.createElement("script");return F.setAttribute("src",P),F.setAttribute("crossorigin","anonymous"),new Promise(function(O){F.addEventListener("load",function(){O()},!1),F.addEventListener("error",function(){O()},!1),document.body.appendChild(F)})}function D(){return ks(this,function P(){return I(P,function(F){switch(F.g){case 1:return F.m=2,S(F,WebAssembly.instantiate(Mi),4);case 4:F.g=3,F.m=0;break;case 2:return F.m=0,F.j=null,F.return(!1);case 3:return F.return(!0)}})})}function H(P){if(this.g=P,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=P&&P.locateFile||ss,typeof window=="object")var F=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")F=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=F,P.options){F=a(Object.keys(P.options));for(var O=F.next();!O.done;O=F.next()){O=O.value;var ae=P.options[O].default;ae!==void 0&&(this.j[O]=typeof ae=="function"?ae():ae)}}}n=H.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function q(P,F){return P.g.files===void 0?[]:typeof P.g.files=="function"?P.g.files(F):P.g.files}function pe(P){return ks(P,function F(){var O=this,ae,Se,Ve,Ae,Ge,ut,Tt,kn,jn,Xn,Wn;return I(F,function(ln){switch(ln.g){case 1:return ae=O,O.R?(Se=q(O,O.j),S(ln,D(),2)):ln.return();case 2:if(Ve=ln.h,typeof window=="object")return Vn("createMediapipeSolutionsWasm",{locateFile:O.locateFile}),Vn("createMediapipeSolutionsPackedAssets",{locateFile:O.locateFile}),ut=Se.filter(function(A){return A.data!==void 0}),Tt=Se.filter(function(A){return A.data===void 0}),kn=Promise.all(ut.map(function(A){var U=Ue(ae,A.url);if(A.path!==void 0){var Q=A.path;U=U.then(function(ie){return ae.overrideFile(Q,ie),Promise.resolve(ie)})}return U})),jn=Promise.all(Tt.map(function(A){return A.simd===void 0||A.simd&&Ve||!A.simd&&!Ve?Ss(ae.locateFile(A.url,ae.S)):Promise.resolve()})).then(function(){return ks(ae,function A(){var U,Q,ie=this;return I(A,function(de){if(de.g==1)return U=window.createMediapipeSolutionsWasm,Q=window.createMediapipeSolutionsPackedAssets,S(de,U(Q),2);ie.h=de.h,de.g=0})})}),Xn=function(){return ks(ae,function A(){var U=this;return I(A,function(Q){return U.g.graph&&U.g.graph.url?Q=S(Q,Ue(U,U.g.graph.url),0):(Q.g=0,Q=void 0),Q})})}(),S(ln,Promise.all([jn,kn,Xn]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return Ae=Se.filter(function(A){return A.simd===void 0||A.simd&&Ve||!A.simd&&!Ve}).map(function(A){return ae.locateFile(A.url,ae.S)}),importScripts.apply(null,l(Ae)),S(ln,createMediapipeSolutionsWasm(Module),6);case 6:O.h=ln.h,O.l=new OffscreenCanvas(1,1),O.h.canvas=O.l,Ge=O.h.GL.createContext(O.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),O.h.GL.makeContextCurrent(Ge),ln.g=4;break;case 7:if(O.l=document.createElement("canvas"),Wn=O.l.getContext("webgl2",{}),!Wn&&(Wn=O.l.getContext("webgl",{}),!Wn))return alert("Failed to create WebGL canvas context when passing video frame."),ln.return();O.D=Wn,O.h.canvas=O.l,O.h.createContext(O.l,!0,!0,{});case 4:O.i=new O.h.SolutionWasm,O.R=!1,ln.g=0}})})}function Oe(P){return ks(P,function F(){var O=this,ae,Se,Ve,Ae,Ge,ut,Tt,kn;return I(F,function(jn){if(jn.g==1){if(O.g.graph&&O.g.graph.url&&O.P===O.g.graph.url)return jn.return();if(O.o=!0,!O.g.graph||!O.g.graph.url){jn.g=2;return}return O.P=O.g.graph.url,S(jn,Ue(O,O.g.graph.url),3)}for(jn.g!=2&&(ae=jn.h,O.i.loadGraph(ae)),Se=a(Object.keys(O.B)),Ve=Se.next();!Ve.done;Ve=Se.next())Ae=Ve.value,O.i.overrideFile(Ae,O.B[Ae]);if(O.B={},O.g.listeners)for(Ge=a(O.g.listeners),ut=Ge.next();!ut.done;ut=Ge.next())Tt=ut.value,qt(O,Tt);kn=O.j,O.j={},O.setOptions(kn),jn.g=0})})}n.reset=function(){return ks(this,function P(){var F=this;return I(P,function(O){F.i&&(F.i.reset(),F.m={},F.s={}),O.g=0})})},n.setOptions=function(P,F){var O=this;if(F=F||this.g.options){for(var ae=[],Se=[],Ve={},Ae=a(Object.keys(P)),Ge=Ae.next();!Ge.done;Ve={K:Ve.K,L:Ve.L},Ge=Ae.next()){var ut=Ge.value;ut in this.j&&this.j[ut]===P[ut]||(this.j[ut]=P[ut],Ge=F[ut],Ge!==void 0&&(Ge.onChange&&(Ve.K=Ge.onChange,Ve.L=P[ut],ae.push(function(Tt){return function(){return ks(O,function kn(){var jn,Xn=this;return I(kn,function(Wn){if(Wn.g==1)return S(Wn,Tt.K(Tt.L),2);jn=Wn.h,jn===!0&&(Xn.o=!0),Wn.g=0})})}}(Ve))),Ge.graphOptionXref&&(ut={valueNumber:Ge.type===1?P[ut]:0,valueBoolean:Ge.type===0?P[ut]:!1,valueString:Ge.type===2?P[ut]:""},Ge=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),Ge.graphOptionXref),ut),Se.push(Ge))))}(ae.length!==0||Se.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(Se),this.u=(this.u===void 0?[]:this.u).concat(ae))}};function st(P){return ks(P,function F(){var O=this,ae,Se,Ve,Ae,Ge,ut,Tt;return I(F,function(kn){switch(kn.g){case 1:if(!O.o)return kn.return();if(!O.u){kn.g=2;break}ae=a(O.u),Se=ae.next();case 3:if(Se.done){kn.g=5;break}return Ve=Se.value,S(kn,Ve(),4);case 4:Se=ae.next(),kn.g=3;break;case 5:O.u=void 0;case 2:if(O.A){for(Ae=new O.h.GraphOptionChangeRequestList,Ge=a(O.A),ut=Ge.next();!ut.done;ut=Ge.next())Tt=ut.value,Ae.push_back(Tt);O.i.changeOptions(Ae),Ae.delete(),O.A=void 0}O.o=!1,kn.g=0}})})}n.initialize=function(){return ks(this,function P(){var F=this;return I(P,function(O){return O.g==1?S(O,pe(F),2):O.g!=3?S(O,Oe(F),3):S(O,st(F),0)})})};function Ue(P,F){return ks(P,function O(){var ae=this,Se,Ve;return I(O,function(Ae){return F in ae.F?Ae.return(ae.F[F]):(Se=ae.locateFile(F,""),Ve=fetch(Se).then(function(Ge){return Ge.arrayBuffer()}),ae.F[F]=Ve,Ae.return(Ve))})})}n.overrideFile=function(P,F){this.i?this.i.overrideFile(P,F):this.B[P]=F},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(P,F){return ks(this,function O(){var ae=this,Se,Ve,Ae,Ge,ut,Tt,kn,jn,Xn;return I(O,function(Wn){switch(Wn.g){case 1:return ae.g.inputs?(Se=1e3*(F??performance.now()),S(Wn,ae.C,2)):Wn.return();case 2:return S(Wn,ae.initialize(),3);case 3:for(Ve=new ae.h.PacketDataList,Ae=a(Object.keys(P)),Ge=Ae.next();!Ge.done;Ge=Ae.next())if(ut=Ge.value,Tt=ae.g.inputs[ut]){e:{var ln=ae,A=P[ut];switch(Tt.type){case"video":var U=ln.m[Tt.stream];if(U||(U=new En(ln.h,ln.D),ln.m[Tt.stream]=U),ln=U,ln.l===0&&(ln.l=ln.h.createTexture()),typeof HTMLVideoElement<"u"&&A instanceof HTMLVideoElement){var Q=A.videoWidth;U=A.videoHeight}else typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement?(Q=A.naturalWidth,U=A.naturalHeight):(Q=A.width,U=A.height);U={glName:ln.l,width:Q,height:U},Q=ln.g,Q.canvas.width=U.width,Q.canvas.height=U.height,Q.activeTexture(Q.TEXTURE0),ln.h.bindTexture2d(ln.l),Q.texImage2D(Q.TEXTURE_2D,0,Q.RGBA,Q.RGBA,Q.UNSIGNED_BYTE,A),ln.h.bindTexture2d(0),ln=U;break e;case"detections":for(U=ln.m[Tt.stream],U||(U=new Ws(ln.h),ln.m[Tt.stream]=U),ln=U,ln.data||(ln.data=new ln.g.DetectionListData),ln.data.reset(A.length),U=0;U<A.length;++U){Q=A[U];var ie=ln.data,de=ie.setBoundingBox,ue=U,fe=Q.T,we=new Ze;Be(we,1,fe.Z),Be(we,2,fe.$),Be(we,3,fe.height),Be(we,4,fe.width),Be(we,5,fe.rotation),Be(we,6,fe.X);var Ke=fe=new ye;rt(Ke,1,ht(we,1)),rt(Ke,2,ht(we,2)),rt(Ke,3,ht(we,3)),rt(Ke,4,ht(we,4)),rt(Ke,5,ht(we,5));var lt=ht(we,6);if(lt!=null&&lt!=null){wt(Ke.g,48);var ft=Ke.g,Dt=lt;lt=0>Dt,Dt=Math.abs(Dt);var Ft=Dt>>>0;for(Dt=Math.floor((Dt-Ft)/4294967296),Dt>>>=0,lt&&(Dt=~Dt>>>0,Ft=(~Ft>>>0)+1,4294967295<Ft&&(Ft=0,Dt++,4294967295<Dt&&(Dt=0))),Pe=Ft,ct=Dt,lt=Pe,Ft=ct;0<Ft||127<lt;)ft.push(lt&127|128),lt=(lt>>>7|Ft<<25)>>>0,Ft>>>=7;ft.push(lt)}if(ns(we,Ke),fe=tt(fe),de.call(ie,ue,fe),Q.O)for(ie=0;ie<Q.O.length;++ie)we=Q.O[ie],Ke=!!we.visibility,de=ln.data,ue=de.addNormalizedLandmark,fe=U,we=Object.assign(Object.assign({},we),{visibility:Ke?we.visibility:0}),Ke=new so,Be(Ke,1,we.x),Be(Ke,2,we.y),Be(Ke,3,we.z),we.visibility&&Be(Ke,4,we.visibility),ft=we=new ye,rt(ft,1,ht(Ke,1)),rt(ft,2,ht(Ke,2)),rt(ft,3,ht(Ke,3)),rt(ft,4,ht(Ke,4)),rt(ft,5,ht(Ke,5)),ns(Ke,ft),we=tt(we),ue.call(de,fe,we);if(Q.M)for(ie=0;ie<Q.M.length;++ie){if(de=ln.data,ue=de.addClassification,fe=U,we=Q.M[ie],Ke=new Ri,Be(Ke,2,we.Y),we.index&&Be(Ke,1,we.index),we.label&&Be(Ke,3,we.label),we.displayName&&Be(Ke,4,we.displayName),ft=we=new ye,Ft=ht(Ke,1),Ft!=null&&Ft!=null)if(wt(ft.g,8),lt=ft.g,0<=Ft)wt(lt,Ft);else{for(Dt=0;9>Dt;Dt++)lt.push(Ft&127|128),Ft>>=7;lt.push(1)}rt(ft,2,ht(Ke,2)),lt=ht(Ke,3),lt!=null&&(lt=ee(lt),wt(ft.g,26),wt(ft.g,lt.length),Qe(ft,ft.g.end()),Qe(ft,lt)),lt=ht(Ke,4),lt!=null&&(lt=ee(lt),wt(ft.g,34),wt(ft.g,lt.length),Qe(ft,ft.g.end()),Qe(ft,lt)),ns(Ke,ft),we=tt(we),ue.call(de,fe,we)}}ln=ln.data;break e;default:ln={}}}switch(kn=ln,jn=Tt.stream,Tt.type){case"video":Ve.pushTexture2d(Object.assign(Object.assign({},kn),{stream:jn,timestamp:Se}));break;case"detections":Xn=kn,Xn.stream=jn,Xn.timestamp=Se,Ve.pushDetectionList(Xn);break;default:throw Error("Unknown input config type: '"+Tt.type+"'")}}return ae.i.send(Ve),S(Wn,ae.C,4);case 4:Ve.delete(),Wn.g=0}})})};function ot(P,F,O){return ks(P,function ae(){var Se,Ve,Ae,Ge,ut,Tt,kn=this,jn,Xn,Wn,ln,A,U,Q,ie;return I(ae,function(de){switch(de.g){case 1:if(!O)return de.return(F);for(Se={},Ve=0,Ae=a(Object.keys(O)),Ge=Ae.next();!Ge.done;Ge=Ae.next())ut=Ge.value,Tt=O[ut],typeof Tt!="string"&&Tt.type==="texture"&&F[Tt.stream]!==void 0&&++Ve;1<Ve&&(kn.G=!1),jn=a(Object.keys(O)),Ge=jn.next();case 2:if(Ge.done){de.g=4;break}if(Xn=Ge.value,Wn=O[Xn],typeof Wn=="string")return Q=Se,ie=Xn,S(de,mt(kn,Xn,F[Wn]),14);if(ln=F[Wn.stream],Wn.type==="detection_list"){if(ln){for(var ue=ln.getRectList(),fe=ln.getLandmarksList(),we=ln.getClassificationsList(),Ke=[],lt=0;lt<ue.size();++lt){var ft=ue.get(lt);e:{var Dt=new Ze;for(ft=new Vt(ft);It(ft);)switch(ft.i){case 13:var Ft=dn(ft);Be(Dt,1,Ft);break;case 21:Ft=dn(ft),Be(Dt,2,Ft);break;case 29:Ft=dn(ft),Be(Dt,3,Ft);break;case 37:Ft=dn(ft),Be(Dt,4,Ft);break;case 45:Ft=dn(ft),Be(Dt,5,Ft);break;case 48:Ft=nn(ft.g),Be(Dt,6,Ft);break;default:if(!hs(Dt,ft))break e}}Dt={Z:dt(Dt,1),$:dt(Dt,2),height:dt(Dt,3),width:dt(Dt,4),rotation:dt(Dt,5,0),X:St(Dt,6,0)},ft=rn(oe(fe.get(lt)),so).map(_n);var Bt=we.get(lt);e:for(Ft=new no,Bt=new Vt(Bt);It(Bt);)switch(Bt.i){case 10:Ft.addClassification(Gt(Bt,new Ri,fr));break;default:if(!hs(Ft,Bt))break e}Dt={T:Dt,O:ft,M:Bn(Ft)},Ke.push(Dt)}ue=Ke}else ue=[];Se[Xn]=ue,de.g=7;break}if(Wn.type==="proto_list"){if(ln){for(ue=Array(ln.size()),fe=0;fe<ln.size();fe++)ue[fe]=ln.get(fe);ln.delete()}else ue=[];Se[Xn]=ue,de.g=7;break}if(ln===void 0){de.g=3;break}if(Wn.type==="float_list"){Se[Xn]=ln,de.g=7;break}if(Wn.type==="proto"){Se[Xn]=ln,de.g=7;break}if(Wn.type!=="texture")throw Error("Unknown output config type: '"+Wn.type+"'");return A=kn.s[Xn],A||(A=new En(kn.h,kn.D),kn.s[Xn]=A),S(de,fs(A,ln,kn.G),13);case 13:U=de.h,Se[Xn]=U;case 7:Wn.transform&&Se[Xn]&&(Se[Xn]=Wn.transform(Se[Xn])),de.g=3;break;case 14:Q[ie]=de.h;case 3:Ge=jn.next(),de.g=2;break;case 4:return de.return(Se)}})})}function mt(P,F,O){return ks(P,function ae(){var Se=this,Ve;return I(ae,function(Ae){return typeof O=="number"||O instanceof Uint8Array||O instanceof Se.h.Uint8BlobList?Ae.return(O):O instanceof Se.h.Texture2dDataOut?(Ve=Se.s[F],Ve||(Ve=new En(Se.h,Se.D),Se.s[F]=Ve),Ae.return(fs(Ve,O,Se.G))):Ae.return(void 0)})})}function qt(P,F){for(var O=F.name||"$",ae=[].concat(l(F.wants)),Se=new P.h.StringList,Ve=a(F.wants),Ae=Ve.next();!Ae.done;Ae=Ve.next())Se.push_back(Ae.value);Ve=P.h.PacketListener.implement({onResults:function(Ge){for(var ut={},Tt=0;Tt<F.wants.length;++Tt)ut[ae[Tt]]=Ge.get(Tt);var kn=P.listeners[O];kn&&(P.C=ot(P,ut,F.outs).then(function(jn){jn=kn(jn);for(var Xn=0;Xn<F.wants.length;++Xn){var Wn=ut[ae[Xn]];typeof Wn=="object"&&Wn.hasOwnProperty&&Wn.hasOwnProperty("delete")&&Wn.delete()}jn&&(P.C=jn)}))}}),P.i.attachMultiListener(Se,Ve),Se.delete()}n.onResults=function(P,F){this.listeners[F||"$"]=P},W("Solution",H),W("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Tn(P){P=bn(P);var F=P.getMesh();if(!F)return P;var O=new Float32Array(F.getVertexBufferList());F.getVertexBufferList=function(){return O};var ae=new Uint32Array(F.getIndexBufferList());return F.getIndexBufferList=function(){return ae},P}var Jn={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(P){return P.map(Tn)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(P){return P.map(function(F){return rn(oe(F),so).map(_n)})}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},Dn=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Nn=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],sn=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],jt=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],Un=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],Qn=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],Gs=[].concat(l(Dn),l(Nn),l(sn),l(jt),l(Un),l(Qn));function ps(P){P=P||{},P=Object.assign(Object.assign({},Jn),P),this.g=new H(P)}n=ps.prototype,n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(P){this.g.onResults(P)},n.initialize=function(){return ks(this,function P(){var F=this;return I(P,function(O){return S(O,F.g.initialize(),0)})})},n.reset=function(){this.g.reset()},n.send=function(P){return ks(this,function F(){var O=this;return I(F,function(ae){return S(ae,O.g.send(P),0)})})},n.setOptions=function(P){this.g.setOptions(P)},W("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),W("FaceMesh",ps),W("FACEMESH_LIPS",Dn),W("FACEMESH_LEFT_EYE",Nn),W("FACEMESH_LEFT_EYEBROW",sn),W("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),W("FACEMESH_RIGHT_EYE",jt),W("FACEMESH_RIGHT_EYEBROW",Un),W("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),W("FACEMESH_FACE_OVAL",Qn),W("FACEMESH_CONTOURS",Gs),W("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),W("matrixDataToMatrix",function(P){for(var F=P.getCols(),O=P.getRows(),ae=P.getPackedDataList(),Se=[],Ve=0;Ve<O;Ve++)Se.push(Array(F));for(Ve=0;Ve<O;Ve++)for(var Ae=0;Ae<F;Ae++){var Ge=P.getLayout()===1?Ve*F+Ae:Ae*O+Ve;Se[Ve][Ae]=ae[Ge]}return Se}),W("VERSION","0.4.1633559619")}).call(W3)),W3}var wK=yK(),G3={},UR;function bK(){return UR||(UR=1,(function(){var n;function e(D){var H=0;return function(){return H<D.length?{done:!1,value:D[H++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(D,H,q){return D==Array.prototype||D==Object.prototype||(D[H]=q.value),D};function s(D){D=[typeof globalThis=="object"&&globalThis,D,typeof window=="object"&&window,typeof self=="object"&&self,typeof ff=="object"&&ff];for(var H=0;H<D.length;++H){var q=D[H];if(q&&q.Math==Math)return q}throw Error("Cannot find global object")}var i=s(this);function r(D,H){if(H)e:{var q=i;D=D.split(".");for(var pe=0;pe<D.length-1;pe++){var Oe=D[pe];if(!(Oe in q))break e;q=q[Oe]}D=D[D.length-1],pe=q[D],H=H(pe),H!=pe&&H!=null&&t(q,D,{configurable:!0,writable:!0,value:H})}}r("Symbol",function(D){function H(st){if(this instanceof H)throw new TypeError("Symbol is not a constructor");return new q(pe+(st||"")+"_"+Oe++,st)}function q(st,Ue){this.g=st,t(this,"description",{configurable:!0,writable:!0,value:Ue})}if(D)return D;q.prototype.toString=function(){return this.g};var pe="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",Oe=0;return H}),r("Symbol.iterator",function(D){if(D)return D;D=Symbol("Symbol.iterator");for(var H="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),q=0;q<H.length;q++){var pe=i[H[q]];typeof pe=="function"&&typeof pe.prototype[D]!="function"&&t(pe.prototype,D,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return D});function o(D){return D={next:D},D[Symbol.iterator]=function(){return this},D}function a(D){var H=typeof Symbol<"u"&&Symbol.iterator&&D[Symbol.iterator];return H?H.call(D):{next:e(D)}}function l(D){if(!(D instanceof Array)){D=a(D);for(var H,q=[];!(H=D.next()).done;)q.push(H.value);D=q}return D}var c=typeof Object.create=="function"?Object.create:function(D){function H(){}return H.prototype=D,new H},u;if(typeof Object.setPrototypeOf=="function")u=Object.setPrototypeOf;else{var d;e:{var h={a:!0},p={};try{p.__proto__=h,d=p.a;break e}catch{}d=!1}u=d?function(D,H){if(D.__proto__=H,D.__proto__!==H)throw new TypeError(D+" is not extensible");return D}:null}var g=u;function y(D,H){if(D.prototype=c(H.prototype),D.prototype.constructor=D,g)g(D,H);else for(var q in H)if(q!="prototype")if(Object.defineProperties){var pe=Object.getOwnPropertyDescriptor(H,q);pe&&Object.defineProperty(D,q,pe)}else D[q]=H[q];D.ea=H.prototype}function x(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function v(D){if(D.l)throw new TypeError("Generator is already running");D.l=!0}x.prototype.o=function(D){this.h=D};function b(D,H){D.j={U:H,V:!0},D.g=D.m||D.s}x.prototype.return=function(D){this.j={return:D},this.g=this.s};function S(D,H,q){return D.g=q,{value:H}}function C(D){this.g=new x,this.h=D}function E(D,H){v(D.g);var q=D.g.i;return q?k(D,"return"in q?q.return:function(pe){return{value:pe,done:!0}},H,D.g.return):(D.g.return(H),R(D))}function k(D,H,q,pe){try{var Oe=H.call(D.g.i,q);if(!(Oe instanceof Object))throw new TypeError("Iterator result "+Oe+" is not an object");if(!Oe.done)return D.g.l=!1,Oe;var st=Oe.value}catch(Ue){return D.g.i=null,b(D.g,Ue),R(D)}return D.g.i=null,pe.call(D.g,st),R(D)}function R(D){for(;D.g.g;)try{var H=D.h(D.g);if(H)return D.g.l=!1,{value:H.value,done:!1}}catch(q){D.g.h=void 0,b(D.g,q)}if(D.g.l=!1,D.g.j){if(H=D.g.j,D.g.j=null,H.V)throw H.U;return{value:H.return,done:!0}}return{value:void 0,done:!0}}function L(D){this.next=function(H){return v(D.g),D.g.i?H=k(D,D.g.i.next,H,D.g.o):(D.g.o(H),H=R(D)),H},this.throw=function(H){return v(D.g),D.g.i?H=k(D,D.g.i.throw,H,D.g.o):(b(D.g,H),H=R(D)),H},this.return=function(H){return E(D,H)},this[Symbol.iterator]=function(){return this}}function I(D,H){return H=new L(new C(H)),g&&D.prototype&&g(H,D.prototype),H}function T(D,H){D instanceof String&&(D+="");var q=0,pe=!1,Oe={next:function(){if(!pe&&q<D.length){var st=q++;return{value:H(st,D[st]),done:!1}}return pe=!0,{done:!0,value:void 0}}};return Oe[Symbol.iterator]=function(){return Oe},Oe}var M=typeof Object.assign=="function"?Object.assign:function(D,H){for(var q=1;q<arguments.length;q++){var pe=arguments[q];if(pe)for(var Oe in pe)Object.prototype.hasOwnProperty.call(pe,Oe)&&(D[Oe]=pe[Oe])}return D};r("Object.assign",function(D){return D||M}),r("Promise",function(D){function H(Ue){this.h=0,this.i=void 0,this.g=[],this.o=!1;var ot=this.j();try{Ue(ot.resolve,ot.reject)}catch(mt){ot.reject(mt)}}function q(){this.g=null}function pe(Ue){return Ue instanceof H?Ue:new H(function(ot){ot(Ue)})}if(D)return D;q.prototype.h=function(Ue){if(this.g==null){this.g=[];var ot=this;this.i(function(){ot.l()})}this.g.push(Ue)};var Oe=i.setTimeout;q.prototype.i=function(Ue){Oe(Ue,0)},q.prototype.l=function(){for(;this.g&&this.g.length;){var Ue=this.g;this.g=[];for(var ot=0;ot<Ue.length;++ot){var mt=Ue[ot];Ue[ot]=null;try{mt()}catch(qt){this.j(qt)}}}this.g=null},q.prototype.j=function(Ue){this.i(function(){throw Ue})},H.prototype.j=function(){function Ue(qt){return function(Tn){mt||(mt=!0,qt.call(ot,Tn))}}var ot=this,mt=!1;return{resolve:Ue(this.C),reject:Ue(this.l)}},H.prototype.C=function(Ue){if(Ue===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(Ue instanceof H)this.F(Ue);else{e:switch(typeof Ue){case"object":var ot=Ue!=null;break e;case"function":ot=!0;break e;default:ot=!1}ot?this.u(Ue):this.m(Ue)}},H.prototype.u=function(Ue){var ot=void 0;try{ot=Ue.then}catch(mt){this.l(mt);return}typeof ot=="function"?this.G(ot,Ue):this.m(Ue)},H.prototype.l=function(Ue){this.s(2,Ue)},H.prototype.m=function(Ue){this.s(1,Ue)},H.prototype.s=function(Ue,ot){if(this.h!=0)throw Error("Cannot settle("+Ue+", "+ot+"): Promise already settled in state"+this.h);this.h=Ue,this.i=ot,this.h===2&&this.D(),this.A()},H.prototype.D=function(){var Ue=this;Oe(function(){if(Ue.B()){var ot=i.console;typeof ot<"u"&&ot.error(Ue.i)}},1)},H.prototype.B=function(){if(this.o)return!1;var Ue=i.CustomEvent,ot=i.Event,mt=i.dispatchEvent;return typeof mt>"u"?!0:(typeof Ue=="function"?Ue=new Ue("unhandledrejection",{cancelable:!0}):typeof ot=="function"?Ue=new ot("unhandledrejection",{cancelable:!0}):(Ue=i.document.createEvent("CustomEvent"),Ue.initCustomEvent("unhandledrejection",!1,!0,Ue)),Ue.promise=this,Ue.reason=this.i,mt(Ue))},H.prototype.A=function(){if(this.g!=null){for(var Ue=0;Ue<this.g.length;++Ue)st.h(this.g[Ue]);this.g=null}};var st=new q;return H.prototype.F=function(Ue){var ot=this.j();Ue.J(ot.resolve,ot.reject)},H.prototype.G=function(Ue,ot){var mt=this.j();try{Ue.call(ot,mt.resolve,mt.reject)}catch(qt){mt.reject(qt)}},H.prototype.then=function(Ue,ot){function mt(Dn,Nn){return typeof Dn=="function"?function(sn){try{qt(Dn(sn))}catch(jt){Tn(jt)}}:Nn}var qt,Tn,Jn=new H(function(Dn,Nn){qt=Dn,Tn=Nn});return this.J(mt(Ue,qt),mt(ot,Tn)),Jn},H.prototype.catch=function(Ue){return this.then(void 0,Ue)},H.prototype.J=function(Ue,ot){function mt(){switch(qt.h){case 1:Ue(qt.i);break;case 2:ot(qt.i);break;default:throw Error("Unexpected state: "+qt.h)}}var qt=this;this.g==null?st.h(mt):this.g.push(mt),this.o=!0},H.resolve=pe,H.reject=function(Ue){return new H(function(ot,mt){mt(Ue)})},H.race=function(Ue){return new H(function(ot,mt){for(var qt=a(Ue),Tn=qt.next();!Tn.done;Tn=qt.next())pe(Tn.value).J(ot,mt)})},H.all=function(Ue){var ot=a(Ue),mt=ot.next();return mt.done?pe([]):new H(function(qt,Tn){function Jn(sn){return function(jt){Dn[sn]=jt,Nn--,Nn==0&&qt(Dn)}}var Dn=[],Nn=0;do Dn.push(void 0),Nn++,pe(mt.value).J(Jn(Dn.length-1),Tn),mt=ot.next();while(!mt.done)})},H}),r("Object.is",function(D){return D||function(H,q){return H===q?H!==0||1/H===1/q:H!==H&&q!==q}}),r("Array.prototype.includes",function(D){return D||function(H,q){var pe=this;pe instanceof String&&(pe=String(pe));var Oe=pe.length;for(q=q||0,0>q&&(q=Math.max(q+Oe,0));q<Oe;q++){var st=pe[q];if(st===H||Object.is(st,H))return!0}return!1}}),r("String.prototype.includes",function(D){return D||function(H,q){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(H instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(H,q||0)!==-1}}),r("Array.prototype.keys",function(D){return D||function(){return T(this,function(H){return H})}});var j=this||self;function W(D,H){D=D.split(".");var q=j;D[0]in q||typeof q.execScript>"u"||q.execScript("var "+D[0]);for(var pe;D.length&&(pe=D.shift());)D.length||H===void 0?q[pe]&&q[pe]!==Object.prototype[pe]?q=q[pe]:q=q[pe]={}:q[pe]=H}function z(D,H){return H=String.fromCharCode.apply(null,H),D==null?H:D+H}var X,B=typeof TextDecoder<"u",J,K=typeof TextEncoder<"u";function ee(D){if(K)D=(J||(J=new TextEncoder)).encode(D);else{var H=void 0;H=H===void 0?!1:H;for(var q=0,pe=new Uint8Array(3*D.length),Oe=0;Oe<D.length;Oe++){var st=D.charCodeAt(Oe);if(128>st)pe[q++]=st;else{if(2048>st)pe[q++]=st>>6|192;else{if(55296<=st&&57343>=st){if(56319>=st&&Oe<D.length){var Ue=D.charCodeAt(++Oe);if(56320<=Ue&&57343>=Ue){st=1024*(st-55296)+Ue-56320+65536,pe[q++]=st>>18|240,pe[q++]=st>>12&63|128,pe[q++]=st>>6&63|128,pe[q++]=st&63|128;continue}else Oe--}if(H)throw Error("Found an unpaired surrogate");st=65533}pe[q++]=st>>12|224,pe[q++]=st>>6&63|128}pe[q++]=st&63|128}}D=pe.subarray(0,q)}return D}var ne={},V=null;function Z(D,H){H===void 0&&(H=0),be(),H=ne[H];for(var q=Array(Math.floor(D.length/3)),pe=H[64]||"",Oe=0,st=0;Oe<D.length-2;Oe+=3){var Ue=D[Oe],ot=D[Oe+1],mt=D[Oe+2],qt=H[Ue>>2];Ue=H[(Ue&3)<<4|ot>>4],ot=H[(ot&15)<<2|mt>>6],mt=H[mt&63],q[st++]=qt+Ue+ot+mt}switch(qt=0,mt=pe,D.length-Oe){case 2:qt=D[Oe+1],mt=H[(qt&15)<<2]||pe;case 1:D=D[Oe],q[st]=H[D>>2]+H[(D&3)<<4|qt>>4]+mt+pe}return q.join("")}function he(D){var H=D.length,q=3*H/4;q%3?q=Math.floor(q):"=.".indexOf(D[H-1])!=-1&&(q="=.".indexOf(D[H-2])!=-1?q-2:q-1);var pe=new Uint8Array(q),Oe=0;return ve(D,function(st){pe[Oe++]=st}),pe.subarray(0,Oe)}function ve(D,H){function q(mt){for(;pe<D.length;){var qt=D.charAt(pe++),Tn=V[qt];if(Tn!=null)return Tn;if(!/^[\s\xa0]*$/.test(qt))throw Error("Unknown base64 encoding at char: "+qt)}return mt}be();for(var pe=0;;){var Oe=q(-1),st=q(0),Ue=q(64),ot=q(64);if(ot===64&&Oe===-1)break;H(Oe<<2|st>>4),Ue!=64&&(H(st<<4&240|Ue>>2),ot!=64&&H(Ue<<6&192|ot))}}function be(){if(!V){V={};for(var D="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),H=["+/=","+/","-_=","-_.","-_"],q=0;5>q;q++){var pe=D.concat(H[q].split(""));ne[q]=pe;for(var Oe=0;Oe<pe.length;Oe++){var st=pe[Oe];V[st]===void 0&&(V[st]=Oe)}}}}var Ie=typeof Uint8Array.prototype.slice=="function",Xe;function Fe(D,H,q){return H===q?Xe||(Xe=new Uint8Array(0)):Ie?D.slice(H,q):new Uint8Array(D.subarray(H,q))}var Pe=0,ct=0;function at(D,H){H=H===void 0?{}:H,H=H.v===void 0?!1:H.v,this.h=null,this.g=this.i=this.j=0,this.l=!1,this.v=H,D&&Ee(this,D)}function Ee(D,H){H=H.constructor===Uint8Array?H:H.constructor===ArrayBuffer?new Uint8Array(H):H.constructor===Array?new Uint8Array(H):H.constructor===String?he(H):H instanceof Uint8Array?new Uint8Array(H.buffer,H.byteOffset,H.byteLength):new Uint8Array(0),D.h=H,D.j=0,D.i=D.h.length,D.g=D.j}at.prototype.reset=function(){this.g=this.j};function nn(D){var H=D.h,q=H[D.g],pe=q&127;return 128>q?(D.g+=1,pe):(q=H[D.g+1],pe|=(q&127)<<7,128>q?(D.g+=2,pe):(q=H[D.g+2],pe|=(q&127)<<14,128>q?(D.g+=3,pe):(q=H[D.g+3],pe|=(q&127)<<21,128>q?(D.g+=4,pe):(q=H[D.g+4],pe|=(q&15)<<28,128>q?(D.g+=5,pe>>>0):(D.g+=5,128<=H[D.g++]&&128<=H[D.g++]&&128<=H[D.g++]&&128<=H[D.g++]&&D.g++,pe)))))}function gt(D){var H=D.h[D.g],q=D.h[D.g+1],pe=D.h[D.g+2],Oe=D.h[D.g+3];return D.g+=4,q=(H<<0|q<<8|pe<<16|Oe<<24)>>>0,D=2*(q>>31)+1,H=q>>>23&255,q&=8388607,H==255?q?NaN:1/0*D:H==0?D*Math.pow(2,-149)*q:D*Math.pow(2,H-150)*(q+Math.pow(2,23))}var vt=[];function wt(){this.g=new Uint8Array(64),this.h=0}wt.prototype.push=function(D){if(!(this.h+1<this.g.length)){var H=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(H)}this.g[this.h++]=D},wt.prototype.length=function(){return this.h},wt.prototype.end=function(){var D=this.g,H=this.h;return this.h=0,Fe(D,0,H)};function Vt(D,H){for(;127<H;)D.push(H&127|128),H>>>=7;D.push(H)}function It(D){var H={},q=H.N===void 0?!1:H.N;this.o={v:H.v===void 0?!1:H.v},this.N=q,H=this.o,vt.length?(q=vt.pop(),H&&(q.v=H.v),D&&Ee(q,D),D=q):D=new at(D,H),this.g=D,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}It.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function zt(D){var H=D.g;if((H=H.g==H.i)||(H=D.j)||(H=D.g,H=H.l||0>H.g||H.g>H.i),H)return!1;D.m=D.g.g,H=nn(D.g);var q=H&7;return q!=0&&q!=5&&q!=1&&q!=2&&q!=3&&q!=4?(D.j=!0,!1):(D.i=H,D.l=H>>>3,D.h=q,!0)}function Gt(D){switch(D.h){case 0:if(D.h!=0)Gt(D);else{for(D=D.g;D.h[D.g]&128;)D.g++;D.g++}break;case 1:D.h!=1?Gt(D):(D=D.g,D.g+=8);break;case 2:if(D.h!=2)Gt(D);else{var H=nn(D.g);D=D.g,D.g+=H}break;case 5:D.h!=5?Gt(D):(D=D.g,D.g+=4);break;case 3:H=D.l;do{if(!zt(D)){D.j=!0;break}if(D.h==4){D.l!=H&&(D.j=!0);break}Gt(D)}while(!0);break;default:D.j=!0}}function dn(D,H,q){var pe=D.g.i,Oe=nn(D.g),st=D.g.g+Oe;if(D.g.i=st,q(H,D),q=st-D.g.g,q!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+Oe+" bytes, instead read "+(Oe-q)+" bytes, either the data ended unexpectedly or the message misreported its own length");return D.g.g=st,D.g.i=pe,H}function vn(D){var H=nn(D.g);D=D.g;var q=D.g;D.g+=H,D=D.h;var pe;if(B)(pe=X)||(pe=X=new TextDecoder("utf-8",{fatal:!1})),pe=pe.decode(D.subarray(q,q+H));else{H=q+H;for(var Oe=[],st=null,Ue,ot,mt;q<H;)Ue=D[q++],128>Ue?Oe.push(Ue):224>Ue?q>=H?Oe.push(65533):(ot=D[q++],194>Ue||(ot&192)!==128?(q--,Oe.push(65533)):Oe.push((Ue&31)<<6|ot&63)):240>Ue?q>=H-1?Oe.push(65533):(ot=D[q++],(ot&192)!==128||Ue===224&&160>ot||Ue===237&&160<=ot||((pe=D[q++])&192)!==128?(q--,Oe.push(65533)):Oe.push((Ue&15)<<12|(ot&63)<<6|pe&63)):244>=Ue?q>=H-2?Oe.push(65533):(ot=D[q++],(ot&192)!==128||(Ue<<28)+(ot-144)>>30!==0||((pe=D[q++])&192)!==128||((mt=D[q++])&192)!==128?(q--,Oe.push(65533)):(Ue=(Ue&7)<<18|(ot&63)<<12|(pe&63)<<6|mt&63,Ue-=65536,Oe.push((Ue>>10&1023)+55296,(Ue&1023)+56320))):Oe.push(65533),8192<=Oe.length&&(st=z(st,Oe),Oe.length=0);pe=z(st,Oe)}return pe}function ce(){this.h=[],this.i=0,this.g=new wt}function Y(D,H){H.length!==0&&(D.h.push(H),D.i+=H.length)}function ye(D){var H=D.i+D.g.length();if(H===0)return new Uint8Array(0);H=new Uint8Array(H);for(var q=D.h,pe=q.length,Oe=0,st=0;st<pe;st++){var Ue=q[st];Ue.length!==0&&(H.set(Ue,Oe),Oe+=Ue.length)}return q=D.g,pe=q.h,pe!==0&&(H.set(q.g.subarray(0,pe),Oe),q.h=0),D.h=[H],H}function Qe(D,H,q){if(q!=null){Vt(D.g,8*H+5),D=D.g;var pe=q;pe=(q=0>pe?1:0)?-pe:pe,pe===0?0<1/pe?Pe=ct=0:(ct=0,Pe=2147483648):isNaN(pe)?(ct=0,Pe=2147483647):34028234663852886e22<pe?(ct=0,Pe=(q<<31|2139095040)>>>0):11754943508222875e-54>pe?(pe=Math.round(pe/Math.pow(2,-149)),ct=0,Pe=(q<<31|pe)>>>0):(H=Math.floor(Math.log(pe)/Math.LN2),pe*=Math.pow(2,-H),pe=Math.round(8388608*pe),16777216<=pe&&++H,ct=0,Pe=(q<<31|H+127<<23|pe&8388607)>>>0),q=Pe,D.push(q>>>0&255),D.push(q>>>8&255),D.push(q>>>16&255),D.push(q>>>24&255)}}var tt=typeof Uint8Array=="function";function rt(D,H,q){if(D!=null)return typeof D=="object"?tt&&D instanceof Uint8Array?q(D):Pt(D,H,q):H(D)}function Pt(D,H,q){if(Array.isArray(D)){for(var pe=Array(D.length),Oe=0;Oe<D.length;Oe++)pe[Oe]=rt(D[Oe],H,q);return Array.isArray(D)&&D.W&&xe(pe),pe}pe={};for(Oe in D)pe[Oe]=rt(D[Oe],H,q);return pe}function pt(D){return typeof D=="number"?isFinite(D)?D:String(D):D}var At={W:{value:!0,configurable:!0}};function xe(D){return Array.isArray(D)&&!Object.isFrozen(D)&&Object.defineProperties(D,At),D}var xt;function Ye(D,H,q){var pe=xt;xt=null,D||(D=pe),pe=this.constructor.ca,D||(D=pe?[pe]:[]),this.j=pe?0:-1,this.i=null,this.g=D;e:{if(pe=this.g.length,D=pe-1,pe&&(pe=this.g[D],!(pe===null||typeof pe!="object"||Array.isArray(pe)||tt&&pe instanceof Uint8Array))){this.l=D-this.j,this.h=pe;break e}H!==void 0&&-1<H?(this.l=Math.max(H,D+1-this.j),this.h=null):this.l=Number.MAX_VALUE}if(q)for(H=0;H<q.length;H++)D=q[H],D<this.l?(D+=this.j,(pe=this.g[D])?xe(pe):this.g[D]=kt):(Et(this),(pe=this.h[D])?xe(pe):this.h[D]=kt)}var kt=Object.freeze(xe([]));function Et(D){var H=D.l+D.j;D.g[H]||(D.h=D.g[H]={})}function bt(D,H,q){return H===-1?null:q!==void 0&&q||H>=D.l?D.h?D.h[H]:void 0:D.g[H+D.j]}function Wt(D){var H=H===void 0?!1:H,q=bt(D,1,H);return q==null&&(q=kt),q===kt&&(q=xe([]),Ht(D,1,q,H)),q}function ht(D,H,q){return D=bt(D,H),D=D==null?D:+D,D??(q===void 0?0:q)}function Ht(D,H,q,pe){pe!==void 0&&pe||H>=D.l?(Et(D),D.h[H]=q):D.g[H+D.j]=q}function Ce(D,H){D.i||(D.i={});var q=D.i[1];if(!q){var pe=Wt(D);q=[];for(var Oe=0;Oe<pe.length;Oe++)q[Oe]=new H(pe[Oe]);D.i[1]=q}return q}function St(D,H,q,pe){var Oe=Ce(D,q);H=H||new q,D=Wt(D),pe!=null?(Oe.splice(pe,0,H),D.splice(pe,0,dt(H))):(Oe.push(H),D.push(dt(H)))}Ye.prototype.toJSON=function(){var D=dt(this);return Pt(D,pt,Z)};function dt(D,H){if(D.i)for(var q in D.i){var pe=D.i[q];if(Array.isArray(pe))for(var Oe=0;Oe<pe.length;Oe++)pe[Oe]&&dt(pe[Oe]);else pe&&dt(pe)}return D.g}Ye.prototype.toString=function(){return dt(this).toString()};function Be(D,H){return D=bt(D,H),D??0}function Rt(D,H){return D=bt(D,H),D??""}function rn(D,H){if(D=D.m){Y(H,H.g.end());for(var q=0;q<D.length;q++)Y(H,D[q])}}function In(D,H){if(H.h==4)return!1;var q=H.m;return Gt(H),H.N||(H=Fe(H.g.h,q,H.g.g),(q=D.m)?q.push(H):D.m=[H]),!0}function zn(D,H){var q=void 0;return new(q||(q=Promise))(function(pe,Oe){function st(mt){try{ot(H.next(mt))}catch(qt){Oe(qt)}}function Ue(mt){try{ot(H.throw(mt))}catch(qt){Oe(qt)}}function ot(mt){mt.done?pe(mt.value):new q(function(qt){qt(mt.value)}).then(st,Ue)}ot((H=H.apply(D,void 0)).next())})}function _s(D){Ye.call(this,D)}y(_s,Ye);function ns(D,H){for(;zt(H);)switch(H.i){case 8:var q=nn(H.g);Ht(D,1,q);break;case 21:q=gt(H.g),Ht(D,2,q);break;case 26:q=vn(H),Ht(D,3,q);break;case 34:q=vn(H),Ht(D,4,q);break;default:if(!In(D,H))return D}return D}function hs(D){Ye.call(this,D,-1,Ls)}y(hs,Ye),hs.prototype.addClassification=function(D,H){return St(this,D,_s,H),this};var Ls=[1];function Or(D){Ye.call(this,D)}y(Or,Ye);function So(D,H){for(;zt(H);)switch(H.i){case 13:var q=gt(H.g);Ht(D,1,q);break;case 21:q=gt(H.g),Ht(D,2,q);break;case 29:q=gt(H.g),Ht(D,3,q);break;case 37:q=gt(H.g),Ht(D,4,q);break;case 45:q=gt(H.g),Ht(D,5,q);break;default:if(!In(D,H))return D}return D}function ks(D){Ye.call(this,D,-1,Ri)}y(ks,Ye);var Ri=[1];function fr(D){Ye.call(this,D)}y(fr,Ye);function no(D,H,q){if(q=D.createShader(q===0?D.VERTEX_SHADER:D.FRAGMENT_SHADER),D.shaderSource(q,H),D.compileShader(q),!D.getShaderParameter(q,D.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+D.getShaderInfoLog(q));return q}function ua(D){return Ce(D,_s).map(function(H){return{index:Be(H,1),Y:ht(H,2),label:bt(H,3)!=null?Rt(H,3):void 0,displayName:bt(H,4)!=null?Rt(H,4):void 0}})}function so(D){return{x:ht(D,1),y:ht(D,2),z:ht(D,3),visibility:bt(D,4)!=null?ht(D,4):void 0}}function pr(D){e:{var H=new ks;for(D=new It(D);zt(D);)switch(D.i){case 10:var q=dn(D,new Or,So);St(H,q,Or,void 0);break;default:if(!In(H,D))break e}}return Ce(H,Or).map(so)}function Co(D,H){this.h=D,this.g=H,this.l=0}function oe(D,H,q){return We(D,H),typeof D.g.canvas.transferToImageBitmap=="function"?Promise.resolve(D.g.canvas.transferToImageBitmap()):q?Promise.resolve(D.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(D.g.canvas):(D.i===void 0&&(D.i=document.createElement("canvas")),new Promise(function(pe){D.i.height=D.g.canvas.height,D.i.width=D.g.canvas.width,D.i.getContext("2d",{}).drawImage(D.g.canvas,0,0,D.g.canvas.width,D.g.canvas.height),pe(D.i)}))}function We(D,H){var q=D.g;if(D.m===void 0){var pe=no(q,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),Oe=no(q,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),st=q.createProgram();if(q.attachShader(st,pe),q.attachShader(st,Oe),q.linkProgram(st),!q.getProgramParameter(st,q.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+q.getProgramInfoLog(st));pe=D.m=st,q.useProgram(pe),Oe=q.getUniformLocation(pe,"sampler0"),D.j={I:q.getAttribLocation(pe,"aVertex"),H:q.getAttribLocation(pe,"aTex"),da:Oe},D.s=q.createBuffer(),q.bindBuffer(q.ARRAY_BUFFER,D.s),q.enableVertexAttribArray(D.j.I),q.vertexAttribPointer(D.j.I,2,q.FLOAT,!1,0,0),q.bufferData(q.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),q.STATIC_DRAW),q.bindBuffer(q.ARRAY_BUFFER,null),D.o=q.createBuffer(),q.bindBuffer(q.ARRAY_BUFFER,D.o),q.enableVertexAttribArray(D.j.H),q.vertexAttribPointer(D.j.H,2,q.FLOAT,!1,0,0),q.bufferData(q.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),q.STATIC_DRAW),q.bindBuffer(q.ARRAY_BUFFER,null),q.uniform1i(Oe,0)}pe=D.j,q.useProgram(D.m),q.canvas.width=H.width,q.canvas.height=H.height,q.viewport(0,0,H.width,H.height),q.activeTexture(q.TEXTURE0),D.h.bindTexture2d(H.glName),q.enableVertexAttribArray(pe.I),q.bindBuffer(q.ARRAY_BUFFER,D.s),q.vertexAttribPointer(pe.I,2,q.FLOAT,!1,0,0),q.enableVertexAttribArray(pe.H),q.bindBuffer(q.ARRAY_BUFFER,D.o),q.vertexAttribPointer(pe.H,2,q.FLOAT,!1,0,0),q.bindFramebuffer(q.DRAW_FRAMEBUFFER?q.DRAW_FRAMEBUFFER:q.FRAMEBUFFER,null),q.clearColor(0,0,0,0),q.clear(q.COLOR_BUFFER_BIT),q.colorMask(!0,!0,!0,!0),q.drawArrays(q.TRIANGLE_FAN,0,4),q.disableVertexAttribArray(pe.I),q.disableVertexAttribArray(pe.H),q.bindBuffer(q.ARRAY_BUFFER,null),D.h.bindTexture2d(0)}function Ze(D){this.g=D}var Je=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function nt(D,H){return H+D}function Kt(D,H){window[D]=H}function on(D){var H=document.createElement("script");return H.setAttribute("src",D),H.setAttribute("crossorigin","anonymous"),new Promise(function(q){H.addEventListener("load",function(){q()},!1),H.addEventListener("error",function(){q()},!1),document.body.appendChild(H)})}function bn(){return zn(this,function D(){return I(D,function(H){switch(H.g){case 1:return H.m=2,S(H,WebAssembly.instantiate(Je),4);case 4:H.g=3,H.m=0;break;case 2:return H.m=0,H.j=null,H.return(!1);case 3:return H.return(!0)}})})}function Yt(D){if(this.g=D,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=D&&D.locateFile||nt,typeof window=="object")var H=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")H=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=H,D.options){H=a(Object.keys(D.options));for(var q=H.next();!q.done;q=H.next()){q=q.value;var pe=D.options[q].default;pe!==void 0&&(this.j[q]=typeof pe=="function"?pe():pe)}}}n=Yt.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function Bn(D,H){return D.g.files===void 0?[]:typeof D.g.files=="function"?D.g.files(H):D.g.files}function _n(D){return zn(D,function H(){var q=this,pe,Oe,st,Ue,ot,mt,qt,Tn,Jn,Dn,Nn;return I(H,function(sn){switch(sn.g){case 1:return pe=q,q.R?(Oe=Bn(q,q.j),S(sn,bn(),2)):sn.return();case 2:if(st=sn.h,typeof window=="object")return Kt("createMediapipeSolutionsWasm",{locateFile:q.locateFile}),Kt("createMediapipeSolutionsPackedAssets",{locateFile:q.locateFile}),mt=Oe.filter(function(jt){return jt.data!==void 0}),qt=Oe.filter(function(jt){return jt.data===void 0}),Tn=Promise.all(mt.map(function(jt){var Un=ws(pe,jt.url);if(jt.path!==void 0){var Qn=jt.path;Un=Un.then(function(Gs){return pe.overrideFile(Qn,Gs),Promise.resolve(Gs)})}return Un})),Jn=Promise.all(qt.map(function(jt){return jt.simd===void 0||jt.simd&&st||!jt.simd&&!st?on(pe.locateFile(jt.url,pe.S)):Promise.resolve()})).then(function(){return zn(pe,function jt(){var Un,Qn,Gs=this;return I(jt,function(ps){if(ps.g==1)return Un=window.createMediapipeSolutionsWasm,Qn=window.createMediapipeSolutionsPackedAssets,S(ps,Un(Qn),2);Gs.h=ps.h,ps.g=0})})}),Dn=function(){return zn(pe,function jt(){var Un=this;return I(jt,function(Qn){return Un.g.graph&&Un.g.graph.url?Qn=S(Qn,ws(Un,Un.g.graph.url),0):(Qn.g=0,Qn=void 0),Qn})})}(),S(sn,Promise.all([Jn,Tn,Dn]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return Ue=Oe.filter(function(jt){return jt.simd===void 0||jt.simd&&st||!jt.simd&&!st}).map(function(jt){return pe.locateFile(jt.url,pe.S)}),importScripts.apply(null,l(Ue)),S(sn,createMediapipeSolutionsWasm(Module),6);case 6:q.h=sn.h,q.l=new OffscreenCanvas(1,1),q.h.canvas=q.l,ot=q.h.GL.createContext(q.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),q.h.GL.makeContextCurrent(ot),sn.g=4;break;case 7:if(q.l=document.createElement("canvas"),Nn=q.l.getContext("webgl2",{}),!Nn&&(Nn=q.l.getContext("webgl",{}),!Nn))return alert("Failed to create WebGL canvas context when passing video frame."),sn.return();q.D=Nn,q.h.canvas=q.l,q.h.createContext(q.l,!0,!0,{});case 4:q.i=new q.h.SolutionWasm,q.R=!1,sn.g=0}})})}function En(D){return zn(D,function H(){var q=this,pe,Oe,st,Ue,ot,mt,qt,Tn;return I(H,function(Jn){if(Jn.g==1){if(q.g.graph&&q.g.graph.url&&q.P===q.g.graph.url)return Jn.return();if(q.o=!0,!q.g.graph||!q.g.graph.url){Jn.g=2;return}return q.P=q.g.graph.url,S(Jn,ws(q,q.g.graph.url),3)}for(Jn.g!=2&&(pe=Jn.h,q.i.loadGraph(pe)),Oe=a(Object.keys(q.B)),st=Oe.next();!st.done;st=Oe.next())Ue=st.value,q.i.overrideFile(Ue,q.B[Ue]);if(q.B={},q.g.listeners)for(ot=a(q.g.listeners),mt=ot.next();!mt.done;mt=ot.next())qt=mt.value,ss(q,qt);Tn=q.j,q.j={},q.setOptions(Tn),Jn.g=0})})}n.reset=function(){return zn(this,function D(){var H=this;return I(D,function(q){H.i&&(H.i.reset(),H.m={},H.s={}),q.g=0})})},n.setOptions=function(D,H){var q=this;if(H=H||this.g.options){for(var pe=[],Oe=[],st={},Ue=a(Object.keys(D)),ot=Ue.next();!ot.done;st={K:st.K,L:st.L},ot=Ue.next()){var mt=ot.value;mt in this.j&&this.j[mt]===D[mt]||(this.j[mt]=D[mt],ot=H[mt],ot!==void 0&&(ot.onChange&&(st.K=ot.onChange,st.L=D[mt],pe.push(function(qt){return function(){return zn(q,function Tn(){var Jn,Dn=this;return I(Tn,function(Nn){if(Nn.g==1)return S(Nn,qt.K(qt.L),2);Jn=Nn.h,Jn===!0&&(Dn.o=!0),Nn.g=0})})}}(st))),ot.graphOptionXref&&(mt={valueNumber:ot.type===1?D[mt]:0,valueBoolean:ot.type===0?D[mt]:!1,valueString:ot.type===2?D[mt]:""},ot=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),ot.graphOptionXref),mt),Oe.push(ot))))}(pe.length!==0||Oe.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(Oe),this.u=(this.u===void 0?[]:this.u).concat(pe))}};function fs(D){return zn(D,function H(){var q=this,pe,Oe,st,Ue,ot,mt,qt;return I(H,function(Tn){switch(Tn.g){case 1:if(!q.o)return Tn.return();if(!q.u){Tn.g=2;break}pe=a(q.u),Oe=pe.next();case 3:if(Oe.done){Tn.g=5;break}return st=Oe.value,S(Tn,st(),4);case 4:Oe=pe.next(),Tn.g=3;break;case 5:q.u=void 0;case 2:if(q.A){for(Ue=new q.h.GraphOptionChangeRequestList,ot=a(q.A),mt=ot.next();!mt.done;mt=ot.next())qt=mt.value,Ue.push_back(qt);q.i.changeOptions(Ue),Ue.delete(),q.A=void 0}q.o=!1,Tn.g=0}})})}n.initialize=function(){return zn(this,function D(){var H=this;return I(D,function(q){return q.g==1?S(q,_n(H),2):q.g!=3?S(q,En(H),3):S(q,fs(H),0)})})};function ws(D,H){return zn(D,function q(){var pe=this,Oe,st;return I(q,function(Ue){return H in pe.F?Ue.return(pe.F[H]):(Oe=pe.locateFile(H,""),st=fetch(Oe).then(function(ot){return ot.arrayBuffer()}),pe.F[H]=st,Ue.return(st))})})}n.overrideFile=function(D,H){this.i?this.i.overrideFile(D,H):this.B[D]=H},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(D,H){return zn(this,function q(){var pe=this,Oe,st,Ue,ot,mt,qt,Tn,Jn,Dn;return I(q,function(Nn){switch(Nn.g){case 1:return pe.g.inputs?(Oe=1e3*(H??performance.now()),S(Nn,pe.C,2)):Nn.return();case 2:return S(Nn,pe.initialize(),3);case 3:for(st=new pe.h.PacketDataList,Ue=a(Object.keys(D)),ot=Ue.next();!ot.done;ot=Ue.next())if(mt=ot.value,qt=pe.g.inputs[mt]){e:{var sn=pe,jt=D[mt];switch(qt.type){case"video":var Un=sn.m[qt.stream];if(Un||(Un=new Co(sn.h,sn.D),sn.m[qt.stream]=Un),sn=Un,sn.l===0&&(sn.l=sn.h.createTexture()),typeof HTMLVideoElement<"u"&&jt instanceof HTMLVideoElement){var Qn=jt.videoWidth;Un=jt.videoHeight}else typeof HTMLImageElement<"u"&&jt instanceof HTMLImageElement?(Qn=jt.naturalWidth,Un=jt.naturalHeight):(Qn=jt.width,Un=jt.height);Un={glName:sn.l,width:Qn,height:Un},Qn=sn.g,Qn.canvas.width=Un.width,Qn.canvas.height=Un.height,Qn.activeTexture(Qn.TEXTURE0),sn.h.bindTexture2d(sn.l),Qn.texImage2D(Qn.TEXTURE_2D,0,Qn.RGBA,Qn.RGBA,Qn.UNSIGNED_BYTE,jt),sn.h.bindTexture2d(0),sn=Un;break e;case"detections":for(Un=sn.m[qt.stream],Un||(Un=new Ze(sn.h),sn.m[qt.stream]=Un),sn=Un,sn.data||(sn.data=new sn.g.DetectionListData),sn.data.reset(jt.length),Un=0;Un<jt.length;++Un){Qn=jt[Un];var Gs=sn.data,ps=Gs.setBoundingBox,P=Un,F=Qn.T,O=new fr;Ht(O,1,F.Z),Ht(O,2,F.$),Ht(O,3,F.height),Ht(O,4,F.width),Ht(O,5,F.rotation),Ht(O,6,F.X);var ae=F=new ce;Qe(ae,1,bt(O,1)),Qe(ae,2,bt(O,2)),Qe(ae,3,bt(O,3)),Qe(ae,4,bt(O,4)),Qe(ae,5,bt(O,5));var Se=bt(O,6);if(Se!=null&&Se!=null){Vt(ae.g,48);var Ve=ae.g,Ae=Se;Se=0>Ae,Ae=Math.abs(Ae);var Ge=Ae>>>0;for(Ae=Math.floor((Ae-Ge)/4294967296),Ae>>>=0,Se&&(Ae=~Ae>>>0,Ge=(~Ge>>>0)+1,4294967295<Ge&&(Ge=0,Ae++,4294967295<Ae&&(Ae=0))),Pe=Ge,ct=Ae,Se=Pe,Ge=ct;0<Ge||127<Se;)Ve.push(Se&127|128),Se=(Se>>>7|Ge<<25)>>>0,Ge>>>=7;Ve.push(Se)}if(rn(O,ae),F=ye(F),ps.call(Gs,P,F),Qn.O)for(Gs=0;Gs<Qn.O.length;++Gs)O=Qn.O[Gs],ae=!!O.visibility,ps=sn.data,P=ps.addNormalizedLandmark,F=Un,O=Object.assign(Object.assign({},O),{visibility:ae?O.visibility:0}),ae=new Or,Ht(ae,1,O.x),Ht(ae,2,O.y),Ht(ae,3,O.z),O.visibility&&Ht(ae,4,O.visibility),Ve=O=new ce,Qe(Ve,1,bt(ae,1)),Qe(Ve,2,bt(ae,2)),Qe(Ve,3,bt(ae,3)),Qe(Ve,4,bt(ae,4)),Qe(Ve,5,bt(ae,5)),rn(ae,Ve),O=ye(O),P.call(ps,F,O);if(Qn.M)for(Gs=0;Gs<Qn.M.length;++Gs){if(ps=sn.data,P=ps.addClassification,F=Un,O=Qn.M[Gs],ae=new _s,Ht(ae,2,O.Y),O.index&&Ht(ae,1,O.index),O.label&&Ht(ae,3,O.label),O.displayName&&Ht(ae,4,O.displayName),Ve=O=new ce,Ge=bt(ae,1),Ge!=null&&Ge!=null)if(Vt(Ve.g,8),Se=Ve.g,0<=Ge)Vt(Se,Ge);else{for(Ae=0;9>Ae;Ae++)Se.push(Ge&127|128),Ge>>=7;Se.push(1)}Qe(Ve,2,bt(ae,2)),Se=bt(ae,3),Se!=null&&(Se=ee(Se),Vt(Ve.g,26),Vt(Ve.g,Se.length),Y(Ve,Ve.g.end()),Y(Ve,Se)),Se=bt(ae,4),Se!=null&&(Se=ee(Se),Vt(Ve.g,34),Vt(Ve.g,Se.length),Y(Ve,Ve.g.end()),Y(Ve,Se)),rn(ae,Ve),O=ye(O),P.call(ps,F,O)}}sn=sn.data;break e;default:sn={}}}switch(Tn=sn,Jn=qt.stream,qt.type){case"video":st.pushTexture2d(Object.assign(Object.assign({},Tn),{stream:Jn,timestamp:Oe}));break;case"detections":Dn=Tn,Dn.stream=Jn,Dn.timestamp=Oe,st.pushDetectionList(Dn);break;default:throw Error("Unknown input config type: '"+qt.type+"'")}}return pe.i.send(st),S(Nn,pe.C,4);case 4:st.delete(),Nn.g=0}})})};function Ws(D,H,q){return zn(D,function pe(){var Oe,st,Ue,ot,mt,qt,Tn=this,Jn,Dn,Nn,sn,jt,Un,Qn,Gs;return I(pe,function(ps){switch(ps.g){case 1:if(!q)return ps.return(H);for(Oe={},st=0,Ue=a(Object.keys(q)),ot=Ue.next();!ot.done;ot=Ue.next())mt=ot.value,qt=q[mt],typeof qt!="string"&&qt.type==="texture"&&H[qt.stream]!==void 0&&++st;1<st&&(Tn.G=!1),Jn=a(Object.keys(q)),ot=Jn.next();case 2:if(ot.done){ps.g=4;break}if(Dn=ot.value,Nn=q[Dn],typeof Nn=="string")return Qn=Oe,Gs=Dn,S(ps,Mi(Tn,Dn,H[Nn]),14);if(sn=H[Nn.stream],Nn.type==="detection_list"){if(sn){for(var P=sn.getRectList(),F=sn.getLandmarksList(),O=sn.getClassificationsList(),ae=[],Se=0;Se<P.size();++Se){var Ve=P.get(Se);e:{var Ae=new fr;for(Ve=new It(Ve);zt(Ve);)switch(Ve.i){case 13:var Ge=gt(Ve.g);Ht(Ae,1,Ge);break;case 21:Ge=gt(Ve.g),Ht(Ae,2,Ge);break;case 29:Ge=gt(Ve.g),Ht(Ae,3,Ge);break;case 37:Ge=gt(Ve.g),Ht(Ae,4,Ge);break;case 45:Ge=gt(Ve.g),Ht(Ae,5,Ge);break;case 48:for(var ut=Ve.g,Tt=128,kn=0,jn=Ge=0;4>jn&&128<=Tt;jn++)Tt=ut.h[ut.g++],kn|=(Tt&127)<<7*jn;if(128<=Tt&&(Tt=ut.h[ut.g++],kn|=(Tt&127)<<28,Ge|=(Tt&127)>>4),128<=Tt)for(jn=0;5>jn&&128<=Tt;jn++)Tt=ut.h[ut.g++],Ge|=(Tt&127)<<7*jn+3;128>Tt?(ut=kn>>>0,Tt=Ge>>>0,(Ge=Tt&2147483648)&&(ut=~ut+1>>>0,Tt=~Tt>>>0,ut==0&&(Tt=Tt+1>>>0)),ut=4294967296*Tt+(ut>>>0),Ge=Ge?-ut:ut):(ut.l=!0,Ge=void 0),Ht(Ae,6,Ge);break;default:if(!In(Ae,Ve))break e}}Ae={Z:ht(Ae,1),$:ht(Ae,2),height:ht(Ae,3),width:ht(Ae,4),rotation:ht(Ae,5,0),X:Be(Ae,6)},Ve=pr(F.get(Se)),ut=O.get(Se);e:for(Ge=new hs,ut=new It(ut);zt(ut);)switch(ut.i){case 10:Ge.addClassification(dn(ut,new _s,ns));break;default:if(!In(Ge,ut))break e}Ae={T:Ae,O:Ve,M:ua(Ge)},ae.push(Ae)}P=ae}else P=[];Oe[Dn]=P,ps.g=7;break}if(Nn.type==="proto_list"){if(sn){for(P=Array(sn.size()),F=0;F<sn.size();F++)P[F]=sn.get(F);sn.delete()}else P=[];Oe[Dn]=P,ps.g=7;break}if(sn===void 0){ps.g=3;break}if(Nn.type==="float_list"){Oe[Dn]=sn,ps.g=7;break}if(Nn.type==="proto"){Oe[Dn]=sn,ps.g=7;break}if(Nn.type!=="texture")throw Error("Unknown output config type: '"+Nn.type+"'");return jt=Tn.s[Dn],jt||(jt=new Co(Tn.h,Tn.D),Tn.s[Dn]=jt),S(ps,oe(jt,sn,Tn.G),13);case 13:Un=ps.h,Oe[Dn]=Un;case 7:Nn.transform&&Oe[Dn]&&(Oe[Dn]=Nn.transform(Oe[Dn])),ps.g=3;break;case 14:Qn[Gs]=ps.h;case 3:ot=Jn.next(),ps.g=2;break;case 4:return ps.return(Oe)}})})}function Mi(D,H,q){return zn(D,function pe(){var Oe=this,st;return I(pe,function(Ue){return typeof q=="number"||q instanceof Uint8Array||q instanceof Oe.h.Uint8BlobList?Ue.return(q):q instanceof Oe.h.Texture2dDataOut?(st=Oe.s[H],st||(st=new Co(Oe.h,Oe.D),Oe.s[H]=st),Ue.return(oe(st,q,Oe.G))):Ue.return(void 0)})})}function ss(D,H){for(var q=H.name||"$",pe=[].concat(l(H.wants)),Oe=new D.h.StringList,st=a(H.wants),Ue=st.next();!Ue.done;Ue=st.next())Oe.push_back(Ue.value);st=D.h.PacketListener.implement({onResults:function(ot){for(var mt={},qt=0;qt<H.wants.length;++qt)mt[pe[qt]]=ot.get(qt);var Tn=D.listeners[q];Tn&&(D.C=Ws(D,mt,H.outs).then(function(Jn){Jn=Tn(Jn);for(var Dn=0;Dn<H.wants.length;++Dn){var Nn=mt[pe[Dn]];typeof Nn=="object"&&Nn.hasOwnProperty&&Nn.hasOwnProperty("delete")&&Nn.delete()}Jn&&(D.C=Jn)}))}}),D.i.attachMultiListener(Oe,st),Oe.delete()}n.onResults=function(D,H){this.listeners[H||"$"]=D},W("Solution",Yt),W("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Vn(D){switch(D===void 0&&(D=0),D){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function Ss(D){var H=this;D=D||{},this.g=new Yt({locateFile:D.locateFile,files:function(q){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Vn(q.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:pr},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:pr},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(q){return zn(H,function pe(){var Oe,st,Ue=this,ot;return I(pe,function(mt){return mt.g==1?(Oe=Vn(q),st="third_party/mediapipe/modules/pose_landmark/"+Oe,S(mt,ws(Ue.g,Oe),2)):(ot=mt.h,Ue.g.overrideFile(st,ot),mt.return(!0))})})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Ss.prototype,n.reset=function(){this.g.reset()},n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(D){this.g.onResults(D)},n.initialize=function(){return zn(this,function D(){var H=this;return I(D,function(q){return S(q,H.g.initialize(),0)})})},n.send=function(D,H){return zn(this,function q(){var pe=this;return I(q,function(Oe){return S(Oe,pe.g.send(D,H),0)})})},n.setOptions=function(D){this.g.setOptions(D)},W("Pose",Ss),W("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),W("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),W("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),W("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),W("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),W("VERSION","0.4.1633558788")}).call(G3)),G3}var SK=bK(),H3={},VR;function CK(){return VR||(VR=1,(function(){function n(T){var M=0;return function(){return M<T.length?{done:!1,value:T[M++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(T,M,j){return T==Array.prototype||T==Object.prototype||(T[M]=j.value),T};function t(T){T=[typeof globalThis=="object"&&globalThis,T,typeof window=="object"&&window,typeof self=="object"&&self,typeof ff=="object"&&ff];for(var M=0;M<T.length;++M){var j=T[M];if(j&&j.Math==Math)return j}throw Error("Cannot find global object")}var s=t(this);function i(T,M){if(M)e:{var j=s;T=T.split(".");for(var W=0;W<T.length-1;W++){var z=T[W];if(!(z in j))break e;j=j[z]}T=T[T.length-1],W=j[T],M=M(W),M!=W&&M!=null&&e(j,T,{configurable:!0,writable:!0,value:M})}}i("Symbol",function(T){function M(X){if(this instanceof M)throw new TypeError("Symbol is not a constructor");return new j(W+(X||"")+"_"+z++,X)}function j(X,B){this.g=X,e(this,"description",{configurable:!0,writable:!0,value:B})}if(T)return T;j.prototype.toString=function(){return this.g};var W="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",z=0;return M}),i("Symbol.iterator",function(T){if(T)return T;T=Symbol("Symbol.iterator");for(var M="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),j=0;j<M.length;j++){var W=s[M[j]];typeof W=="function"&&typeof W.prototype[T]!="function"&&e(W.prototype,T,{configurable:!0,writable:!0,value:function(){return r(n(this))}})}return T});function r(T){return T={next:T},T[Symbol.iterator]=function(){return this},T}function o(T){var M=typeof Symbol<"u"&&Symbol.iterator&&T[Symbol.iterator];return M?M.call(T):{next:n(T)}}function a(){this.i=!1,this.g=null,this.o=void 0,this.j=1,this.m=0,this.h=null}function l(T){if(T.i)throw new TypeError("Generator is already running");T.i=!0}a.prototype.l=function(T){this.o=T};function c(T,M){T.h={F:M,G:!0},T.j=T.m}a.prototype.return=function(T){this.h={return:T},this.j=this.m};function u(T){this.g=new a,this.h=T}function d(T,M){l(T.g);var j=T.g.g;return j?h(T,"return"in j?j.return:function(W){return{value:W,done:!0}},M,T.g.return):(T.g.return(M),p(T))}function h(T,M,j,W){try{var z=M.call(T.g.g,j);if(!(z instanceof Object))throw new TypeError("Iterator result "+z+" is not an object");if(!z.done)return T.g.i=!1,z;var X=z.value}catch(B){return T.g.g=null,c(T.g,B),p(T)}return T.g.g=null,W.call(T.g,X),p(T)}function p(T){for(;T.g.j;)try{var M=T.h(T.g);if(M)return T.g.i=!1,{value:M.value,done:!1}}catch(j){T.g.o=void 0,c(T.g,j)}if(T.g.i=!1,T.g.h){if(M=T.g.h,T.g.h=null,M.G)throw M.F;return{value:M.return,done:!0}}return{value:void 0,done:!0}}function g(T){this.next=function(M){return l(T.g),T.g.g?M=h(T,T.g.g.next,M,T.g.l):(T.g.l(M),M=p(T)),M},this.throw=function(M){return l(T.g),T.g.g?M=h(T,T.g.g.throw,M,T.g.l):(c(T.g,M),M=p(T)),M},this.return=function(M){return d(T,M)},this[Symbol.iterator]=function(){return this}}function y(T){function M(W){return T.next(W)}function j(W){return T.throw(W)}return new Promise(function(W,z){function X(B){B.done?W(B.value):Promise.resolve(B.value).then(M,j).then(X,z)}X(T.next())})}i("Promise",function(T){function M(B){this.h=0,this.i=void 0,this.g=[],this.o=!1;var J=this.j();try{B(J.resolve,J.reject)}catch(K){J.reject(K)}}function j(){this.g=null}function W(B){return B instanceof M?B:new M(function(J){J(B)})}if(T)return T;j.prototype.h=function(B){if(this.g==null){this.g=[];var J=this;this.i(function(){J.l()})}this.g.push(B)};var z=s.setTimeout;j.prototype.i=function(B){z(B,0)},j.prototype.l=function(){for(;this.g&&this.g.length;){var B=this.g;this.g=[];for(var J=0;J<B.length;++J){var K=B[J];B[J]=null;try{K()}catch(ee){this.j(ee)}}}this.g=null},j.prototype.j=function(B){this.i(function(){throw B})},M.prototype.j=function(){function B(ee){return function(ne){K||(K=!0,ee.call(J,ne))}}var J=this,K=!1;return{resolve:B(this.A),reject:B(this.l)}},M.prototype.A=function(B){if(B===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(B instanceof M)this.C(B);else{e:switch(typeof B){case"object":var J=B!=null;break e;case"function":J=!0;break e;default:J=!1}J?this.v(B):this.m(B)}},M.prototype.v=function(B){var J=void 0;try{J=B.then}catch(K){this.l(K);return}typeof J=="function"?this.D(J,B):this.m(B)},M.prototype.l=function(B){this.u(2,B)},M.prototype.m=function(B){this.u(1,B)},M.prototype.u=function(B,J){if(this.h!=0)throw Error("Cannot settle("+B+", "+J+"): Promise already settled in state"+this.h);this.h=B,this.i=J,this.h===2&&this.B(),this.H()},M.prototype.B=function(){var B=this;z(function(){if(B.I()){var J=s.console;typeof J<"u"&&J.error(B.i)}},1)},M.prototype.I=function(){if(this.o)return!1;var B=s.CustomEvent,J=s.Event,K=s.dispatchEvent;return typeof K>"u"?!0:(typeof B=="function"?B=new B("unhandledrejection",{cancelable:!0}):typeof J=="function"?B=new J("unhandledrejection",{cancelable:!0}):(B=s.document.createEvent("CustomEvent"),B.initCustomEvent("unhandledrejection",!1,!0,B)),B.promise=this,B.reason=this.i,K(B))},M.prototype.H=function(){if(this.g!=null){for(var B=0;B<this.g.length;++B)X.h(this.g[B]);this.g=null}};var X=new j;return M.prototype.C=function(B){var J=this.j();B.s(J.resolve,J.reject)},M.prototype.D=function(B,J){var K=this.j();try{B.call(J,K.resolve,K.reject)}catch(ee){K.reject(ee)}},M.prototype.then=function(B,J){function K(Z,he){return typeof Z=="function"?function(ve){try{ee(Z(ve))}catch(be){ne(be)}}:he}var ee,ne,V=new M(function(Z,he){ee=Z,ne=he});return this.s(K(B,ee),K(J,ne)),V},M.prototype.catch=function(B){return this.then(void 0,B)},M.prototype.s=function(B,J){function K(){switch(ee.h){case 1:B(ee.i);break;case 2:J(ee.i);break;default:throw Error("Unexpected state: "+ee.h)}}var ee=this;this.g==null?X.h(K):this.g.push(K),this.o=!0},M.resolve=W,M.reject=function(B){return new M(function(J,K){K(B)})},M.race=function(B){return new M(function(J,K){for(var ee=o(B),ne=ee.next();!ne.done;ne=ee.next())W(ne.value).s(J,K)})},M.all=function(B){var J=o(B),K=J.next();return K.done?W([]):new M(function(ee,ne){function V(ve){return function(be){Z[ve]=be,he--,he==0&&ee(Z)}}var Z=[],he=0;do Z.push(void 0),he++,W(K.value).s(V(Z.length-1),ne),K=J.next();while(!K.done)})},M});var x=typeof Object.assign=="function"?Object.assign:function(T,M){for(var j=1;j<arguments.length;j++){var W=arguments[j];if(W)for(var z in W)Object.prototype.hasOwnProperty.call(W,z)&&(T[z]=W[z])}return T};i("Object.assign",function(T){return T||x});var v=this||self,b={facingMode:"user",width:640,height:480};function S(T,M){this.video=T,this.i=0,this.h=Object.assign(Object.assign({},b),M)}S.prototype.stop=function(){var T=this,M,j,W,z;return y(new g(new u(function(X){if(T.g){for(M=T.g.getTracks(),j=o(M),W=j.next();!W.done;W=j.next())z=W.value,z.stop();T.g=void 0}X.j=0})))},S.prototype.start=function(){var T=this,M;return y(new g(new u(function(j){return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||alert("No navigator.mediaDevices.getUserMedia exists."),M=T.h,j.return(navigator.mediaDevices.getUserMedia({video:{facingMode:M.facingMode,width:M.width,height:M.height}}).then(function(W){E(T,W)}).catch(function(W){var z="Failed to acquire camera feed: "+W;throw console.error(z),alert(z),W}))})))};function C(T){window.requestAnimationFrame(function(){k(T)})}function E(T,M){T.g=M,T.video.srcObject=M,T.video.onloadedmetadata=function(){T.video.play(),C(T)}}function k(T){var M=null;T.video.paused||T.video.currentTime===T.i||(T.i=T.video.currentTime,M=T.h.onFrame()),M?M.then(function(){C(T)}):C(T)}var R=["Camera"],L=v;R[0]in L||typeof L.execScript>"u"||L.execScript("var "+R[0]);for(var I;R.length&&(I=R.shift());)R.length||S===void 0?L[I]&&L[I]!==Object.prototype[I]?L=L[I]:L=L[I]={}:L[I]=S}).call(H3)),H3}var _K=CK();const EK="/assets/soo-0000-Photoroom-BBdVyFPE.png",TK="/assets/soo-0001-Photoroom-CRiqCddx.png",IK="/assets/soo-0002-Photoroom-SUq0Wl_H.png",kK="/assets/soo-0003-Photoroom-VGW0wNwY.png",AK="/assets/soo-0004-Photoroom-CxkRqstL.png",RK="/assets/soo-0005-Photoroom-DywkhGHf.png",MK="/assets/soo-0006-Photoroom-DPEePvTh.png",NK="/assets/soo-0007-Photoroom-_h9KKY2U.png",PK="/assets/soo-0008-Photoroom-Btq2RRP6.png",DK="/assets/soo-0009-Photoroom-D-PhzpM4.png",LK="/assets/soo-0010-Photoroom-CnufWnMi.png",$K=[EK,TK,IK,kK,AK,RK,MK,NK,PK,DK,LK],LF=({videoRef:n,onStatsUpdate:e})=>{const[t,s]=le.useState(0),[i,r]=le.useState({x:0,y:0,scale:1}),[o,a]=le.useState("Initialisation..."),[l,c]=le.useState(!0),u=le.useRef(null),d=le.useRef(null),h=le.useRef(null),p=le.useRef(null),g=le.useRef(null),y=le.useRef({x:0,y:0,scale:1,angle:0}),x=.3,v=(M,j)=>j+(M-j)*x,b=le.useRef({tFrameStart:0,tAfterFaceMesh:0,tBeforeOverlay:0,tPoseStart:0,tPoseBeforeInference:0,tPoseEnd:0});let S=0;const C=le.useRef([]),E=le.useRef(0),k=15,R=.15,L=(M,j,W,z,X)=>{const B=performance.now();C.current.push({x:M,y:j,time:B}),C.current.length>k&&C.current.shift();const J=Math.max(0,Math.min(100,100*(1-X/200))),K=z*.2,ee=Math.abs(j-W),ne=Math.max(0,Math.min(100,100*(1-ee/(K*2))));let V=100;if(C.current.length>=2){const ve=C.current;let be=[];for(let Fe=1;Fe<ve.length;Fe++){const Pe=ve[Fe].x-ve[Fe-1].x,ct=ve[Fe].y-ve[Fe-1].y,at=ve[Fe].time-ve[Fe-1].time,Ee=Math.sqrt(Pe*Pe+ct*ct)/at;be.push(Ee)}const Ie=be.reduce((Fe,Pe)=>Fe+Pe,0)/be.length,Xe=be.reduce((Fe,Pe)=>Fe+Math.pow(Pe-Ie,2),0)/be.length;V=Math.max(0,Math.min(100,100*(1-Xe/5)))}const Z=(J*.3+ne*.4+V*.3)/100,he=E.current+(Z-E.current)*R;return E.current=he,he};le.useEffect(()=>{if(!n.current||!u.current)return;let M=null,j=!0;return(async()=>{try{a("Chargement FaceMesh & Pose...");const z=new wK.FaceMesh({locateFile:B=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4.1633559619/${B}`});z.setOptions({maxNumFaces:1,refineLandmarks:!1,minDetectionConfidence:.5,minTrackingConfidence:.5,enableFaceGeometry:!1}),z.onResults(B=>{var ee;if(!j)return;const J=performance.now()-b.current.tFrameStart;b.current.tAfterFaceMesh=performance.now(),p.current=B;const K=(ee=B.multiFaceLandmarks)==null?void 0:ee[0];g.current&&(b.current.tBeforeOverlay=performance.now(),I(B,g.current,J))}),d.current=z;const X=new SK.Pose({locateFile:B=>`https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.4.1633558788/${B}`});X.setOptions({modelComplexity:0,smoothLandmarks:!0,minDetectionConfidence:.5,minTrackingConfidence:.5,enableSegmentation:!1}),X.onResults(B=>{if(!j)return;b.current.tPoseBeforeInference=performance.now(),b.current.tPoseEnd=performance.now();const J=performance.now()-b.current.tAfterFaceMesh;b.current.tBeforeOverlay=performance.now(),g.current=B,p.current&&I(p.current,B,void 0,J)}),h.current=X,a("FaceMesh & Pose initialisés"),M=new _K.Camera(n.current,{onFrame:async()=>{if(j)try{b.current.tFrameStart=performance.now(),d.current&&S%2===0&&await d.current.send({image:n.current}),S++,S%3===0&&(b.current.tPoseStart=performance.now(),h.current&&await h.current.send({image:n.current}))}catch(B){if(!j)return;console.error("Erreur frame:",B),a(`Erreur frame: ${B.message}`)}},width:480,height:270}),await M.start(),a("Caméra démarrée (480x270, skip 1/2 frames pour Pose)")}catch(z){console.error("Erreur init:",z),a(`Erreur init: ${z.message}`)}})(),()=>{var z,X;j=!1,M==null||M.stop(),(z=d.current)==null||z.close(),(X=h.current)==null||X.close()}},[n]);const I=(M,j,W,z)=>{var bt,Wt,ht;const X=performance.now(),B=(bt=M.multiFaceLandmarks)==null?void 0:bt[0],J=j.poseLandmarks;if(!B||!J)return;const K=B[33],ee=B[263],ne=B[152],V=J[11],Z=J[12],he=((Wt=n.current)==null?void 0:Wt.offsetWidth)||1,ve=((ht=n.current)==null?void 0:ht.offsetHeight)||1,be=-Math.atan2(ee.y-K.y,ee.x-K.x),Ie=v(be,y.current.angle),Xe=(V.x+Z.x)/2,Fe=(V.y+Z.y)/2,Pe=Xe*he,ct=Fe*ve,at=ne.x*he,Ee=ne.y*ve,nn=.7*Pe+.3*at,gt=.7*ct+.3*Ee,vt=10,Vt=he-nn+5,It=gt+vt,zt=Math.hypot((Z.x-V.x)*he,(Z.y-V.y)*ve),Gt=Math.abs(K.x-ee.x)*he,dn=(zt+Gt)/620+.08,vn=v(dn,y.current.scale);let ce=Math.round(Ie*11/(2*Math.PI));Math.abs(Ie)<.3&&(ce=10),ce=Math.max(0,Math.min(10,ce));const Y=L(Vt,It,gt,zt,W||0),ye={detectedPoints:B.length,confidence:Y,processingTime:W||0};e==null||e(ye);const Qe=v(Vt,y.current.x),tt=v(It,y.current.y);y.current={x:Qe,y:tt,scale:vn,angle:Ie},s(ce),r({x:Qe,y:tt,scale:vn});const rt=performance.now()-X,{tPoseStart:Pt,tPoseBeforeInference:pt,tPoseEnd:At}=b.current,xe=(pt-Pt).toFixed(1),xt=(At-pt).toFixed(1),Ye=(W==null?void 0:W.toFixed(1))??"0",kt=(z==null?void 0:z.toFixed(1))??"0",Et=rt.toFixed(1);a(`FaceMesh: ${Ye} ms | Pose: ${kt} ms | Overlay: ${Et} ms | PoseDetails: start->beforeInf:${xe}ms, beforeInf->end:${xt}ms`)},T=({isVisible:M,onClose:j})=>{const[W,z]=le.useState(null),X={position:{title:"Le collier apparaît automatiquement!    Positionnez vous bien au centre de l'image pour faire apparaitre le collier rapidement"}};return M?G.jsxs("div",{className:"absolute right-4 top-4 w-72 bg-white/90 backdrop-blur-md rounded-xl shadow-xl border border-white/20 overflow-hidden",style:{pointerEvents:"auto",zIndex:1e3},children:[G.jsx("div",{className:"p-4 border-b border-gray-200",children:G.jsx("h3",{className:"text-lg font-semibold text-gray-900",children:"Contrôles du Collier"})}),G.jsx("div",{className:"divide-y divide-gray-100",children:Object.entries(X).map(([B,J])=>G.jsxs("div",{className:"p-4 hover:bg-emerald-50 transition-colors cursor-help",onMouseEnter:()=>z(B),onMouseLeave:()=>z(null),children:[G.jsxs("div",{className:"flex items-center gap-3",children:[G.jsx("span",{className:"text-2xl",children:J.icon}),G.jsxs("div",{children:[G.jsx("h4",{className:"font-medium text-gray-900",children:J.title}),G.jsx("div",{className:"flex items-center gap-2",children:G.jsx("span",{className:"text-xs px-2 py-1 bg-gray-100 rounded",children:J.shortcut})})]})]}),W===B&&G.jsx("p",{className:"mt-2 text-sm text-gray-600 animate-fadeIn",children:J.description})]},B))}),G.jsx("div",{className:"p-4 bg-gray-50",children:G.jsx("button",{onClick:j,className:`w-full px-4 py-2 bg-emerald-500 text-white rounded-lg
                     hover:bg-emerald-600 transition-colors text-sm font-medium`,children:"Compris !"})})]}):null};return G.jsxs("div",{style:{position:"absolute",top:0,left:0,width:"100%",height:"100%",pointerEvents:"none"},children:[G.jsx(T,{isVisible:l,onClose:()=>c(!1)}),G.jsx("canvas",{ref:u,style:{position:"absolute",width:"100%",height:"100%",pointerEvents:"none"}}),G.jsx("img",{src:$K[t],alt:"Collier",style:{position:"absolute",left:`${i.x}px`,top:`${i.y}px`,transform:`translate(-50%, -50%) scale(${i.scale}) rotate(${y.current.angle}rad)`,maxWidth:"300px",opacity:.9}}),G.jsxs("div",{style:{position:"absolute",top:10,left:10,background:"rgba(0,0,0,0.7)",color:"white",padding:"5px",borderRadius:"5px",fontSize:"12px",zIndex:1e3},children:["État: ",o]})]})},FK=({onComplete:n})=>{const[e,t]=le.useState(0),s=[{title:"Essayer",description:"Activez votre caméra pour commencer l'essayage en temps réel",targetId:"try-button",position:{bottom:"120%",left:"50%",transform:"translateX(-50%)"}},{title:"Agrandir",description:"Passez en plein écran pour une meilleure expérience",targetId:"expand-button",position:{left:"-120%",top:"50%",transform:"translateY(-50%)"}}];return le.useEffect(()=>{e>=s.length&&n()},[e,n]),G.jsxs("div",{className:"fixed inset-0 z-50",children:[G.jsx(wn.div,{className:"absolute inset-0 bg-black/50",initial:{opacity:0},animate:{opacity:1},transition:{duration:.3}}),s.map((i,r)=>e===r&&G.jsx(wn.div,{className:"absolute",initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.3},style:{...i.position,pointerEvents:"auto"},children:G.jsxs("div",{className:"relative",children:[G.jsx("div",{className:"absolute -inset-4 bg-emerald-500/20 rounded-full animate-pulse"}),G.jsxs("div",{className:"bg-white rounded-xl shadow-xl p-4 w-64",children:[G.jsx("h3",{className:"font-medium text-gray-900 mb-1",children:i.title}),G.jsx("p",{className:"text-sm text-gray-600 mb-3",children:i.description}),G.jsx("button",{onClick:()=>t(o=>o+1),className:"w-full px-3 py-1.5 bg-emerald-500 text-white text-sm rounded-lg hover:bg-emerald-600 transition-colors",children:r===s.length-1?"Compris !":"Suivant"})]})]})},r))]})},OK=({videoRef:n,children:e})=>{const t=le.useRef(null),[s,i]=le.useState(!0),[r,o]=le.useState(!1),[a,l]=le.useState(null),[c,u]=le.useState(!1),[d,h]=le.useState(!1),[p,g]=le.useState({detectedPoints:0,confidence:0,processingTime:0}),[y,x]=le.useState(!1),v=le.useRef(null);le.useEffect(()=>{const I=new IntersectionObserver(([T])=>{T.isIntersecting&&setTimeout(()=>{x(!0)},500)},{threshold:.8});return v.current&&I.observe(v.current),()=>{v.current&&I.unobserve(v.current)}},[]);const b=()=>{x(!1)};le.useEffect(()=>{document.createElement("canvas").getContext("webgl")||l("Erreur : WebGL semble indisponible dans ce navigateur. Veuillez vérifier vos réglages ou utiliser un autre navigateur.")},[]);const S=async()=>{try{console.log("Starting camera...");const I=await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1280},height:{ideal:720},facingMode:"user",frameRate:{ideal:30}}});n.current&&(n.current.srcObject=I,n.current.onloadedmetadata=()=>{var T;(T=n.current)==null||T.play().then(()=>{console.log("Video playback started"),i(!1),o(!0),h(!0)}).catch(M=>{console.error("Error starting video playback:",M),l("Failed to start video playback")})})}catch(I){console.error("Camera error:",I),l("Failed to access camera"),i(!1)}},C=()=>{console.log("Stopping camera..."),n.current&&n.current.srcObject&&(n.current.srcObject.getTracks().forEach(T=>{T.stop(),console.log("Track stopped:",T.kind)}),n.current.srcObject=null),o(!1),h(!1),g({detectedPoints:0,confidence:0,processingTime:0}),console.log("Camera stopped and state reset")},E=I=>{g(I)};le.useEffect(()=>{const I=()=>{u(!!document.fullscreenElement)};return document.addEventListener("fullscreenchange",I),()=>{d&&C(),document.removeEventListener("fullscreenchange",I)}},[d]);const k=async()=>{try{!c&&t.current?await t.current.requestFullscreen():document.exitFullscreen&&await document.exitFullscreen()}catch(I){console.error("Erreur de plein écran:",I)}};if(a)return G.jsxs("div",{className:"camera-error text-red-600 p-8 text-center",children:[G.jsx("p",{children:a}),G.jsx("p",{children:"Veuillez vérifier votre navigateur ou vos autorisations."})]});const R=new Date().getFullYear(),L=[{name:"Instagram",href:"https://www.instagram.com/bleureflet/",icon:G.jsx("path",{fillRule:"evenodd",d:"M12.315 2c2.43 0 2.784.013 3.808.06 1.064.049 1.791.218 2.427.465a4.902 4.902 0 011.772 1.153 4.902 4.902 0 011.153 1.772c.247.636.416 1.363.465 2.427.048 1.067.06 1.407.06 4.123v.08c0 2.643-.012 2.987-.06 4.043-.049 1.064-.218 1.791-.465 2.427a4.902 4.902 0 01-1.153 1.772 4.902 4.902 0 01-1.772 1.153c-.636.247-1.363.416-2.427.465-1.067.048-1.407.06-4.123.06h-.08c-2.643 0-2.987-.012-4.043-.06-1.064-.049-1.791-.218-2.427-.465a4.902 4.902 0 01-1.772-1.153 4.902 4.902 0 01-1.153-1.772c-.247-.636-.416-1.363-.465-2.427-.047-1.024-.06-1.379-.06-3.808v-.63c0-2.43.013-2.784.06-3.808.049-1.064.218-1.791.465-2.427a4.902 4.902 0 011.153-1.772A4.902 4.902 0 015.45 2.525c.636-.247 1.363-.416 2.427-.465C8.901 2.013 9.256 2 11.685 2h.63zm-.081 1.802h-.468c-2.456 0-2.784.011-3.807.058-.975.045-1.504.207-1.857.344-.467.182-.8.398-1.15.748-.35.35-.566.683-.748 1.15-.137.353-.3.882-.344 1.857-.047 1.023-.058 1.351-.058 3.807v.468c0 2.456.011 2.784.058 3.807.045.975.207 1.504.344 1.857.182.466.398.8.748 1.15.35.35.683.566 1.15.748.353.137.882.3 1.857.344 1.054.048 1.37.058 4.041.058h.08c2.597 0 2.917-.01 3.96-.058.976-.045 1.505-.207 1.858-.344.466-.182.8-.398 1.15-.748.35-.35.566-.683.748-1.15.137-.353.3-.882.344-1.857.048-1.055.058-1.37.058-4.041v-.08c0-2.597-.01-2.917-.058-3.96-.045-.976-.207-1.505-.344-1.858a3.097 3.097 0 00-.748-1.15 3.098 3.098 0 00-1.15-.748c-.353-.137-.882-.3-1.857-.344-1.023-.047-1.351-.058-3.807-.058zM12 6.865a5.135 5.135 0 110 10.27 5.135 5.135 0 010-10.27zm0 1.802a3.333 3.333 0 100 6.666 3.333 3.333 0 000-6.666zm5.338-3.205a1.2 1.2 0 110 2.4 1.2 1.2 0 010-2.4z",clipRule:"evenodd"})},{name:"Pinterest",href:"https://www.pinterest.fr/bleureflet/",icon:G.jsx("path",{fillRule:"evenodd",d:"M12 2C6.477 2 2 6.477 2 12c0 4.237 2.636 7.855 6.356 9.312-.088-.791-.167-2.005.035-2.868.181-.78 1.172-4.97 1.172-4.97s-.299-.6-.299-1.486c0-1.39.806-2.428 1.81-2.428.852 0 1.264.64 1.264 1.408 0 .858-.546 2.14-.828 3.33-.236.995.5 1.807 1.48 1.807 1.778 0 3.144-1.874 3.144-4.58 0-2.393-1.72-4.068-4.177-4.068-2.845 0-4.515 2.135-4.515 4.34 0 .859.331 1.781.745 2.281a.3.3 0 01.069.288l-.278 1.133c-.044.183-.145.223-.335.134-1.249-.581-2.03-2.407-2.03-3.874 0-3.154 2.292-6.052 6.608-6.052 3.469 0 6.165 2.473 6.165 5.776 0 3.447-2.173 6.22-5.19 6.22-1.013 0-1.965-.525-2.291-1.148l-.623 2.378c-.226.869-.835 1.958-1.244 2.621.937.29 1.931.446 2.962.446 5.523 0 10-4.477 10-10S17.523 2 12 2z",clipRule:"evenodd"})}];return G.jsxs(wn.div,{ref:v,initial:{opacity:0},whileInView:{opacity:1},viewport:{once:!0},className:"relative w-full",children:[y&&G.jsx(FK,{onComplete:b}),G.jsxs("div",{className:"max-w-7xl mx-auto px-4",children:[G.jsxs("div",{className:"text-left mb-12",children:[G.jsx(wn.h2,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},viewport:{once:!0},className:"font-heading text-5xl text-black mb-2 text-left max-w-7xl mx-auto",children:"Essayez nos colliers virtuellement"}),G.jsx(wn.p,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},viewport:{once:!0},transition:{delay:.2},className:"font-display text-xl text-black/70 text-left max-w-7xl mx-auto",children:"Notre technologie d'IA analyse votre morphologie en temps réel pour un essayage virtuel photoréaliste"})]}),G.jsxs("div",{className:"flex flex-col lg:flex-row gap-8",children:[G.jsx(wn.div,{initial:{opacity:0,x:-20},whileInView:{opacity:1,x:0},viewport:{once:!0},className:"lg:flex-1",children:G.jsxs("div",{ref:t,className:"relative w-full h-[80vh] bg-black rounded-lg overflow-hidden",children:[G.jsx("video",{ref:n,className:"absolute top-0 left-0 w-full h-full object-cover",playsInline:!0,muted:!0,style:{transform:"scaleX(-1)"}}),r&&n.current&&G.jsx(LF,{videoRef:n,onStatsUpdate:E}),G.jsx("div",{className:"absolute top-0 left-0 right-0 p-6 flex justify-between items-start",children:G.jsxs("div",{className:"flex items-center space-x-3 bg-black/40 backdrop-blur-md rounded-2xl px-6 py-3 border border-white/10",children:[G.jsx("div",{className:`w-3 h-3 ${d?"bg-[#64ffa2]":"bg-red-500"} rounded-full animate-pulse`}),G.jsx("span",{className:"font-heading text-xl text-white",children:d?"Active":"Inactive"})]})}),!d&&G.jsx("div",{className:"absolute inset-0 flex items-center justify-center",children:G.jsxs("div",{className:"text-center px-6",children:[G.jsx("div",{className:"w-20 h-20 bg-white/5 rounded-full flex items-center justify-center mx-auto mb-6 border-2 border-dashed border-white/20",children:G.jsx("svg",{className:"w-10 h-10 text-white/40",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"})})}),G.jsx("p",{className:"text-xl text-white/60 font-display",children:"Caméra non activée"})]})}),G.jsx("div",{className:`absolute ${c?"bottom-8":"bottom-0"} left-0 right-0 p-5 transition-all duration-500`,children:G.jsxs(wn.div,{className:"flex justify-between items-center px-1",initial:!1,animate:c?{y:0,opacity:1}:{y:0,opacity:1},transition:{duration:.3},children:[G.jsxs("div",{className:"flex items-center space-x-3",children:[G.jsx(wn.button,{whileHover:{scale:1.02,backgroundColor:d?"rgba(239, 68, 68, 0.9)":"rgba(100, 255, 162, 0.9)",boxShadow:d?"0 0 20px rgba(239, 68, 68, 0.2)":"0 0 20px rgba(100, 255, 162, 0.2)"},whileTap:{scale:.98},onClick:()=>d?C():S(),className:`px-5 py-2 ${d?"bg-red-500/70":"bg-[#64ffa2]/70"} backdrop-blur-sm text-black/90 rounded-full font-display text-sm tracking-wide transition-all duration-300 border ${d?"border-red-500/20":"border-[#64ffa2]/20"}`,id:"try-button",children:d?"✕ Arrêter":"→ Essayer"}),d&&G.jsx(wn.div,{initial:{opacity:0,x:-10},animate:{opacity:1,x:0},className:"flex items-center space-x-4",children:G.jsx("div",{className:"flex items-center space-x-1.5 bg-white/5 backdrop-blur-sm rounded-full px-3 py-1.5 border border-white/10",children:G.jsxs(wn.span,{animate:{scale:[1,1.1,1]},transition:{duration:2,repeat:1/0},className:"font-display text-xs text-white/60",children:[p.detectedPoints," points"]})})})]}),G.jsxs("div",{className:"flex items-center space-x-3",children:[d&&G.jsx(vK,{}),G.jsx(wn.button,{whileHover:{scale:1.02},whileTap:{scale:.98},onClick:k,className:`px-4 py-1.5 bg-black/10 backdrop-blur-sm text-white/90 rounded-full font-display text-xs tracking-wide transition-all duration-300 border border-white/10 ${c?"hover:bg-black/20":""}`,id:"expand-button",children:c?"← Réduire":"↗ Agrandir"}),d&&G.jsxs("div",{className:"flex items-center space-x-1.5 bg-black/10 backdrop-blur-sm rounded-full px-3 py-1.5",children:[G.jsx("div",{className:"w-1 h-1 bg-red-500/80 rounded-full animate-pulse"}),G.jsx("span",{className:"font-display text-xs text-white/50",children:"Live"})]})]})]})}),e]})}),G.jsxs(wn.div,{initial:{opacity:0,x:20},whileInView:{opacity:1,x:0},viewport:{once:!0},className:"lg:w-96 space-y-6",children:[G.jsxs("div",{className:"grid gap-4",children:[G.jsx("div",{className:"bg-gradient-to-br from-black/40 to-black/20 backdrop-blur-md rounded-2xl p-6 border border-white/10",children:G.jsxs("div",{className:"flex items-center justify-between",children:[G.jsxs("div",{children:[G.jsx("p",{className:"font-display text-lg text-white/60 mb-2",children:"Points détectés"}),G.jsxs("div",{className:"flex items-baseline space-x-2",children:[G.jsx("span",{className:"font-heading text-4xl text-[#64ffa2]",children:p.detectedPoints}),G.jsx("span",{className:"font-display text-white/40",children:"points"})]})]}),G.jsx("div",{className:"w-12 h-12 bg-[#64ffa2]/10 rounded-xl flex items-center justify-center",children:G.jsxs("svg",{className:"w-6 h-6 text-[#64ffa2]",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:[G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M15 12a3 3 0 11-6 0 3 3 0 016 0z"}),G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"})]})})]})}),G.jsx("div",{className:"bg-gradient-to-br from-black/40 to-black/20 backdrop-blur-md rounded-2xl p-6 border border-white/10",children:G.jsxs("div",{className:"flex items-center justify-between",children:[G.jsxs("div",{children:[G.jsx("p",{className:"font-display text-lg text-white/60 mb-2",children:"Confiance"}),G.jsxs("div",{className:"flex items-baseline space-x-2",children:[G.jsx("span",{className:"font-heading text-4xl text-[#64ffa2]",children:(p.confidence*100).toFixed(1)}),G.jsx("span",{className:"font-display text-white/40",children:"%"})]})]}),G.jsx("div",{className:"w-12 h-12 bg-[#64ffa2]/10 rounded-xl flex items-center justify-center",children:G.jsx("svg",{className:"w-6 h-6 text-[#64ffa2]",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"})})})]})}),G.jsx("div",{className:"bg-gradient-to-br from-black/40 to-black/20 backdrop-blur-md rounded-2xl p-6 border border-white/10",children:G.jsxs("div",{className:"flex items-center justify-between",children:[G.jsxs("div",{children:[G.jsx("p",{className:"font-display text-lg text-white/60 mb-2",children:"Temps de traitement"}),G.jsxs("div",{className:"flex items-baseline space-x=2",children:[G.jsx("span",{className:"font-heading text-4xl text-[#64ffa2]",children:Math.round(p.processingTime)}),G.jsx("span",{className:"font-display text-white/40",children:"ms"})]})]}),G.jsx("div",{className:"w-12 h-12 bg-[#64ffa2]/10 rounded-xl flex items-center justify-center",children:G.jsx("svg",{className:"w-6 h-6 text-[#64ffa2]",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"})})})]})})]}),G.jsx("div",{className:"bg-gradient-to-br from-black/40 to-black/20 backdrop-blur-md rounded-2xl p-6 border border-white/10",children:G.jsxs("div",{className:"flex items-start space-x-4",children:[G.jsx("div",{className:"w-10 h-10 bg-[#64ffa2]/10 rounded-lg flex items-center justify-center flex-shrink-0",children:G.jsx("svg",{className:"w-6 h-6 text-[#64ffa2]",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"})})}),G.jsx("p",{className:"font-display text-sm text-white/60 leading-relaxed",children:"Notre système utilise des algorithmes avancés de deep learning et MediaPipe pour analyser la morphologie du cou et des épaules, permettant un placement précis et réaliste des colliers virtuels."})]})})]})]})]}),G.jsxs("div",{className:"mt-32 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-24",children:[G.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-12",children:[G.jsxs("div",{className:"col-span-1 lg:col-span-2",children:[G.jsx(cd,{to:"/",className:"block mb-6",children:G.jsx(wn.img,{src:DF,alt:"Bleu Reflet Logo",className:"h-16",whileHover:{scale:1.05},transition:{type:"spring",stiffness:300}})}),G.jsx("p",{className:"text-gray-400 text-base leading-relaxed mb-8",children:"Un projet innovant alliant technologie et bijouterie, développé dans le cadre du projet Engineering d'EFREI Paris-Panthéon-Assas."}),G.jsx("div",{className:"flex space-x-6",children:L.map(I=>G.jsxs(wn.a,{href:I.href,target:"_blank",rel:"noopener noreferrer",className:"text-gray-400 hover:text-white transition-colors p-2 hover:bg-white/5 rounded-lg",whileHover:{scale:1.1},whileTap:{scale:.95},children:[G.jsx("span",{className:"sr-only",children:I.name}),G.jsx("svg",{className:"h-7 w-7",fill:"currentColor",viewBox:"0 0 24 24",children:I.icon})]},I.name))})]}),G.jsxs("div",{className:"backdrop-blur-sm bg-white/5 rounded-2xl p-8",children:[G.jsx("h3",{className:"text-white font-semibold text-xl mb-6",children:"Le Projet"}),G.jsxs("ul",{className:"space-y-4",children:[G.jsx("li",{children:G.jsxs(cd,{to:"/about",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"À propos"})]})}),G.jsx("li",{children:G.jsxs(cd,{to:"/team",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"L'équipe"})]})}),G.jsx("li",{children:G.jsxs("a",{href:"https://www.efrei.fr",target:"_blank",rel:"noopener noreferrer",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"EFREI Paris-Panthéon-Assas"})]})})]})]}),G.jsxs("div",{className:"backdrop-blur-sm bg-white/5 rounded-2xl p-8",children:[G.jsx("h3",{className:"text-white font-semibold text-xl mb-6",children:"Contact"}),G.jsxs("ul",{className:"space-y-4",children:[G.jsx("li",{children:G.jsxs("a",{href:"mailto:contact@bleureflet.fr",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"contact@bleureflet.fr"})]})}),G.jsx("li",{children:G.jsxs("a",{href:"https://www.linkedin.com/company/bleu-reflet",target:"_blank",rel:"noopener noreferrer",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"LinkedIn"})]})})]})]})]}),G.jsx("div",{className:"border-t border-white/10 mt-20 pt-12",children:G.jsxs("div",{className:"flex flex-col md:flex-row justify-between items-center",children:[G.jsxs("p",{className:"text-gray-500 text-sm mb-6 md:mb-0",children:[R," Bleu Reflet × Engineering Project EFREI ",R-1,"/",R]}),G.jsxs("div",{className:"flex space-x-8",children:[G.jsxs(wn.a,{href:"https://gitlab.com/bleu-reflet/efrei/bleu-reflet-collier/-/tree/test?ref_type=heads",target:"_blank",rel:"noopener noreferrer",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",whileHover:{scale:1.05},whileTap:{scale:.95},children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"GitHub"})]}),G.jsxs(wn.a,{href:"https://www.efrei.fr/programme-grande-ecole/le-cycle-ingenieur/ingenieur-big-data/",target:"_blank",rel:"noopener noreferrer",className:"text-gray-400 hover:text-white transition-colors flex items-center space-x-2 group",whileHover:{scale:1.05},whileTap:{scale:.95},children:[G.jsx("span",{className:"w-1.5 h-1.5 bg-[#64ffa2]/50 rounded-full group-hover:bg-[#64ffa2]"}),G.jsx("span",{children:"Programme M2"})]})]})]})})]})]})},zK="data:image/svg+xml,%3csvg%20width='1250'%20height='405'%20viewBox='0%200%201250%20405'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M1223.28%2059.9775L1440%2057.9451V62.0176L1223.28%2059.9775Z'%20fill='%238F40FF'/%3e%3cpath%20d='M1189.3%2069.5549L1440%2067.5225V71.595L1189.3%2069.5549Z'%20fill='%238F40FF'/%3e%3cpath%20d='M1155.32%2079.05L1440%2077.0175V81.09L1155.32%2079.05Z'%20fill='%238F40FF'/%3e%3cpath%20d='M1121.34%2088.5526L1440%2086.5126V90.5851L1121.34%2088.5526Z'%20fill='%238F40FF'/%3e%3cpath%20d='M1087.36%2098.1301L1440%2096.0901V100.163L1087.36%2098.1301Z'%20fill='%238F40FF'/%3e%3cpath%20d='M1053.38%20107.625L1440%20105.585V109.657L1053.38%20107.625Z'%20fill='%238F40FF'/%3e%3cpath%20d='M1019.4%20117.12L1440%20115.088V119.153L1019.4%20117.12Z'%20fill='%238F40FF'/%3e%3cpath%20d='M985.418%20126.615L1440%20124.583V128.648L985.418%20126.615Z'%20fill='%238F40FF'/%3e%3cpath%20d='M951.443%20136.11L1440%20134.078V138.15L951.443%20136.11Z'%20fill='%238F40FF'/%3e%3cpath%20d='M917.46%20145.613L1440%20143.573V147.645L917.46%20145.613Z'%20fill='%238F40FF'/%3e%3cpath%20d='M883.477%20155.108L1440%20153.068V157.14L883.477%20155.108Z'%20fill='%238F40FF'/%3e%3cpath%20d='M849.503%20164.603L1440%20162.57V166.635L849.503%20164.603Z'%20fill='%238F40FF'/%3e%3cpath%20d='M815.52%20174.18L1440%20172.147V176.212L815.52%20174.18Z'%20fill='%238F40FF'/%3e%3cpath%20d='M781.537%20183.675L1440%20181.642V185.707L781.537%20183.675Z'%20fill='%238F40FF'/%3e%3cpath%20d='M747.562%20193.17L1440%20191.138V195.21L747.562%20193.17Z'%20fill='%238F40FF'/%3e%3cpath%20d='M713.58%20202.748L1440%20200.715V204.788L713.58%20202.748Z'%20fill='%238F40FF'/%3e%3cpath%20d='M679.598%20212.242L1440%20210.21V214.283L679.598%20212.242Z'%20fill='%238F40FF'/%3e%3cpath%20d='M645.622%20221.745L1440%20219.705V223.777L645.622%20221.745Z'%20fill='%238F40FF'/%3e%3cpath%20d='M611.64%20231.24L1440%20229.208V233.273L611.64%20231.24Z'%20fill='%238F40FF'/%3e%3cpath%20d='M577.657%20240.735L1440%20238.703V242.768L577.657%20240.735Z'%20fill='%238F40FF'/%3e%3cpath%20d='M543.682%20250.23L1440%20248.198V252.27L543.682%20250.23Z'%20fill='%238F40FF'/%3e%3cpath%20d='M509.7%20259.733L1440%20257.693V261.765L509.7%20259.733Z'%20fill='%238F40FF'/%3e%3cpath%20d='M475.718%20269.227L1440%20267.188V271.26L475.718%20269.227Z'%20fill='%238F40FF'/%3e%3cpath%20d='M441.742%20278.805L1440%20276.765V280.838L441.742%20278.805Z'%20fill='%238F40FF'/%3e%3cpath%20d='M407.76%20288.3L1440%20286.267V290.332L407.76%20288.3Z'%20fill='%238F40FF'/%3e%3cpath%20d='M373.777%20297.795L1440%20295.763V299.828L373.777%20297.795Z'%20fill='%238F40FF'/%3e%3cpath%20d='M339.802%20307.373L1440%20305.34V309.405L339.802%20307.373Z'%20fill='%238F40FF'/%3e%3cpath%20d='M305.82%20316.867L1440%20314.835V318.908L305.82%20316.867Z'%20fill='%238F40FF'/%3e%3cpath%20d='M271.837%20326.362L1440%20324.33V328.402L271.837%20326.362Z'%20fill='%238F40FF'/%3e%3cpath%20d='M237.863%20335.865L1440%20333.825V337.898L237.863%20335.865Z'%20fill='%238F40FF'/%3e%3cpath%20d='M203.88%20345.36L1440%20343.32V347.393L203.88%20345.36Z'%20fill='%238F40FF'/%3e%3cpath%20d='M169.897%20354.938L1440%20352.898V356.97L169.897%20354.938Z'%20fill='%238F40FF'/%3e%3cpath%20d='M135.922%20364.433L1440%20362.4V366.465L135.922%20364.433Z'%20fill='%238F40FF'/%3e%3cpath%20d='M101.94%20373.928L1440%20371.895V375.96L101.94%20373.928Z'%20fill='%238F40FF'/%3e%3cpath%20d='M67.9575%20383.505L1440%20381.473V385.538L67.9575%20383.505Z'%20fill='%238F40FF'/%3e%3cpath%20d='M33.9825%20393L1440%20390.968V395.04L33.9825%20393Z'%20fill='%238F40FF'/%3e%3cpath%20d='M0%20402.495L1440%20400.462V404.535L0%20402.495Z'%20fill='%238F40FF'/%3e%3c/svg%3e",BK=()=>{const n=[{title:"Intelligence Artificielle",description:"Notre technologie d'IA analyse en temps réel votre morphologie pour un placement précis",icon:G.jsx("svg",{className:"w-6 h-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"})})},{title:"Haute Précision",description:"Détection des points clés du cou et des épaules pour un essayage réaliste",icon:G.jsx("svg",{className:"w-6 h-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"})})},{title:"Temps Réel",description:"Visualisation instantanée des colliers avec un suivi fluide de vos mouvements",icon:G.jsx("svg",{className:"w-6 h-6",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"})})}];return G.jsxs("section",{id:"features",className:"relative py-24 bg-[#140308]",children:[G.jsx("div",{className:"absolute inset-0 hidden sm:block",style:{backgroundImage:`url(${zK})`,backgroundSize:"contain",backgroundRepeat:"no-repeat",backgroundPosition:"right center",opacity:.05}}),G.jsxs("div",{className:"container mx-auto px-4 max-w-7xl relative z-10",children:[G.jsxs("div",{className:"max-w-3xl",children:[G.jsx(wn.h6,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},viewport:{once:!0},className:"text-[#64ffa2] font-display text-lg mb-4 uppercase tracking-wider",children:"Comprendre pourquoi"}),G.jsx(wn.h2,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},viewport:{once:!0},transition:{delay:.1},className:"font-heading text-4xl md:text-5xl lg:text-6xl text-white leading-tight mb-8",children:"Essayez virtuellement nos colliers avec une précision inégalée"})]}),G.jsx("div",{className:"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mt-16",children:n.map((e,t)=>G.jsxs(wn.div,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},viewport:{once:!0},transition:{delay:t*.1},className:"bg-white/5 backdrop-blur-lg rounded-2xl p-8 hover:bg-white/10 transition-colors",children:[G.jsx("div",{className:"w-12 h-12 bg-[#64ffa2]/10 rounded-xl flex items-center justify-center mb-6",children:G.jsx("div",{className:"text-[#64ffa2]",children:e.icon})}),G.jsx("h3",{className:"font-heading text-xl text-white mb-4",children:e.title}),G.jsx("p",{className:"font-display text-gray-400 leading-relaxed",children:e.description})]},e.title))})]})]})},UK=[{id:1,name:"Céleste",description:"Or blanc 18K, constellation de diamants naturels",price:"2 490 €",image:"/necklaces/celestial.jpg",specs:["Or 18K","Diamants 0.5ct","42-45cm"]},{id:2,name:"Vénitienne",description:"Or rose, maille fine, finition miroir",price:"890 €",image:"/necklaces/venetian.jpg",specs:["Or rose","Maille 1mm","40-45cm"]},{id:3,name:"Akoya",description:"Perles japonaises AAA, lustre exceptionnel",price:"1 990 €",image:"/necklaces/pearl.jpg",specs:["Perles 7.5mm","Or blanc","45cm"]}],VK=900,WK=32,GK=.4,HK=()=>{const n=le.useRef(null),e=le.useRef([]),[t,s]=le.useState(!1),[i,r]=le.useState(0),[o,a]=le.useState(0),[l,c]=le.useState(0),u=le.useRef(!1),d=()=>{if(!n.current)return;const x=n.current.getBoundingClientRect(),v=x.left+x.width/2;let b=0,S=l;return e.current.forEach((C,E)=>{if(!C)return;const k=C.getBoundingClientRect(),R=k.left+k.width/2,I=1-Math.abs(v-R)/(x.width/2);I>b&&(b=I,S=E)}),{mostVisibleIndex:S,visibility:b}},h=x=>{if(!n.current||u.current)return;u.current=!0;const v=x*(VK+WK),b=n.current.scrollLeft;WX(b,v,{duration:.6,ease:[.32,.72,0,1],onUpdate:C=>{n.current&&(n.current.scrollLeft=C)},onComplete:()=>{u.current=!1,c(x)}})},p=x=>{u.current||(s(!0),r(x.pageX-n.current.offsetLeft),a(n.current.scrollLeft))},g=()=>{s(!1);const x=d();x&&x.visibility>GK?h(x.mostVisibleIndex):h(l)},y=x=>{if(!t||u.current)return;x.preventDefault();const b=(x.pageX-n.current.offsetLeft-i)*1.2;n.current&&(n.current.scrollLeft=o-b)};return G.jsx("section",{className:"py-32 bg-white overflow-hidden",children:G.jsxs("div",{className:"max-w-[100vw] mx-auto",children:[G.jsxs(wn.div,{initial:{opacity:0,y:20},whileInView:{opacity:1,y:0},viewport:{once:!0},transition:{duration:.6},className:"text-center mb-20 px-8",children:[G.jsx("span",{className:"text-sm font-medium tracking-widest text-blue-600 uppercase mb-3 block",children:"Collection"}),G.jsx("h2",{className:"text-7xl font-heading text-gray-900 mb-4 tracking-tight",children:"Essentiels"})]}),G.jsx("div",{ref:n,className:"flex space-x-8 overflow-x-auto pb-12 scrollbar-hide cursor-grab active:cursor-grabbing px-8 relative",style:{scrollbarWidth:"none",msOverflowStyle:"none",WebkitOverflowScrolling:"touch",scrollBehavior:"auto"},onMouseDown:p,onMouseUp:g,onMouseLeave:g,onMouseMove:y,children:UK.map((x,v)=>G.jsxs(wn.div,{ref:b=>e.current[v]=b,initial:{opacity:0,x:50},whileInView:{opacity:1,x:0},viewport:{once:!0,margin:"-100px"},transition:{duration:.6,delay:v*.1},className:"group relative bg-gray-50 rounded-[2.5rem] p-12 hover:bg-gray-100 transition-all duration-500 flex-none w-[900px]",style:{background:"linear-gradient(to bottom right, #ffffff, #f3f4f6)",boxShadow:"0 4px 60px -20px rgba(0, 0, 0, 0.15)",border:"1px solid rgba(229, 231, 235, 0.8)"},children:[G.jsxs(wn.div,{className:"absolute top-6 right-6 z-30",initial:{opacity:0},animate:{opacity:1},transition:{duration:.2},children:[G.jsxs(wn.button,{onClick:()=>{const b=document.getElementById("demo");if(b){const C=b.getBoundingClientRect().top+window.pageYOffset- -100;window.scrollTo({top:C,behavior:"smooth"})}},className:"relative flex items-center bg-white/80 hover:bg-white rounded-xl shadow-sm overflow-hidden group",whileHover:"hover",animate:"rest",initial:"rest",whileTap:{scale:.99},variants:{rest:{scale:1},hover:{scale:1.01}},transition:{type:"spring",stiffness:400,damping:20},children:[G.jsx("div",{className:"relative p-2.5 bg-gray-50 group-hover:bg-gray-100 transition-colors duration-200",children:G.jsx(wn.div,{className:"w-7 h-7 flex items-center justify-center",children:G.jsx("img",{src:"/assets/logo2.svg",alt:"Essayer en réalité augmentée",className:"w-9 h-9 transform scale-150"})})}),G.jsx(wn.div,{className:"overflow-hidden",variants:{rest:{width:0,opacity:0},hover:{width:160,opacity:1}},transition:{duration:.2,ease:"easeOut"},children:G.jsx("span",{className:"block px-3 text-sm font-medium text-[#2b73da] whitespace-nowrap",style:{textShadow:"0 0 0px rgba(100, 255, 162, 0.3)",fontFamily:"TT Ramillas, serif"},children:"Bleu Reflet Collier"})}),G.jsx("div",{className:"absolute inset-0 -z-10 opacity-0 group-hover:opacity-100 transition-opacity duration-200",children:G.jsx("div",{className:"absolute inset-0 bg-gradient-to-r from-[#64ffa2]/5 to-transparent"})})]}),G.jsx(wn.div,{className:"absolute -top-0.5 -right-0.5",initial:{scale:0},animate:{scale:1},transition:{type:"spring",stiffness:400,damping:20,delay:.5},children:G.jsx("span",{className:"block w-2 h-2 rounded-full bg-[#64ffa2] shadow-[0_0_10px_rgba(100,255,162,0.5)]",children:G.jsx("span",{className:"absolute inline-flex w-full h-full rounded-full bg-[#64ffa2] animate-ping opacity-20"})})})]}),G.jsxs("div",{className:"flex space-x-12",children:[G.jsx("div",{className:"relative w-[350px] aspect-[3/4] overflow-hidden rounded-[2rem]",children:G.jsx("img",{src:x.image,alt:x.name,className:"object-cover w-full h-full transform group-hover:scale-105 transition-transform duration-700"})}),G.jsxs("div",{className:"flex-1 pt-6 space-y-10",children:[G.jsx("div",{children:G.jsxs(wn.div,{initial:{opacity:0},whileInView:{opacity:1},transition:{delay:.2},children:[G.jsx("h3",{className:"text-5xl font-heading text-gray-900 mb-4",children:x.name}),G.jsx("p",{className:"text-gray-600 font-light text-xl",children:x.description})]})}),G.jsx("div",{className:"flex flex-wrap gap-3",children:x.specs.map((b,S)=>G.jsx("span",{className:"px-8 py-4 bg-white rounded-full text-base text-gray-600 shadow-sm",children:b},S))}),G.jsxs("div",{className:"flex items-center justify-between pt-10",children:[G.jsxs("div",{className:"space-y-2",children:[G.jsx("span",{className:"text-base text-gray-500",style:{fontFamily:"TT Ramillas, serif"},children:"Prix"}),G.jsx("p",{className:"text-4xl text-gray-900",style:{fontFamily:"TT Ramillas, serif"},children:x.price})]}),G.jsxs(wn.button,{className:"relative overflow-hidden bg-gray-900 text-white px-12 py-4 rounded-xl text-lg transition-all duration-300",style:{fontFamily:"TT Ramillas, serif",boxShadow:"0 4px 14px -4px rgba(0, 0, 0, 0.2)"},whileHover:{scale:1.02,boxShadow:"0 6px 20px -4px rgba(0, 0, 0, 0.3)"},whileTap:{scale:.98},children:[G.jsxs("span",{className:"relative z-10 flex items-center gap-2",children:[G.jsx("svg",{className:"w-5 h-5",viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"2",d:"M16 11V7a4 4 0 00-8 0v4M5 9h14l1 12H4L5 9z"})}),"Acheter"]}),G.jsx("div",{className:"absolute inset-0 bg-gradient-to-r from-gray-800 to-gray-900 opacity-0 group-hover:opacity-100 transition-opacity duration-300"})]})]})]})]})]},x.id))}),G.jsx("div",{className:"flex justify-center mt-8 space-x-2",children:G.jsxs("div",{className:"text-sm text-gray-400 flex items-center space-x-2",children:[G.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.5,stroke:"currentColor",className:"w-5 h-5",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15.042 21.672L13.684 16.6m0 0l-2.51 2.225.569-9.47 5.227 7.917-3.286-.672zM12 2.25V4.5m5.834.166l-1.591 1.591M20.25 10.5H18M7.757 14.743l-1.59 1.59M6 10.5H3.75m4.007-4.243l-1.59-1.59"})}),G.jsx("span",{children:"Cliquez et glissez pour explorer"})]})})]})})};/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const AE="158",Ch={ROTATE:0,DOLLY:1,PAN:2},_h={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},jK=0,WR=1,XK=2,$F=1,FF=2,ec=3,dc=0,xo=1,al=2,Qc=0,of=1,GR=2,HR=3,jR=4,qK=5,Yu=100,KK=101,YK=102,XR=103,qR=104,ZK=200,QK=201,JK=202,eY=203,AC=204,RC=205,tY=206,nY=207,sY=208,iY=209,rY=210,oY=211,aY=212,lY=213,cY=214,uY=0,dY=1,hY=2,s2=3,fY=4,pY=5,mY=6,gY=7,OF=0,xY=1,vY=2,Jc=0,yY=1,wY=2,bY=3,SY=4,CY=5,KR="attached",_Y="detached",zF=300,xf=301,vf=302,MC=303,NC=304,sy=306,yf=1e3,ea=1001,i2=1002,ar=1003,PC=1004,Pv=1005,po=1006,BF=1007,vd=1008,eu=1009,EY=1010,TY=1011,RE=1012,UF=1013,Xc=1014,sc=1015,Rg=1016,VF=1017,WF=1018,ud=1020,IY=1021,ta=1023,kY=1024,AY=1025,dd=1026,wf=1027,RY=1028,GF=1029,MY=1030,HF=1031,jF=1033,j3=33776,X3=33777,q3=33778,K3=33779,YR=35840,ZR=35841,QR=35842,JR=35843,NY=36196,eM=37492,tM=37496,nM=37808,sM=37809,iM=37810,rM=37811,oM=37812,aM=37813,lM=37814,cM=37815,uM=37816,dM=37817,hM=37818,fM=37819,pM=37820,mM=37821,Y3=36492,gM=36494,xM=36495,PY=36283,vM=36284,yM=36285,wM=36286,Mg=2300,bf=2301,Z3=2302,bM=2400,SM=2401,CM=2402,DY=2500,LY=0,XF=1,DC=2,qF=3e3,hd=3001,$Y=3200,FY=3201,KF=0,OY=1,na="",hi="srgb",yr="srgb-linear",ME="display-p3",iy="display-p3-linear",r2="linear",si="srgb",o2="rec709",a2="p3",Eh=7680,_M=519,zY=512,BY=513,UY=514,VY=515,WY=516,GY=517,HY=518,jY=519,LC=35044,EM="300 es",$C=1035,ic=2e3,l2=2001;class Fd{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let r=0,o=i.length;r<o;r++)i[r].call(this,e);e.target=null}}}const kr=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let TM=1234567;const xg=Math.PI/180,Sf=180/Math.PI;function Aa(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(kr[n&255]+kr[n>>8&255]+kr[n>>16&255]+kr[n>>24&255]+"-"+kr[e&255]+kr[e>>8&255]+"-"+kr[e>>16&15|64]+kr[e>>24&255]+"-"+kr[t&63|128]+kr[t>>8&255]+"-"+kr[t>>16&255]+kr[t>>24&255]+kr[s&255]+kr[s>>8&255]+kr[s>>16&255]+kr[s>>24&255]).toLowerCase()}function xr(n,e,t){return Math.max(e,Math.min(t,n))}function NE(n,e){return(n%e+e)%e}function XY(n,e,t,s,i){return s+(n-e)*(i-s)/(t-e)}function qY(n,e,t){return n!==e?(t-n)/(e-n):0}function vg(n,e,t){return(1-t)*n+t*e}function KY(n,e,t,s){return vg(n,e,1-Math.exp(-t*s))}function YY(n,e=1){return e-Math.abs(NE(n,e*2)-e)}function ZY(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function QY(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function JY(n,e){return n+Math.floor(Math.random()*(e-n+1))}function eZ(n,e){return n+Math.random()*(e-n)}function tZ(n){return n*(.5-Math.random())}function nZ(n){n!==void 0&&(TM=n);let e=TM+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function sZ(n){return n*xg}function iZ(n){return n*Sf}function FC(n){return(n&n-1)===0&&n!==0}function YF(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function c2(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function rZ(n,e,t,s,i){const r=Math.cos,o=Math.sin,a=r(t/2),l=o(t/2),c=r((e+s)/2),u=o((e+s)/2),d=r((e-s)/2),h=o((e-s)/2),p=r((s-e)/2),g=o((s-e)/2);switch(i){case"XYX":n.set(a*u,l*d,l*h,a*c);break;case"YZY":n.set(l*h,a*u,l*d,a*c);break;case"ZXZ":n.set(l*d,l*h,a*u,a*c);break;case"XZX":n.set(a*u,l*g,l*p,a*c);break;case"YXY":n.set(l*p,a*u,l*g,a*c);break;case"ZYZ":n.set(l*g,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function ll(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Us(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const ZF={DEG2RAD:xg,RAD2DEG:Sf,generateUUID:Aa,clamp:xr,euclideanModulo:NE,mapLinear:XY,inverseLerp:qY,lerp:vg,damp:KY,pingpong:YY,smoothstep:ZY,smootherstep:QY,randInt:JY,randFloat:eZ,randFloatSpread:tZ,seededRandom:nZ,degToRad:sZ,radToDeg:iZ,isPowerOfTwo:FC,ceilPowerOfTwo:YF,floorPowerOfTwo:c2,setQuaternionFromProperEuler:rZ,normalize:Us,denormalize:ll};class Zn{constructor(e=0,t=0){Zn.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6],this.y=i[1]*t+i[4]*s+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(xr(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),i=Math.sin(t),r=this.x-e.x,o=this.y-e.y;return this.x=r*s-o*i+e.x,this.y=r*i+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class cs{constructor(e,t,s,i,r,o,a,l,c){cs.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,i,r,o,a,l,c)}set(e,t,s,i,r,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=t,u[4]=r,u[5]=l,u[6]=s,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,o=s[0],a=s[3],l=s[6],c=s[1],u=s[4],d=s[7],h=s[2],p=s[5],g=s[8],y=i[0],x=i[3],v=i[6],b=i[1],S=i[4],C=i[7],E=i[2],k=i[5],R=i[8];return r[0]=o*y+a*b+l*E,r[3]=o*x+a*S+l*k,r[6]=o*v+a*C+l*R,r[1]=c*y+u*b+d*E,r[4]=c*x+u*S+d*k,r[7]=c*v+u*C+d*R,r[2]=h*y+p*b+g*E,r[5]=h*x+p*S+g*k,r[8]=h*v+p*C+g*R,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-s*r*u+s*a*l+i*r*c-i*o*l}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],d=u*o-a*c,h=a*l-u*r,p=c*r-o*l,g=t*d+s*h+i*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const y=1/g;return e[0]=d*y,e[1]=(i*c-u*s)*y,e[2]=(a*s-i*o)*y,e[3]=h*y,e[4]=(u*t-i*l)*y,e[5]=(i*r-a*t)*y,e[6]=p*y,e[7]=(s*l-c*t)*y,e[8]=(o*t-s*r)*y,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,i,r,o,a){const l=Math.cos(r),c=Math.sin(r);return this.set(s*l,s*c,-s*(l*o+c*a)+o+e,-i*c,i*l,-i*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(Q3.makeScale(e,t)),this}rotate(e){return this.premultiply(Q3.makeRotation(-e)),this}translate(e,t){return this.premultiply(Q3.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<9;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const Q3=new cs;function QF(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}function Ng(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function oZ(){const n=Ng("canvas");return n.style.display="block",n}const IM={};function yg(n){n in IM||(IM[n]=!0,console.warn(n))}const kM=new cs().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),AM=new cs().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Rx={[yr]:{transfer:r2,primaries:o2,toReference:n=>n,fromReference:n=>n},[hi]:{transfer:si,primaries:o2,toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[iy]:{transfer:r2,primaries:a2,toReference:n=>n.applyMatrix3(AM),fromReference:n=>n.applyMatrix3(kM)},[ME]:{transfer:si,primaries:a2,toReference:n=>n.convertSRGBToLinear().applyMatrix3(AM),fromReference:n=>n.applyMatrix3(kM).convertLinearToSRGB()}},aZ=new Set([yr,iy]),Ps={enabled:!0,_workingColorSpace:yr,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(n){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!n},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!aZ.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const s=Rx[e].toReference,i=Rx[t].fromReference;return i(s(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return Rx[n].primaries},getTransfer:function(n){return n===na?r2:Rx[n].transfer}};function af(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function J3(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let Th;class JF{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Th===void 0&&(Th=Ng("canvas")),Th.width=e.width,Th.height=e.height;const s=Th.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),t=Th}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Ng("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const i=s.getImageData(0,0,e.width,e.height),r=i.data;for(let o=0;o<r.length;o++)r[o]=af(r[o]/255)*255;return s.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(af(t[s]/255)*255):t[s]=af(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let lZ=0;class eO{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:lZ++}),this.uuid=Aa(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?r.push(eS(i[o].image)):r.push(eS(i[o]))}else r=eS(i);s.url=r}return t||(e.images[this.uuid]=s),s}}function eS(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?JF.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let cZ=0;class vr extends Fd{constructor(e=vr.DEFAULT_IMAGE,t=vr.DEFAULT_MAPPING,s=ea,i=ea,r=po,o=vd,a=ta,l=eu,c=vr.DEFAULT_ANISOTROPY,u=na){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:cZ++}),this.uuid=Aa(),this.name="",this.source=new eO(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Zn(0,0),this.repeat=new Zn(1,1),this.center=new Zn(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new cs,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof u=="string"?this.colorSpace=u:(yg("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=u===hd?hi:na),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==zF)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case yf:e.x=e.x-Math.floor(e.x);break;case ea:e.x=e.x<0?0:1;break;case i2:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case yf:e.y=e.y-Math.floor(e.y);break;case ea:e.y=e.y<0?0:1;break;case i2:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return yg("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===hi?hd:qF}set encoding(e){yg("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===hd?hi:na}}vr.DEFAULT_IMAGE=null;vr.DEFAULT_MAPPING=zF;vr.DEFAULT_ANISOTROPY=1;class qs{constructor(e=0,t=0,s=0,i=1){qs.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*i+o[12]*r,this.y=o[1]*t+o[5]*s+o[9]*i+o[13]*r,this.z=o[2]*t+o[6]*s+o[10]*i+o[14]*r,this.w=o[3]*t+o[7]*s+o[11]*i+o[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,i,r;const l=e.elements,c=l[0],u=l[4],d=l[8],h=l[1],p=l[5],g=l[9],y=l[2],x=l[6],v=l[10];if(Math.abs(u-h)<.01&&Math.abs(d-y)<.01&&Math.abs(g-x)<.01){if(Math.abs(u+h)<.1&&Math.abs(d+y)<.1&&Math.abs(g+x)<.1&&Math.abs(c+p+v-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const S=(c+1)/2,C=(p+1)/2,E=(v+1)/2,k=(u+h)/4,R=(d+y)/4,L=(g+x)/4;return S>C&&S>E?S<.01?(s=0,i=.707106781,r=.707106781):(s=Math.sqrt(S),i=k/s,r=R/s):C>E?C<.01?(s=.707106781,i=0,r=.707106781):(i=Math.sqrt(C),s=k/i,r=L/i):E<.01?(s=.707106781,i=.707106781,r=0):(r=Math.sqrt(E),s=R/r,i=L/r),this.set(s,i,r,t),this}let b=Math.sqrt((x-g)*(x-g)+(d-y)*(d-y)+(h-u)*(h-u));return Math.abs(b)<.001&&(b=1),this.x=(x-g)/b,this.y=(d-y)/b,this.z=(h-u)/b,this.w=Math.acos((c+p+v-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class uZ extends Fd{constructor(e=1,t=1,s={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new qs(0,0,e,t),this.scissorTest=!1,this.viewport=new qs(0,0,e,t);const i={width:e,height:t,depth:1};s.encoding!==void 0&&(yg("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),s.colorSpace=s.encoding===hd?hi:na),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:po,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},s),this.texture=new vr(i,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=s.generateMipmaps,this.texture.internalFormat=s.internalFormat,this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.depthTexture=s.depthTexture,this.samples=s.samples}setSize(e,t,s=1){(this.width!==e||this.height!==t||this.depth!==s)&&(this.width=e,this.height=t,this.depth=s,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=s,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new eO(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class yd extends uZ{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class tO extends vr{constructor(e=null,t=1,s=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=ar,this.minFilter=ar,this.wrapR=ea,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class dZ extends vr{constructor(e=null,t=1,s=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=ar,this.minFilter=ar,this.wrapR=ea,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}let Sl=class{constructor(e=0,t=0,s=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=i}static slerpFlat(e,t,s,i,r,o,a){let l=s[i+0],c=s[i+1],u=s[i+2],d=s[i+3];const h=r[o+0],p=r[o+1],g=r[o+2],y=r[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=d;return}if(a===1){e[t+0]=h,e[t+1]=p,e[t+2]=g,e[t+3]=y;return}if(d!==y||l!==h||c!==p||u!==g){let x=1-a;const v=l*h+c*p+u*g+d*y,b=v>=0?1:-1,S=1-v*v;if(S>Number.EPSILON){const E=Math.sqrt(S),k=Math.atan2(E,v*b);x=Math.sin(x*k)/E,a=Math.sin(a*k)/E}const C=a*b;if(l=l*x+h*C,c=c*x+p*C,u=u*x+g*C,d=d*x+y*C,x===1-a){const E=1/Math.sqrt(l*l+c*c+u*u+d*d);l*=E,c*=E,u*=E,d*=E}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=d}static multiplyQuaternionsFlat(e,t,s,i,r,o){const a=s[i],l=s[i+1],c=s[i+2],u=s[i+3],d=r[o],h=r[o+1],p=r[o+2],g=r[o+3];return e[t]=a*g+u*d+l*p-c*h,e[t+1]=l*g+u*h+c*d-a*p,e[t+2]=c*g+u*p+a*h-l*d,e[t+3]=u*g-a*d-l*h-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,i){return this._x=e,this._y=t,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const s=e._x,i=e._y,r=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(s/2),u=a(i/2),d=a(r/2),h=l(s/2),p=l(i/2),g=l(r/2);switch(o){case"XYZ":this._x=h*u*d+c*p*g,this._y=c*p*d-h*u*g,this._z=c*u*g+h*p*d,this._w=c*u*d-h*p*g;break;case"YXZ":this._x=h*u*d+c*p*g,this._y=c*p*d-h*u*g,this._z=c*u*g-h*p*d,this._w=c*u*d+h*p*g;break;case"ZXY":this._x=h*u*d-c*p*g,this._y=c*p*d+h*u*g,this._z=c*u*g+h*p*d,this._w=c*u*d-h*p*g;break;case"ZYX":this._x=h*u*d-c*p*g,this._y=c*p*d+h*u*g,this._z=c*u*g-h*p*d,this._w=c*u*d+h*p*g;break;case"YZX":this._x=h*u*d+c*p*g,this._y=c*p*d+h*u*g,this._z=c*u*g-h*p*d,this._w=c*u*d-h*p*g;break;case"XZY":this._x=h*u*d-c*p*g,this._y=c*p*d-h*u*g,this._z=c*u*g+h*p*d,this._w=c*u*d+h*p*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,i=Math.sin(s);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],r=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],d=t[10],h=s+a+d;if(h>0){const p=.5/Math.sqrt(h+1);this._w=.25/p,this._x=(u-l)*p,this._y=(r-c)*p,this._z=(o-i)*p}else if(s>a&&s>d){const p=2*Math.sqrt(1+s-a-d);this._w=(u-l)/p,this._x=.25*p,this._y=(i+o)/p,this._z=(r+c)/p}else if(a>d){const p=2*Math.sqrt(1+a-s-d);this._w=(r-c)/p,this._x=(i+o)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+d-s-a);this._w=(o-i)/p,this._x=(r+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(xr(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const i=Math.min(1,t/s);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,i=e._y,r=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=s*u+o*a+i*c-r*l,this._y=i*u+o*l+r*a-s*c,this._z=r*u+o*c+s*l-i*a,this._w=o*u-s*a-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,i=this._y,r=this._z,o=this._w;let a=o*e._w+s*e._x+i*e._y+r*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=i,this._z=r,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*s+t*this._x,this._y=p*i+t*this._y,this._z=p*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),d=Math.sin((1-t)*u)/c,h=Math.sin(t*u)/c;return this._w=o*d+this._w*h,this._x=s*d+this._x*h,this._y=i*d+this._y*h,this._z=r*d+this._z*h,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=Math.random(),t=Math.sqrt(1-e),s=Math.sqrt(e),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(i),s*Math.sin(r),s*Math.cos(r),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}};class Ne{constructor(e=0,t=0,s=0){Ne.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(RM.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(RM.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6]*i,this.y=r[1]*t+r[4]*s+r[7]*i,this.z=r[2]*t+r[5]*s+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=e.elements,o=1/(r[3]*t+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*s+r[8]*i+r[12])*o,this.y=(r[1]*t+r[5]*s+r[9]*i+r[13])*o,this.z=(r[2]*t+r[6]*s+r[10]*i+r[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,i=this.z,r=e.x,o=e.y,a=e.z,l=e.w,c=2*(o*i-a*s),u=2*(a*t-r*i),d=2*(r*s-o*t);return this.x=t+l*c+o*d-a*u,this.y=s+l*u+a*c-r*d,this.z=i+l*d+r*u-o*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*s+r[8]*i,this.y=r[1]*t+r[5]*s+r[9]*i,this.z=r[2]*t+r[6]*s+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,i=e.y,r=e.z,o=t.x,a=t.y,l=t.z;return this.x=i*l-r*a,this.y=r*o-s*l,this.z=s*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return tS.copy(this).projectOnVector(e),this.sub(tS)}reflect(e){return this.sub(tS.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(xr(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,i=this.z-e.z;return t*t+s*s+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const i=Math.sin(t)*e;return this.x=i*Math.sin(s),this.y=Math.cos(t)*e,this.z=i*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,s=Math.sqrt(1-e**2);return this.x=s*Math.cos(t),this.y=s*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const tS=new Ne,RM=new Sl;class La{constructor(e=new Ne(1/0,1/0,1/0),t=new Ne(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(xa.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(xa.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=xa.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const r=s.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=r.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,xa):xa.fromBufferAttribute(r,o),xa.applyMatrix4(e.matrixWorld),this.expandByPoint(xa);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Mx.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Mx.copy(s.boundingBox)),Mx.applyMatrix4(e.matrixWorld),this.union(Mx)}const i=e.children;for(let r=0,o=i.length;r<o;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,xa),xa.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Fm),Nx.subVectors(this.max,Fm),Ih.subVectors(e.a,Fm),kh.subVectors(e.b,Fm),Ah.subVectors(e.c,Fm),Dc.subVectors(kh,Ih),Lc.subVectors(Ah,kh),Fu.subVectors(Ih,Ah);let t=[0,-Dc.z,Dc.y,0,-Lc.z,Lc.y,0,-Fu.z,Fu.y,Dc.z,0,-Dc.x,Lc.z,0,-Lc.x,Fu.z,0,-Fu.x,-Dc.y,Dc.x,0,-Lc.y,Lc.x,0,-Fu.y,Fu.x,0];return!nS(t,Ih,kh,Ah,Nx)||(t=[1,0,0,0,1,0,0,0,1],!nS(t,Ih,kh,Ah,Nx))?!1:(Px.crossVectors(Dc,Lc),t=[Px.x,Px.y,Px.z],nS(t,Ih,kh,Ah,Nx))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,xa).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(xa).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Gl[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Gl[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Gl[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Gl[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Gl[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Gl[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Gl[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Gl[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Gl),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Gl=[new Ne,new Ne,new Ne,new Ne,new Ne,new Ne,new Ne,new Ne],xa=new Ne,Mx=new La,Ih=new Ne,kh=new Ne,Ah=new Ne,Dc=new Ne,Lc=new Ne,Fu=new Ne,Fm=new Ne,Nx=new Ne,Px=new Ne,Ou=new Ne;function nS(n,e,t,s,i){for(let r=0,o=n.length-3;r<=o;r+=3){Ou.fromArray(n,r);const a=i.x*Math.abs(Ou.x)+i.y*Math.abs(Ou.y)+i.z*Math.abs(Ou.z),l=e.dot(Ou),c=t.dot(Ou),u=s.dot(Ou);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const hZ=new La,Om=new Ne,sS=new Ne;let Rl=class{constructor(e=new Ne,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):hZ.setFromPoints(e).getCenter(s);let i=0;for(let r=0,o=e.length;r<o;r++)i=Math.max(i,s.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Om.subVectors(e,this.center);const t=Om.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),i=(s-this.radius)*.5;this.center.addScaledVector(Om,i/s),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(sS.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Om.copy(e.center).add(sS)),this.expandByPoint(Om.copy(e.center).sub(sS))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}};const Hl=new Ne,iS=new Ne,Dx=new Ne,$c=new Ne,rS=new Ne,Lx=new Ne,oS=new Ne;let r0=class{constructor(e=new Ne,t=new Ne(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Hl)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Hl.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Hl.copy(this.origin).addScaledVector(this.direction,t),Hl.distanceToSquared(e))}distanceSqToSegment(e,t,s,i){iS.copy(e).add(t).multiplyScalar(.5),Dx.copy(t).sub(e).normalize(),$c.copy(this.origin).sub(iS);const r=e.distanceTo(t)*.5,o=-this.direction.dot(Dx),a=$c.dot(this.direction),l=-$c.dot(Dx),c=$c.lengthSq(),u=Math.abs(1-o*o);let d,h,p,g;if(u>0)if(d=o*l-a,h=o*a-l,g=r*u,d>=0)if(h>=-g)if(h<=g){const y=1/u;d*=y,h*=y,p=d*(d+o*h+2*a)+h*(o*d+h+2*l)+c}else h=r,d=Math.max(0,-(o*h+a)),p=-d*d+h*(h+2*l)+c;else h=-r,d=Math.max(0,-(o*h+a)),p=-d*d+h*(h+2*l)+c;else h<=-g?(d=Math.max(0,-(-o*r+a)),h=d>0?-r:Math.min(Math.max(-r,-l),r),p=-d*d+h*(h+2*l)+c):h<=g?(d=0,h=Math.min(Math.max(-r,-l),r),p=h*(h+2*l)+c):(d=Math.max(0,-(o*r+a)),h=d>0?r:Math.min(Math.max(-r,-l),r),p=-d*d+h*(h+2*l)+c);else h=o>0?-r:r,d=Math.max(0,-(o*h+a)),p=-d*d+h*(h+2*l)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(iS).addScaledVector(Dx,h),p}intersectSphere(e,t){Hl.subVectors(e.center,this.origin);const s=Hl.dot(this.direction),i=Hl.dot(Hl)-s*s,r=e.radius*e.radius;if(i>r)return null;const o=Math.sqrt(r-i),a=s-o,l=s+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,i,r,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,d=1/this.direction.z,h=this.origin;return c>=0?(s=(e.min.x-h.x)*c,i=(e.max.x-h.x)*c):(s=(e.max.x-h.x)*c,i=(e.min.x-h.x)*c),u>=0?(r=(e.min.y-h.y)*u,o=(e.max.y-h.y)*u):(r=(e.max.y-h.y)*u,o=(e.min.y-h.y)*u),s>o||r>i||((r>s||isNaN(s))&&(s=r),(o<i||isNaN(i))&&(i=o),d>=0?(a=(e.min.z-h.z)*d,l=(e.max.z-h.z)*d):(a=(e.max.z-h.z)*d,l=(e.min.z-h.z)*d),s>l||a>i)||((a>s||s!==s)&&(s=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(s>=0?s:i,t)}intersectsBox(e){return this.intersectBox(e,Hl)!==null}intersectTriangle(e,t,s,i,r){rS.subVectors(t,e),Lx.subVectors(s,e),oS.crossVectors(rS,Lx);let o=this.direction.dot(oS),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;$c.subVectors(this.origin,e);const l=a*this.direction.dot(Lx.crossVectors($c,Lx));if(l<0)return null;const c=a*this.direction.dot(rS.cross($c));if(c<0||l+c>o)return null;const u=-a*$c.dot(oS);return u<0?null:this.at(u/o,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}};class us{constructor(e,t,s,i,r,o,a,l,c,u,d,h,p,g,y,x){us.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,i,r,o,a,l,c,u,d,h,p,g,y,x)}set(e,t,s,i,r,o,a,l,c,u,d,h,p,g,y,x){const v=this.elements;return v[0]=e,v[4]=t,v[8]=s,v[12]=i,v[1]=r,v[5]=o,v[9]=a,v[13]=l,v[2]=c,v[6]=u,v[10]=d,v[14]=h,v[3]=p,v[7]=g,v[11]=y,v[15]=x,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new us().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,i=1/Rh.setFromMatrixColumn(e,0).length(),r=1/Rh.setFromMatrixColumn(e,1).length(),o=1/Rh.setFromMatrixColumn(e,2).length();return t[0]=s[0]*i,t[1]=s[1]*i,t[2]=s[2]*i,t[3]=0,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,i=e.y,r=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(i),c=Math.sin(i),u=Math.cos(r),d=Math.sin(r);if(e.order==="XYZ"){const h=o*u,p=o*d,g=a*u,y=a*d;t[0]=l*u,t[4]=-l*d,t[8]=c,t[1]=p+g*c,t[5]=h-y*c,t[9]=-a*l,t[2]=y-h*c,t[6]=g+p*c,t[10]=o*l}else if(e.order==="YXZ"){const h=l*u,p=l*d,g=c*u,y=c*d;t[0]=h+y*a,t[4]=g*a-p,t[8]=o*c,t[1]=o*d,t[5]=o*u,t[9]=-a,t[2]=p*a-g,t[6]=y+h*a,t[10]=o*l}else if(e.order==="ZXY"){const h=l*u,p=l*d,g=c*u,y=c*d;t[0]=h-y*a,t[4]=-o*d,t[8]=g+p*a,t[1]=p+g*a,t[5]=o*u,t[9]=y-h*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const h=o*u,p=o*d,g=a*u,y=a*d;t[0]=l*u,t[4]=g*c-p,t[8]=h*c+y,t[1]=l*d,t[5]=y*c+h,t[9]=p*c-g,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const h=o*l,p=o*c,g=a*l,y=a*c;t[0]=l*u,t[4]=y-h*d,t[8]=g*d+p,t[1]=d,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=p*d+g,t[10]=h-y*d}else if(e.order==="XZY"){const h=o*l,p=o*c,g=a*l,y=a*c;t[0]=l*u,t[4]=-d,t[8]=c*u,t[1]=h*d+y,t[5]=o*u,t[9]=p*d-g,t[2]=g*d-p,t[6]=a*u,t[10]=y*d+h}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(fZ,e,pZ)}lookAt(e,t,s){const i=this.elements;return Io.subVectors(e,t),Io.lengthSq()===0&&(Io.z=1),Io.normalize(),Fc.crossVectors(s,Io),Fc.lengthSq()===0&&(Math.abs(s.z)===1?Io.x+=1e-4:Io.z+=1e-4,Io.normalize(),Fc.crossVectors(s,Io)),Fc.normalize(),$x.crossVectors(Io,Fc),i[0]=Fc.x,i[4]=$x.x,i[8]=Io.x,i[1]=Fc.y,i[5]=$x.y,i[9]=Io.y,i[2]=Fc.z,i[6]=$x.z,i[10]=Io.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,o=s[0],a=s[4],l=s[8],c=s[12],u=s[1],d=s[5],h=s[9],p=s[13],g=s[2],y=s[6],x=s[10],v=s[14],b=s[3],S=s[7],C=s[11],E=s[15],k=i[0],R=i[4],L=i[8],I=i[12],T=i[1],M=i[5],j=i[9],W=i[13],z=i[2],X=i[6],B=i[10],J=i[14],K=i[3],ee=i[7],ne=i[11],V=i[15];return r[0]=o*k+a*T+l*z+c*K,r[4]=o*R+a*M+l*X+c*ee,r[8]=o*L+a*j+l*B+c*ne,r[12]=o*I+a*W+l*J+c*V,r[1]=u*k+d*T+h*z+p*K,r[5]=u*R+d*M+h*X+p*ee,r[9]=u*L+d*j+h*B+p*ne,r[13]=u*I+d*W+h*J+p*V,r[2]=g*k+y*T+x*z+v*K,r[6]=g*R+y*M+x*X+v*ee,r[10]=g*L+y*j+x*B+v*ne,r[14]=g*I+y*W+x*J+v*V,r[3]=b*k+S*T+C*z+E*K,r[7]=b*R+S*M+C*X+E*ee,r[11]=b*L+S*j+C*B+E*ne,r[15]=b*I+S*W+C*J+E*V,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],i=e[8],r=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],d=e[6],h=e[10],p=e[14],g=e[3],y=e[7],x=e[11],v=e[15];return g*(+r*l*d-i*c*d-r*a*h+s*c*h+i*a*p-s*l*p)+y*(+t*l*p-t*c*h+r*o*h-i*o*p+i*c*u-r*l*u)+x*(+t*c*d-t*a*p-r*o*d+s*o*p+r*a*u-s*c*u)+v*(-i*a*u-t*l*d+t*a*h+i*o*d-s*o*h+s*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],d=e[9],h=e[10],p=e[11],g=e[12],y=e[13],x=e[14],v=e[15],b=d*x*c-y*h*c+y*l*p-a*x*p-d*l*v+a*h*v,S=g*h*c-u*x*c-g*l*p+o*x*p+u*l*v-o*h*v,C=u*y*c-g*d*c+g*a*p-o*y*p-u*a*v+o*d*v,E=g*d*l-u*y*l-g*a*h+o*y*h+u*a*x-o*d*x,k=t*b+s*S+i*C+r*E;if(k===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const R=1/k;return e[0]=b*R,e[1]=(y*h*r-d*x*r-y*i*p+s*x*p+d*i*v-s*h*v)*R,e[2]=(a*x*r-y*l*r+y*i*c-s*x*c-a*i*v+s*l*v)*R,e[3]=(d*l*r-a*h*r-d*i*c+s*h*c+a*i*p-s*l*p)*R,e[4]=S*R,e[5]=(u*x*r-g*h*r+g*i*p-t*x*p-u*i*v+t*h*v)*R,e[6]=(g*l*r-o*x*r-g*i*c+t*x*c+o*i*v-t*l*v)*R,e[7]=(o*h*r-u*l*r+u*i*c-t*h*c-o*i*p+t*l*p)*R,e[8]=C*R,e[9]=(g*d*r-u*y*r-g*s*p+t*y*p+u*s*v-t*d*v)*R,e[10]=(o*y*r-g*a*r+g*s*c-t*y*c-o*s*v+t*a*v)*R,e[11]=(u*a*r-o*d*r-u*s*c+t*d*c+o*s*p-t*a*p)*R,e[12]=E*R,e[13]=(u*y*i-g*d*i+g*s*h-t*y*h-u*s*x+t*d*x)*R,e[14]=(g*a*i-o*y*i-g*s*l+t*y*l+o*s*x-t*a*x)*R,e[15]=(o*d*i-u*a*i+u*s*l-t*d*l-o*s*h+t*a*h)*R,this}scale(e){const t=this.elements,s=e.x,i=e.y,r=e.z;return t[0]*=s,t[4]*=i,t[8]*=r,t[1]*=s,t[5]*=i,t[9]*=r,t[2]*=s,t[6]*=i,t[10]*=r,t[3]*=s,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),i=Math.sin(t),r=1-s,o=e.x,a=e.y,l=e.z,c=r*o,u=r*a;return this.set(c*o+s,c*a-i*l,c*l+i*a,0,c*a+i*l,u*a+s,u*l-i*o,0,c*l-i*a,u*l+i*o,r*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,i,r,o){return this.set(1,s,r,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,s){const i=this.elements,r=t._x,o=t._y,a=t._z,l=t._w,c=r+r,u=o+o,d=a+a,h=r*c,p=r*u,g=r*d,y=o*u,x=o*d,v=a*d,b=l*c,S=l*u,C=l*d,E=s.x,k=s.y,R=s.z;return i[0]=(1-(y+v))*E,i[1]=(p+C)*E,i[2]=(g-S)*E,i[3]=0,i[4]=(p-C)*k,i[5]=(1-(h+v))*k,i[6]=(x+b)*k,i[7]=0,i[8]=(g+S)*R,i[9]=(x-b)*R,i[10]=(1-(h+y))*R,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,s){const i=this.elements;let r=Rh.set(i[0],i[1],i[2]).length();const o=Rh.set(i[4],i[5],i[6]).length(),a=Rh.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],va.copy(this);const c=1/r,u=1/o,d=1/a;return va.elements[0]*=c,va.elements[1]*=c,va.elements[2]*=c,va.elements[4]*=u,va.elements[5]*=u,va.elements[6]*=u,va.elements[8]*=d,va.elements[9]*=d,va.elements[10]*=d,t.setFromRotationMatrix(va),s.x=r,s.y=o,s.z=a,this}makePerspective(e,t,s,i,r,o,a=ic){const l=this.elements,c=2*r/(t-e),u=2*r/(s-i),d=(t+e)/(t-e),h=(s+i)/(s-i);let p,g;if(a===ic)p=-(o+r)/(o-r),g=-2*o*r/(o-r);else if(a===l2)p=-o/(o-r),g=-o*r/(o-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=u,l[9]=h,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,s,i,r,o,a=ic){const l=this.elements,c=1/(t-e),u=1/(s-i),d=1/(o-r),h=(t+e)*c,p=(s+i)*u;let g,y;if(a===ic)g=(o+r)*d,y=-2*d;else if(a===l2)g=r*d,y=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-h,l[1]=0,l[5]=2*u,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=y,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<16;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const Rh=new Ne,va=new us,fZ=new Ne(0,0,0),pZ=new Ne(1,1,1),Fc=new Ne,$x=new Ne,Io=new Ne,MM=new us,NM=new Sl;class ry{constructor(e=0,t=0,s=0,i=ry.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,i=this._order){return this._x=e,this._y=t,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const i=e.elements,r=i[0],o=i[4],a=i[8],l=i[1],c=i[5],u=i[9],d=i[2],h=i[6],p=i[10];switch(t){case"XYZ":this._y=Math.asin(xr(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(h,c),this._z=0);break;case"YXZ":this._x=Math.asin(-xr(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-d,r),this._z=0);break;case"ZXY":this._x=Math.asin(xr(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-xr(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(h,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(xr(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-d,r)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-xr(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(h,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return MM.makeRotationFromQuaternion(e),this.setFromRotationMatrix(MM,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return NM.setFromEuler(this),this.setFromQuaternion(NM,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}ry.DEFAULT_ORDER="XYZ";class nO{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let mZ=0;const PM=new Ne,Mh=new Sl,jl=new us,Fx=new Ne,zm=new Ne,gZ=new Ne,xZ=new Sl,DM=new Ne(1,0,0),LM=new Ne(0,1,0),$M=new Ne(0,0,1),vZ={type:"added"},yZ={type:"removed"};class mi extends Fd{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:mZ++}),this.uuid=Aa(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=mi.DEFAULT_UP.clone();const e=new Ne,t=new ry,s=new Sl,i=new Ne(1,1,1);function r(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(r),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new us},normalMatrix:{value:new cs}}),this.matrix=new us,this.matrixWorld=new us,this.matrixAutoUpdate=mi.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=mi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new nO,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Mh.setFromAxisAngle(e,t),this.quaternion.multiply(Mh),this}rotateOnWorldAxis(e,t){return Mh.setFromAxisAngle(e,t),this.quaternion.premultiply(Mh),this}rotateX(e){return this.rotateOnAxis(DM,e)}rotateY(e){return this.rotateOnAxis(LM,e)}rotateZ(e){return this.rotateOnAxis($M,e)}translateOnAxis(e,t){return PM.copy(e).applyQuaternion(this.quaternion),this.position.add(PM.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(DM,e)}translateY(e){return this.translateOnAxis(LM,e)}translateZ(e){return this.translateOnAxis($M,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(jl.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?Fx.copy(e):Fx.set(e,t,s);const i=this.parent;this.updateWorldMatrix(!0,!1),zm.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?jl.lookAt(zm,Fx,this.up):jl.lookAt(Fx,zm,this.up),this.quaternion.setFromRotationMatrix(jl),i&&(jl.extractRotation(i.matrixWorld),Mh.setFromRotationMatrix(jl),this.quaternion.premultiply(Mh.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(vZ)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(yZ)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),jl.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),jl.multiply(e.parent.matrixWorld)),e.applyMatrix4(jl),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,i=this.children.length;s<i;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t){let s=[];this[e]===t&&s.push(this);for(let i=0,r=this.children.length;i<r;i++){const o=this.children[i].getObjectsByProperty(e,t);o.length>0&&(s=s.concat(o))}return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(zm,e,gZ),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(zm,xZ,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,i=t.length;s<i;s++){const r=t[s];(r.matrixWorldAutoUpdate===!0||e===!0)&&r.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,o=i.length;r<o;r++){const a=i[r];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const d=l[c];r(e.shapes,d)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(r(e.materials,this.material[l]));i.material=a}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(r(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),d=o(e.shapes),h=o(e.skeletons),p=o(e.animations),g=o(e.nodes);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),u.length>0&&(s.images=u),d.length>0&&(s.shapes=d),h.length>0&&(s.skeletons=h),p.length>0&&(s.animations=p),g.length>0&&(s.nodes=g)}return s.object=i,s;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const i=e.children[s];this.add(i.clone())}return this}}mi.DEFAULT_UP=new Ne(0,1,0);mi.DEFAULT_MATRIX_AUTO_UPDATE=!0;mi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ya=new Ne,Xl=new Ne,aS=new Ne,ql=new Ne,Nh=new Ne,Ph=new Ne,FM=new Ne,lS=new Ne,cS=new Ne,uS=new Ne;let Ox=!1;class _a{constructor(e=new Ne,t=new Ne,s=new Ne){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,i){i.subVectors(s,t),ya.subVectors(e,t),i.cross(ya);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,s,i,r){ya.subVectors(i,t),Xl.subVectors(s,t),aS.subVectors(e,t);const o=ya.dot(ya),a=ya.dot(Xl),l=ya.dot(aS),c=Xl.dot(Xl),u=Xl.dot(aS),d=o*c-a*a;if(d===0)return r.set(-2,-1,-1);const h=1/d,p=(c*l-a*u)*h,g=(o*u-a*l)*h;return r.set(1-p-g,g,p)}static containsPoint(e,t,s,i){return this.getBarycoord(e,t,s,i,ql),ql.x>=0&&ql.y>=0&&ql.x+ql.y<=1}static getUV(e,t,s,i,r,o,a,l){return Ox===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Ox=!0),this.getInterpolation(e,t,s,i,r,o,a,l)}static getInterpolation(e,t,s,i,r,o,a,l){return this.getBarycoord(e,t,s,i,ql),l.setScalar(0),l.addScaledVector(r,ql.x),l.addScaledVector(o,ql.y),l.addScaledVector(a,ql.z),l}static isFrontFacing(e,t,s,i){return ya.subVectors(s,t),Xl.subVectors(e,t),ya.cross(Xl).dot(i)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,i){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,s,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return ya.subVectors(this.c,this.b),Xl.subVectors(this.a,this.b),ya.cross(Xl).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return _a.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return _a.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,s,i,r){return Ox===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Ox=!0),_a.getInterpolation(e,this.a,this.b,this.c,t,s,i,r)}getInterpolation(e,t,s,i,r){return _a.getInterpolation(e,this.a,this.b,this.c,t,s,i,r)}containsPoint(e){return _a.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return _a.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,i=this.b,r=this.c;let o,a;Nh.subVectors(i,s),Ph.subVectors(r,s),lS.subVectors(e,s);const l=Nh.dot(lS),c=Ph.dot(lS);if(l<=0&&c<=0)return t.copy(s);cS.subVectors(e,i);const u=Nh.dot(cS),d=Ph.dot(cS);if(u>=0&&d<=u)return t.copy(i);const h=l*d-u*c;if(h<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(s).addScaledVector(Nh,o);uS.subVectors(e,r);const p=Nh.dot(uS),g=Ph.dot(uS);if(g>=0&&p<=g)return t.copy(r);const y=p*c-l*g;if(y<=0&&c>=0&&g<=0)return a=c/(c-g),t.copy(s).addScaledVector(Ph,a);const x=u*g-p*d;if(x<=0&&d-u>=0&&p-g>=0)return FM.subVectors(r,i),a=(d-u)/(d-u+(p-g)),t.copy(i).addScaledVector(FM,a);const v=1/(x+y+h);return o=y*v,a=h*v,t.copy(s).addScaledVector(Nh,o).addScaledVector(Ph,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const sO={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Oc={h:0,s:0,l:0},zx={h:0,s:0,l:0};function dS(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class Kn{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=hi){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Ps.toWorkingColorSpace(this,t),this}setRGB(e,t,s,i=Ps.workingColorSpace){return this.r=e,this.g=t,this.b=s,Ps.toWorkingColorSpace(this,i),this}setHSL(e,t,s,i=Ps.workingColorSpace){if(e=NE(e,1),t=xr(t,0,1),s=xr(s,0,1),t===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+t):s+t-s*t,o=2*s-r;this.r=dS(o,r,e+1/3),this.g=dS(o,r,e),this.b=dS(o,r,e-1/3)}return Ps.toWorkingColorSpace(this,i),this}setStyle(e,t=hi){function s(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],o=r.length;if(o===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=hi){const s=sO[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=af(e.r),this.g=af(e.g),this.b=af(e.b),this}copyLinearToSRGB(e){return this.r=J3(e.r),this.g=J3(e.g),this.b=J3(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=hi){return Ps.fromWorkingColorSpace(Ar.copy(this),e),Math.round(xr(Ar.r*255,0,255))*65536+Math.round(xr(Ar.g*255,0,255))*256+Math.round(xr(Ar.b*255,0,255))}getHexString(e=hi){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Ps.workingColorSpace){Ps.fromWorkingColorSpace(Ar.copy(this),t);const s=Ar.r,i=Ar.g,r=Ar.b,o=Math.max(s,i,r),a=Math.min(s,i,r);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const d=o-a;switch(c=u<=.5?d/(o+a):d/(2-o-a),o){case s:l=(i-r)/d+(i<r?6:0);break;case i:l=(r-s)/d+2;break;case r:l=(s-i)/d+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=Ps.workingColorSpace){return Ps.fromWorkingColorSpace(Ar.copy(this),t),e.r=Ar.r,e.g=Ar.g,e.b=Ar.b,e}getStyle(e=hi){Ps.fromWorkingColorSpace(Ar.copy(this),e);const t=Ar.r,s=Ar.g,i=Ar.b;return e!==hi?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(i*255)})`}offsetHSL(e,t,s){return this.getHSL(Oc),this.setHSL(Oc.h+e,Oc.s+t,Oc.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(Oc),e.getHSL(zx);const s=vg(Oc.h,zx.h,t),i=vg(Oc.s,zx.s,t),r=vg(Oc.l,zx.l,t);return this.setHSL(s,i,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,i=this.b,r=e.elements;return this.r=r[0]*t+r[3]*s+r[6]*i,this.g=r[1]*t+r[4]*s+r[7]*i,this.b=r[2]*t+r[5]*s+r[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ar=new Kn;Kn.NAMES=sO;let wZ=0,ml=class extends Fd{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:wZ++}),this.uuid=Aa(),this.name="",this.type="Material",this.blending=of,this.side=dc,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=AC,this.blendDst=RC,this.blendEquation=Yu,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Kn(0,0,0),this.blendAlpha=0,this.depthFunc=s2,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=_M,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Eh,this.stencilZFail=Eh,this.stencilZPass=Eh,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==of&&(s.blending=this.blending),this.side!==dc&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==AC&&(s.blendSrc=this.blendSrc),this.blendDst!==RC&&(s.blendDst=this.blendDst),this.blendEquation!==Yu&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==s2&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==_M&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Eh&&(s.stencilFail=this.stencilFail),this.stencilZFail!==Eh&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==Eh&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function i(r){const o=[];for(const a in r){const l=r[a];delete l.metadata,o.push(l)}return o}if(t){const r=i(e.textures),o=i(e.images);r.length>0&&(s.textures=r),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const i=t.length;s=new Array(i);for(let r=0;r!==i;++r)s[r]=t[r].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}};class qc extends ml{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Kn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=OF,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Di=new Ne,Bx=new Zn;class Kr{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=LC,this.updateRange={offset:0,count:-1},this.gpuType=sc,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[s+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)Bx.fromBufferAttribute(this,t),Bx.applyMatrix3(e),this.setXY(t,Bx.x,Bx.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)Di.fromBufferAttribute(this,t),Di.applyMatrix3(e),this.setXYZ(t,Di.x,Di.y,Di.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)Di.fromBufferAttribute(this,t),Di.applyMatrix4(e),this.setXYZ(t,Di.x,Di.y,Di.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Di.fromBufferAttribute(this,t),Di.applyNormalMatrix(e),this.setXYZ(t,Di.x,Di.y,Di.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Di.fromBufferAttribute(this,t),Di.transformDirection(e),this.setXYZ(t,Di.x,Di.y,Di.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=ll(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Us(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=ll(t,this.array)),t}setX(e,t){return this.normalized&&(t=Us(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=ll(t,this.array)),t}setY(e,t){return this.normalized&&(t=Us(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=ll(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Us(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=ll(t,this.array)),t}setW(e,t){return this.normalized&&(t=Us(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Us(t,this.array),s=Us(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=Us(t,this.array),s=Us(s,this.array),i=Us(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e*=this.itemSize,this.normalized&&(t=Us(t,this.array),s=Us(s,this.array),i=Us(i,this.array),r=Us(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==LC&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}class iO extends Kr{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class rO extends Kr{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class Ra extends Kr{constructor(e,t,s){super(new Float32Array(e),t,s)}}let bZ=0;const qo=new us,hS=new mi,Dh=new Ne,ko=new La,Bm=new La,rr=new Ne;class Va extends Fd{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:bZ++}),this.uuid=Aa(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(QF(e)?rO:iO)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new cs().getNormalMatrix(e);s.applyNormalMatrix(r),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return qo.makeRotationFromQuaternion(e),this.applyMatrix4(qo),this}rotateX(e){return qo.makeRotationX(e),this.applyMatrix4(qo),this}rotateY(e){return qo.makeRotationY(e),this.applyMatrix4(qo),this}rotateZ(e){return qo.makeRotationZ(e),this.applyMatrix4(qo),this}translate(e,t,s){return qo.makeTranslation(e,t,s),this.applyMatrix4(qo),this}scale(e,t,s){return qo.makeScale(e,t,s),this.applyMatrix4(qo),this}lookAt(e){return hS.lookAt(e),hS.updateMatrix(),this.applyMatrix4(hS.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Dh).negate(),this.translate(Dh.x,Dh.y,Dh.z),this}setFromPoints(e){const t=[];for(let s=0,i=e.length;s<i;s++){const r=e[s];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Ra(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new La);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Ne(-1/0,-1/0,-1/0),new Ne(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,i=t.length;s<i;s++){const r=t[s];ko.setFromBufferAttribute(r),this.morphTargetsRelative?(rr.addVectors(this.boundingBox.min,ko.min),this.boundingBox.expandByPoint(rr),rr.addVectors(this.boundingBox.max,ko.max),this.boundingBox.expandByPoint(rr)):(this.boundingBox.expandByPoint(ko.min),this.boundingBox.expandByPoint(ko.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Rl);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Ne,1/0);return}if(e){const s=this.boundingSphere.center;if(ko.setFromBufferAttribute(e),t)for(let r=0,o=t.length;r<o;r++){const a=t[r];Bm.setFromBufferAttribute(a),this.morphTargetsRelative?(rr.addVectors(ko.min,Bm.min),ko.expandByPoint(rr),rr.addVectors(ko.max,Bm.max),ko.expandByPoint(rr)):(ko.expandByPoint(Bm.min),ko.expandByPoint(Bm.max))}ko.getCenter(s);let i=0;for(let r=0,o=e.count;r<o;r++)rr.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(rr));if(t)for(let r=0,o=t.length;r<o;r++){const a=t[r],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)rr.fromBufferAttribute(a,c),l&&(Dh.fromBufferAttribute(e,c),rr.add(Dh)),i=Math.max(i,s.distanceToSquared(rr))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.array,i=t.position.array,r=t.normal.array,o=t.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Kr(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let T=0;T<a;T++)c[T]=new Ne,u[T]=new Ne;const d=new Ne,h=new Ne,p=new Ne,g=new Zn,y=new Zn,x=new Zn,v=new Ne,b=new Ne;function S(T,M,j){d.fromArray(i,T*3),h.fromArray(i,M*3),p.fromArray(i,j*3),g.fromArray(o,T*2),y.fromArray(o,M*2),x.fromArray(o,j*2),h.sub(d),p.sub(d),y.sub(g),x.sub(g);const W=1/(y.x*x.y-x.x*y.y);isFinite(W)&&(v.copy(h).multiplyScalar(x.y).addScaledVector(p,-y.y).multiplyScalar(W),b.copy(p).multiplyScalar(y.x).addScaledVector(h,-x.x).multiplyScalar(W),c[T].add(v),c[M].add(v),c[j].add(v),u[T].add(b),u[M].add(b),u[j].add(b))}let C=this.groups;C.length===0&&(C=[{start:0,count:s.length}]);for(let T=0,M=C.length;T<M;++T){const j=C[T],W=j.start,z=j.count;for(let X=W,B=W+z;X<B;X+=3)S(s[X+0],s[X+1],s[X+2])}const E=new Ne,k=new Ne,R=new Ne,L=new Ne;function I(T){R.fromArray(r,T*3),L.copy(R);const M=c[T];E.copy(M),E.sub(R.multiplyScalar(R.dot(M))).normalize(),k.crossVectors(L,M);const W=k.dot(u[T])<0?-1:1;l[T*4]=E.x,l[T*4+1]=E.y,l[T*4+2]=E.z,l[T*4+3]=W}for(let T=0,M=C.length;T<M;++T){const j=C[T],W=j.start,z=j.count;for(let X=W,B=W+z;X<B;X+=3)I(s[X+0]),I(s[X+1]),I(s[X+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Kr(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let h=0,p=s.count;h<p;h++)s.setXYZ(h,0,0,0);const i=new Ne,r=new Ne,o=new Ne,a=new Ne,l=new Ne,c=new Ne,u=new Ne,d=new Ne;if(e)for(let h=0,p=e.count;h<p;h+=3){const g=e.getX(h+0),y=e.getX(h+1),x=e.getX(h+2);i.fromBufferAttribute(t,g),r.fromBufferAttribute(t,y),o.fromBufferAttribute(t,x),u.subVectors(o,r),d.subVectors(i,r),u.cross(d),a.fromBufferAttribute(s,g),l.fromBufferAttribute(s,y),c.fromBufferAttribute(s,x),a.add(u),l.add(u),c.add(u),s.setXYZ(g,a.x,a.y,a.z),s.setXYZ(y,l.x,l.y,l.z),s.setXYZ(x,c.x,c.y,c.z)}else for(let h=0,p=t.count;h<p;h+=3)i.fromBufferAttribute(t,h+0),r.fromBufferAttribute(t,h+1),o.fromBufferAttribute(t,h+2),u.subVectors(o,r),d.subVectors(i,r),u.cross(d),s.setXYZ(h+0,u.x,u.y,u.z),s.setXYZ(h+1,u.x,u.y,u.z),s.setXYZ(h+2,u.x,u.y,u.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)rr.fromBufferAttribute(e,t),rr.normalize(),e.setXYZ(t,rr.x,rr.y,rr.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,d=a.normalized,h=new c.constructor(l.length*u);let p=0,g=0;for(let y=0,x=l.length;y<x;y++){a.isInterleavedBufferAttribute?p=l[y]*a.data.stride+a.offset:p=l[y]*u;for(let v=0;v<u;v++)h[g++]=c[p++]}return new Kr(h,u,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Va,s=this.index.array,i=this.attributes;for(const a in i){const l=i[a],c=e(l,s);t.setAttribute(a,c)}const r=this.morphAttributes;for(const a in r){const l=[],c=r[a];for(let u=0,d=c.length;u<d;u++){const h=c[u],p=e(h,s);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let d=0,h=c.length;d<h;d++){const p=c[d];u.push(p.toJSON(e.data))}u.length>0&&(i[l]=u,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(t));const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(t))}const r=e.morphAttributes;for(const c in r){const u=[],d=r[c];for(let h=0,p=d.length;h<p;h++)u.push(d[h].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const d=o[c];this.addGroup(d.start,d.count,d.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const OM=new us,zu=new r0,Ux=new Rl,zM=new Ne,Lh=new Ne,$h=new Ne,Fh=new Ne,fS=new Ne,Vx=new Ne,Wx=new Zn,Gx=new Zn,Hx=new Zn,BM=new Ne,UM=new Ne,VM=new Ne,jx=new Ne,Xx=new Ne;class Mo extends mi{constructor(e=new Va,t=new qc){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}getVertexPosition(e,t){const s=this.geometry,i=s.attributes.position,r=s.morphAttributes.position,o=s.morphTargetsRelative;t.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(r&&a){Vx.set(0,0,0);for(let l=0,c=r.length;l<c;l++){const u=a[l],d=r[l];u!==0&&(fS.fromBufferAttribute(d,e),o?Vx.addScaledVector(fS,u):Vx.addScaledVector(fS.sub(t),u))}t.add(Vx)}return t}raycast(e,t){const s=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),Ux.copy(s.boundingSphere),Ux.applyMatrix4(r),zu.copy(e.ray).recast(e.near),!(Ux.containsPoint(zu.origin)===!1&&(zu.intersectSphere(Ux,zM)===null||zu.origin.distanceToSquared(zM)>(e.far-e.near)**2))&&(OM.copy(r).invert(),zu.copy(e.ray).applyMatrix4(OM),!(s.boundingBox!==null&&zu.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,zu)))}_computeIntersections(e,t,s){let i;const r=this.geometry,o=this.material,a=r.index,l=r.attributes.position,c=r.attributes.uv,u=r.attributes.uv1,d=r.attributes.normal,h=r.groups,p=r.drawRange;if(a!==null)if(Array.isArray(o))for(let g=0,y=h.length;g<y;g++){const x=h[g],v=o[x.materialIndex],b=Math.max(x.start,p.start),S=Math.min(a.count,Math.min(x.start+x.count,p.start+p.count));for(let C=b,E=S;C<E;C+=3){const k=a.getX(C),R=a.getX(C+1),L=a.getX(C+2);i=qx(this,v,e,s,c,u,d,k,R,L),i&&(i.faceIndex=Math.floor(C/3),i.face.materialIndex=x.materialIndex,t.push(i))}}else{const g=Math.max(0,p.start),y=Math.min(a.count,p.start+p.count);for(let x=g,v=y;x<v;x+=3){const b=a.getX(x),S=a.getX(x+1),C=a.getX(x+2);i=qx(this,o,e,s,c,u,d,b,S,C),i&&(i.faceIndex=Math.floor(x/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(o))for(let g=0,y=h.length;g<y;g++){const x=h[g],v=o[x.materialIndex],b=Math.max(x.start,p.start),S=Math.min(l.count,Math.min(x.start+x.count,p.start+p.count));for(let C=b,E=S;C<E;C+=3){const k=C,R=C+1,L=C+2;i=qx(this,v,e,s,c,u,d,k,R,L),i&&(i.faceIndex=Math.floor(C/3),i.face.materialIndex=x.materialIndex,t.push(i))}}else{const g=Math.max(0,p.start),y=Math.min(l.count,p.start+p.count);for(let x=g,v=y;x<v;x+=3){const b=x,S=x+1,C=x+2;i=qx(this,o,e,s,c,u,d,b,S,C),i&&(i.faceIndex=Math.floor(x/3),t.push(i))}}}}function SZ(n,e,t,s,i,r,o,a){let l;if(e.side===xo?l=s.intersectTriangle(o,r,i,!0,a):l=s.intersectTriangle(i,r,o,e.side===dc,a),l===null)return null;Xx.copy(a),Xx.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(Xx);return c<t.near||c>t.far?null:{distance:c,point:Xx.clone(),object:n}}function qx(n,e,t,s,i,r,o,a,l,c){n.getVertexPosition(a,Lh),n.getVertexPosition(l,$h),n.getVertexPosition(c,Fh);const u=SZ(n,e,t,s,Lh,$h,Fh,jx);if(u){i&&(Wx.fromBufferAttribute(i,a),Gx.fromBufferAttribute(i,l),Hx.fromBufferAttribute(i,c),u.uv=_a.getInterpolation(jx,Lh,$h,Fh,Wx,Gx,Hx,new Zn)),r&&(Wx.fromBufferAttribute(r,a),Gx.fromBufferAttribute(r,l),Hx.fromBufferAttribute(r,c),u.uv1=_a.getInterpolation(jx,Lh,$h,Fh,Wx,Gx,Hx,new Zn),u.uv2=u.uv1),o&&(BM.fromBufferAttribute(o,a),UM.fromBufferAttribute(o,l),VM.fromBufferAttribute(o,c),u.normal=_a.getInterpolation(jx,Lh,$h,Fh,BM,UM,VM,new Ne),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const d={a,b:l,c,normal:new Ne,materialIndex:0};_a.getNormal(Lh,$h,Fh,d.normal),u.face=d}return u}class o0 extends Va{constructor(e=1,t=1,s=1,i=1,r=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:i,heightSegments:r,depthSegments:o};const a=this;i=Math.floor(i),r=Math.floor(r),o=Math.floor(o);const l=[],c=[],u=[],d=[];let h=0,p=0;g("z","y","x",-1,-1,s,t,e,o,r,0),g("z","y","x",1,-1,s,t,-e,o,r,1),g("x","z","y",1,1,e,s,t,i,o,2),g("x","z","y",1,-1,e,s,-t,i,o,3),g("x","y","z",1,-1,e,t,s,i,r,4),g("x","y","z",-1,-1,e,t,-s,i,r,5),this.setIndex(l),this.setAttribute("position",new Ra(c,3)),this.setAttribute("normal",new Ra(u,3)),this.setAttribute("uv",new Ra(d,2));function g(y,x,v,b,S,C,E,k,R,L,I){const T=C/R,M=E/L,j=C/2,W=E/2,z=k/2,X=R+1,B=L+1;let J=0,K=0;const ee=new Ne;for(let ne=0;ne<B;ne++){const V=ne*M-W;for(let Z=0;Z<X;Z++){const he=Z*T-j;ee[y]=he*b,ee[x]=V*S,ee[v]=z,c.push(ee.x,ee.y,ee.z),ee[y]=0,ee[x]=0,ee[v]=k>0?1:-1,u.push(ee.x,ee.y,ee.z),d.push(Z/R),d.push(1-ne/L),J+=1}}for(let ne=0;ne<L;ne++)for(let V=0;V<R;V++){const Z=h+V+X*ne,he=h+V+X*(ne+1),ve=h+(V+1)+X*(ne+1),be=h+(V+1)+X*ne;l.push(Z,he,be),l.push(he,ve,be),K+=6}a.addGroup(p,K,I),p+=K,h+=J}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new o0(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Cf(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const i=n[t][s];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=i.clone():Array.isArray(i)?e[t][s]=i.slice():e[t][s]=i}}return e}function Wr(n){const e={};for(let t=0;t<n.length;t++){const s=Cf(n[t]);for(const i in s)e[i]=s[i]}return e}function CZ(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function oO(n){return n.getRenderTarget()===null?n.outputColorSpace:Ps.workingColorSpace}const _Z={clone:Cf,merge:Wr};var EZ=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,TZ=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class wd extends ml{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=EZ,this.fragmentShader=TZ,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Cf(e.uniforms),this.uniformsGroups=CZ(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const i in this.extensions)this.extensions[i]===!0&&(s[i]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class aO extends mi{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new us,this.projectionMatrix=new us,this.projectionMatrixInverse=new us,this.coordinateSystem=ic}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Hr extends aO{constructor(e=50,t=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Sf*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(xg*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Sf*2*Math.atan(Math.tan(xg*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,s,i,r,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(xg*.5*this.fov)/this.zoom,s=2*t,i=this.aspect*s,r=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;r+=o.offsetX*i/l,t-=o.offsetY*s/c,i*=o.width/l,s*=o.height/c}const a=this.filmOffset;a!==0&&(r+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Oh=-90,zh=1;class IZ extends mi{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Hr(Oh,zh,e,t);i.layers=this.layers,this.add(i);const r=new Hr(Oh,zh,e,t);r.layers=this.layers,this.add(r);const o=new Hr(Oh,zh,e,t);o.layers=this.layers,this.add(o);const a=new Hr(Oh,zh,e,t);a.layers=this.layers,this.add(a);const l=new Hr(Oh,zh,e,t);l.layers=this.layers,this.add(l);const c=new Hr(Oh,zh,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,i,r,o,a,l]=t;for(const c of t)this.remove(c);if(e===ic)s.up.set(0,1,0),s.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===l2)s.up.set(0,-1,0),s.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[r,o,a,l,c,u]=this.children,d=e.getRenderTarget(),h=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),g=e.xr.enabled;e.xr.enabled=!1;const y=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,i),e.render(t,r),e.setRenderTarget(s,1,i),e.render(t,o),e.setRenderTarget(s,2,i),e.render(t,a),e.setRenderTarget(s,3,i),e.render(t,l),e.setRenderTarget(s,4,i),e.render(t,c),s.texture.generateMipmaps=y,e.setRenderTarget(s,5,i),e.render(t,u),e.setRenderTarget(d,h,p),e.xr.enabled=g,s.texture.needsPMREMUpdate=!0}}class lO extends vr{constructor(e,t,s,i,r,o,a,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:xf,super(e,t,s,i,r,o,a,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class kZ extends yd{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},i=[s,s,s,s,s,s];t.encoding!==void 0&&(yg("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===hd?hi:na),this.texture=new lO(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:po}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new o0(5,5,5),r=new wd({name:"CubemapFromEquirect",uniforms:Cf(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:xo,blending:Qc});r.uniforms.tEquirect.value=t;const o=new Mo(i,r),a=t.minFilter;return t.minFilter===vd&&(t.minFilter=po),new IZ(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,s,i){const r=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,i);e.setRenderTarget(r)}}const pS=new Ne,AZ=new Ne,RZ=new cs;class Gc{constructor(e=new Ne(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,i){return this.normal.set(e,t,s),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const i=pS.subVectors(s,t).cross(AZ.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(pS),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(e.start).addScaledVector(s,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||RZ.getNormalMatrix(e),i=this.coplanarPoint(pS).applyMatrix4(e),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Bu=new Rl,Kx=new Ne;class PE{constructor(e=new Gc,t=new Gc,s=new Gc,i=new Gc,r=new Gc,o=new Gc){this.planes=[e,t,s,i,r,o]}set(e,t,s,i,r,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(i),a[4].copy(r),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=ic){const s=this.planes,i=e.elements,r=i[0],o=i[1],a=i[2],l=i[3],c=i[4],u=i[5],d=i[6],h=i[7],p=i[8],g=i[9],y=i[10],x=i[11],v=i[12],b=i[13],S=i[14],C=i[15];if(s[0].setComponents(l-r,h-c,x-p,C-v).normalize(),s[1].setComponents(l+r,h+c,x+p,C+v).normalize(),s[2].setComponents(l+o,h+u,x+g,C+b).normalize(),s[3].setComponents(l-o,h-u,x-g,C-b).normalize(),s[4].setComponents(l-a,h-d,x-y,C-S).normalize(),t===ic)s[5].setComponents(l+a,h+d,x+y,C+S).normalize();else if(t===l2)s[5].setComponents(a,d,y,S).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Bu.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Bu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Bu)}intersectsSprite(e){return Bu.center.set(0,0,0),Bu.radius=.7071067811865476,Bu.applyMatrix4(e.matrixWorld),this.intersectsSphere(Bu)}intersectsSphere(e){const t=this.planes,s=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(s)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const i=t[s];if(Kx.x=i.normal.x>0?e.max.x:e.min.x,Kx.y=i.normal.y>0?e.max.y:e.min.y,Kx.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Kx)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function cO(){let n=null,e=!1,t=null,s=null;function i(r,o){t(r,o),s=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){n=r}}}function MZ(n,e){const t=e.isWebGL2,s=new WeakMap;function i(c,u){const d=c.array,h=c.usage,p=n.createBuffer();n.bindBuffer(u,p),n.bufferData(u,d,h),c.onUploadCallback();let g;if(d instanceof Float32Array)g=n.FLOAT;else if(d instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)g=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else g=n.UNSIGNED_SHORT;else if(d instanceof Int16Array)g=n.SHORT;else if(d instanceof Uint32Array)g=n.UNSIGNED_INT;else if(d instanceof Int32Array)g=n.INT;else if(d instanceof Int8Array)g=n.BYTE;else if(d instanceof Uint8Array)g=n.UNSIGNED_BYTE;else if(d instanceof Uint8ClampedArray)g=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+d);return{buffer:p,type:g,bytesPerElement:d.BYTES_PER_ELEMENT,version:c.version}}function r(c,u,d){const h=u.array,p=u.updateRange;n.bindBuffer(d,c),p.count===-1?n.bufferSubData(d,0,h):(t?n.bufferSubData(d,p.offset*h.BYTES_PER_ELEMENT,h,p.offset,p.count):n.bufferSubData(d,p.offset*h.BYTES_PER_ELEMENT,h.subarray(p.offset,p.offset+p.count)),p.count=-1),u.onUploadCallback()}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),s.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=s.get(c);u&&(n.deleteBuffer(u.buffer),s.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const h=s.get(c);(!h||h.version<c.version)&&s.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const d=s.get(c);d===void 0?s.set(c,i(c,u)):d.version<c.version&&(r(d.buffer,c,u),d.version=c.version)}return{get:o,remove:a,update:l}}class oy extends Va{constructor(e=1,t=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:i};const r=e/2,o=t/2,a=Math.floor(s),l=Math.floor(i),c=a+1,u=l+1,d=e/a,h=t/l,p=[],g=[],y=[],x=[];for(let v=0;v<u;v++){const b=v*h-o;for(let S=0;S<c;S++){const C=S*d-r;g.push(C,-b,0),y.push(0,0,1),x.push(S/a),x.push(1-v/l)}}for(let v=0;v<l;v++)for(let b=0;b<a;b++){const S=b+c*v,C=b+c*(v+1),E=b+1+c*(v+1),k=b+1+c*v;p.push(S,C,k),p.push(C,E,k)}this.setIndex(p),this.setAttribute("position",new Ra(g,3)),this.setAttribute("normal",new Ra(y,3)),this.setAttribute("uv",new Ra(x,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oy(e.width,e.height,e.widthSegments,e.heightSegments)}}var NZ=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,PZ=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,DZ=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,LZ=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,$Z=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,FZ=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,OZ=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,zZ=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,BZ=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,UZ=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,VZ=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,WZ=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,GZ=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,HZ=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,jZ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,XZ=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,qZ=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,KZ=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,YZ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,ZZ=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,QZ=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,JZ=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,eQ=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,tQ=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,nQ=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,sQ=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,iQ=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,rQ=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,oQ="gl_FragColor = linearToOutputTexel( gl_FragColor );",aQ=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,lQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,cQ=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,uQ=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,dQ=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,hQ=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fQ=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,pQ=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,mQ=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,gQ=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,xQ=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,vQ=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,yQ=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,wQ=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,bQ=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,SQ=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,CQ=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,_Q=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,EQ=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,TQ=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,IQ=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,kQ=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,AQ=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,RQ=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,MQ=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,NQ=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,PQ=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,DQ=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,LQ=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,$Q=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,FQ=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,OQ=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,zQ=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,BQ=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,UQ=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,VQ=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,WQ=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,GQ=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,HQ=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,jQ=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,XQ=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,qQ=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,KQ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,YQ=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,ZQ=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,QQ=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,JQ=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,eJ=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,tJ=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,nJ=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,sJ=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,iJ=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,rJ=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,oJ=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,aJ=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,lJ=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,cJ=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,uJ=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,dJ=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,hJ=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,fJ=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,pJ=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,mJ=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,gJ=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,xJ=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,vJ=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,yJ=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,wJ=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,bJ=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,SJ=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,CJ=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,_J=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,EJ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,TJ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,IJ=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,kJ=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const AJ=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,RJ=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,MJ=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,NJ=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,PJ=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,DJ=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,LJ=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,$J=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,FJ=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,OJ=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,zJ=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,BJ=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,UJ=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,VJ=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,WJ=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,GJ=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,HJ=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,jJ=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,XJ=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,qJ=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,KJ=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,YJ=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,ZJ=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,QJ=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,JJ=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,eee=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,tee=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,nee=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,see=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,iee=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,ree=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,oee=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,aee=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,lee=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,is={alphahash_fragment:NZ,alphahash_pars_fragment:PZ,alphamap_fragment:DZ,alphamap_pars_fragment:LZ,alphatest_fragment:$Z,alphatest_pars_fragment:FZ,aomap_fragment:OZ,aomap_pars_fragment:zZ,begin_vertex:BZ,beginnormal_vertex:UZ,bsdfs:VZ,iridescence_fragment:WZ,bumpmap_pars_fragment:GZ,clipping_planes_fragment:HZ,clipping_planes_pars_fragment:jZ,clipping_planes_pars_vertex:XZ,clipping_planes_vertex:qZ,color_fragment:KZ,color_pars_fragment:YZ,color_pars_vertex:ZZ,color_vertex:QZ,common:JZ,cube_uv_reflection_fragment:eQ,defaultnormal_vertex:tQ,displacementmap_pars_vertex:nQ,displacementmap_vertex:sQ,emissivemap_fragment:iQ,emissivemap_pars_fragment:rQ,colorspace_fragment:oQ,colorspace_pars_fragment:aQ,envmap_fragment:lQ,envmap_common_pars_fragment:cQ,envmap_pars_fragment:uQ,envmap_pars_vertex:dQ,envmap_physical_pars_fragment:CQ,envmap_vertex:hQ,fog_vertex:fQ,fog_pars_vertex:pQ,fog_fragment:mQ,fog_pars_fragment:gQ,gradientmap_pars_fragment:xQ,lightmap_fragment:vQ,lightmap_pars_fragment:yQ,lights_lambert_fragment:wQ,lights_lambert_pars_fragment:bQ,lights_pars_begin:SQ,lights_toon_fragment:_Q,lights_toon_pars_fragment:EQ,lights_phong_fragment:TQ,lights_phong_pars_fragment:IQ,lights_physical_fragment:kQ,lights_physical_pars_fragment:AQ,lights_fragment_begin:RQ,lights_fragment_maps:MQ,lights_fragment_end:NQ,logdepthbuf_fragment:PQ,logdepthbuf_pars_fragment:DQ,logdepthbuf_pars_vertex:LQ,logdepthbuf_vertex:$Q,map_fragment:FQ,map_pars_fragment:OQ,map_particle_fragment:zQ,map_particle_pars_fragment:BQ,metalnessmap_fragment:UQ,metalnessmap_pars_fragment:VQ,morphcolor_vertex:WQ,morphnormal_vertex:GQ,morphtarget_pars_vertex:HQ,morphtarget_vertex:jQ,normal_fragment_begin:XQ,normal_fragment_maps:qQ,normal_pars_fragment:KQ,normal_pars_vertex:YQ,normal_vertex:ZQ,normalmap_pars_fragment:QQ,clearcoat_normal_fragment_begin:JQ,clearcoat_normal_fragment_maps:eJ,clearcoat_pars_fragment:tJ,iridescence_pars_fragment:nJ,opaque_fragment:sJ,packing:iJ,premultiplied_alpha_fragment:rJ,project_vertex:oJ,dithering_fragment:aJ,dithering_pars_fragment:lJ,roughnessmap_fragment:cJ,roughnessmap_pars_fragment:uJ,shadowmap_pars_fragment:dJ,shadowmap_pars_vertex:hJ,shadowmap_vertex:fJ,shadowmask_pars_fragment:pJ,skinbase_vertex:mJ,skinning_pars_vertex:gJ,skinning_vertex:xJ,skinnormal_vertex:vJ,specularmap_fragment:yJ,specularmap_pars_fragment:wJ,tonemapping_fragment:bJ,tonemapping_pars_fragment:SJ,transmission_fragment:CJ,transmission_pars_fragment:_J,uv_pars_fragment:EJ,uv_pars_vertex:TJ,uv_vertex:IJ,worldpos_vertex:kJ,background_vert:AJ,background_frag:RJ,backgroundCube_vert:MJ,backgroundCube_frag:NJ,cube_vert:PJ,cube_frag:DJ,depth_vert:LJ,depth_frag:$J,distanceRGBA_vert:FJ,distanceRGBA_frag:OJ,equirect_vert:zJ,equirect_frag:BJ,linedashed_vert:UJ,linedashed_frag:VJ,meshbasic_vert:WJ,meshbasic_frag:GJ,meshlambert_vert:HJ,meshlambert_frag:jJ,meshmatcap_vert:XJ,meshmatcap_frag:qJ,meshnormal_vert:KJ,meshnormal_frag:YJ,meshphong_vert:ZJ,meshphong_frag:QJ,meshphysical_vert:JJ,meshphysical_frag:eee,meshtoon_vert:tee,meshtoon_frag:nee,points_vert:see,points_frag:iee,shadow_vert:ree,shadow_frag:oee,sprite_vert:aee,sprite_frag:lee},Zt={common:{diffuse:{value:new Kn(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new cs},alphaMap:{value:null},alphaMapTransform:{value:new cs},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new cs}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new cs}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new cs}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new cs},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new cs},normalScale:{value:new Zn(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new cs},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new cs}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new cs}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new cs}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Kn(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Kn(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new cs},alphaTest:{value:0},uvTransform:{value:new cs}},sprite:{diffuse:{value:new Kn(16777215)},opacity:{value:1},center:{value:new Zn(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new cs},alphaMap:{value:null},alphaMapTransform:{value:new cs},alphaTest:{value:0}}},sl={basic:{uniforms:Wr([Zt.common,Zt.specularmap,Zt.envmap,Zt.aomap,Zt.lightmap,Zt.fog]),vertexShader:is.meshbasic_vert,fragmentShader:is.meshbasic_frag},lambert:{uniforms:Wr([Zt.common,Zt.specularmap,Zt.envmap,Zt.aomap,Zt.lightmap,Zt.emissivemap,Zt.bumpmap,Zt.normalmap,Zt.displacementmap,Zt.fog,Zt.lights,{emissive:{value:new Kn(0)}}]),vertexShader:is.meshlambert_vert,fragmentShader:is.meshlambert_frag},phong:{uniforms:Wr([Zt.common,Zt.specularmap,Zt.envmap,Zt.aomap,Zt.lightmap,Zt.emissivemap,Zt.bumpmap,Zt.normalmap,Zt.displacementmap,Zt.fog,Zt.lights,{emissive:{value:new Kn(0)},specular:{value:new Kn(1118481)},shininess:{value:30}}]),vertexShader:is.meshphong_vert,fragmentShader:is.meshphong_frag},standard:{uniforms:Wr([Zt.common,Zt.envmap,Zt.aomap,Zt.lightmap,Zt.emissivemap,Zt.bumpmap,Zt.normalmap,Zt.displacementmap,Zt.roughnessmap,Zt.metalnessmap,Zt.fog,Zt.lights,{emissive:{value:new Kn(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:is.meshphysical_vert,fragmentShader:is.meshphysical_frag},toon:{uniforms:Wr([Zt.common,Zt.aomap,Zt.lightmap,Zt.emissivemap,Zt.bumpmap,Zt.normalmap,Zt.displacementmap,Zt.gradientmap,Zt.fog,Zt.lights,{emissive:{value:new Kn(0)}}]),vertexShader:is.meshtoon_vert,fragmentShader:is.meshtoon_frag},matcap:{uniforms:Wr([Zt.common,Zt.bumpmap,Zt.normalmap,Zt.displacementmap,Zt.fog,{matcap:{value:null}}]),vertexShader:is.meshmatcap_vert,fragmentShader:is.meshmatcap_frag},points:{uniforms:Wr([Zt.points,Zt.fog]),vertexShader:is.points_vert,fragmentShader:is.points_frag},dashed:{uniforms:Wr([Zt.common,Zt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:is.linedashed_vert,fragmentShader:is.linedashed_frag},depth:{uniforms:Wr([Zt.common,Zt.displacementmap]),vertexShader:is.depth_vert,fragmentShader:is.depth_frag},normal:{uniforms:Wr([Zt.common,Zt.bumpmap,Zt.normalmap,Zt.displacementmap,{opacity:{value:1}}]),vertexShader:is.meshnormal_vert,fragmentShader:is.meshnormal_frag},sprite:{uniforms:Wr([Zt.sprite,Zt.fog]),vertexShader:is.sprite_vert,fragmentShader:is.sprite_frag},background:{uniforms:{uvTransform:{value:new cs},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:is.background_vert,fragmentShader:is.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:is.backgroundCube_vert,fragmentShader:is.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:is.cube_vert,fragmentShader:is.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:is.equirect_vert,fragmentShader:is.equirect_frag},distanceRGBA:{uniforms:Wr([Zt.common,Zt.displacementmap,{referencePosition:{value:new Ne},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:is.distanceRGBA_vert,fragmentShader:is.distanceRGBA_frag},shadow:{uniforms:Wr([Zt.lights,Zt.fog,{color:{value:new Kn(0)},opacity:{value:1}}]),vertexShader:is.shadow_vert,fragmentShader:is.shadow_frag}};sl.physical={uniforms:Wr([sl.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new cs},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new cs},clearcoatNormalScale:{value:new Zn(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new cs},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new cs},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new cs},sheen:{value:0},sheenColor:{value:new Kn(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new cs},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new cs},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new cs},transmissionSamplerSize:{value:new Zn},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new cs},attenuationDistance:{value:0},attenuationColor:{value:new Kn(0)},specularColor:{value:new Kn(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new cs},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new cs},anisotropyVector:{value:new Zn},anisotropyMap:{value:null},anisotropyMapTransform:{value:new cs}}]),vertexShader:is.meshphysical_vert,fragmentShader:is.meshphysical_frag};const Yx={r:0,b:0,g:0};function cee(n,e,t,s,i,r,o){const a=new Kn(0);let l=r===!0?0:1,c,u,d=null,h=0,p=null;function g(x,v){let b=!1,S=v.isScene===!0?v.background:null;S&&S.isTexture&&(S=(v.backgroundBlurriness>0?t:e).get(S)),S===null?y(a,l):S&&S.isColor&&(y(S,1),b=!0);const C=n.xr.getEnvironmentBlendMode();C==="additive"?s.buffers.color.setClear(0,0,0,1,o):C==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,o),(n.autoClear||b)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),S&&(S.isCubeTexture||S.mapping===sy)?(u===void 0&&(u=new Mo(new o0(1,1,1),new wd({name:"BackgroundCubeMaterial",uniforms:Cf(sl.backgroundCube.uniforms),vertexShader:sl.backgroundCube.vertexShader,fragmentShader:sl.backgroundCube.fragmentShader,side:xo,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(E,k,R){this.matrixWorld.copyPosition(R.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),u.material.uniforms.envMap.value=S,u.material.uniforms.flipEnvMap.value=S.isCubeTexture&&S.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=v.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=v.backgroundIntensity,u.material.toneMapped=Ps.getTransfer(S.colorSpace)!==si,(d!==S||h!==S.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,d=S,h=S.version,p=n.toneMapping),u.layers.enableAll(),x.unshift(u,u.geometry,u.material,0,0,null)):S&&S.isTexture&&(c===void 0&&(c=new Mo(new oy(2,2),new wd({name:"BackgroundMaterial",uniforms:Cf(sl.background.uniforms),vertexShader:sl.background.vertexShader,fragmentShader:sl.background.fragmentShader,side:dc,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=S,c.material.uniforms.backgroundIntensity.value=v.backgroundIntensity,c.material.toneMapped=Ps.getTransfer(S.colorSpace)!==si,S.matrixAutoUpdate===!0&&S.updateMatrix(),c.material.uniforms.uvTransform.value.copy(S.matrix),(d!==S||h!==S.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,d=S,h=S.version,p=n.toneMapping),c.layers.enableAll(),x.unshift(c,c.geometry,c.material,0,0,null))}function y(x,v){x.getRGB(Yx,oO(n)),s.buffers.color.setClear(Yx.r,Yx.g,Yx.b,v,o)}return{getClearColor:function(){return a},setClearColor:function(x,v=1){a.set(x),l=v,y(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(x){l=x,y(a,l)},render:g}}function uee(n,e,t,s){const i=n.getParameter(n.MAX_VERTEX_ATTRIBS),r=s.isWebGL2?null:e.get("OES_vertex_array_object"),o=s.isWebGL2||r!==null,a={},l=x(null);let c=l,u=!1;function d(z,X,B,J,K){let ee=!1;if(o){const ne=y(J,B,X);c!==ne&&(c=ne,p(c.object)),ee=v(z,J,B,K),ee&&b(z,J,B,K)}else{const ne=X.wireframe===!0;(c.geometry!==J.id||c.program!==B.id||c.wireframe!==ne)&&(c.geometry=J.id,c.program=B.id,c.wireframe=ne,ee=!0)}K!==null&&t.update(K,n.ELEMENT_ARRAY_BUFFER),(ee||u)&&(u=!1,L(z,X,B,J),K!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(K).buffer))}function h(){return s.isWebGL2?n.createVertexArray():r.createVertexArrayOES()}function p(z){return s.isWebGL2?n.bindVertexArray(z):r.bindVertexArrayOES(z)}function g(z){return s.isWebGL2?n.deleteVertexArray(z):r.deleteVertexArrayOES(z)}function y(z,X,B){const J=B.wireframe===!0;let K=a[z.id];K===void 0&&(K={},a[z.id]=K);let ee=K[X.id];ee===void 0&&(ee={},K[X.id]=ee);let ne=ee[J];return ne===void 0&&(ne=x(h()),ee[J]=ne),ne}function x(z){const X=[],B=[],J=[];for(let K=0;K<i;K++)X[K]=0,B[K]=0,J[K]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:X,enabledAttributes:B,attributeDivisors:J,object:z,attributes:{},index:null}}function v(z,X,B,J){const K=c.attributes,ee=X.attributes;let ne=0;const V=B.getAttributes();for(const Z in V)if(V[Z].location>=0){const ve=K[Z];let be=ee[Z];if(be===void 0&&(Z==="instanceMatrix"&&z.instanceMatrix&&(be=z.instanceMatrix),Z==="instanceColor"&&z.instanceColor&&(be=z.instanceColor)),ve===void 0||ve.attribute!==be||be&&ve.data!==be.data)return!0;ne++}return c.attributesNum!==ne||c.index!==J}function b(z,X,B,J){const K={},ee=X.attributes;let ne=0;const V=B.getAttributes();for(const Z in V)if(V[Z].location>=0){let ve=ee[Z];ve===void 0&&(Z==="instanceMatrix"&&z.instanceMatrix&&(ve=z.instanceMatrix),Z==="instanceColor"&&z.instanceColor&&(ve=z.instanceColor));const be={};be.attribute=ve,ve&&ve.data&&(be.data=ve.data),K[Z]=be,ne++}c.attributes=K,c.attributesNum=ne,c.index=J}function S(){const z=c.newAttributes;for(let X=0,B=z.length;X<B;X++)z[X]=0}function C(z){E(z,0)}function E(z,X){const B=c.newAttributes,J=c.enabledAttributes,K=c.attributeDivisors;B[z]=1,J[z]===0&&(n.enableVertexAttribArray(z),J[z]=1),K[z]!==X&&((s.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](z,X),K[z]=X)}function k(){const z=c.newAttributes,X=c.enabledAttributes;for(let B=0,J=X.length;B<J;B++)X[B]!==z[B]&&(n.disableVertexAttribArray(B),X[B]=0)}function R(z,X,B,J,K,ee,ne){ne===!0?n.vertexAttribIPointer(z,X,B,K,ee):n.vertexAttribPointer(z,X,B,J,K,ee)}function L(z,X,B,J){if(s.isWebGL2===!1&&(z.isInstancedMesh||J.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;S();const K=J.attributes,ee=B.getAttributes(),ne=X.defaultAttributeValues;for(const V in ee){const Z=ee[V];if(Z.location>=0){let he=K[V];if(he===void 0&&(V==="instanceMatrix"&&z.instanceMatrix&&(he=z.instanceMatrix),V==="instanceColor"&&z.instanceColor&&(he=z.instanceColor)),he!==void 0){const ve=he.normalized,be=he.itemSize,Ie=t.get(he);if(Ie===void 0)continue;const Xe=Ie.buffer,Fe=Ie.type,Pe=Ie.bytesPerElement,ct=s.isWebGL2===!0&&(Fe===n.INT||Fe===n.UNSIGNED_INT||he.gpuType===UF);if(he.isInterleavedBufferAttribute){const at=he.data,Ee=at.stride,nn=he.offset;if(at.isInstancedInterleavedBuffer){for(let gt=0;gt<Z.locationSize;gt++)E(Z.location+gt,at.meshPerAttribute);z.isInstancedMesh!==!0&&J._maxInstanceCount===void 0&&(J._maxInstanceCount=at.meshPerAttribute*at.count)}else for(let gt=0;gt<Z.locationSize;gt++)C(Z.location+gt);n.bindBuffer(n.ARRAY_BUFFER,Xe);for(let gt=0;gt<Z.locationSize;gt++)R(Z.location+gt,be/Z.locationSize,Fe,ve,Ee*Pe,(nn+be/Z.locationSize*gt)*Pe,ct)}else{if(he.isInstancedBufferAttribute){for(let at=0;at<Z.locationSize;at++)E(Z.location+at,he.meshPerAttribute);z.isInstancedMesh!==!0&&J._maxInstanceCount===void 0&&(J._maxInstanceCount=he.meshPerAttribute*he.count)}else for(let at=0;at<Z.locationSize;at++)C(Z.location+at);n.bindBuffer(n.ARRAY_BUFFER,Xe);for(let at=0;at<Z.locationSize;at++)R(Z.location+at,be/Z.locationSize,Fe,ve,be*Pe,be/Z.locationSize*at*Pe,ct)}}else if(ne!==void 0){const ve=ne[V];if(ve!==void 0)switch(ve.length){case 2:n.vertexAttrib2fv(Z.location,ve);break;case 3:n.vertexAttrib3fv(Z.location,ve);break;case 4:n.vertexAttrib4fv(Z.location,ve);break;default:n.vertexAttrib1fv(Z.location,ve)}}}}k()}function I(){j();for(const z in a){const X=a[z];for(const B in X){const J=X[B];for(const K in J)g(J[K].object),delete J[K];delete X[B]}delete a[z]}}function T(z){if(a[z.id]===void 0)return;const X=a[z.id];for(const B in X){const J=X[B];for(const K in J)g(J[K].object),delete J[K];delete X[B]}delete a[z.id]}function M(z){for(const X in a){const B=a[X];if(B[z.id]===void 0)continue;const J=B[z.id];for(const K in J)g(J[K].object),delete J[K];delete B[z.id]}}function j(){W(),u=!0,c!==l&&(c=l,p(c.object))}function W(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:d,reset:j,resetDefaultState:W,dispose:I,releaseStatesOfGeometry:T,releaseStatesOfProgram:M,initAttributes:S,enableAttribute:C,disableUnusedAttributes:k}}function dee(n,e,t,s){const i=s.isWebGL2;let r;function o(c){r=c}function a(c,u){n.drawArrays(r,c,u),t.update(u,r,1)}function l(c,u,d){if(d===0)return;let h,p;if(i)h=n,p="drawArraysInstanced";else if(h=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",h===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}h[p](r,c,u,d),t.update(u,r,d)}this.setMode=o,this.render=a,this.renderInstances=l}function hee(n,e,t){let s;function i(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const R=e.get("EXT_texture_filter_anisotropic");s=n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function r(R){if(R==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";R="mediump"}return R==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const l=r(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,d=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),h=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),g=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),y=n.getParameter(n.MAX_VERTEX_ATTRIBS),x=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),v=n.getParameter(n.MAX_VARYING_VECTORS),b=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),S=h>0,C=o||e.has("OES_texture_float"),E=S&&C,k=o?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:r,precision:a,logarithmicDepthBuffer:u,maxTextures:d,maxVertexTextures:h,maxTextureSize:p,maxCubemapSize:g,maxAttributes:y,maxVertexUniforms:x,maxVaryings:v,maxFragmentUniforms:b,vertexTextures:S,floatFragmentTextures:C,floatVertexTextures:E,maxSamples:k}}function fee(n){const e=this;let t=null,s=0,i=!1,r=!1;const o=new Gc,a=new cs,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(d,h){const p=d.length!==0||h||s!==0||i;return i=h,s=d.length,p},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(d,h){t=u(d,h,0)},this.setState=function(d,h,p){const g=d.clippingPlanes,y=d.clipIntersection,x=d.clipShadows,v=n.get(d);if(!i||g===null||g.length===0||r&&!x)r?u(null):c();else{const b=r?0:s,S=b*4;let C=v.clippingState||null;l.value=C,C=u(g,h,S,p);for(let E=0;E!==S;++E)C[E]=t[E];v.clippingState=C,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function u(d,h,p,g){const y=d!==null?d.length:0;let x=null;if(y!==0){if(x=l.value,g!==!0||x===null){const v=p+y*4,b=h.matrixWorldInverse;a.getNormalMatrix(b),(x===null||x.length<v)&&(x=new Float32Array(v));for(let S=0,C=p;S!==y;++S,C+=4)o.copy(d[S]).applyMatrix4(b,a),o.normal.toArray(x,C),x[C+3]=o.constant}l.value=x,l.needsUpdate=!0}return e.numPlanes=y,e.numIntersection=0,x}}function pee(n){let e=new WeakMap;function t(o,a){return a===MC?o.mapping=xf:a===NC&&(o.mapping=vf),o}function s(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===MC||a===NC)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new kZ(l.height/2);return c.fromEquirectangularTexture(n,o),e.set(o,c),o.addEventListener("dispose",i),t(c.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function r(){e=new WeakMap}return{get:s,dispose:r}}class DE extends aO{constructor(e=-1,t=1,s=1,i=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=i,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,i,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=s-e,o=s+e,a=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const sf=4,WM=[.125,.215,.35,.446,.526,.582],Zu=20,mS=new DE,GM=new Kn;let gS=null,xS=0,vS=0;const Xu=(1+Math.sqrt(5))/2,Bh=1/Xu,HM=[new Ne(1,1,1),new Ne(-1,1,1),new Ne(1,1,-1),new Ne(-1,1,-1),new Ne(0,Xu,Bh),new Ne(0,Xu,-Bh),new Ne(Bh,0,Xu),new Ne(-Bh,0,Xu),new Ne(Xu,Bh,0),new Ne(-Xu,Bh,0)];class jM{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,i=100){gS=this._renderer.getRenderTarget(),xS=this._renderer.getActiveCubeFace(),vS=this._renderer.getActiveMipmapLevel(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,s,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=KM(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=qM(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(gS,xS,vS),e.scissorTest=!1,Zx(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===xf||e.mapping===vf?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),gS=this._renderer.getRenderTarget(),xS=this._renderer.getActiveCubeFace(),vS=this._renderer.getActiveMipmapLevel();const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:po,minFilter:po,generateMipmaps:!1,type:Rg,format:ta,colorSpace:yr,depthBuffer:!1},i=XM(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=XM(e,t,s);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=mee(r)),this._blurMaterial=gee(r,e,t)}return i}_compileMaterial(e){const t=new Mo(this._lodPlanes[0],e);this._renderer.compile(t,mS)}_sceneToCubeUV(e,t,s,i){const a=new Hr(90,1,t,s),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,d=u.autoClear,h=u.toneMapping;u.getClearColor(GM),u.toneMapping=Jc,u.autoClear=!1;const p=new qc({name:"PMREM.Background",side:xo,depthWrite:!1,depthTest:!1}),g=new Mo(new o0,p);let y=!1;const x=e.background;x?x.isColor&&(p.color.copy(x),e.background=null,y=!0):(p.color.copy(GM),y=!0);for(let v=0;v<6;v++){const b=v%3;b===0?(a.up.set(0,l[v],0),a.lookAt(c[v],0,0)):b===1?(a.up.set(0,0,l[v]),a.lookAt(0,c[v],0)):(a.up.set(0,l[v],0),a.lookAt(0,0,c[v]));const S=this._cubeSize;Zx(i,b*S,v>2?S:0,S,S),u.setRenderTarget(i),y&&u.render(g,a),u.render(e,a)}g.geometry.dispose(),g.material.dispose(),u.toneMapping=h,u.autoClear=d,e.background=x}_textureToCubeUV(e,t){const s=this._renderer,i=e.mapping===xf||e.mapping===vf;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=KM()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=qM());const r=i?this._cubemapMaterial:this._equirectMaterial,o=new Mo(this._lodPlanes[0],r),a=r.uniforms;a.envMap.value=e;const l=this._cubeSize;Zx(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(o,mS)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=HM[(i-1)%HM.length];this._blur(e,i-1,i,r,o)}t.autoClear=s}_blur(e,t,s,i,r){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,i,"latitudinal",r),this._halfBlur(o,e,s,s,i,"longitudinal",r)}_halfBlur(e,t,s,i,r,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,d=new Mo(this._lodPlanes[i],c),h=c.uniforms,p=this._sizeLods[s]-1,g=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*Zu-1),y=r/g,x=isFinite(r)?1+Math.floor(u*y):Zu;x>Zu&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Zu}`);const v=[];let b=0;for(let R=0;R<Zu;++R){const L=R/y,I=Math.exp(-L*L/2);v.push(I),R===0?b+=I:R<x&&(b+=2*I)}for(let R=0;R<v.length;R++)v[R]=v[R]/b;h.envMap.value=e.texture,h.samples.value=x,h.weights.value=v,h.latitudinal.value=o==="latitudinal",a&&(h.poleAxis.value=a);const{_lodMax:S}=this;h.dTheta.value=g,h.mipInt.value=S-s;const C=this._sizeLods[i],E=3*C*(i>S-sf?i-S+sf:0),k=4*(this._cubeSize-C);Zx(t,E,k,3*C,2*C),l.setRenderTarget(t),l.render(d,mS)}}function mee(n){const e=[],t=[],s=[];let i=n;const r=n-sf+1+WM.length;for(let o=0;o<r;o++){const a=Math.pow(2,i);t.push(a);let l=1/a;o>n-sf?l=WM[o-n+sf-1]:o===0&&(l=0),s.push(l);const c=1/(a-2),u=-c,d=1+c,h=[u,u,d,u,d,d,u,u,d,d,u,d],p=6,g=6,y=3,x=2,v=1,b=new Float32Array(y*g*p),S=new Float32Array(x*g*p),C=new Float32Array(v*g*p);for(let k=0;k<p;k++){const R=k%3*2/3-1,L=k>2?0:-1,I=[R,L,0,R+2/3,L,0,R+2/3,L+1,0,R,L,0,R+2/3,L+1,0,R,L+1,0];b.set(I,y*g*k),S.set(h,x*g*k);const T=[k,k,k,k,k,k];C.set(T,v*g*k)}const E=new Va;E.setAttribute("position",new Kr(b,y)),E.setAttribute("uv",new Kr(S,x)),E.setAttribute("faceIndex",new Kr(C,v)),e.push(E),i>sf&&i--}return{lodPlanes:e,sizeLods:t,sigmas:s}}function XM(n,e,t){const s=new yd(n,e,t);return s.texture.mapping=sy,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function Zx(n,e,t,s,i){n.viewport.set(e,t,s,i),n.scissor.set(e,t,s,i)}function gee(n,e,t){const s=new Float32Array(Zu),i=new Ne(0,1,0);return new wd({name:"SphericalGaussianBlur",defines:{n:Zu,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:LE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Qc,depthTest:!1,depthWrite:!1})}function qM(){return new wd({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:LE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Qc,depthTest:!1,depthWrite:!1})}function KM(){return new wd({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:LE(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Qc,depthTest:!1,depthWrite:!1})}function LE(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function xee(n){let e=new WeakMap,t=null;function s(a){if(a&&a.isTexture){const l=a.mapping,c=l===MC||l===NC,u=l===xf||l===vf;if(c||u)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let d=e.get(a);return t===null&&(t=new jM(n)),d=c?t.fromEquirectangular(a,d):t.fromCubemap(a,d),e.set(a,d),d.texture}else{if(e.has(a))return e.get(a).texture;{const d=a.image;if(c&&d&&d.height>0||u&&d&&i(d)){t===null&&(t=new jM(n));const h=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,h),a.addEventListener("dispose",r),h.texture}else return null}}}return a}function i(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function r(a){const l=a.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:o}}function vee(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let i;switch(s){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(s)}return e[s]=i,i}return{has:function(s){return t(s)!==null},init:function(s){s.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(s){const i=t(s);return i===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),i}}}function yee(n,e,t,s){const i={},r=new WeakMap;function o(d){const h=d.target;h.index!==null&&e.remove(h.index);for(const g in h.attributes)e.remove(h.attributes[g]);for(const g in h.morphAttributes){const y=h.morphAttributes[g];for(let x=0,v=y.length;x<v;x++)e.remove(y[x])}h.removeEventListener("dispose",o),delete i[h.id];const p=r.get(h);p&&(e.remove(p),r.delete(h)),s.releaseStatesOfGeometry(h),h.isInstancedBufferGeometry===!0&&delete h._maxInstanceCount,t.memory.geometries--}function a(d,h){return i[h.id]===!0||(h.addEventListener("dispose",o),i[h.id]=!0,t.memory.geometries++),h}function l(d){const h=d.attributes;for(const g in h)e.update(h[g],n.ARRAY_BUFFER);const p=d.morphAttributes;for(const g in p){const y=p[g];for(let x=0,v=y.length;x<v;x++)e.update(y[x],n.ARRAY_BUFFER)}}function c(d){const h=[],p=d.index,g=d.attributes.position;let y=0;if(p!==null){const b=p.array;y=p.version;for(let S=0,C=b.length;S<C;S+=3){const E=b[S+0],k=b[S+1],R=b[S+2];h.push(E,k,k,R,R,E)}}else if(g!==void 0){const b=g.array;y=g.version;for(let S=0,C=b.length/3-1;S<C;S+=3){const E=S+0,k=S+1,R=S+2;h.push(E,k,k,R,R,E)}}else return;const x=new(QF(h)?rO:iO)(h,1);x.version=y;const v=r.get(d);v&&e.remove(v),r.set(d,x)}function u(d){const h=r.get(d);if(h){const p=d.index;p!==null&&h.version<p.version&&c(d)}else c(d);return r.get(d)}return{get:a,update:l,getWireframeAttribute:u}}function wee(n,e,t,s){const i=s.isWebGL2;let r;function o(h){r=h}let a,l;function c(h){a=h.type,l=h.bytesPerElement}function u(h,p){n.drawElements(r,p,a,h*l),t.update(p,r,1)}function d(h,p,g){if(g===0)return;let y,x;if(i)y=n,x="drawElementsInstanced";else if(y=e.get("ANGLE_instanced_arrays"),x="drawElementsInstancedANGLE",y===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}y[x](r,p,a,h*l,g),t.update(p,r,g)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=d}function bee(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(r,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(r/3);break;case n.LINES:t.lines+=a*(r/2);break;case n.LINE_STRIP:t.lines+=a*(r-1);break;case n.LINE_LOOP:t.lines+=a*r;break;case n.POINTS:t.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:s}}function See(n,e){return n[0]-e[0]}function Cee(n,e){return Math.abs(e[1])-Math.abs(n[1])}function _ee(n,e,t){const s={},i=new Float32Array(8),r=new WeakMap,o=new qs,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,u,d){const h=c.morphTargetInfluences;if(e.isWebGL2===!0){const g=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,y=g!==void 0?g.length:0;let x=r.get(u);if(x===void 0||x.count!==y){let X=function(){W.dispose(),r.delete(u),u.removeEventListener("dispose",X)};var p=X;x!==void 0&&x.texture.dispose();const S=u.morphAttributes.position!==void 0,C=u.morphAttributes.normal!==void 0,E=u.morphAttributes.color!==void 0,k=u.morphAttributes.position||[],R=u.morphAttributes.normal||[],L=u.morphAttributes.color||[];let I=0;S===!0&&(I=1),C===!0&&(I=2),E===!0&&(I=3);let T=u.attributes.position.count*I,M=1;T>e.maxTextureSize&&(M=Math.ceil(T/e.maxTextureSize),T=e.maxTextureSize);const j=new Float32Array(T*M*4*y),W=new tO(j,T,M,y);W.type=sc,W.needsUpdate=!0;const z=I*4;for(let B=0;B<y;B++){const J=k[B],K=R[B],ee=L[B],ne=T*M*4*B;for(let V=0;V<J.count;V++){const Z=V*z;S===!0&&(o.fromBufferAttribute(J,V),j[ne+Z+0]=o.x,j[ne+Z+1]=o.y,j[ne+Z+2]=o.z,j[ne+Z+3]=0),C===!0&&(o.fromBufferAttribute(K,V),j[ne+Z+4]=o.x,j[ne+Z+5]=o.y,j[ne+Z+6]=o.z,j[ne+Z+7]=0),E===!0&&(o.fromBufferAttribute(ee,V),j[ne+Z+8]=o.x,j[ne+Z+9]=o.y,j[ne+Z+10]=o.z,j[ne+Z+11]=ee.itemSize===4?o.w:1)}}x={count:y,texture:W,size:new Zn(T,M)},r.set(u,x),u.addEventListener("dispose",X)}let v=0;for(let S=0;S<h.length;S++)v+=h[S];const b=u.morphTargetsRelative?1:1-v;d.getUniforms().setValue(n,"morphTargetBaseInfluence",b),d.getUniforms().setValue(n,"morphTargetInfluences",h),d.getUniforms().setValue(n,"morphTargetsTexture",x.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",x.size)}else{const g=h===void 0?0:h.length;let y=s[u.id];if(y===void 0||y.length!==g){y=[];for(let C=0;C<g;C++)y[C]=[C,0];s[u.id]=y}for(let C=0;C<g;C++){const E=y[C];E[0]=C,E[1]=h[C]}y.sort(Cee);for(let C=0;C<8;C++)C<g&&y[C][1]?(a[C][0]=y[C][0],a[C][1]=y[C][1]):(a[C][0]=Number.MAX_SAFE_INTEGER,a[C][1]=0);a.sort(See);const x=u.morphAttributes.position,v=u.morphAttributes.normal;let b=0;for(let C=0;C<8;C++){const E=a[C],k=E[0],R=E[1];k!==Number.MAX_SAFE_INTEGER&&R?(x&&u.getAttribute("morphTarget"+C)!==x[k]&&u.setAttribute("morphTarget"+C,x[k]),v&&u.getAttribute("morphNormal"+C)!==v[k]&&u.setAttribute("morphNormal"+C,v[k]),i[C]=R,b+=R):(x&&u.hasAttribute("morphTarget"+C)===!0&&u.deleteAttribute("morphTarget"+C),v&&u.hasAttribute("morphNormal"+C)===!0&&u.deleteAttribute("morphNormal"+C),i[C]=0)}const S=u.morphTargetsRelative?1:1-b;d.getUniforms().setValue(n,"morphTargetBaseInfluence",S),d.getUniforms().setValue(n,"morphTargetInfluences",i)}}return{update:l}}function Eee(n,e,t,s){let i=new WeakMap;function r(l){const c=s.render.frame,u=l.geometry,d=e.get(l,u);if(i.get(d)!==c&&(e.update(d),i.set(d,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),i.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const h=l.skeleton;i.get(h)!==c&&(h.update(),i.set(h,c))}return d}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:o}}const uO=new vr,dO=new tO,hO=new dZ,fO=new lO,YM=[],ZM=[],QM=new Float32Array(16),JM=new Float32Array(9),eN=new Float32Array(4);function Hf(n,e,t){const s=n[0];if(s<=0||s>0)return n;const i=e*t;let r=YM[i];if(r===void 0&&(r=new Float32Array(i),YM[i]=r),e!==0){s.toArray(r,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(r,a)}return r}function Yi(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function Zi(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function ay(n,e){let t=ZM[e];t===void 0&&(t=new Int32Array(e),ZM[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function Tee(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function Iee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2fv(this.addr,e),Zi(t,e)}}function kee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Yi(t,e))return;n.uniform3fv(this.addr,e),Zi(t,e)}}function Aee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4fv(this.addr,e),Zi(t,e)}}function Ree(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Yi(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,s))return;eN.set(s),n.uniformMatrix2fv(this.addr,!1,eN),Zi(t,s)}}function Mee(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Yi(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,s))return;JM.set(s),n.uniformMatrix3fv(this.addr,!1,JM),Zi(t,s)}}function Nee(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Yi(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,s))return;QM.set(s),n.uniformMatrix4fv(this.addr,!1,QM),Zi(t,s)}}function Pee(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function Dee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2iv(this.addr,e),Zi(t,e)}}function Lee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yi(t,e))return;n.uniform3iv(this.addr,e),Zi(t,e)}}function $ee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4iv(this.addr,e),Zi(t,e)}}function Fee(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function Oee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2uiv(this.addr,e),Zi(t,e)}}function zee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yi(t,e))return;n.uniform3uiv(this.addr,e),Zi(t,e)}}function Bee(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4uiv(this.addr,e),Zi(t,e)}}function Uee(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2D(e||uO,i)}function Vee(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture3D(e||hO,i)}function Wee(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTextureCube(e||fO,i)}function Gee(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2DArray(e||dO,i)}function Hee(n){switch(n){case 5126:return Tee;case 35664:return Iee;case 35665:return kee;case 35666:return Aee;case 35674:return Ree;case 35675:return Mee;case 35676:return Nee;case 5124:case 35670:return Pee;case 35667:case 35671:return Dee;case 35668:case 35672:return Lee;case 35669:case 35673:return $ee;case 5125:return Fee;case 36294:return Oee;case 36295:return zee;case 36296:return Bee;case 35678:case 36198:case 36298:case 36306:case 35682:return Uee;case 35679:case 36299:case 36307:return Vee;case 35680:case 36300:case 36308:case 36293:return Wee;case 36289:case 36303:case 36311:case 36292:return Gee}}function jee(n,e){n.uniform1fv(this.addr,e)}function Xee(n,e){const t=Hf(e,this.size,2);n.uniform2fv(this.addr,t)}function qee(n,e){const t=Hf(e,this.size,3);n.uniform3fv(this.addr,t)}function Kee(n,e){const t=Hf(e,this.size,4);n.uniform4fv(this.addr,t)}function Yee(n,e){const t=Hf(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Zee(n,e){const t=Hf(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function Qee(n,e){const t=Hf(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function Jee(n,e){n.uniform1iv(this.addr,e)}function ete(n,e){n.uniform2iv(this.addr,e)}function tte(n,e){n.uniform3iv(this.addr,e)}function nte(n,e){n.uniform4iv(this.addr,e)}function ste(n,e){n.uniform1uiv(this.addr,e)}function ite(n,e){n.uniform2uiv(this.addr,e)}function rte(n,e){n.uniform3uiv(this.addr,e)}function ote(n,e){n.uniform4uiv(this.addr,e)}function ate(n,e,t){const s=this.cache,i=e.length,r=ay(t,i);Yi(s,r)||(n.uniform1iv(this.addr,r),Zi(s,r));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||uO,r[o])}function lte(n,e,t){const s=this.cache,i=e.length,r=ay(t,i);Yi(s,r)||(n.uniform1iv(this.addr,r),Zi(s,r));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||hO,r[o])}function cte(n,e,t){const s=this.cache,i=e.length,r=ay(t,i);Yi(s,r)||(n.uniform1iv(this.addr,r),Zi(s,r));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||fO,r[o])}function ute(n,e,t){const s=this.cache,i=e.length,r=ay(t,i);Yi(s,r)||(n.uniform1iv(this.addr,r),Zi(s,r));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||dO,r[o])}function dte(n){switch(n){case 5126:return jee;case 35664:return Xee;case 35665:return qee;case 35666:return Kee;case 35674:return Yee;case 35675:return Zee;case 35676:return Qee;case 5124:case 35670:return Jee;case 35667:case 35671:return ete;case 35668:case 35672:return tte;case 35669:case 35673:return nte;case 5125:return ste;case 36294:return ite;case 36295:return rte;case 36296:return ote;case 35678:case 36198:case 36298:case 36306:case 35682:return ate;case 35679:case 36299:case 36307:return lte;case 35680:case 36300:case 36308:case 36293:return cte;case 36289:case 36303:case 36311:case 36292:return ute}}class hte{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.setValue=Hee(t.type)}}class fte{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.size=t.size,this.setValue=dte(t.type)}}class pte{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const i=this.seq;for(let r=0,o=i.length;r!==o;++r){const a=i[r];a.setValue(e,t[a.id],s)}}}const yS=/(\w+)(\])?(\[|\.)?/g;function tN(n,e){n.seq.push(e),n.map[e.id]=e}function mte(n,e,t){const s=n.name,i=s.length;for(yS.lastIndex=0;;){const r=yS.exec(s),o=yS.lastIndex;let a=r[1];const l=r[2]==="]",c=r[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){tN(t,c===void 0?new hte(a,n,e):new fte(a,n,e));break}else{let d=t.map[a];d===void 0&&(d=new pte(a),tN(t,d)),t=d}}}class Dv{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<s;++i){const r=e.getActiveUniform(t,i),o=e.getUniformLocation(t,r.name);mte(r,o,this)}}setValue(e,t,s,i){const r=this.map[t];r!==void 0&&r.setValue(e,s,i)}setOptional(e,t,s){const i=t[s];i!==void 0&&this.setValue(e,s,i)}static upload(e,t,s,i){for(let r=0,o=t.length;r!==o;++r){const a=t[r],l=s[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,i)}}static seqWithValue(e,t){const s=[];for(let i=0,r=e.length;i!==r;++i){const o=e[i];o.id in t&&s.push(o)}return s}}function nN(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}const gte=37297;let xte=0;function vte(n,e){const t=n.split(`
`),s=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let o=i;o<r;o++){const a=o+1;s.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return s.join(`
`)}function yte(n){const e=Ps.getPrimaries(Ps.workingColorSpace),t=Ps.getPrimaries(n);let s;switch(e===t?s="":e===a2&&t===o2?s="LinearDisplayP3ToLinearSRGB":e===o2&&t===a2&&(s="LinearSRGBToLinearDisplayP3"),n){case yr:case iy:return[s,"LinearTransferOETF"];case hi:case ME:return[s,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[s,"LinearTransferOETF"]}}function sN(n,e,t){const s=n.getShaderParameter(e,n.COMPILE_STATUS),i=n.getShaderInfoLog(e).trim();if(s&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const o=parseInt(r[1]);return t.toUpperCase()+`

`+i+`

`+vte(n.getShaderSource(e),o)}else return i}function wte(n,e){const t=yte(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function bte(n,e){let t;switch(e){case yY:t="Linear";break;case wY:t="Reinhard";break;case bY:t="OptimizedCineon";break;case SY:t="ACESFilmic";break;case CY:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Ste(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ng).join(`
`)}function Cte(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function _te(n,e){const t={},s=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let i=0;i<s;i++){const r=n.getActiveAttrib(e,i),o=r.name;let a=1;r.type===n.FLOAT_MAT2&&(a=2),r.type===n.FLOAT_MAT3&&(a=3),r.type===n.FLOAT_MAT4&&(a=4),t[o]={type:r.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function ng(n){return n!==""}function iN(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function rN(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Ete=/^[ \t]*#include +<([\w\d./]+)>/gm;function OC(n){return n.replace(Ete,Ite)}const Tte=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function Ite(n,e){let t=is[e];if(t===void 0){const s=Tte.get(e);if(s!==void 0)t=is[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return OC(t)}const kte=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function oN(n){return n.replace(kte,Ate)}function Ate(n,e,t,s){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=s.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function aN(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Rte(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===$F?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===FF?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===ec&&(e="SHADOWMAP_TYPE_VSM"),e}function Mte(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case xf:case vf:e="ENVMAP_TYPE_CUBE";break;case sy:e="ENVMAP_TYPE_CUBE_UV";break}return e}function Nte(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case vf:e="ENVMAP_MODE_REFRACTION";break}return e}function Pte(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case OF:e="ENVMAP_BLENDING_MULTIPLY";break;case xY:e="ENVMAP_BLENDING_MIX";break;case vY:e="ENVMAP_BLENDING_ADD";break}return e}function Dte(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:s,maxMip:t}}function Lte(n,e,t,s){const i=n.getContext(),r=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=Rte(t),c=Mte(t),u=Nte(t),d=Pte(t),h=Dte(t),p=t.isWebGL2?"":Ste(t),g=Cte(r),y=i.createProgram();let x,v,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(x=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g].filter(ng).join(`
`),x.length>0&&(x+=`
`),v=[p,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g].filter(ng).join(`
`),v.length>0&&(v+=`
`)):(x=[aN(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(ng).join(`
`),v=[p,aN(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+d:"",h?"#define CUBEUV_TEXEL_WIDTH "+h.texelWidth:"",h?"#define CUBEUV_TEXEL_HEIGHT "+h.texelHeight:"",h?"#define CUBEUV_MAX_MIP "+h.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Jc?"#define TONE_MAPPING":"",t.toneMapping!==Jc?is.tonemapping_pars_fragment:"",t.toneMapping!==Jc?bte("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",is.colorspace_pars_fragment,wte("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(ng).join(`
`)),o=OC(o),o=iN(o,t),o=rN(o,t),a=OC(a),a=iN(a,t),a=rN(a,t),o=oN(o),a=oN(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,x=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+x,v=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===EM?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===EM?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);const S=b+x+o,C=b+v+a,E=nN(i,i.VERTEX_SHADER,S),k=nN(i,i.FRAGMENT_SHADER,C);i.attachShader(y,E),i.attachShader(y,k),t.index0AttributeName!==void 0?i.bindAttribLocation(y,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(y,0,"position"),i.linkProgram(y);function R(M){if(n.debug.checkShaderErrors){const j=i.getProgramInfoLog(y).trim(),W=i.getShaderInfoLog(E).trim(),z=i.getShaderInfoLog(k).trim();let X=!0,B=!0;if(i.getProgramParameter(y,i.LINK_STATUS)===!1)if(X=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,y,E,k);else{const J=sN(i,E,"vertex"),K=sN(i,k,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(y,i.VALIDATE_STATUS)+`

Program Info Log: `+j+`
`+J+`
`+K)}else j!==""?console.warn("THREE.WebGLProgram: Program Info Log:",j):(W===""||z==="")&&(B=!1);B&&(M.diagnostics={runnable:X,programLog:j,vertexShader:{log:W,prefix:x},fragmentShader:{log:z,prefix:v}})}i.deleteShader(E),i.deleteShader(k),L=new Dv(i,y),I=_te(i,y)}let L;this.getUniforms=function(){return L===void 0&&R(this),L};let I;this.getAttributes=function(){return I===void 0&&R(this),I};let T=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return T===!1&&(T=i.getProgramParameter(y,gte)),T},this.destroy=function(){s.releaseStatesOfProgram(this),i.deleteProgram(y),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=xte++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=E,this.fragmentShader=k,this}let $te=0;class Fte{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(s),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new Ote(e),t.set(e,s)),s}}class Ote{constructor(e){this.id=$te++,this.code=e,this.usedTimes=0}}function zte(n,e,t,s,i,r,o){const a=new nO,l=new Fte,c=[],u=i.isWebGL2,d=i.logarithmicDepthBuffer,h=i.vertexTextures;let p=i.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function y(I){return I===0?"uv":`uv${I}`}function x(I,T,M,j,W){const z=j.fog,X=W.geometry,B=I.isMeshStandardMaterial?j.environment:null,J=(I.isMeshStandardMaterial?t:e).get(I.envMap||B),K=J&&J.mapping===sy?J.image.height:null,ee=g[I.type];I.precision!==null&&(p=i.getMaxPrecision(I.precision),p!==I.precision&&console.warn("THREE.WebGLProgram.getParameters:",I.precision,"not supported, using",p,"instead."));const ne=X.morphAttributes.position||X.morphAttributes.normal||X.morphAttributes.color,V=ne!==void 0?ne.length:0;let Z=0;X.morphAttributes.position!==void 0&&(Z=1),X.morphAttributes.normal!==void 0&&(Z=2),X.morphAttributes.color!==void 0&&(Z=3);let he,ve,be,Ie;if(ee){const zn=sl[ee];he=zn.vertexShader,ve=zn.fragmentShader}else he=I.vertexShader,ve=I.fragmentShader,l.update(I),be=l.getVertexShaderID(I),Ie=l.getFragmentShaderID(I);const Xe=n.getRenderTarget(),Fe=W.isInstancedMesh===!0,Pe=!!I.map,ct=!!I.matcap,at=!!J,Ee=!!I.aoMap,nn=!!I.lightMap,gt=!!I.bumpMap,vt=!!I.normalMap,wt=!!I.displacementMap,Vt=!!I.emissiveMap,It=!!I.metalnessMap,zt=!!I.roughnessMap,Gt=I.anisotropy>0,dn=I.clearcoat>0,vn=I.iridescence>0,ce=I.sheen>0,Y=I.transmission>0,ye=Gt&&!!I.anisotropyMap,Qe=dn&&!!I.clearcoatMap,tt=dn&&!!I.clearcoatNormalMap,rt=dn&&!!I.clearcoatRoughnessMap,Pt=vn&&!!I.iridescenceMap,pt=vn&&!!I.iridescenceThicknessMap,At=ce&&!!I.sheenColorMap,xe=ce&&!!I.sheenRoughnessMap,xt=!!I.specularMap,Ye=!!I.specularColorMap,kt=!!I.specularIntensityMap,Et=Y&&!!I.transmissionMap,bt=Y&&!!I.thicknessMap,Wt=!!I.gradientMap,ht=!!I.alphaMap,Ht=I.alphaTest>0,Ce=!!I.alphaHash,St=!!I.extensions,dt=!!X.attributes.uv1,Be=!!X.attributes.uv2,Rt=!!X.attributes.uv3;let rn=Jc;return I.toneMapped&&(Xe===null||Xe.isXRRenderTarget===!0)&&(rn=n.toneMapping),{isWebGL2:u,shaderID:ee,shaderType:I.type,shaderName:I.name,vertexShader:he,fragmentShader:ve,defines:I.defines,customVertexShaderID:be,customFragmentShaderID:Ie,isRawShaderMaterial:I.isRawShaderMaterial===!0,glslVersion:I.glslVersion,precision:p,instancing:Fe,instancingColor:Fe&&W.instanceColor!==null,supportsVertexTextures:h,outputColorSpace:Xe===null?n.outputColorSpace:Xe.isXRRenderTarget===!0?Xe.texture.colorSpace:yr,map:Pe,matcap:ct,envMap:at,envMapMode:at&&J.mapping,envMapCubeUVHeight:K,aoMap:Ee,lightMap:nn,bumpMap:gt,normalMap:vt,displacementMap:h&&wt,emissiveMap:Vt,normalMapObjectSpace:vt&&I.normalMapType===OY,normalMapTangentSpace:vt&&I.normalMapType===KF,metalnessMap:It,roughnessMap:zt,anisotropy:Gt,anisotropyMap:ye,clearcoat:dn,clearcoatMap:Qe,clearcoatNormalMap:tt,clearcoatRoughnessMap:rt,iridescence:vn,iridescenceMap:Pt,iridescenceThicknessMap:pt,sheen:ce,sheenColorMap:At,sheenRoughnessMap:xe,specularMap:xt,specularColorMap:Ye,specularIntensityMap:kt,transmission:Y,transmissionMap:Et,thicknessMap:bt,gradientMap:Wt,opaque:I.transparent===!1&&I.blending===of,alphaMap:ht,alphaTest:Ht,alphaHash:Ce,combine:I.combine,mapUv:Pe&&y(I.map.channel),aoMapUv:Ee&&y(I.aoMap.channel),lightMapUv:nn&&y(I.lightMap.channel),bumpMapUv:gt&&y(I.bumpMap.channel),normalMapUv:vt&&y(I.normalMap.channel),displacementMapUv:wt&&y(I.displacementMap.channel),emissiveMapUv:Vt&&y(I.emissiveMap.channel),metalnessMapUv:It&&y(I.metalnessMap.channel),roughnessMapUv:zt&&y(I.roughnessMap.channel),anisotropyMapUv:ye&&y(I.anisotropyMap.channel),clearcoatMapUv:Qe&&y(I.clearcoatMap.channel),clearcoatNormalMapUv:tt&&y(I.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:rt&&y(I.clearcoatRoughnessMap.channel),iridescenceMapUv:Pt&&y(I.iridescenceMap.channel),iridescenceThicknessMapUv:pt&&y(I.iridescenceThicknessMap.channel),sheenColorMapUv:At&&y(I.sheenColorMap.channel),sheenRoughnessMapUv:xe&&y(I.sheenRoughnessMap.channel),specularMapUv:xt&&y(I.specularMap.channel),specularColorMapUv:Ye&&y(I.specularColorMap.channel),specularIntensityMapUv:kt&&y(I.specularIntensityMap.channel),transmissionMapUv:Et&&y(I.transmissionMap.channel),thicknessMapUv:bt&&y(I.thicknessMap.channel),alphaMapUv:ht&&y(I.alphaMap.channel),vertexTangents:!!X.attributes.tangent&&(vt||Gt),vertexColors:I.vertexColors,vertexAlphas:I.vertexColors===!0&&!!X.attributes.color&&X.attributes.color.itemSize===4,vertexUv1s:dt,vertexUv2s:Be,vertexUv3s:Rt,pointsUvs:W.isPoints===!0&&!!X.attributes.uv&&(Pe||ht),fog:!!z,useFog:I.fog===!0,fogExp2:z&&z.isFogExp2,flatShading:I.flatShading===!0,sizeAttenuation:I.sizeAttenuation===!0,logarithmicDepthBuffer:d,skinning:W.isSkinnedMesh===!0,morphTargets:X.morphAttributes.position!==void 0,morphNormals:X.morphAttributes.normal!==void 0,morphColors:X.morphAttributes.color!==void 0,morphTargetsCount:V,morphTextureStride:Z,numDirLights:T.directional.length,numPointLights:T.point.length,numSpotLights:T.spot.length,numSpotLightMaps:T.spotLightMap.length,numRectAreaLights:T.rectArea.length,numHemiLights:T.hemi.length,numDirLightShadows:T.directionalShadowMap.length,numPointLightShadows:T.pointShadowMap.length,numSpotLightShadows:T.spotShadowMap.length,numSpotLightShadowsWithMaps:T.numSpotLightShadowsWithMaps,numLightProbes:T.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:I.dithering,shadowMapEnabled:n.shadowMap.enabled&&M.length>0,shadowMapType:n.shadowMap.type,toneMapping:rn,useLegacyLights:n._useLegacyLights,decodeVideoTexture:Pe&&I.map.isVideoTexture===!0&&Ps.getTransfer(I.map.colorSpace)===si,premultipliedAlpha:I.premultipliedAlpha,doubleSided:I.side===al,flipSided:I.side===xo,useDepthPacking:I.depthPacking>=0,depthPacking:I.depthPacking||0,index0AttributeName:I.index0AttributeName,extensionDerivatives:St&&I.extensions.derivatives===!0,extensionFragDepth:St&&I.extensions.fragDepth===!0,extensionDrawBuffers:St&&I.extensions.drawBuffers===!0,extensionShaderTextureLOD:St&&I.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:u||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||s.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:I.customProgramCacheKey()}}function v(I){const T=[];if(I.shaderID?T.push(I.shaderID):(T.push(I.customVertexShaderID),T.push(I.customFragmentShaderID)),I.defines!==void 0)for(const M in I.defines)T.push(M),T.push(I.defines[M]);return I.isRawShaderMaterial===!1&&(b(T,I),S(T,I),T.push(n.outputColorSpace)),T.push(I.customProgramCacheKey),T.join()}function b(I,T){I.push(T.precision),I.push(T.outputColorSpace),I.push(T.envMapMode),I.push(T.envMapCubeUVHeight),I.push(T.mapUv),I.push(T.alphaMapUv),I.push(T.lightMapUv),I.push(T.aoMapUv),I.push(T.bumpMapUv),I.push(T.normalMapUv),I.push(T.displacementMapUv),I.push(T.emissiveMapUv),I.push(T.metalnessMapUv),I.push(T.roughnessMapUv),I.push(T.anisotropyMapUv),I.push(T.clearcoatMapUv),I.push(T.clearcoatNormalMapUv),I.push(T.clearcoatRoughnessMapUv),I.push(T.iridescenceMapUv),I.push(T.iridescenceThicknessMapUv),I.push(T.sheenColorMapUv),I.push(T.sheenRoughnessMapUv),I.push(T.specularMapUv),I.push(T.specularColorMapUv),I.push(T.specularIntensityMapUv),I.push(T.transmissionMapUv),I.push(T.thicknessMapUv),I.push(T.combine),I.push(T.fogExp2),I.push(T.sizeAttenuation),I.push(T.morphTargetsCount),I.push(T.morphAttributeCount),I.push(T.numDirLights),I.push(T.numPointLights),I.push(T.numSpotLights),I.push(T.numSpotLightMaps),I.push(T.numHemiLights),I.push(T.numRectAreaLights),I.push(T.numDirLightShadows),I.push(T.numPointLightShadows),I.push(T.numSpotLightShadows),I.push(T.numSpotLightShadowsWithMaps),I.push(T.numLightProbes),I.push(T.shadowMapType),I.push(T.toneMapping),I.push(T.numClippingPlanes),I.push(T.numClipIntersection),I.push(T.depthPacking)}function S(I,T){a.disableAll(),T.isWebGL2&&a.enable(0),T.supportsVertexTextures&&a.enable(1),T.instancing&&a.enable(2),T.instancingColor&&a.enable(3),T.matcap&&a.enable(4),T.envMap&&a.enable(5),T.normalMapObjectSpace&&a.enable(6),T.normalMapTangentSpace&&a.enable(7),T.clearcoat&&a.enable(8),T.iridescence&&a.enable(9),T.alphaTest&&a.enable(10),T.vertexColors&&a.enable(11),T.vertexAlphas&&a.enable(12),T.vertexUv1s&&a.enable(13),T.vertexUv2s&&a.enable(14),T.vertexUv3s&&a.enable(15),T.vertexTangents&&a.enable(16),T.anisotropy&&a.enable(17),T.alphaHash&&a.enable(18),I.push(a.mask),a.disableAll(),T.fog&&a.enable(0),T.useFog&&a.enable(1),T.flatShading&&a.enable(2),T.logarithmicDepthBuffer&&a.enable(3),T.skinning&&a.enable(4),T.morphTargets&&a.enable(5),T.morphNormals&&a.enable(6),T.morphColors&&a.enable(7),T.premultipliedAlpha&&a.enable(8),T.shadowMapEnabled&&a.enable(9),T.useLegacyLights&&a.enable(10),T.doubleSided&&a.enable(11),T.flipSided&&a.enable(12),T.useDepthPacking&&a.enable(13),T.dithering&&a.enable(14),T.transmission&&a.enable(15),T.sheen&&a.enable(16),T.opaque&&a.enable(17),T.pointsUvs&&a.enable(18),T.decodeVideoTexture&&a.enable(19),I.push(a.mask)}function C(I){const T=g[I.type];let M;if(T){const j=sl[T];M=_Z.clone(j.uniforms)}else M=I.uniforms;return M}function E(I,T){let M;for(let j=0,W=c.length;j<W;j++){const z=c[j];if(z.cacheKey===T){M=z,++M.usedTimes;break}}return M===void 0&&(M=new Lte(n,T,I,r),c.push(M)),M}function k(I){if(--I.usedTimes===0){const T=c.indexOf(I);c[T]=c[c.length-1],c.pop(),I.destroy()}}function R(I){l.remove(I)}function L(){l.dispose()}return{getParameters:x,getProgramCacheKey:v,getUniforms:C,acquireProgram:E,releaseProgram:k,releaseShaderCache:R,programs:c,dispose:L}}function Bte(){let n=new WeakMap;function e(r){let o=n.get(r);return o===void 0&&(o={},n.set(r,o)),o}function t(r){n.delete(r)}function s(r,o,a){n.get(r)[o]=a}function i(){n=new WeakMap}return{get:e,remove:t,update:s,dispose:i}}function Ute(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function lN(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function cN(){const n=[];let e=0;const t=[],s=[],i=[];function r(){e=0,t.length=0,s.length=0,i.length=0}function o(d,h,p,g,y,x){let v=n[e];return v===void 0?(v={id:d.id,object:d,geometry:h,material:p,groupOrder:g,renderOrder:d.renderOrder,z:y,group:x},n[e]=v):(v.id=d.id,v.object=d,v.geometry=h,v.material=p,v.groupOrder=g,v.renderOrder=d.renderOrder,v.z=y,v.group=x),e++,v}function a(d,h,p,g,y,x){const v=o(d,h,p,g,y,x);p.transmission>0?s.push(v):p.transparent===!0?i.push(v):t.push(v)}function l(d,h,p,g,y,x){const v=o(d,h,p,g,y,x);p.transmission>0?s.unshift(v):p.transparent===!0?i.unshift(v):t.unshift(v)}function c(d,h){t.length>1&&t.sort(d||Ute),s.length>1&&s.sort(h||lN),i.length>1&&i.sort(h||lN)}function u(){for(let d=e,h=n.length;d<h;d++){const p=n[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:s,transparent:i,init:r,push:a,unshift:l,finish:u,sort:c}}function Vte(){let n=new WeakMap;function e(s,i){const r=n.get(s);let o;return r===void 0?(o=new cN,n.set(s,[o])):i>=r.length?(o=new cN,r.push(o)):o=r[i],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function Wte(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Ne,color:new Kn};break;case"SpotLight":t={position:new Ne,direction:new Ne,color:new Kn,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Ne,color:new Kn,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Ne,skyColor:new Kn,groundColor:new Kn};break;case"RectAreaLight":t={color:new Kn,position:new Ne,halfWidth:new Ne,halfHeight:new Ne};break}return n[e.id]=t,t}}}function Gte(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Zn};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Zn};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Zn,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let Hte=0;function jte(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function Xte(n,e){const t=new Wte,s=Gte(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let u=0;u<9;u++)i.probe.push(new Ne);const r=new Ne,o=new us,a=new us;function l(u,d){let h=0,p=0,g=0;for(let j=0;j<9;j++)i.probe[j].set(0,0,0);let y=0,x=0,v=0,b=0,S=0,C=0,E=0,k=0,R=0,L=0,I=0;u.sort(jte);const T=d===!0?Math.PI:1;for(let j=0,W=u.length;j<W;j++){const z=u[j],X=z.color,B=z.intensity,J=z.distance,K=z.shadow&&z.shadow.map?z.shadow.map.texture:null;if(z.isAmbientLight)h+=X.r*B*T,p+=X.g*B*T,g+=X.b*B*T;else if(z.isLightProbe){for(let ee=0;ee<9;ee++)i.probe[ee].addScaledVector(z.sh.coefficients[ee],B);I++}else if(z.isDirectionalLight){const ee=t.get(z);if(ee.color.copy(z.color).multiplyScalar(z.intensity*T),z.castShadow){const ne=z.shadow,V=s.get(z);V.shadowBias=ne.bias,V.shadowNormalBias=ne.normalBias,V.shadowRadius=ne.radius,V.shadowMapSize=ne.mapSize,i.directionalShadow[y]=V,i.directionalShadowMap[y]=K,i.directionalShadowMatrix[y]=z.shadow.matrix,C++}i.directional[y]=ee,y++}else if(z.isSpotLight){const ee=t.get(z);ee.position.setFromMatrixPosition(z.matrixWorld),ee.color.copy(X).multiplyScalar(B*T),ee.distance=J,ee.coneCos=Math.cos(z.angle),ee.penumbraCos=Math.cos(z.angle*(1-z.penumbra)),ee.decay=z.decay,i.spot[v]=ee;const ne=z.shadow;if(z.map&&(i.spotLightMap[R]=z.map,R++,ne.updateMatrices(z),z.castShadow&&L++),i.spotLightMatrix[v]=ne.matrix,z.castShadow){const V=s.get(z);V.shadowBias=ne.bias,V.shadowNormalBias=ne.normalBias,V.shadowRadius=ne.radius,V.shadowMapSize=ne.mapSize,i.spotShadow[v]=V,i.spotShadowMap[v]=K,k++}v++}else if(z.isRectAreaLight){const ee=t.get(z);ee.color.copy(X).multiplyScalar(B),ee.halfWidth.set(z.width*.5,0,0),ee.halfHeight.set(0,z.height*.5,0),i.rectArea[b]=ee,b++}else if(z.isPointLight){const ee=t.get(z);if(ee.color.copy(z.color).multiplyScalar(z.intensity*T),ee.distance=z.distance,ee.decay=z.decay,z.castShadow){const ne=z.shadow,V=s.get(z);V.shadowBias=ne.bias,V.shadowNormalBias=ne.normalBias,V.shadowRadius=ne.radius,V.shadowMapSize=ne.mapSize,V.shadowCameraNear=ne.camera.near,V.shadowCameraFar=ne.camera.far,i.pointShadow[x]=V,i.pointShadowMap[x]=K,i.pointShadowMatrix[x]=z.shadow.matrix,E++}i.point[x]=ee,x++}else if(z.isHemisphereLight){const ee=t.get(z);ee.skyColor.copy(z.color).multiplyScalar(B*T),ee.groundColor.copy(z.groundColor).multiplyScalar(B*T),i.hemi[S]=ee,S++}}b>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=Zt.LTC_FLOAT_1,i.rectAreaLTC2=Zt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=Zt.LTC_HALF_1,i.rectAreaLTC2=Zt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=h,i.ambient[1]=p,i.ambient[2]=g;const M=i.hash;(M.directionalLength!==y||M.pointLength!==x||M.spotLength!==v||M.rectAreaLength!==b||M.hemiLength!==S||M.numDirectionalShadows!==C||M.numPointShadows!==E||M.numSpotShadows!==k||M.numSpotMaps!==R||M.numLightProbes!==I)&&(i.directional.length=y,i.spot.length=v,i.rectArea.length=b,i.point.length=x,i.hemi.length=S,i.directionalShadow.length=C,i.directionalShadowMap.length=C,i.pointShadow.length=E,i.pointShadowMap.length=E,i.spotShadow.length=k,i.spotShadowMap.length=k,i.directionalShadowMatrix.length=C,i.pointShadowMatrix.length=E,i.spotLightMatrix.length=k+R-L,i.spotLightMap.length=R,i.numSpotLightShadowsWithMaps=L,i.numLightProbes=I,M.directionalLength=y,M.pointLength=x,M.spotLength=v,M.rectAreaLength=b,M.hemiLength=S,M.numDirectionalShadows=C,M.numPointShadows=E,M.numSpotShadows=k,M.numSpotMaps=R,M.numLightProbes=I,i.version=Hte++)}function c(u,d){let h=0,p=0,g=0,y=0,x=0;const v=d.matrixWorldInverse;for(let b=0,S=u.length;b<S;b++){const C=u[b];if(C.isDirectionalLight){const E=i.directional[h];E.direction.setFromMatrixPosition(C.matrixWorld),r.setFromMatrixPosition(C.target.matrixWorld),E.direction.sub(r),E.direction.transformDirection(v),h++}else if(C.isSpotLight){const E=i.spot[g];E.position.setFromMatrixPosition(C.matrixWorld),E.position.applyMatrix4(v),E.direction.setFromMatrixPosition(C.matrixWorld),r.setFromMatrixPosition(C.target.matrixWorld),E.direction.sub(r),E.direction.transformDirection(v),g++}else if(C.isRectAreaLight){const E=i.rectArea[y];E.position.setFromMatrixPosition(C.matrixWorld),E.position.applyMatrix4(v),a.identity(),o.copy(C.matrixWorld),o.premultiply(v),a.extractRotation(o),E.halfWidth.set(C.width*.5,0,0),E.halfHeight.set(0,C.height*.5,0),E.halfWidth.applyMatrix4(a),E.halfHeight.applyMatrix4(a),y++}else if(C.isPointLight){const E=i.point[p];E.position.setFromMatrixPosition(C.matrixWorld),E.position.applyMatrix4(v),p++}else if(C.isHemisphereLight){const E=i.hemi[x];E.direction.setFromMatrixPosition(C.matrixWorld),E.direction.transformDirection(v),x++}}}return{setup:l,setupView:c,state:i}}function uN(n,e){const t=new Xte(n,e),s=[],i=[];function r(){s.length=0,i.length=0}function o(d){s.push(d)}function a(d){i.push(d)}function l(d){t.setup(s,d)}function c(d){t.setupView(s,d)}return{init:r,state:{lightsArray:s,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function qte(n,e){let t=new WeakMap;function s(r,o=0){const a=t.get(r);let l;return a===void 0?(l=new uN(n,e),t.set(r,[l])):o>=a.length?(l=new uN(n,e),a.push(l)):l=a[o],l}function i(){t=new WeakMap}return{get:s,dispose:i}}class Kte extends ml{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=$Y,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class Yte extends ml{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const Zte=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Qte=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Jte(n,e,t){let s=new PE;const i=new Zn,r=new Zn,o=new qs,a=new Kte({depthPacking:FY}),l=new Yte,c={},u=t.maxTextureSize,d={[dc]:xo,[xo]:dc,[al]:al},h=new wd({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Zn},radius:{value:4}},vertexShader:Zte,fragmentShader:Qte}),p=h.clone();p.defines.HORIZONTAL_PASS=1;const g=new Va;g.setAttribute("position",new Kr(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const y=new Mo(g,h),x=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=$F;let v=this.type;this.render=function(E,k,R){if(x.enabled===!1||x.autoUpdate===!1&&x.needsUpdate===!1||E.length===0)return;const L=n.getRenderTarget(),I=n.getActiveCubeFace(),T=n.getActiveMipmapLevel(),M=n.state;M.setBlending(Qc),M.buffers.color.setClear(1,1,1,1),M.buffers.depth.setTest(!0),M.setScissorTest(!1);const j=v!==ec&&this.type===ec,W=v===ec&&this.type!==ec;for(let z=0,X=E.length;z<X;z++){const B=E[z],J=B.shadow;if(J===void 0){console.warn("THREE.WebGLShadowMap:",B,"has no shadow.");continue}if(J.autoUpdate===!1&&J.needsUpdate===!1)continue;i.copy(J.mapSize);const K=J.getFrameExtents();if(i.multiply(K),r.copy(J.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/K.x),i.x=r.x*K.x,J.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/K.y),i.y=r.y*K.y,J.mapSize.y=r.y)),J.map===null||j===!0||W===!0){const ne=this.type!==ec?{minFilter:ar,magFilter:ar}:{};J.map!==null&&J.map.dispose(),J.map=new yd(i.x,i.y,ne),J.map.texture.name=B.name+".shadowMap",J.camera.updateProjectionMatrix()}n.setRenderTarget(J.map),n.clear();const ee=J.getViewportCount();for(let ne=0;ne<ee;ne++){const V=J.getViewport(ne);o.set(r.x*V.x,r.y*V.y,r.x*V.z,r.y*V.w),M.viewport(o),J.updateMatrices(B,ne),s=J.getFrustum(),C(k,R,J.camera,B,this.type)}J.isPointLightShadow!==!0&&this.type===ec&&b(J,R),J.needsUpdate=!1}v=this.type,x.needsUpdate=!1,n.setRenderTarget(L,I,T)};function b(E,k){const R=e.update(y);h.defines.VSM_SAMPLES!==E.blurSamples&&(h.defines.VSM_SAMPLES=E.blurSamples,p.defines.VSM_SAMPLES=E.blurSamples,h.needsUpdate=!0,p.needsUpdate=!0),E.mapPass===null&&(E.mapPass=new yd(i.x,i.y)),h.uniforms.shadow_pass.value=E.map.texture,h.uniforms.resolution.value=E.mapSize,h.uniforms.radius.value=E.radius,n.setRenderTarget(E.mapPass),n.clear(),n.renderBufferDirect(k,null,R,h,y,null),p.uniforms.shadow_pass.value=E.mapPass.texture,p.uniforms.resolution.value=E.mapSize,p.uniforms.radius.value=E.radius,n.setRenderTarget(E.map),n.clear(),n.renderBufferDirect(k,null,R,p,y,null)}function S(E,k,R,L){let I=null;const T=R.isPointLight===!0?E.customDistanceMaterial:E.customDepthMaterial;if(T!==void 0)I=T;else if(I=R.isPointLight===!0?l:a,n.localClippingEnabled&&k.clipShadows===!0&&Array.isArray(k.clippingPlanes)&&k.clippingPlanes.length!==0||k.displacementMap&&k.displacementScale!==0||k.alphaMap&&k.alphaTest>0||k.map&&k.alphaTest>0){const M=I.uuid,j=k.uuid;let W=c[M];W===void 0&&(W={},c[M]=W);let z=W[j];z===void 0&&(z=I.clone(),W[j]=z),I=z}if(I.visible=k.visible,I.wireframe=k.wireframe,L===ec?I.side=k.shadowSide!==null?k.shadowSide:k.side:I.side=k.shadowSide!==null?k.shadowSide:d[k.side],I.alphaMap=k.alphaMap,I.alphaTest=k.alphaTest,I.map=k.map,I.clipShadows=k.clipShadows,I.clippingPlanes=k.clippingPlanes,I.clipIntersection=k.clipIntersection,I.displacementMap=k.displacementMap,I.displacementScale=k.displacementScale,I.displacementBias=k.displacementBias,I.wireframeLinewidth=k.wireframeLinewidth,I.linewidth=k.linewidth,R.isPointLight===!0&&I.isMeshDistanceMaterial===!0){const M=n.properties.get(I);M.light=R}return I}function C(E,k,R,L,I){if(E.visible===!1)return;if(E.layers.test(k.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&I===ec)&&(!E.frustumCulled||s.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse,E.matrixWorld);const j=e.update(E),W=E.material;if(Array.isArray(W)){const z=j.groups;for(let X=0,B=z.length;X<B;X++){const J=z[X],K=W[J.materialIndex];if(K&&K.visible){const ee=S(E,K,L,I);n.renderBufferDirect(R,null,j,ee,E,J)}}}else if(W.visible){const z=S(E,W,L,I);n.renderBufferDirect(R,null,j,z,E,null)}}const M=E.children;for(let j=0,W=M.length;j<W;j++)C(M[j],k,R,L,I)}}function ene(n,e,t){const s=t.isWebGL2;function i(){let Ce=!1;const St=new qs;let dt=null;const Be=new qs(0,0,0,0);return{setMask:function(Rt){dt!==Rt&&!Ce&&(n.colorMask(Rt,Rt,Rt,Rt),dt=Rt)},setLocked:function(Rt){Ce=Rt},setClear:function(Rt,rn,In,zn,_s){_s===!0&&(Rt*=zn,rn*=zn,In*=zn),St.set(Rt,rn,In,zn),Be.equals(St)===!1&&(n.clearColor(Rt,rn,In,zn),Be.copy(St))},reset:function(){Ce=!1,dt=null,Be.set(-1,0,0,0)}}}function r(){let Ce=!1,St=null,dt=null,Be=null;return{setTest:function(Rt){Rt?Pe(n.DEPTH_TEST):ct(n.DEPTH_TEST)},setMask:function(Rt){St!==Rt&&!Ce&&(n.depthMask(Rt),St=Rt)},setFunc:function(Rt){if(dt!==Rt){switch(Rt){case uY:n.depthFunc(n.NEVER);break;case dY:n.depthFunc(n.ALWAYS);break;case hY:n.depthFunc(n.LESS);break;case s2:n.depthFunc(n.LEQUAL);break;case fY:n.depthFunc(n.EQUAL);break;case pY:n.depthFunc(n.GEQUAL);break;case mY:n.depthFunc(n.GREATER);break;case gY:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}dt=Rt}},setLocked:function(Rt){Ce=Rt},setClear:function(Rt){Be!==Rt&&(n.clearDepth(Rt),Be=Rt)},reset:function(){Ce=!1,St=null,dt=null,Be=null}}}function o(){let Ce=!1,St=null,dt=null,Be=null,Rt=null,rn=null,In=null,zn=null,_s=null;return{setTest:function(ns){Ce||(ns?Pe(n.STENCIL_TEST):ct(n.STENCIL_TEST))},setMask:function(ns){St!==ns&&!Ce&&(n.stencilMask(ns),St=ns)},setFunc:function(ns,hs,Ls){(dt!==ns||Be!==hs||Rt!==Ls)&&(n.stencilFunc(ns,hs,Ls),dt=ns,Be=hs,Rt=Ls)},setOp:function(ns,hs,Ls){(rn!==ns||In!==hs||zn!==Ls)&&(n.stencilOp(ns,hs,Ls),rn=ns,In=hs,zn=Ls)},setLocked:function(ns){Ce=ns},setClear:function(ns){_s!==ns&&(n.clearStencil(ns),_s=ns)},reset:function(){Ce=!1,St=null,dt=null,Be=null,Rt=null,rn=null,In=null,zn=null,_s=null}}}const a=new i,l=new r,c=new o,u=new WeakMap,d=new WeakMap;let h={},p={},g=new WeakMap,y=[],x=null,v=!1,b=null,S=null,C=null,E=null,k=null,R=null,L=null,I=new Kn(0,0,0),T=0,M=!1,j=null,W=null,z=null,X=null,B=null;const J=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let K=!1,ee=0;const ne=n.getParameter(n.VERSION);ne.indexOf("WebGL")!==-1?(ee=parseFloat(/^WebGL (\d)/.exec(ne)[1]),K=ee>=1):ne.indexOf("OpenGL ES")!==-1&&(ee=parseFloat(/^OpenGL ES (\d)/.exec(ne)[1]),K=ee>=2);let V=null,Z={};const he=n.getParameter(n.SCISSOR_BOX),ve=n.getParameter(n.VIEWPORT),be=new qs().fromArray(he),Ie=new qs().fromArray(ve);function Xe(Ce,St,dt,Be){const Rt=new Uint8Array(4),rn=n.createTexture();n.bindTexture(Ce,rn),n.texParameteri(Ce,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(Ce,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let In=0;In<dt;In++)s&&(Ce===n.TEXTURE_3D||Ce===n.TEXTURE_2D_ARRAY)?n.texImage3D(St,0,n.RGBA,1,1,Be,0,n.RGBA,n.UNSIGNED_BYTE,Rt):n.texImage2D(St+In,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,Rt);return rn}const Fe={};Fe[n.TEXTURE_2D]=Xe(n.TEXTURE_2D,n.TEXTURE_2D,1),Fe[n.TEXTURE_CUBE_MAP]=Xe(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),s&&(Fe[n.TEXTURE_2D_ARRAY]=Xe(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),Fe[n.TEXTURE_3D]=Xe(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),Pe(n.DEPTH_TEST),l.setFunc(s2),It(!1),zt(WR),Pe(n.CULL_FACE),wt(Qc);function Pe(Ce){h[Ce]!==!0&&(n.enable(Ce),h[Ce]=!0)}function ct(Ce){h[Ce]!==!1&&(n.disable(Ce),h[Ce]=!1)}function at(Ce,St){return p[Ce]!==St?(n.bindFramebuffer(Ce,St),p[Ce]=St,s&&(Ce===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=St),Ce===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=St)),!0):!1}function Ee(Ce,St){let dt=y,Be=!1;if(Ce)if(dt=g.get(St),dt===void 0&&(dt=[],g.set(St,dt)),Ce.isWebGLMultipleRenderTargets){const Rt=Ce.texture;if(dt.length!==Rt.length||dt[0]!==n.COLOR_ATTACHMENT0){for(let rn=0,In=Rt.length;rn<In;rn++)dt[rn]=n.COLOR_ATTACHMENT0+rn;dt.length=Rt.length,Be=!0}}else dt[0]!==n.COLOR_ATTACHMENT0&&(dt[0]=n.COLOR_ATTACHMENT0,Be=!0);else dt[0]!==n.BACK&&(dt[0]=n.BACK,Be=!0);Be&&(t.isWebGL2?n.drawBuffers(dt):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(dt))}function nn(Ce){return x!==Ce?(n.useProgram(Ce),x=Ce,!0):!1}const gt={[Yu]:n.FUNC_ADD,[KK]:n.FUNC_SUBTRACT,[YK]:n.FUNC_REVERSE_SUBTRACT};if(s)gt[XR]=n.MIN,gt[qR]=n.MAX;else{const Ce=e.get("EXT_blend_minmax");Ce!==null&&(gt[XR]=Ce.MIN_EXT,gt[qR]=Ce.MAX_EXT)}const vt={[ZK]:n.ZERO,[QK]:n.ONE,[JK]:n.SRC_COLOR,[AC]:n.SRC_ALPHA,[rY]:n.SRC_ALPHA_SATURATE,[sY]:n.DST_COLOR,[tY]:n.DST_ALPHA,[eY]:n.ONE_MINUS_SRC_COLOR,[RC]:n.ONE_MINUS_SRC_ALPHA,[iY]:n.ONE_MINUS_DST_COLOR,[nY]:n.ONE_MINUS_DST_ALPHA,[oY]:n.CONSTANT_COLOR,[aY]:n.ONE_MINUS_CONSTANT_COLOR,[lY]:n.CONSTANT_ALPHA,[cY]:n.ONE_MINUS_CONSTANT_ALPHA};function wt(Ce,St,dt,Be,Rt,rn,In,zn,_s,ns){if(Ce===Qc){v===!0&&(ct(n.BLEND),v=!1);return}if(v===!1&&(Pe(n.BLEND),v=!0),Ce!==qK){if(Ce!==b||ns!==M){if((S!==Yu||k!==Yu)&&(n.blendEquation(n.FUNC_ADD),S=Yu,k=Yu),ns)switch(Ce){case of:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case GR:n.blendFunc(n.ONE,n.ONE);break;case HR:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case jR:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",Ce);break}else switch(Ce){case of:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case GR:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case HR:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case jR:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",Ce);break}C=null,E=null,R=null,L=null,I.set(0,0,0),T=0,b=Ce,M=ns}return}Rt=Rt||St,rn=rn||dt,In=In||Be,(St!==S||Rt!==k)&&(n.blendEquationSeparate(gt[St],gt[Rt]),S=St,k=Rt),(dt!==C||Be!==E||rn!==R||In!==L)&&(n.blendFuncSeparate(vt[dt],vt[Be],vt[rn],vt[In]),C=dt,E=Be,R=rn,L=In),(zn.equals(I)===!1||_s!==T)&&(n.blendColor(zn.r,zn.g,zn.b,_s),I.copy(zn),T=_s),b=Ce,M=!1}function Vt(Ce,St){Ce.side===al?ct(n.CULL_FACE):Pe(n.CULL_FACE);let dt=Ce.side===xo;St&&(dt=!dt),It(dt),Ce.blending===of&&Ce.transparent===!1?wt(Qc):wt(Ce.blending,Ce.blendEquation,Ce.blendSrc,Ce.blendDst,Ce.blendEquationAlpha,Ce.blendSrcAlpha,Ce.blendDstAlpha,Ce.blendColor,Ce.blendAlpha,Ce.premultipliedAlpha),l.setFunc(Ce.depthFunc),l.setTest(Ce.depthTest),l.setMask(Ce.depthWrite),a.setMask(Ce.colorWrite);const Be=Ce.stencilWrite;c.setTest(Be),Be&&(c.setMask(Ce.stencilWriteMask),c.setFunc(Ce.stencilFunc,Ce.stencilRef,Ce.stencilFuncMask),c.setOp(Ce.stencilFail,Ce.stencilZFail,Ce.stencilZPass)),dn(Ce.polygonOffset,Ce.polygonOffsetFactor,Ce.polygonOffsetUnits),Ce.alphaToCoverage===!0?Pe(n.SAMPLE_ALPHA_TO_COVERAGE):ct(n.SAMPLE_ALPHA_TO_COVERAGE)}function It(Ce){j!==Ce&&(Ce?n.frontFace(n.CW):n.frontFace(n.CCW),j=Ce)}function zt(Ce){Ce!==jK?(Pe(n.CULL_FACE),Ce!==W&&(Ce===WR?n.cullFace(n.BACK):Ce===XK?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):ct(n.CULL_FACE),W=Ce}function Gt(Ce){Ce!==z&&(K&&n.lineWidth(Ce),z=Ce)}function dn(Ce,St,dt){Ce?(Pe(n.POLYGON_OFFSET_FILL),(X!==St||B!==dt)&&(n.polygonOffset(St,dt),X=St,B=dt)):ct(n.POLYGON_OFFSET_FILL)}function vn(Ce){Ce?Pe(n.SCISSOR_TEST):ct(n.SCISSOR_TEST)}function ce(Ce){Ce===void 0&&(Ce=n.TEXTURE0+J-1),V!==Ce&&(n.activeTexture(Ce),V=Ce)}function Y(Ce,St,dt){dt===void 0&&(V===null?dt=n.TEXTURE0+J-1:dt=V);let Be=Z[dt];Be===void 0&&(Be={type:void 0,texture:void 0},Z[dt]=Be),(Be.type!==Ce||Be.texture!==St)&&(V!==dt&&(n.activeTexture(dt),V=dt),n.bindTexture(Ce,St||Fe[Ce]),Be.type=Ce,Be.texture=St)}function ye(){const Ce=Z[V];Ce!==void 0&&Ce.type!==void 0&&(n.bindTexture(Ce.type,null),Ce.type=void 0,Ce.texture=void 0)}function Qe(){try{n.compressedTexImage2D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function tt(){try{n.compressedTexImage3D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function rt(){try{n.texSubImage2D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function Pt(){try{n.texSubImage3D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function pt(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function At(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function xe(){try{n.texStorage2D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function xt(){try{n.texStorage3D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function Ye(){try{n.texImage2D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function kt(){try{n.texImage3D.apply(n,arguments)}catch(Ce){console.error("THREE.WebGLState:",Ce)}}function Et(Ce){be.equals(Ce)===!1&&(n.scissor(Ce.x,Ce.y,Ce.z,Ce.w),be.copy(Ce))}function bt(Ce){Ie.equals(Ce)===!1&&(n.viewport(Ce.x,Ce.y,Ce.z,Ce.w),Ie.copy(Ce))}function Wt(Ce,St){let dt=d.get(St);dt===void 0&&(dt=new WeakMap,d.set(St,dt));let Be=dt.get(Ce);Be===void 0&&(Be=n.getUniformBlockIndex(St,Ce.name),dt.set(Ce,Be))}function ht(Ce,St){const Be=d.get(St).get(Ce);u.get(St)!==Be&&(n.uniformBlockBinding(St,Be,Ce.__bindingPointIndex),u.set(St,Be))}function Ht(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),s===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},V=null,Z={},p={},g=new WeakMap,y=[],x=null,v=!1,b=null,S=null,C=null,E=null,k=null,R=null,L=null,I=new Kn(0,0,0),T=0,M=!1,j=null,W=null,z=null,X=null,B=null,be.set(0,0,n.canvas.width,n.canvas.height),Ie.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:Pe,disable:ct,bindFramebuffer:at,drawBuffers:Ee,useProgram:nn,setBlending:wt,setMaterial:Vt,setFlipSided:It,setCullFace:zt,setLineWidth:Gt,setPolygonOffset:dn,setScissorTest:vn,activeTexture:ce,bindTexture:Y,unbindTexture:ye,compressedTexImage2D:Qe,compressedTexImage3D:tt,texImage2D:Ye,texImage3D:kt,updateUBOMapping:Wt,uniformBlockBinding:ht,texStorage2D:xe,texStorage3D:xt,texSubImage2D:rt,texSubImage3D:Pt,compressedTexSubImage2D:pt,compressedTexSubImage3D:At,scissor:Et,viewport:bt,reset:Ht}}function tne(n,e,t,s,i,r,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,d=i.maxSamples,h=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),g=new WeakMap;let y;const x=new WeakMap;let v=!1;try{v=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function b(ce,Y){return v?new OffscreenCanvas(ce,Y):Ng("canvas")}function S(ce,Y,ye,Qe){let tt=1;if((ce.width>Qe||ce.height>Qe)&&(tt=Qe/Math.max(ce.width,ce.height)),tt<1||Y===!0)if(typeof HTMLImageElement<"u"&&ce instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&ce instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&ce instanceof ImageBitmap){const rt=Y?c2:Math.floor,Pt=rt(tt*ce.width),pt=rt(tt*ce.height);y===void 0&&(y=b(Pt,pt));const At=ye?b(Pt,pt):y;return At.width=Pt,At.height=pt,At.getContext("2d").drawImage(ce,0,0,Pt,pt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ce.width+"x"+ce.height+") to ("+Pt+"x"+pt+")."),At}else return"data"in ce&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ce.width+"x"+ce.height+")."),ce;return ce}function C(ce){return FC(ce.width)&&FC(ce.height)}function E(ce){return a?!1:ce.wrapS!==ea||ce.wrapT!==ea||ce.minFilter!==ar&&ce.minFilter!==po}function k(ce,Y){return ce.generateMipmaps&&Y&&ce.minFilter!==ar&&ce.minFilter!==po}function R(ce){n.generateMipmap(ce)}function L(ce,Y,ye,Qe,tt=!1){if(a===!1)return Y;if(ce!==null){if(n[ce]!==void 0)return n[ce];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+ce+"'")}let rt=Y;if(Y===n.RED&&(ye===n.FLOAT&&(rt=n.R32F),ye===n.HALF_FLOAT&&(rt=n.R16F),ye===n.UNSIGNED_BYTE&&(rt=n.R8)),Y===n.RED_INTEGER&&(ye===n.UNSIGNED_BYTE&&(rt=n.R8UI),ye===n.UNSIGNED_SHORT&&(rt=n.R16UI),ye===n.UNSIGNED_INT&&(rt=n.R32UI),ye===n.BYTE&&(rt=n.R8I),ye===n.SHORT&&(rt=n.R16I),ye===n.INT&&(rt=n.R32I)),Y===n.RG&&(ye===n.FLOAT&&(rt=n.RG32F),ye===n.HALF_FLOAT&&(rt=n.RG16F),ye===n.UNSIGNED_BYTE&&(rt=n.RG8)),Y===n.RGBA){const Pt=tt?r2:Ps.getTransfer(Qe);ye===n.FLOAT&&(rt=n.RGBA32F),ye===n.HALF_FLOAT&&(rt=n.RGBA16F),ye===n.UNSIGNED_BYTE&&(rt=Pt===si?n.SRGB8_ALPHA8:n.RGBA8),ye===n.UNSIGNED_SHORT_4_4_4_4&&(rt=n.RGBA4),ye===n.UNSIGNED_SHORT_5_5_5_1&&(rt=n.RGB5_A1)}return(rt===n.R16F||rt===n.R32F||rt===n.RG16F||rt===n.RG32F||rt===n.RGBA16F||rt===n.RGBA32F)&&e.get("EXT_color_buffer_float"),rt}function I(ce,Y,ye){return k(ce,ye)===!0||ce.isFramebufferTexture&&ce.minFilter!==ar&&ce.minFilter!==po?Math.log2(Math.max(Y.width,Y.height))+1:ce.mipmaps!==void 0&&ce.mipmaps.length>0?ce.mipmaps.length:ce.isCompressedTexture&&Array.isArray(ce.image)?Y.mipmaps.length:1}function T(ce){return ce===ar||ce===PC||ce===Pv?n.NEAREST:n.LINEAR}function M(ce){const Y=ce.target;Y.removeEventListener("dispose",M),W(Y),Y.isVideoTexture&&g.delete(Y)}function j(ce){const Y=ce.target;Y.removeEventListener("dispose",j),X(Y)}function W(ce){const Y=s.get(ce);if(Y.__webglInit===void 0)return;const ye=ce.source,Qe=x.get(ye);if(Qe){const tt=Qe[Y.__cacheKey];tt.usedTimes--,tt.usedTimes===0&&z(ce),Object.keys(Qe).length===0&&x.delete(ye)}s.remove(ce)}function z(ce){const Y=s.get(ce);n.deleteTexture(Y.__webglTexture);const ye=ce.source,Qe=x.get(ye);delete Qe[Y.__cacheKey],o.memory.textures--}function X(ce){const Y=ce.texture,ye=s.get(ce),Qe=s.get(Y);if(Qe.__webglTexture!==void 0&&(n.deleteTexture(Qe.__webglTexture),o.memory.textures--),ce.depthTexture&&ce.depthTexture.dispose(),ce.isWebGLCubeRenderTarget)for(let tt=0;tt<6;tt++){if(Array.isArray(ye.__webglFramebuffer[tt]))for(let rt=0;rt<ye.__webglFramebuffer[tt].length;rt++)n.deleteFramebuffer(ye.__webglFramebuffer[tt][rt]);else n.deleteFramebuffer(ye.__webglFramebuffer[tt]);ye.__webglDepthbuffer&&n.deleteRenderbuffer(ye.__webglDepthbuffer[tt])}else{if(Array.isArray(ye.__webglFramebuffer))for(let tt=0;tt<ye.__webglFramebuffer.length;tt++)n.deleteFramebuffer(ye.__webglFramebuffer[tt]);else n.deleteFramebuffer(ye.__webglFramebuffer);if(ye.__webglDepthbuffer&&n.deleteRenderbuffer(ye.__webglDepthbuffer),ye.__webglMultisampledFramebuffer&&n.deleteFramebuffer(ye.__webglMultisampledFramebuffer),ye.__webglColorRenderbuffer)for(let tt=0;tt<ye.__webglColorRenderbuffer.length;tt++)ye.__webglColorRenderbuffer[tt]&&n.deleteRenderbuffer(ye.__webglColorRenderbuffer[tt]);ye.__webglDepthRenderbuffer&&n.deleteRenderbuffer(ye.__webglDepthRenderbuffer)}if(ce.isWebGLMultipleRenderTargets)for(let tt=0,rt=Y.length;tt<rt;tt++){const Pt=s.get(Y[tt]);Pt.__webglTexture&&(n.deleteTexture(Pt.__webglTexture),o.memory.textures--),s.remove(Y[tt])}s.remove(Y),s.remove(ce)}let B=0;function J(){B=0}function K(){const ce=B;return ce>=l&&console.warn("THREE.WebGLTextures: Trying to use "+ce+" texture units while this GPU supports only "+l),B+=1,ce}function ee(ce){const Y=[];return Y.push(ce.wrapS),Y.push(ce.wrapT),Y.push(ce.wrapR||0),Y.push(ce.magFilter),Y.push(ce.minFilter),Y.push(ce.anisotropy),Y.push(ce.internalFormat),Y.push(ce.format),Y.push(ce.type),Y.push(ce.generateMipmaps),Y.push(ce.premultiplyAlpha),Y.push(ce.flipY),Y.push(ce.unpackAlignment),Y.push(ce.colorSpace),Y.join()}function ne(ce,Y){const ye=s.get(ce);if(ce.isVideoTexture&&dn(ce),ce.isRenderTargetTexture===!1&&ce.version>0&&ye.__version!==ce.version){const Qe=ce.image;if(Qe===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Qe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Pe(ye,ce,Y);return}}t.bindTexture(n.TEXTURE_2D,ye.__webglTexture,n.TEXTURE0+Y)}function V(ce,Y){const ye=s.get(ce);if(ce.version>0&&ye.__version!==ce.version){Pe(ye,ce,Y);return}t.bindTexture(n.TEXTURE_2D_ARRAY,ye.__webglTexture,n.TEXTURE0+Y)}function Z(ce,Y){const ye=s.get(ce);if(ce.version>0&&ye.__version!==ce.version){Pe(ye,ce,Y);return}t.bindTexture(n.TEXTURE_3D,ye.__webglTexture,n.TEXTURE0+Y)}function he(ce,Y){const ye=s.get(ce);if(ce.version>0&&ye.__version!==ce.version){ct(ye,ce,Y);return}t.bindTexture(n.TEXTURE_CUBE_MAP,ye.__webglTexture,n.TEXTURE0+Y)}const ve={[yf]:n.REPEAT,[ea]:n.CLAMP_TO_EDGE,[i2]:n.MIRRORED_REPEAT},be={[ar]:n.NEAREST,[PC]:n.NEAREST_MIPMAP_NEAREST,[Pv]:n.NEAREST_MIPMAP_LINEAR,[po]:n.LINEAR,[BF]:n.LINEAR_MIPMAP_NEAREST,[vd]:n.LINEAR_MIPMAP_LINEAR},Ie={[zY]:n.NEVER,[jY]:n.ALWAYS,[BY]:n.LESS,[VY]:n.LEQUAL,[UY]:n.EQUAL,[HY]:n.GEQUAL,[WY]:n.GREATER,[GY]:n.NOTEQUAL};function Xe(ce,Y,ye){if(ye?(n.texParameteri(ce,n.TEXTURE_WRAP_S,ve[Y.wrapS]),n.texParameteri(ce,n.TEXTURE_WRAP_T,ve[Y.wrapT]),(ce===n.TEXTURE_3D||ce===n.TEXTURE_2D_ARRAY)&&n.texParameteri(ce,n.TEXTURE_WRAP_R,ve[Y.wrapR]),n.texParameteri(ce,n.TEXTURE_MAG_FILTER,be[Y.magFilter]),n.texParameteri(ce,n.TEXTURE_MIN_FILTER,be[Y.minFilter])):(n.texParameteri(ce,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(ce,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(ce===n.TEXTURE_3D||ce===n.TEXTURE_2D_ARRAY)&&n.texParameteri(ce,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(Y.wrapS!==ea||Y.wrapT!==ea)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(ce,n.TEXTURE_MAG_FILTER,T(Y.magFilter)),n.texParameteri(ce,n.TEXTURE_MIN_FILTER,T(Y.minFilter)),Y.minFilter!==ar&&Y.minFilter!==po&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),Y.compareFunction&&(n.texParameteri(ce,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(ce,n.TEXTURE_COMPARE_FUNC,Ie[Y.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const Qe=e.get("EXT_texture_filter_anisotropic");if(Y.magFilter===ar||Y.minFilter!==Pv&&Y.minFilter!==vd||Y.type===sc&&e.has("OES_texture_float_linear")===!1||a===!1&&Y.type===Rg&&e.has("OES_texture_half_float_linear")===!1)return;(Y.anisotropy>1||s.get(Y).__currentAnisotropy)&&(n.texParameterf(ce,Qe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(Y.anisotropy,i.getMaxAnisotropy())),s.get(Y).__currentAnisotropy=Y.anisotropy)}}function Fe(ce,Y){let ye=!1;ce.__webglInit===void 0&&(ce.__webglInit=!0,Y.addEventListener("dispose",M));const Qe=Y.source;let tt=x.get(Qe);tt===void 0&&(tt={},x.set(Qe,tt));const rt=ee(Y);if(rt!==ce.__cacheKey){tt[rt]===void 0&&(tt[rt]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,ye=!0),tt[rt].usedTimes++;const Pt=tt[ce.__cacheKey];Pt!==void 0&&(tt[ce.__cacheKey].usedTimes--,Pt.usedTimes===0&&z(Y)),ce.__cacheKey=rt,ce.__webglTexture=tt[rt].texture}return ye}function Pe(ce,Y,ye){let Qe=n.TEXTURE_2D;(Y.isDataArrayTexture||Y.isCompressedArrayTexture)&&(Qe=n.TEXTURE_2D_ARRAY),Y.isData3DTexture&&(Qe=n.TEXTURE_3D);const tt=Fe(ce,Y),rt=Y.source;t.bindTexture(Qe,ce.__webglTexture,n.TEXTURE0+ye);const Pt=s.get(rt);if(rt.version!==Pt.__version||tt===!0){t.activeTexture(n.TEXTURE0+ye);const pt=Ps.getPrimaries(Ps.workingColorSpace),At=Y.colorSpace===na?null:Ps.getPrimaries(Y.colorSpace),xe=Y.colorSpace===na||pt===At?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,Y.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Y.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,Y.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,xe);const xt=E(Y)&&C(Y.image)===!1;let Ye=S(Y.image,xt,!1,u);Ye=vn(Y,Ye);const kt=C(Ye)||a,Et=r.convert(Y.format,Y.colorSpace);let bt=r.convert(Y.type),Wt=L(Y.internalFormat,Et,bt,Y.colorSpace,Y.isVideoTexture);Xe(Qe,Y,kt);let ht;const Ht=Y.mipmaps,Ce=a&&Y.isVideoTexture!==!0,St=Pt.__version===void 0||tt===!0,dt=I(Y,Ye,kt);if(Y.isDepthTexture)Wt=n.DEPTH_COMPONENT,a?Y.type===sc?Wt=n.DEPTH_COMPONENT32F:Y.type===Xc?Wt=n.DEPTH_COMPONENT24:Y.type===ud?Wt=n.DEPTH24_STENCIL8:Wt=n.DEPTH_COMPONENT16:Y.type===sc&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),Y.format===dd&&Wt===n.DEPTH_COMPONENT&&Y.type!==RE&&Y.type!==Xc&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),Y.type=Xc,bt=r.convert(Y.type)),Y.format===wf&&Wt===n.DEPTH_COMPONENT&&(Wt=n.DEPTH_STENCIL,Y.type!==ud&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),Y.type=ud,bt=r.convert(Y.type))),St&&(Ce?t.texStorage2D(n.TEXTURE_2D,1,Wt,Ye.width,Ye.height):t.texImage2D(n.TEXTURE_2D,0,Wt,Ye.width,Ye.height,0,Et,bt,null));else if(Y.isDataTexture)if(Ht.length>0&&kt){Ce&&St&&t.texStorage2D(n.TEXTURE_2D,dt,Wt,Ht[0].width,Ht[0].height);for(let Be=0,Rt=Ht.length;Be<Rt;Be++)ht=Ht[Be],Ce?t.texSubImage2D(n.TEXTURE_2D,Be,0,0,ht.width,ht.height,Et,bt,ht.data):t.texImage2D(n.TEXTURE_2D,Be,Wt,ht.width,ht.height,0,Et,bt,ht.data);Y.generateMipmaps=!1}else Ce?(St&&t.texStorage2D(n.TEXTURE_2D,dt,Wt,Ye.width,Ye.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,Ye.width,Ye.height,Et,bt,Ye.data)):t.texImage2D(n.TEXTURE_2D,0,Wt,Ye.width,Ye.height,0,Et,bt,Ye.data);else if(Y.isCompressedTexture)if(Y.isCompressedArrayTexture){Ce&&St&&t.texStorage3D(n.TEXTURE_2D_ARRAY,dt,Wt,Ht[0].width,Ht[0].height,Ye.depth);for(let Be=0,Rt=Ht.length;Be<Rt;Be++)ht=Ht[Be],Y.format!==ta?Et!==null?Ce?t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,Be,0,0,0,ht.width,ht.height,Ye.depth,Et,ht.data,0,0):t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,Be,Wt,ht.width,ht.height,Ye.depth,0,ht.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ce?t.texSubImage3D(n.TEXTURE_2D_ARRAY,Be,0,0,0,ht.width,ht.height,Ye.depth,Et,bt,ht.data):t.texImage3D(n.TEXTURE_2D_ARRAY,Be,Wt,ht.width,ht.height,Ye.depth,0,Et,bt,ht.data)}else{Ce&&St&&t.texStorage2D(n.TEXTURE_2D,dt,Wt,Ht[0].width,Ht[0].height);for(let Be=0,Rt=Ht.length;Be<Rt;Be++)ht=Ht[Be],Y.format!==ta?Et!==null?Ce?t.compressedTexSubImage2D(n.TEXTURE_2D,Be,0,0,ht.width,ht.height,Et,ht.data):t.compressedTexImage2D(n.TEXTURE_2D,Be,Wt,ht.width,ht.height,0,ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ce?t.texSubImage2D(n.TEXTURE_2D,Be,0,0,ht.width,ht.height,Et,bt,ht.data):t.texImage2D(n.TEXTURE_2D,Be,Wt,ht.width,ht.height,0,Et,bt,ht.data)}else if(Y.isDataArrayTexture)Ce?(St&&t.texStorage3D(n.TEXTURE_2D_ARRAY,dt,Wt,Ye.width,Ye.height,Ye.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,Ye.width,Ye.height,Ye.depth,Et,bt,Ye.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,Wt,Ye.width,Ye.height,Ye.depth,0,Et,bt,Ye.data);else if(Y.isData3DTexture)Ce?(St&&t.texStorage3D(n.TEXTURE_3D,dt,Wt,Ye.width,Ye.height,Ye.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,Ye.width,Ye.height,Ye.depth,Et,bt,Ye.data)):t.texImage3D(n.TEXTURE_3D,0,Wt,Ye.width,Ye.height,Ye.depth,0,Et,bt,Ye.data);else if(Y.isFramebufferTexture){if(St)if(Ce)t.texStorage2D(n.TEXTURE_2D,dt,Wt,Ye.width,Ye.height);else{let Be=Ye.width,Rt=Ye.height;for(let rn=0;rn<dt;rn++)t.texImage2D(n.TEXTURE_2D,rn,Wt,Be,Rt,0,Et,bt,null),Be>>=1,Rt>>=1}}else if(Ht.length>0&&kt){Ce&&St&&t.texStorage2D(n.TEXTURE_2D,dt,Wt,Ht[0].width,Ht[0].height);for(let Be=0,Rt=Ht.length;Be<Rt;Be++)ht=Ht[Be],Ce?t.texSubImage2D(n.TEXTURE_2D,Be,0,0,Et,bt,ht):t.texImage2D(n.TEXTURE_2D,Be,Wt,Et,bt,ht);Y.generateMipmaps=!1}else Ce?(St&&t.texStorage2D(n.TEXTURE_2D,dt,Wt,Ye.width,Ye.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,Et,bt,Ye)):t.texImage2D(n.TEXTURE_2D,0,Wt,Et,bt,Ye);k(Y,kt)&&R(Qe),Pt.__version=rt.version,Y.onUpdate&&Y.onUpdate(Y)}ce.__version=Y.version}function ct(ce,Y,ye){if(Y.image.length!==6)return;const Qe=Fe(ce,Y),tt=Y.source;t.bindTexture(n.TEXTURE_CUBE_MAP,ce.__webglTexture,n.TEXTURE0+ye);const rt=s.get(tt);if(tt.version!==rt.__version||Qe===!0){t.activeTexture(n.TEXTURE0+ye);const Pt=Ps.getPrimaries(Ps.workingColorSpace),pt=Y.colorSpace===na?null:Ps.getPrimaries(Y.colorSpace),At=Y.colorSpace===na||Pt===pt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,Y.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Y.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,Y.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,At);const xe=Y.isCompressedTexture||Y.image[0].isCompressedTexture,xt=Y.image[0]&&Y.image[0].isDataTexture,Ye=[];for(let Be=0;Be<6;Be++)!xe&&!xt?Ye[Be]=S(Y.image[Be],!1,!0,c):Ye[Be]=xt?Y.image[Be].image:Y.image[Be],Ye[Be]=vn(Y,Ye[Be]);const kt=Ye[0],Et=C(kt)||a,bt=r.convert(Y.format,Y.colorSpace),Wt=r.convert(Y.type),ht=L(Y.internalFormat,bt,Wt,Y.colorSpace),Ht=a&&Y.isVideoTexture!==!0,Ce=rt.__version===void 0||Qe===!0;let St=I(Y,kt,Et);Xe(n.TEXTURE_CUBE_MAP,Y,Et);let dt;if(xe){Ht&&Ce&&t.texStorage2D(n.TEXTURE_CUBE_MAP,St,ht,kt.width,kt.height);for(let Be=0;Be<6;Be++){dt=Ye[Be].mipmaps;for(let Rt=0;Rt<dt.length;Rt++){const rn=dt[Rt];Y.format!==ta?bt!==null?Ht?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt,0,0,rn.width,rn.height,bt,rn.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt,ht,rn.width,rn.height,0,rn.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ht?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt,0,0,rn.width,rn.height,bt,Wt,rn.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt,ht,rn.width,rn.height,0,bt,Wt,rn.data)}}}else{dt=Y.mipmaps,Ht&&Ce&&(dt.length>0&&St++,t.texStorage2D(n.TEXTURE_CUBE_MAP,St,ht,Ye[0].width,Ye[0].height));for(let Be=0;Be<6;Be++)if(xt){Ht?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,0,0,0,Ye[Be].width,Ye[Be].height,bt,Wt,Ye[Be].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,0,ht,Ye[Be].width,Ye[Be].height,0,bt,Wt,Ye[Be].data);for(let Rt=0;Rt<dt.length;Rt++){const In=dt[Rt].image[Be].image;Ht?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt+1,0,0,In.width,In.height,bt,Wt,In.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt+1,ht,In.width,In.height,0,bt,Wt,In.data)}}else{Ht?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,0,0,0,bt,Wt,Ye[Be]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,0,ht,bt,Wt,Ye[Be]);for(let Rt=0;Rt<dt.length;Rt++){const rn=dt[Rt];Ht?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt+1,0,0,bt,Wt,rn.image[Be]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Be,Rt+1,ht,bt,Wt,rn.image[Be])}}}k(Y,Et)&&R(n.TEXTURE_CUBE_MAP),rt.__version=tt.version,Y.onUpdate&&Y.onUpdate(Y)}ce.__version=Y.version}function at(ce,Y,ye,Qe,tt,rt){const Pt=r.convert(ye.format,ye.colorSpace),pt=r.convert(ye.type),At=L(ye.internalFormat,Pt,pt,ye.colorSpace);if(!s.get(Y).__hasExternalTextures){const xt=Math.max(1,Y.width>>rt),Ye=Math.max(1,Y.height>>rt);tt===n.TEXTURE_3D||tt===n.TEXTURE_2D_ARRAY?t.texImage3D(tt,rt,At,xt,Ye,Y.depth,0,Pt,pt,null):t.texImage2D(tt,rt,At,xt,Ye,0,Pt,pt,null)}t.bindFramebuffer(n.FRAMEBUFFER,ce),Gt(Y)?h.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,Qe,tt,s.get(ye).__webglTexture,0,zt(Y)):(tt===n.TEXTURE_2D||tt>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&tt<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,Qe,tt,s.get(ye).__webglTexture,rt),t.bindFramebuffer(n.FRAMEBUFFER,null)}function Ee(ce,Y,ye){if(n.bindRenderbuffer(n.RENDERBUFFER,ce),Y.depthBuffer&&!Y.stencilBuffer){let Qe=a===!0?n.DEPTH_COMPONENT24:n.DEPTH_COMPONENT16;if(ye||Gt(Y)){const tt=Y.depthTexture;tt&&tt.isDepthTexture&&(tt.type===sc?Qe=n.DEPTH_COMPONENT32F:tt.type===Xc&&(Qe=n.DEPTH_COMPONENT24));const rt=zt(Y);Gt(Y)?h.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,rt,Qe,Y.width,Y.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,rt,Qe,Y.width,Y.height)}else n.renderbufferStorage(n.RENDERBUFFER,Qe,Y.width,Y.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,ce)}else if(Y.depthBuffer&&Y.stencilBuffer){const Qe=zt(Y);ye&&Gt(Y)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Qe,n.DEPTH24_STENCIL8,Y.width,Y.height):Gt(Y)?h.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Qe,n.DEPTH24_STENCIL8,Y.width,Y.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,Y.width,Y.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,ce)}else{const Qe=Y.isWebGLMultipleRenderTargets===!0?Y.texture:[Y.texture];for(let tt=0;tt<Qe.length;tt++){const rt=Qe[tt],Pt=r.convert(rt.format,rt.colorSpace),pt=r.convert(rt.type),At=L(rt.internalFormat,Pt,pt,rt.colorSpace),xe=zt(Y);ye&&Gt(Y)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,xe,At,Y.width,Y.height):Gt(Y)?h.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,xe,At,Y.width,Y.height):n.renderbufferStorage(n.RENDERBUFFER,At,Y.width,Y.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function nn(ce,Y){if(Y&&Y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,ce),!(Y.depthTexture&&Y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(Y.depthTexture).__webglTexture||Y.depthTexture.image.width!==Y.width||Y.depthTexture.image.height!==Y.height)&&(Y.depthTexture.image.width=Y.width,Y.depthTexture.image.height=Y.height,Y.depthTexture.needsUpdate=!0),ne(Y.depthTexture,0);const Qe=s.get(Y.depthTexture).__webglTexture,tt=zt(Y);if(Y.depthTexture.format===dd)Gt(Y)?h.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Qe,0,tt):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,Qe,0);else if(Y.depthTexture.format===wf)Gt(Y)?h.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Qe,0,tt):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,Qe,0);else throw new Error("Unknown depthTexture format")}function gt(ce){const Y=s.get(ce),ye=ce.isWebGLCubeRenderTarget===!0;if(ce.depthTexture&&!Y.__autoAllocateDepthBuffer){if(ye)throw new Error("target.depthTexture not supported in Cube render targets");nn(Y.__webglFramebuffer,ce)}else if(ye){Y.__webglDepthbuffer=[];for(let Qe=0;Qe<6;Qe++)t.bindFramebuffer(n.FRAMEBUFFER,Y.__webglFramebuffer[Qe]),Y.__webglDepthbuffer[Qe]=n.createRenderbuffer(),Ee(Y.__webglDepthbuffer[Qe],ce,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,Y.__webglFramebuffer),Y.__webglDepthbuffer=n.createRenderbuffer(),Ee(Y.__webglDepthbuffer,ce,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function vt(ce,Y,ye){const Qe=s.get(ce);Y!==void 0&&at(Qe.__webglFramebuffer,ce,ce.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),ye!==void 0&&gt(ce)}function wt(ce){const Y=ce.texture,ye=s.get(ce),Qe=s.get(Y);ce.addEventListener("dispose",j),ce.isWebGLMultipleRenderTargets!==!0&&(Qe.__webglTexture===void 0&&(Qe.__webglTexture=n.createTexture()),Qe.__version=Y.version,o.memory.textures++);const tt=ce.isWebGLCubeRenderTarget===!0,rt=ce.isWebGLMultipleRenderTargets===!0,Pt=C(ce)||a;if(tt){ye.__webglFramebuffer=[];for(let pt=0;pt<6;pt++)if(a&&Y.mipmaps&&Y.mipmaps.length>0){ye.__webglFramebuffer[pt]=[];for(let At=0;At<Y.mipmaps.length;At++)ye.__webglFramebuffer[pt][At]=n.createFramebuffer()}else ye.__webglFramebuffer[pt]=n.createFramebuffer()}else{if(a&&Y.mipmaps&&Y.mipmaps.length>0){ye.__webglFramebuffer=[];for(let pt=0;pt<Y.mipmaps.length;pt++)ye.__webglFramebuffer[pt]=n.createFramebuffer()}else ye.__webglFramebuffer=n.createFramebuffer();if(rt)if(i.drawBuffers){const pt=ce.texture;for(let At=0,xe=pt.length;At<xe;At++){const xt=s.get(pt[At]);xt.__webglTexture===void 0&&(xt.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&ce.samples>0&&Gt(ce)===!1){const pt=rt?Y:[Y];ye.__webglMultisampledFramebuffer=n.createFramebuffer(),ye.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,ye.__webglMultisampledFramebuffer);for(let At=0;At<pt.length;At++){const xe=pt[At];ye.__webglColorRenderbuffer[At]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,ye.__webglColorRenderbuffer[At]);const xt=r.convert(xe.format,xe.colorSpace),Ye=r.convert(xe.type),kt=L(xe.internalFormat,xt,Ye,xe.colorSpace,ce.isXRRenderTarget===!0),Et=zt(ce);n.renderbufferStorageMultisample(n.RENDERBUFFER,Et,kt,ce.width,ce.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+At,n.RENDERBUFFER,ye.__webglColorRenderbuffer[At])}n.bindRenderbuffer(n.RENDERBUFFER,null),ce.depthBuffer&&(ye.__webglDepthRenderbuffer=n.createRenderbuffer(),Ee(ye.__webglDepthRenderbuffer,ce,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(tt){t.bindTexture(n.TEXTURE_CUBE_MAP,Qe.__webglTexture),Xe(n.TEXTURE_CUBE_MAP,Y,Pt);for(let pt=0;pt<6;pt++)if(a&&Y.mipmaps&&Y.mipmaps.length>0)for(let At=0;At<Y.mipmaps.length;At++)at(ye.__webglFramebuffer[pt][At],ce,Y,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+pt,At);else at(ye.__webglFramebuffer[pt],ce,Y,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+pt,0);k(Y,Pt)&&R(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(rt){const pt=ce.texture;for(let At=0,xe=pt.length;At<xe;At++){const xt=pt[At],Ye=s.get(xt);t.bindTexture(n.TEXTURE_2D,Ye.__webglTexture),Xe(n.TEXTURE_2D,xt,Pt),at(ye.__webglFramebuffer,ce,xt,n.COLOR_ATTACHMENT0+At,n.TEXTURE_2D,0),k(xt,Pt)&&R(n.TEXTURE_2D)}t.unbindTexture()}else{let pt=n.TEXTURE_2D;if((ce.isWebGL3DRenderTarget||ce.isWebGLArrayRenderTarget)&&(a?pt=ce.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(pt,Qe.__webglTexture),Xe(pt,Y,Pt),a&&Y.mipmaps&&Y.mipmaps.length>0)for(let At=0;At<Y.mipmaps.length;At++)at(ye.__webglFramebuffer[At],ce,Y,n.COLOR_ATTACHMENT0,pt,At);else at(ye.__webglFramebuffer,ce,Y,n.COLOR_ATTACHMENT0,pt,0);k(Y,Pt)&&R(pt),t.unbindTexture()}ce.depthBuffer&&gt(ce)}function Vt(ce){const Y=C(ce)||a,ye=ce.isWebGLMultipleRenderTargets===!0?ce.texture:[ce.texture];for(let Qe=0,tt=ye.length;Qe<tt;Qe++){const rt=ye[Qe];if(k(rt,Y)){const Pt=ce.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,pt=s.get(rt).__webglTexture;t.bindTexture(Pt,pt),R(Pt),t.unbindTexture()}}}function It(ce){if(a&&ce.samples>0&&Gt(ce)===!1){const Y=ce.isWebGLMultipleRenderTargets?ce.texture:[ce.texture],ye=ce.width,Qe=ce.height;let tt=n.COLOR_BUFFER_BIT;const rt=[],Pt=ce.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,pt=s.get(ce),At=ce.isWebGLMultipleRenderTargets===!0;if(At)for(let xe=0;xe<Y.length;xe++)t.bindFramebuffer(n.FRAMEBUFFER,pt.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+xe,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,pt.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+xe,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,pt.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,pt.__webglFramebuffer);for(let xe=0;xe<Y.length;xe++){rt.push(n.COLOR_ATTACHMENT0+xe),ce.depthBuffer&&rt.push(Pt);const xt=pt.__ignoreDepthValues!==void 0?pt.__ignoreDepthValues:!1;if(xt===!1&&(ce.depthBuffer&&(tt|=n.DEPTH_BUFFER_BIT),ce.stencilBuffer&&(tt|=n.STENCIL_BUFFER_BIT)),At&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,pt.__webglColorRenderbuffer[xe]),xt===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[Pt]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[Pt])),At){const Ye=s.get(Y[xe]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,Ye,0)}n.blitFramebuffer(0,0,ye,Qe,0,0,ye,Qe,tt,n.NEAREST),p&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,rt)}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),At)for(let xe=0;xe<Y.length;xe++){t.bindFramebuffer(n.FRAMEBUFFER,pt.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+xe,n.RENDERBUFFER,pt.__webglColorRenderbuffer[xe]);const xt=s.get(Y[xe]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,pt.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+xe,n.TEXTURE_2D,xt,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,pt.__webglMultisampledFramebuffer)}}function zt(ce){return Math.min(d,ce.samples)}function Gt(ce){const Y=s.get(ce);return a&&ce.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&Y.__useRenderToTexture!==!1}function dn(ce){const Y=o.render.frame;g.get(ce)!==Y&&(g.set(ce,Y),ce.update())}function vn(ce,Y){const ye=ce.colorSpace,Qe=ce.format,tt=ce.type;return ce.isCompressedTexture===!0||ce.isVideoTexture===!0||ce.format===$C||ye!==yr&&ye!==na&&(Ps.getTransfer(ye)===si?a===!1?e.has("EXT_sRGB")===!0&&Qe===ta?(ce.format=$C,ce.minFilter=po,ce.generateMipmaps=!1):Y=JF.sRGBToLinear(Y):(Qe!==ta||tt!==eu)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",ye)),Y}this.allocateTextureUnit=K,this.resetTextureUnits=J,this.setTexture2D=ne,this.setTexture2DArray=V,this.setTexture3D=Z,this.setTextureCube=he,this.rebindTextures=vt,this.setupRenderTarget=wt,this.updateRenderTargetMipmap=Vt,this.updateMultisampleRenderTarget=It,this.setupDepthRenderbuffer=gt,this.setupFrameBufferTexture=at,this.useMultisampledRTT=Gt}function nne(n,e,t){const s=t.isWebGL2;function i(r,o=na){let a;const l=Ps.getTransfer(o);if(r===eu)return n.UNSIGNED_BYTE;if(r===VF)return n.UNSIGNED_SHORT_4_4_4_4;if(r===WF)return n.UNSIGNED_SHORT_5_5_5_1;if(r===EY)return n.BYTE;if(r===TY)return n.SHORT;if(r===RE)return n.UNSIGNED_SHORT;if(r===UF)return n.INT;if(r===Xc)return n.UNSIGNED_INT;if(r===sc)return n.FLOAT;if(r===Rg)return s?n.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(r===IY)return n.ALPHA;if(r===ta)return n.RGBA;if(r===kY)return n.LUMINANCE;if(r===AY)return n.LUMINANCE_ALPHA;if(r===dd)return n.DEPTH_COMPONENT;if(r===wf)return n.DEPTH_STENCIL;if(r===$C)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(r===RY)return n.RED;if(r===GF)return n.RED_INTEGER;if(r===MY)return n.RG;if(r===HF)return n.RG_INTEGER;if(r===jF)return n.RGBA_INTEGER;if(r===j3||r===X3||r===q3||r===K3)if(l===si)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(r===j3)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===X3)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===q3)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===K3)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(r===j3)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===X3)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===q3)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===K3)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===YR||r===ZR||r===QR||r===JR)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(r===YR)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===ZR)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===QR)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===JR)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===NY)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===eM||r===tM)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(r===eM)return l===si?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(r===tM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===nM||r===sM||r===iM||r===rM||r===oM||r===aM||r===lM||r===cM||r===uM||r===dM||r===hM||r===fM||r===pM||r===mM)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(r===nM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===sM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===iM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===rM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===oM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===aM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===lM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===cM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===uM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===dM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===hM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===fM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===pM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===mM)return l===si?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===Y3||r===gM||r===xM)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(r===Y3)return l===si?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(r===gM)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(r===xM)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(r===PY||r===vM||r===yM||r===wM)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(r===Y3)return a.COMPRESSED_RED_RGTC1_EXT;if(r===vM)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(r===yM)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(r===wM)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return r===ud?s?n.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[r]!==void 0?n[r]:null}return{convert:i}}class sne extends Hr{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class rd extends mi{constructor(){super(),this.isGroup=!0,this.type="Group"}}const ine={type:"move"};class wS{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new rd,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new rd,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Ne,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Ne),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new rd,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Ne,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Ne),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let i=null,r=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const y of e.hand.values()){const x=t.getJointPose(y,s),v=this._getHandJoint(c,y);x!==null&&(v.matrix.fromArray(x.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.matrixWorldNeedsUpdate=!0,v.jointRadius=x.radius),v.visible=x!==null}const u=c.joints["index-finger-tip"],d=c.joints["thumb-tip"],h=u.position.distanceTo(d.position),p=.02,g=.005;c.inputState.pinching&&h>p+g?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&h<=p-g&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,s),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,s),i===null&&r!==null&&(i=r),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(ine)))}return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new rd;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class rne extends vr{constructor(e,t,s,i,r,o,a,l,c,u){if(u=u!==void 0?u:dd,u!==dd&&u!==wf)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&u===dd&&(s=Xc),s===void 0&&u===wf&&(s=ud),super(null,i,r,o,a,l,u,s,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:ar,this.minFilter=l!==void 0?l:ar,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class one extends Fd{constructor(e,t){super();const s=this;let i=null,r=1,o=null,a="local-floor",l=1,c=null,u=null,d=null,h=null,p=null,g=null;const y=t.getContextAttributes();let x=null,v=null;const b=[],S=[],C=new Hr;C.layers.enable(1),C.viewport=new qs;const E=new Hr;E.layers.enable(2),E.viewport=new qs;const k=[C,E],R=new sne;R.layers.enable(1),R.layers.enable(2);let L=null,I=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(V){let Z=b[V];return Z===void 0&&(Z=new wS,b[V]=Z),Z.getTargetRaySpace()},this.getControllerGrip=function(V){let Z=b[V];return Z===void 0&&(Z=new wS,b[V]=Z),Z.getGripSpace()},this.getHand=function(V){let Z=b[V];return Z===void 0&&(Z=new wS,b[V]=Z),Z.getHandSpace()};function T(V){const Z=S.indexOf(V.inputSource);if(Z===-1)return;const he=b[Z];he!==void 0&&(he.update(V.inputSource,V.frame,c||o),he.dispatchEvent({type:V.type,data:V.inputSource}))}function M(){i.removeEventListener("select",T),i.removeEventListener("selectstart",T),i.removeEventListener("selectend",T),i.removeEventListener("squeeze",T),i.removeEventListener("squeezestart",T),i.removeEventListener("squeezeend",T),i.removeEventListener("end",M),i.removeEventListener("inputsourceschange",j);for(let V=0;V<b.length;V++){const Z=S[V];Z!==null&&(S[V]=null,b[V].disconnect(Z))}L=null,I=null,e.setRenderTarget(x),p=null,h=null,d=null,i=null,v=null,ne.stop(),s.isPresenting=!1,s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(V){r=V,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(V){a=V,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(V){c=V},this.getBaseLayer=function(){return h!==null?h:p},this.getBinding=function(){return d},this.getFrame=function(){return g},this.getSession=function(){return i},this.setSession=async function(V){if(i=V,i!==null){if(x=e.getRenderTarget(),i.addEventListener("select",T),i.addEventListener("selectstart",T),i.addEventListener("selectend",T),i.addEventListener("squeeze",T),i.addEventListener("squeezestart",T),i.addEventListener("squeezeend",T),i.addEventListener("end",M),i.addEventListener("inputsourceschange",j),y.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const Z={antialias:i.renderState.layers===void 0?y.antialias:!0,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:r};p=new XRWebGLLayer(i,t,Z),i.updateRenderState({baseLayer:p}),v=new yd(p.framebufferWidth,p.framebufferHeight,{format:ta,type:eu,colorSpace:e.outputColorSpace,stencilBuffer:y.stencil})}else{let Z=null,he=null,ve=null;y.depth&&(ve=y.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Z=y.stencil?wf:dd,he=y.stencil?ud:Xc);const be={colorFormat:t.RGBA8,depthFormat:ve,scaleFactor:r};d=new XRWebGLBinding(i,t),h=d.createProjectionLayer(be),i.updateRenderState({layers:[h]}),v=new yd(h.textureWidth,h.textureHeight,{format:ta,type:eu,depthTexture:new rne(h.textureWidth,h.textureHeight,he,void 0,void 0,void 0,void 0,void 0,void 0,Z),stencilBuffer:y.stencil,colorSpace:e.outputColorSpace,samples:y.antialias?4:0});const Ie=e.properties.get(v);Ie.__ignoreDepthValues=h.ignoreDepthValues}v.isXRRenderTarget=!0,this.setFoveation(l),c=null,o=await i.requestReferenceSpace(a),ne.setContext(i),ne.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function j(V){for(let Z=0;Z<V.removed.length;Z++){const he=V.removed[Z],ve=S.indexOf(he);ve>=0&&(S[ve]=null,b[ve].disconnect(he))}for(let Z=0;Z<V.added.length;Z++){const he=V.added[Z];let ve=S.indexOf(he);if(ve===-1){for(let Ie=0;Ie<b.length;Ie++)if(Ie>=S.length){S.push(he),ve=Ie;break}else if(S[Ie]===null){S[Ie]=he,ve=Ie;break}if(ve===-1)break}const be=b[ve];be&&be.connect(he)}}const W=new Ne,z=new Ne;function X(V,Z,he){W.setFromMatrixPosition(Z.matrixWorld),z.setFromMatrixPosition(he.matrixWorld);const ve=W.distanceTo(z),be=Z.projectionMatrix.elements,Ie=he.projectionMatrix.elements,Xe=be[14]/(be[10]-1),Fe=be[14]/(be[10]+1),Pe=(be[9]+1)/be[5],ct=(be[9]-1)/be[5],at=(be[8]-1)/be[0],Ee=(Ie[8]+1)/Ie[0],nn=Xe*at,gt=Xe*Ee,vt=ve/(-at+Ee),wt=vt*-at;Z.matrixWorld.decompose(V.position,V.quaternion,V.scale),V.translateX(wt),V.translateZ(vt),V.matrixWorld.compose(V.position,V.quaternion,V.scale),V.matrixWorldInverse.copy(V.matrixWorld).invert();const Vt=Xe+vt,It=Fe+vt,zt=nn-wt,Gt=gt+(ve-wt),dn=Pe*Fe/It*Vt,vn=ct*Fe/It*Vt;V.projectionMatrix.makePerspective(zt,Gt,dn,vn,Vt,It),V.projectionMatrixInverse.copy(V.projectionMatrix).invert()}function B(V,Z){Z===null?V.matrixWorld.copy(V.matrix):V.matrixWorld.multiplyMatrices(Z.matrixWorld,V.matrix),V.matrixWorldInverse.copy(V.matrixWorld).invert()}this.updateCamera=function(V){if(i===null)return;R.near=E.near=C.near=V.near,R.far=E.far=C.far=V.far,(L!==R.near||I!==R.far)&&(i.updateRenderState({depthNear:R.near,depthFar:R.far}),L=R.near,I=R.far);const Z=V.parent,he=R.cameras;B(R,Z);for(let ve=0;ve<he.length;ve++)B(he[ve],Z);he.length===2?X(R,C,E):R.projectionMatrix.copy(C.projectionMatrix),J(V,R,Z)};function J(V,Z,he){he===null?V.matrix.copy(Z.matrixWorld):(V.matrix.copy(he.matrixWorld),V.matrix.invert(),V.matrix.multiply(Z.matrixWorld)),V.matrix.decompose(V.position,V.quaternion,V.scale),V.updateMatrixWorld(!0),V.projectionMatrix.copy(Z.projectionMatrix),V.projectionMatrixInverse.copy(Z.projectionMatrixInverse),V.isPerspectiveCamera&&(V.fov=Sf*2*Math.atan(1/V.projectionMatrix.elements[5]),V.zoom=1)}this.getCamera=function(){return R},this.getFoveation=function(){if(!(h===null&&p===null))return l},this.setFoveation=function(V){l=V,h!==null&&(h.fixedFoveation=V),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=V)};let K=null;function ee(V,Z){if(u=Z.getViewerPose(c||o),g=Z,u!==null){const he=u.views;p!==null&&(e.setRenderTargetFramebuffer(v,p.framebuffer),e.setRenderTarget(v));let ve=!1;he.length!==R.cameras.length&&(R.cameras.length=0,ve=!0);for(let be=0;be<he.length;be++){const Ie=he[be];let Xe=null;if(p!==null)Xe=p.getViewport(Ie);else{const Pe=d.getViewSubImage(h,Ie);Xe=Pe.viewport,be===0&&(e.setRenderTargetTextures(v,Pe.colorTexture,h.ignoreDepthValues?void 0:Pe.depthStencilTexture),e.setRenderTarget(v))}let Fe=k[be];Fe===void 0&&(Fe=new Hr,Fe.layers.enable(be),Fe.viewport=new qs,k[be]=Fe),Fe.matrix.fromArray(Ie.transform.matrix),Fe.matrix.decompose(Fe.position,Fe.quaternion,Fe.scale),Fe.projectionMatrix.fromArray(Ie.projectionMatrix),Fe.projectionMatrixInverse.copy(Fe.projectionMatrix).invert(),Fe.viewport.set(Xe.x,Xe.y,Xe.width,Xe.height),be===0&&(R.matrix.copy(Fe.matrix),R.matrix.decompose(R.position,R.quaternion,R.scale)),ve===!0&&R.cameras.push(Fe)}}for(let he=0;he<b.length;he++){const ve=S[he],be=b[he];ve!==null&&be!==void 0&&be.update(ve,Z,c||o)}K&&K(V,Z),Z.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:Z}),g=null}const ne=new cO;ne.setAnimationLoop(ee),this.setAnimationLoop=function(V){K=V},this.dispose=function(){}}}function ane(n,e){function t(x,v){x.matrixAutoUpdate===!0&&x.updateMatrix(),v.value.copy(x.matrix)}function s(x,v){v.color.getRGB(x.fogColor.value,oO(n)),v.isFog?(x.fogNear.value=v.near,x.fogFar.value=v.far):v.isFogExp2&&(x.fogDensity.value=v.density)}function i(x,v,b,S,C){v.isMeshBasicMaterial||v.isMeshLambertMaterial?r(x,v):v.isMeshToonMaterial?(r(x,v),d(x,v)):v.isMeshPhongMaterial?(r(x,v),u(x,v)):v.isMeshStandardMaterial?(r(x,v),h(x,v),v.isMeshPhysicalMaterial&&p(x,v,C)):v.isMeshMatcapMaterial?(r(x,v),g(x,v)):v.isMeshDepthMaterial?r(x,v):v.isMeshDistanceMaterial?(r(x,v),y(x,v)):v.isMeshNormalMaterial?r(x,v):v.isLineBasicMaterial?(o(x,v),v.isLineDashedMaterial&&a(x,v)):v.isPointsMaterial?l(x,v,b,S):v.isSpriteMaterial?c(x,v):v.isShadowMaterial?(x.color.value.copy(v.color),x.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function r(x,v){x.opacity.value=v.opacity,v.color&&x.diffuse.value.copy(v.color),v.emissive&&x.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(x.map.value=v.map,t(v.map,x.mapTransform)),v.alphaMap&&(x.alphaMap.value=v.alphaMap,t(v.alphaMap,x.alphaMapTransform)),v.bumpMap&&(x.bumpMap.value=v.bumpMap,t(v.bumpMap,x.bumpMapTransform),x.bumpScale.value=v.bumpScale,v.side===xo&&(x.bumpScale.value*=-1)),v.normalMap&&(x.normalMap.value=v.normalMap,t(v.normalMap,x.normalMapTransform),x.normalScale.value.copy(v.normalScale),v.side===xo&&x.normalScale.value.negate()),v.displacementMap&&(x.displacementMap.value=v.displacementMap,t(v.displacementMap,x.displacementMapTransform),x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias),v.emissiveMap&&(x.emissiveMap.value=v.emissiveMap,t(v.emissiveMap,x.emissiveMapTransform)),v.specularMap&&(x.specularMap.value=v.specularMap,t(v.specularMap,x.specularMapTransform)),v.alphaTest>0&&(x.alphaTest.value=v.alphaTest);const b=e.get(v).envMap;if(b&&(x.envMap.value=b,x.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,x.reflectivity.value=v.reflectivity,x.ior.value=v.ior,x.refractionRatio.value=v.refractionRatio),v.lightMap){x.lightMap.value=v.lightMap;const S=n._useLegacyLights===!0?Math.PI:1;x.lightMapIntensity.value=v.lightMapIntensity*S,t(v.lightMap,x.lightMapTransform)}v.aoMap&&(x.aoMap.value=v.aoMap,x.aoMapIntensity.value=v.aoMapIntensity,t(v.aoMap,x.aoMapTransform))}function o(x,v){x.diffuse.value.copy(v.color),x.opacity.value=v.opacity,v.map&&(x.map.value=v.map,t(v.map,x.mapTransform))}function a(x,v){x.dashSize.value=v.dashSize,x.totalSize.value=v.dashSize+v.gapSize,x.scale.value=v.scale}function l(x,v,b,S){x.diffuse.value.copy(v.color),x.opacity.value=v.opacity,x.size.value=v.size*b,x.scale.value=S*.5,v.map&&(x.map.value=v.map,t(v.map,x.uvTransform)),v.alphaMap&&(x.alphaMap.value=v.alphaMap,t(v.alphaMap,x.alphaMapTransform)),v.alphaTest>0&&(x.alphaTest.value=v.alphaTest)}function c(x,v){x.diffuse.value.copy(v.color),x.opacity.value=v.opacity,x.rotation.value=v.rotation,v.map&&(x.map.value=v.map,t(v.map,x.mapTransform)),v.alphaMap&&(x.alphaMap.value=v.alphaMap,t(v.alphaMap,x.alphaMapTransform)),v.alphaTest>0&&(x.alphaTest.value=v.alphaTest)}function u(x,v){x.specular.value.copy(v.specular),x.shininess.value=Math.max(v.shininess,1e-4)}function d(x,v){v.gradientMap&&(x.gradientMap.value=v.gradientMap)}function h(x,v){x.metalness.value=v.metalness,v.metalnessMap&&(x.metalnessMap.value=v.metalnessMap,t(v.metalnessMap,x.metalnessMapTransform)),x.roughness.value=v.roughness,v.roughnessMap&&(x.roughnessMap.value=v.roughnessMap,t(v.roughnessMap,x.roughnessMapTransform)),e.get(v).envMap&&(x.envMapIntensity.value=v.envMapIntensity)}function p(x,v,b){x.ior.value=v.ior,v.sheen>0&&(x.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),x.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(x.sheenColorMap.value=v.sheenColorMap,t(v.sheenColorMap,x.sheenColorMapTransform)),v.sheenRoughnessMap&&(x.sheenRoughnessMap.value=v.sheenRoughnessMap,t(v.sheenRoughnessMap,x.sheenRoughnessMapTransform))),v.clearcoat>0&&(x.clearcoat.value=v.clearcoat,x.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(x.clearcoatMap.value=v.clearcoatMap,t(v.clearcoatMap,x.clearcoatMapTransform)),v.clearcoatRoughnessMap&&(x.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap,t(v.clearcoatRoughnessMap,x.clearcoatRoughnessMapTransform)),v.clearcoatNormalMap&&(x.clearcoatNormalMap.value=v.clearcoatNormalMap,t(v.clearcoatNormalMap,x.clearcoatNormalMapTransform),x.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),v.side===xo&&x.clearcoatNormalScale.value.negate())),v.iridescence>0&&(x.iridescence.value=v.iridescence,x.iridescenceIOR.value=v.iridescenceIOR,x.iridescenceThicknessMinimum.value=v.iridescenceThicknessRange[0],x.iridescenceThicknessMaximum.value=v.iridescenceThicknessRange[1],v.iridescenceMap&&(x.iridescenceMap.value=v.iridescenceMap,t(v.iridescenceMap,x.iridescenceMapTransform)),v.iridescenceThicknessMap&&(x.iridescenceThicknessMap.value=v.iridescenceThicknessMap,t(v.iridescenceThicknessMap,x.iridescenceThicknessMapTransform))),v.transmission>0&&(x.transmission.value=v.transmission,x.transmissionSamplerMap.value=b.texture,x.transmissionSamplerSize.value.set(b.width,b.height),v.transmissionMap&&(x.transmissionMap.value=v.transmissionMap,t(v.transmissionMap,x.transmissionMapTransform)),x.thickness.value=v.thickness,v.thicknessMap&&(x.thicknessMap.value=v.thicknessMap,t(v.thicknessMap,x.thicknessMapTransform)),x.attenuationDistance.value=v.attenuationDistance,x.attenuationColor.value.copy(v.attenuationColor)),v.anisotropy>0&&(x.anisotropyVector.value.set(v.anisotropy*Math.cos(v.anisotropyRotation),v.anisotropy*Math.sin(v.anisotropyRotation)),v.anisotropyMap&&(x.anisotropyMap.value=v.anisotropyMap,t(v.anisotropyMap,x.anisotropyMapTransform))),x.specularIntensity.value=v.specularIntensity,x.specularColor.value.copy(v.specularColor),v.specularColorMap&&(x.specularColorMap.value=v.specularColorMap,t(v.specularColorMap,x.specularColorMapTransform)),v.specularIntensityMap&&(x.specularIntensityMap.value=v.specularIntensityMap,t(v.specularIntensityMap,x.specularIntensityMapTransform))}function g(x,v){v.matcap&&(x.matcap.value=v.matcap)}function y(x,v){const b=e.get(v).light;x.referencePosition.value.setFromMatrixPosition(b.matrixWorld),x.nearDistance.value=b.shadow.camera.near,x.farDistance.value=b.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:i}}function lne(n,e,t,s){let i={},r={},o=[];const a=t.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(b,S){const C=S.program;s.uniformBlockBinding(b,C)}function c(b,S){let C=i[b.id];C===void 0&&(g(b),C=u(b),i[b.id]=C,b.addEventListener("dispose",x));const E=S.program;s.updateUBOMapping(b,E);const k=e.render.frame;r[b.id]!==k&&(h(b),r[b.id]=k)}function u(b){const S=d();b.__bindingPointIndex=S;const C=n.createBuffer(),E=b.__size,k=b.usage;return n.bindBuffer(n.UNIFORM_BUFFER,C),n.bufferData(n.UNIFORM_BUFFER,E,k),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,S,C),C}function d(){for(let b=0;b<a;b++)if(o.indexOf(b)===-1)return o.push(b),b;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function h(b){const S=i[b.id],C=b.uniforms,E=b.__cache;n.bindBuffer(n.UNIFORM_BUFFER,S);for(let k=0,R=C.length;k<R;k++){const L=C[k];if(p(L,k,E)===!0){const I=L.__offset,T=Array.isArray(L.value)?L.value:[L.value];let M=0;for(let j=0;j<T.length;j++){const W=T[j],z=y(W);typeof W=="number"?(L.__data[0]=W,n.bufferSubData(n.UNIFORM_BUFFER,I+M,L.__data)):W.isMatrix3?(L.__data[0]=W.elements[0],L.__data[1]=W.elements[1],L.__data[2]=W.elements[2],L.__data[3]=W.elements[0],L.__data[4]=W.elements[3],L.__data[5]=W.elements[4],L.__data[6]=W.elements[5],L.__data[7]=W.elements[0],L.__data[8]=W.elements[6],L.__data[9]=W.elements[7],L.__data[10]=W.elements[8],L.__data[11]=W.elements[0]):(W.toArray(L.__data,M),M+=z.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,I,L.__data)}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(b,S,C){const E=b.value;if(C[S]===void 0){if(typeof E=="number")C[S]=E;else{const k=Array.isArray(E)?E:[E],R=[];for(let L=0;L<k.length;L++)R.push(k[L].clone());C[S]=R}return!0}else if(typeof E=="number"){if(C[S]!==E)return C[S]=E,!0}else{const k=Array.isArray(C[S])?C[S]:[C[S]],R=Array.isArray(E)?E:[E];for(let L=0;L<k.length;L++){const I=k[L];if(I.equals(R[L])===!1)return I.copy(R[L]),!0}}return!1}function g(b){const S=b.uniforms;let C=0;const E=16;let k=0;for(let R=0,L=S.length;R<L;R++){const I=S[R],T={boundary:0,storage:0},M=Array.isArray(I.value)?I.value:[I.value];for(let j=0,W=M.length;j<W;j++){const z=M[j],X=y(z);T.boundary+=X.boundary,T.storage+=X.storage}if(I.__data=new Float32Array(T.storage/Float32Array.BYTES_PER_ELEMENT),I.__offset=C,R>0){k=C%E;const j=E-k;k!==0&&j-T.boundary<0&&(C+=E-k,I.__offset=C)}C+=T.storage}return k=C%E,k>0&&(C+=E-k),b.__size=C,b.__cache={},this}function y(b){const S={boundary:0,storage:0};return typeof b=="number"?(S.boundary=4,S.storage=4):b.isVector2?(S.boundary=8,S.storage=8):b.isVector3||b.isColor?(S.boundary=16,S.storage=12):b.isVector4?(S.boundary=16,S.storage=16):b.isMatrix3?(S.boundary=48,S.storage=48):b.isMatrix4?(S.boundary=64,S.storage=64):b.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",b),S}function x(b){const S=b.target;S.removeEventListener("dispose",x);const C=o.indexOf(S.__bindingPointIndex);o.splice(C,1),n.deleteBuffer(i[S.id]),delete i[S.id],delete r[S.id]}function v(){for(const b in i)n.deleteBuffer(i[b]);o=[],i={},r={}}return{bind:l,update:c,dispose:v}}class pO{constructor(e={}){const{canvas:t=oZ(),context:s=null,depth:i=!0,stencil:r=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:d=!1}=e;this.isWebGLRenderer=!0;let h;s!==null?h=s.getContextAttributes().alpha:h=o;const p=new Uint32Array(4),g=new Int32Array(4);let y=null,x=null;const v=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=hi,this._useLegacyLights=!1,this.toneMapping=Jc,this.toneMappingExposure=1;const S=this;let C=!1,E=0,k=0,R=null,L=-1,I=null;const T=new qs,M=new qs;let j=null;const W=new Kn(0);let z=0,X=t.width,B=t.height,J=1,K=null,ee=null;const ne=new qs(0,0,X,B),V=new qs(0,0,X,B);let Z=!1;const he=new PE;let ve=!1,be=!1,Ie=null;const Xe=new us,Fe=new Zn,Pe=new Ne,ct={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function at(){return R===null?J:1}let Ee=s;function nn(oe,We){for(let Ze=0;Ze<oe.length;Ze++){const Je=oe[Ze],nt=t.getContext(Je,We);if(nt!==null)return nt}return null}try{const oe={alpha:!0,depth:i,stencil:r,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:d};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${AE}`),t.addEventListener("webglcontextlost",Ht,!1),t.addEventListener("webglcontextrestored",Ce,!1),t.addEventListener("webglcontextcreationerror",St,!1),Ee===null){const We=["webgl2","webgl","experimental-webgl"];if(S.isWebGL1Renderer===!0&&We.shift(),Ee=nn(We,oe),Ee===null)throw nn(We)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&Ee instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),Ee.getShaderPrecisionFormat===void 0&&(Ee.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(oe){throw console.error("THREE.WebGLRenderer: "+oe.message),oe}let gt,vt,wt,Vt,It,zt,Gt,dn,vn,ce,Y,ye,Qe,tt,rt,Pt,pt,At,xe,xt,Ye,kt,Et,bt;function Wt(){gt=new vee(Ee),vt=new hee(Ee,gt,e),gt.init(vt),kt=new nne(Ee,gt,vt),wt=new ene(Ee,gt,vt),Vt=new bee(Ee),It=new Bte,zt=new tne(Ee,gt,wt,It,vt,kt,Vt),Gt=new pee(S),dn=new xee(S),vn=new MZ(Ee,vt),Et=new uee(Ee,gt,vn,vt),ce=new yee(Ee,vn,Vt,Et),Y=new Eee(Ee,ce,vn,Vt),xe=new _ee(Ee,vt,zt),Pt=new fee(It),ye=new zte(S,Gt,dn,gt,vt,Et,Pt),Qe=new ane(S,It),tt=new Vte,rt=new qte(gt,vt),At=new cee(S,Gt,dn,wt,Y,h,l),pt=new Jte(S,Y,vt),bt=new lne(Ee,Vt,vt,wt),xt=new dee(Ee,gt,Vt,vt),Ye=new wee(Ee,gt,Vt,vt),Vt.programs=ye.programs,S.capabilities=vt,S.extensions=gt,S.properties=It,S.renderLists=tt,S.shadowMap=pt,S.state=wt,S.info=Vt}Wt();const ht=new one(S,Ee);this.xr=ht,this.getContext=function(){return Ee},this.getContextAttributes=function(){return Ee.getContextAttributes()},this.forceContextLoss=function(){const oe=gt.get("WEBGL_lose_context");oe&&oe.loseContext()},this.forceContextRestore=function(){const oe=gt.get("WEBGL_lose_context");oe&&oe.restoreContext()},this.getPixelRatio=function(){return J},this.setPixelRatio=function(oe){oe!==void 0&&(J=oe,this.setSize(X,B,!1))},this.getSize=function(oe){return oe.set(X,B)},this.setSize=function(oe,We,Ze=!0){if(ht.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}X=oe,B=We,t.width=Math.floor(oe*J),t.height=Math.floor(We*J),Ze===!0&&(t.style.width=oe+"px",t.style.height=We+"px"),this.setViewport(0,0,oe,We)},this.getDrawingBufferSize=function(oe){return oe.set(X*J,B*J).floor()},this.setDrawingBufferSize=function(oe,We,Ze){X=oe,B=We,J=Ze,t.width=Math.floor(oe*Ze),t.height=Math.floor(We*Ze),this.setViewport(0,0,oe,We)},this.getCurrentViewport=function(oe){return oe.copy(T)},this.getViewport=function(oe){return oe.copy(ne)},this.setViewport=function(oe,We,Ze,Je){oe.isVector4?ne.set(oe.x,oe.y,oe.z,oe.w):ne.set(oe,We,Ze,Je),wt.viewport(T.copy(ne).multiplyScalar(J).floor())},this.getScissor=function(oe){return oe.copy(V)},this.setScissor=function(oe,We,Ze,Je){oe.isVector4?V.set(oe.x,oe.y,oe.z,oe.w):V.set(oe,We,Ze,Je),wt.scissor(M.copy(V).multiplyScalar(J).floor())},this.getScissorTest=function(){return Z},this.setScissorTest=function(oe){wt.setScissorTest(Z=oe)},this.setOpaqueSort=function(oe){K=oe},this.setTransparentSort=function(oe){ee=oe},this.getClearColor=function(oe){return oe.copy(At.getClearColor())},this.setClearColor=function(){At.setClearColor.apply(At,arguments)},this.getClearAlpha=function(){return At.getClearAlpha()},this.setClearAlpha=function(){At.setClearAlpha.apply(At,arguments)},this.clear=function(oe=!0,We=!0,Ze=!0){let Je=0;if(oe){let nt=!1;if(R!==null){const Kt=R.texture.format;nt=Kt===jF||Kt===HF||Kt===GF}if(nt){const Kt=R.texture.type,on=Kt===eu||Kt===Xc||Kt===RE||Kt===ud||Kt===VF||Kt===WF,bn=At.getClearColor(),Yt=At.getClearAlpha(),Bn=bn.r,_n=bn.g,En=bn.b;on?(p[0]=Bn,p[1]=_n,p[2]=En,p[3]=Yt,Ee.clearBufferuiv(Ee.COLOR,0,p)):(g[0]=Bn,g[1]=_n,g[2]=En,g[3]=Yt,Ee.clearBufferiv(Ee.COLOR,0,g))}else Je|=Ee.COLOR_BUFFER_BIT}We&&(Je|=Ee.DEPTH_BUFFER_BIT),Ze&&(Je|=Ee.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Ee.clear(Je)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ht,!1),t.removeEventListener("webglcontextrestored",Ce,!1),t.removeEventListener("webglcontextcreationerror",St,!1),tt.dispose(),rt.dispose(),It.dispose(),Gt.dispose(),dn.dispose(),Y.dispose(),Et.dispose(),bt.dispose(),ye.dispose(),ht.dispose(),ht.removeEventListener("sessionstart",_s),ht.removeEventListener("sessionend",ns),Ie&&(Ie.dispose(),Ie=null),hs.stop()};function Ht(oe){oe.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),C=!0}function Ce(){console.log("THREE.WebGLRenderer: Context Restored."),C=!1;const oe=Vt.autoReset,We=pt.enabled,Ze=pt.autoUpdate,Je=pt.needsUpdate,nt=pt.type;Wt(),Vt.autoReset=oe,pt.enabled=We,pt.autoUpdate=Ze,pt.needsUpdate=Je,pt.type=nt}function St(oe){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",oe.statusMessage)}function dt(oe){const We=oe.target;We.removeEventListener("dispose",dt),Be(We)}function Be(oe){Rt(oe),It.remove(oe)}function Rt(oe){const We=It.get(oe).programs;We!==void 0&&(We.forEach(function(Ze){ye.releaseProgram(Ze)}),oe.isShaderMaterial&&ye.releaseShaderCache(oe))}this.renderBufferDirect=function(oe,We,Ze,Je,nt,Kt){We===null&&(We=ct);const on=nt.isMesh&&nt.matrixWorld.determinant()<0,bn=so(oe,We,Ze,Je,nt);wt.setMaterial(Je,on);let Yt=Ze.index,Bn=1;if(Je.wireframe===!0){if(Yt=ce.getWireframeAttribute(Ze),Yt===void 0)return;Bn=2}const _n=Ze.drawRange,En=Ze.attributes.position;let fs=_n.start*Bn,ws=(_n.start+_n.count)*Bn;Kt!==null&&(fs=Math.max(fs,Kt.start*Bn),ws=Math.min(ws,(Kt.start+Kt.count)*Bn)),Yt!==null?(fs=Math.max(fs,0),ws=Math.min(ws,Yt.count)):En!=null&&(fs=Math.max(fs,0),ws=Math.min(ws,En.count));const Ws=ws-fs;if(Ws<0||Ws===1/0)return;Et.setup(nt,Je,bn,Ze,Yt);let Mi,ss=xt;if(Yt!==null&&(Mi=vn.get(Yt),ss=Ye,ss.setIndex(Mi)),nt.isMesh)Je.wireframe===!0?(wt.setLineWidth(Je.wireframeLinewidth*at()),ss.setMode(Ee.LINES)):ss.setMode(Ee.TRIANGLES);else if(nt.isLine){let Vn=Je.linewidth;Vn===void 0&&(Vn=1),wt.setLineWidth(Vn*at()),nt.isLineSegments?ss.setMode(Ee.LINES):nt.isLineLoop?ss.setMode(Ee.LINE_LOOP):ss.setMode(Ee.LINE_STRIP)}else nt.isPoints?ss.setMode(Ee.POINTS):nt.isSprite&&ss.setMode(Ee.TRIANGLES);if(nt.isInstancedMesh)ss.renderInstances(fs,Ws,nt.count);else if(Ze.isInstancedBufferGeometry){const Vn=Ze._maxInstanceCount!==void 0?Ze._maxInstanceCount:1/0,Ss=Math.min(Ze.instanceCount,Vn);ss.renderInstances(fs,Ws,Ss)}else ss.render(fs,Ws)};function rn(oe,We,Ze){oe.transparent===!0&&oe.side===al&&oe.forceSinglePass===!1?(oe.side=xo,oe.needsUpdate=!0,fr(oe,We,Ze),oe.side=dc,oe.needsUpdate=!0,fr(oe,We,Ze),oe.side=al):fr(oe,We,Ze)}this.compile=function(oe,We,Ze=null){Ze===null&&(Ze=oe),x=rt.get(Ze),x.init(),b.push(x),Ze.traverseVisible(function(nt){nt.isLight&&nt.layers.test(We.layers)&&(x.pushLight(nt),nt.castShadow&&x.pushShadow(nt))}),oe!==Ze&&oe.traverseVisible(function(nt){nt.isLight&&nt.layers.test(We.layers)&&(x.pushLight(nt),nt.castShadow&&x.pushShadow(nt))}),x.setupLights(S._useLegacyLights);const Je=new Set;return oe.traverse(function(nt){const Kt=nt.material;if(Kt)if(Array.isArray(Kt))for(let on=0;on<Kt.length;on++){const bn=Kt[on];rn(bn,Ze,nt),Je.add(bn)}else rn(Kt,Ze,nt),Je.add(Kt)}),b.pop(),x=null,Je},this.compileAsync=function(oe,We,Ze=null){const Je=this.compile(oe,We,Ze);return new Promise(nt=>{function Kt(){if(Je.forEach(function(on){It.get(on).currentProgram.isReady()&&Je.delete(on)}),Je.size===0){nt(oe);return}setTimeout(Kt,10)}gt.get("KHR_parallel_shader_compile")!==null?Kt():setTimeout(Kt,10)})};let In=null;function zn(oe){In&&In(oe)}function _s(){hs.stop()}function ns(){hs.start()}const hs=new cO;hs.setAnimationLoop(zn),typeof self<"u"&&hs.setContext(self),this.setAnimationLoop=function(oe){In=oe,ht.setAnimationLoop(oe),oe===null?hs.stop():hs.start()},ht.addEventListener("sessionstart",_s),ht.addEventListener("sessionend",ns),this.render=function(oe,We){if(We!==void 0&&We.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(C===!0)return;oe.matrixWorldAutoUpdate===!0&&oe.updateMatrixWorld(),We.parent===null&&We.matrixWorldAutoUpdate===!0&&We.updateMatrixWorld(),ht.enabled===!0&&ht.isPresenting===!0&&(ht.cameraAutoUpdate===!0&&ht.updateCamera(We),We=ht.getCamera()),oe.isScene===!0&&oe.onBeforeRender(S,oe,We,R),x=rt.get(oe,b.length),x.init(),b.push(x),Xe.multiplyMatrices(We.projectionMatrix,We.matrixWorldInverse),he.setFromProjectionMatrix(Xe),be=this.localClippingEnabled,ve=Pt.init(this.clippingPlanes,be),y=tt.get(oe,v.length),y.init(),v.push(y),Ls(oe,We,0,S.sortObjects),y.finish(),S.sortObjects===!0&&y.sort(K,ee),this.info.render.frame++,ve===!0&&Pt.beginShadows();const Ze=x.state.shadowsArray;if(pt.render(Ze,oe,We),ve===!0&&Pt.endShadows(),this.info.autoReset===!0&&this.info.reset(),At.render(y,oe),x.setupLights(S._useLegacyLights),We.isArrayCamera){const Je=We.cameras;for(let nt=0,Kt=Je.length;nt<Kt;nt++){const on=Je[nt];Or(y,oe,on,on.viewport)}}else Or(y,oe,We);R!==null&&(zt.updateMultisampleRenderTarget(R),zt.updateRenderTargetMipmap(R)),oe.isScene===!0&&oe.onAfterRender(S,oe,We),Et.resetDefaultState(),L=-1,I=null,b.pop(),b.length>0?x=b[b.length-1]:x=null,v.pop(),v.length>0?y=v[v.length-1]:y=null};function Ls(oe,We,Ze,Je){if(oe.visible===!1)return;if(oe.layers.test(We.layers)){if(oe.isGroup)Ze=oe.renderOrder;else if(oe.isLOD)oe.autoUpdate===!0&&oe.update(We);else if(oe.isLight)x.pushLight(oe),oe.castShadow&&x.pushShadow(oe);else if(oe.isSprite){if(!oe.frustumCulled||he.intersectsSprite(oe)){Je&&Pe.setFromMatrixPosition(oe.matrixWorld).applyMatrix4(Xe);const on=Y.update(oe),bn=oe.material;bn.visible&&y.push(oe,on,bn,Ze,Pe.z,null)}}else if((oe.isMesh||oe.isLine||oe.isPoints)&&(!oe.frustumCulled||he.intersectsObject(oe))){const on=Y.update(oe),bn=oe.material;if(Je&&(oe.boundingSphere!==void 0?(oe.boundingSphere===null&&oe.computeBoundingSphere(),Pe.copy(oe.boundingSphere.center)):(on.boundingSphere===null&&on.computeBoundingSphere(),Pe.copy(on.boundingSphere.center)),Pe.applyMatrix4(oe.matrixWorld).applyMatrix4(Xe)),Array.isArray(bn)){const Yt=on.groups;for(let Bn=0,_n=Yt.length;Bn<_n;Bn++){const En=Yt[Bn],fs=bn[En.materialIndex];fs&&fs.visible&&y.push(oe,on,fs,Ze,Pe.z,En)}}else bn.visible&&y.push(oe,on,bn,Ze,Pe.z,null)}}const Kt=oe.children;for(let on=0,bn=Kt.length;on<bn;on++)Ls(Kt[on],We,Ze,Je)}function Or(oe,We,Ze,Je){const nt=oe.opaque,Kt=oe.transmissive,on=oe.transparent;x.setupLightsView(Ze),ve===!0&&Pt.setGlobalState(S.clippingPlanes,Ze),Kt.length>0&&So(nt,Kt,We,Ze),Je&&wt.viewport(T.copy(Je)),nt.length>0&&ks(nt,We,Ze),Kt.length>0&&ks(Kt,We,Ze),on.length>0&&ks(on,We,Ze),wt.buffers.depth.setTest(!0),wt.buffers.depth.setMask(!0),wt.buffers.color.setMask(!0),wt.setPolygonOffset(!1)}function So(oe,We,Ze,Je){if((Ze.isScene===!0?Ze.overrideMaterial:null)!==null)return;const Kt=vt.isWebGL2;Ie===null&&(Ie=new yd(1,1,{generateMipmaps:!0,type:gt.has("EXT_color_buffer_half_float")?Rg:eu,minFilter:vd,samples:Kt?4:0})),S.getDrawingBufferSize(Fe),Kt?Ie.setSize(Fe.x,Fe.y):Ie.setSize(c2(Fe.x),c2(Fe.y));const on=S.getRenderTarget();S.setRenderTarget(Ie),S.getClearColor(W),z=S.getClearAlpha(),z<1&&S.setClearColor(16777215,.5),S.clear();const bn=S.toneMapping;S.toneMapping=Jc,ks(oe,Ze,Je),zt.updateMultisampleRenderTarget(Ie),zt.updateRenderTargetMipmap(Ie);let Yt=!1;for(let Bn=0,_n=We.length;Bn<_n;Bn++){const En=We[Bn],fs=En.object,ws=En.geometry,Ws=En.material,Mi=En.group;if(Ws.side===al&&fs.layers.test(Je.layers)){const ss=Ws.side;Ws.side=xo,Ws.needsUpdate=!0,Ri(fs,Ze,Je,ws,Ws,Mi),Ws.side=ss,Ws.needsUpdate=!0,Yt=!0}}Yt===!0&&(zt.updateMultisampleRenderTarget(Ie),zt.updateRenderTargetMipmap(Ie)),S.setRenderTarget(on),S.setClearColor(W,z),S.toneMapping=bn}function ks(oe,We,Ze){const Je=We.isScene===!0?We.overrideMaterial:null;for(let nt=0,Kt=oe.length;nt<Kt;nt++){const on=oe[nt],bn=on.object,Yt=on.geometry,Bn=Je===null?on.material:Je,_n=on.group;bn.layers.test(Ze.layers)&&Ri(bn,We,Ze,Yt,Bn,_n)}}function Ri(oe,We,Ze,Je,nt,Kt){oe.onBeforeRender(S,We,Ze,Je,nt,Kt),oe.modelViewMatrix.multiplyMatrices(Ze.matrixWorldInverse,oe.matrixWorld),oe.normalMatrix.getNormalMatrix(oe.modelViewMatrix),nt.onBeforeRender(S,We,Ze,Je,oe,Kt),nt.transparent===!0&&nt.side===al&&nt.forceSinglePass===!1?(nt.side=xo,nt.needsUpdate=!0,S.renderBufferDirect(Ze,We,Je,nt,oe,Kt),nt.side=dc,nt.needsUpdate=!0,S.renderBufferDirect(Ze,We,Je,nt,oe,Kt),nt.side=al):S.renderBufferDirect(Ze,We,Je,nt,oe,Kt),oe.onAfterRender(S,We,Ze,Je,nt,Kt)}function fr(oe,We,Ze){We.isScene!==!0&&(We=ct);const Je=It.get(oe),nt=x.state.lights,Kt=x.state.shadowsArray,on=nt.state.version,bn=ye.getParameters(oe,nt.state,Kt,We,Ze),Yt=ye.getProgramCacheKey(bn);let Bn=Je.programs;Je.environment=oe.isMeshStandardMaterial?We.environment:null,Je.fog=We.fog,Je.envMap=(oe.isMeshStandardMaterial?dn:Gt).get(oe.envMap||Je.environment),Bn===void 0&&(oe.addEventListener("dispose",dt),Bn=new Map,Je.programs=Bn);let _n=Bn.get(Yt);if(_n!==void 0){if(Je.currentProgram===_n&&Je.lightsStateVersion===on)return ua(oe,bn),_n}else bn.uniforms=ye.getUniforms(oe),oe.onBuild(Ze,bn,S),oe.onBeforeCompile(bn,S),_n=ye.acquireProgram(bn,Yt),Bn.set(Yt,_n),Je.uniforms=bn.uniforms;const En=Je.uniforms;return(!oe.isShaderMaterial&&!oe.isRawShaderMaterial||oe.clipping===!0)&&(En.clippingPlanes=Pt.uniform),ua(oe,bn),Je.needsLights=Co(oe),Je.lightsStateVersion=on,Je.needsLights&&(En.ambientLightColor.value=nt.state.ambient,En.lightProbe.value=nt.state.probe,En.directionalLights.value=nt.state.directional,En.directionalLightShadows.value=nt.state.directionalShadow,En.spotLights.value=nt.state.spot,En.spotLightShadows.value=nt.state.spotShadow,En.rectAreaLights.value=nt.state.rectArea,En.ltc_1.value=nt.state.rectAreaLTC1,En.ltc_2.value=nt.state.rectAreaLTC2,En.pointLights.value=nt.state.point,En.pointLightShadows.value=nt.state.pointShadow,En.hemisphereLights.value=nt.state.hemi,En.directionalShadowMap.value=nt.state.directionalShadowMap,En.directionalShadowMatrix.value=nt.state.directionalShadowMatrix,En.spotShadowMap.value=nt.state.spotShadowMap,En.spotLightMatrix.value=nt.state.spotLightMatrix,En.spotLightMap.value=nt.state.spotLightMap,En.pointShadowMap.value=nt.state.pointShadowMap,En.pointShadowMatrix.value=nt.state.pointShadowMatrix),Je.currentProgram=_n,Je.uniformsList=null,_n}function no(oe){if(oe.uniformsList===null){const We=oe.currentProgram.getUniforms();oe.uniformsList=Dv.seqWithValue(We.seq,oe.uniforms)}return oe.uniformsList}function ua(oe,We){const Ze=It.get(oe);Ze.outputColorSpace=We.outputColorSpace,Ze.instancing=We.instancing,Ze.instancingColor=We.instancingColor,Ze.skinning=We.skinning,Ze.morphTargets=We.morphTargets,Ze.morphNormals=We.morphNormals,Ze.morphColors=We.morphColors,Ze.morphTargetsCount=We.morphTargetsCount,Ze.numClippingPlanes=We.numClippingPlanes,Ze.numIntersection=We.numClipIntersection,Ze.vertexAlphas=We.vertexAlphas,Ze.vertexTangents=We.vertexTangents,Ze.toneMapping=We.toneMapping}function so(oe,We,Ze,Je,nt){We.isScene!==!0&&(We=ct),zt.resetTextureUnits();const Kt=We.fog,on=Je.isMeshStandardMaterial?We.environment:null,bn=R===null?S.outputColorSpace:R.isXRRenderTarget===!0?R.texture.colorSpace:yr,Yt=(Je.isMeshStandardMaterial?dn:Gt).get(Je.envMap||on),Bn=Je.vertexColors===!0&&!!Ze.attributes.color&&Ze.attributes.color.itemSize===4,_n=!!Ze.attributes.tangent&&(!!Je.normalMap||Je.anisotropy>0),En=!!Ze.morphAttributes.position,fs=!!Ze.morphAttributes.normal,ws=!!Ze.morphAttributes.color;let Ws=Jc;Je.toneMapped&&(R===null||R.isXRRenderTarget===!0)&&(Ws=S.toneMapping);const Mi=Ze.morphAttributes.position||Ze.morphAttributes.normal||Ze.morphAttributes.color,ss=Mi!==void 0?Mi.length:0,Vn=It.get(Je),Ss=x.state.lights;if(ve===!0&&(be===!0||oe!==I)){const mt=oe===I&&Je.id===L;Pt.setState(Je,oe,mt)}let D=!1;Je.version===Vn.__version?(Vn.needsLights&&Vn.lightsStateVersion!==Ss.state.version||Vn.outputColorSpace!==bn||nt.isInstancedMesh&&Vn.instancing===!1||!nt.isInstancedMesh&&Vn.instancing===!0||nt.isSkinnedMesh&&Vn.skinning===!1||!nt.isSkinnedMesh&&Vn.skinning===!0||nt.isInstancedMesh&&Vn.instancingColor===!0&&nt.instanceColor===null||nt.isInstancedMesh&&Vn.instancingColor===!1&&nt.instanceColor!==null||Vn.envMap!==Yt||Je.fog===!0&&Vn.fog!==Kt||Vn.numClippingPlanes!==void 0&&(Vn.numClippingPlanes!==Pt.numPlanes||Vn.numIntersection!==Pt.numIntersection)||Vn.vertexAlphas!==Bn||Vn.vertexTangents!==_n||Vn.morphTargets!==En||Vn.morphNormals!==fs||Vn.morphColors!==ws||Vn.toneMapping!==Ws||vt.isWebGL2===!0&&Vn.morphTargetsCount!==ss)&&(D=!0):(D=!0,Vn.__version=Je.version);let H=Vn.currentProgram;D===!0&&(H=fr(Je,We,nt));let q=!1,pe=!1,Oe=!1;const st=H.getUniforms(),Ue=Vn.uniforms;if(wt.useProgram(H.program)&&(q=!0,pe=!0,Oe=!0),Je.id!==L&&(L=Je.id,pe=!0),q||I!==oe){st.setValue(Ee,"projectionMatrix",oe.projectionMatrix),st.setValue(Ee,"viewMatrix",oe.matrixWorldInverse);const mt=st.map.cameraPosition;mt!==void 0&&mt.setValue(Ee,Pe.setFromMatrixPosition(oe.matrixWorld)),vt.logarithmicDepthBuffer&&st.setValue(Ee,"logDepthBufFC",2/(Math.log(oe.far+1)/Math.LN2)),(Je.isMeshPhongMaterial||Je.isMeshToonMaterial||Je.isMeshLambertMaterial||Je.isMeshBasicMaterial||Je.isMeshStandardMaterial||Je.isShaderMaterial)&&st.setValue(Ee,"isOrthographic",oe.isOrthographicCamera===!0),I!==oe&&(I=oe,pe=!0,Oe=!0)}if(nt.isSkinnedMesh){st.setOptional(Ee,nt,"bindMatrix"),st.setOptional(Ee,nt,"bindMatrixInverse");const mt=nt.skeleton;mt&&(vt.floatVertexTextures?(mt.boneTexture===null&&mt.computeBoneTexture(),st.setValue(Ee,"boneTexture",mt.boneTexture,zt),st.setValue(Ee,"boneTextureSize",mt.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const ot=Ze.morphAttributes;if((ot.position!==void 0||ot.normal!==void 0||ot.color!==void 0&&vt.isWebGL2===!0)&&xe.update(nt,Ze,H),(pe||Vn.receiveShadow!==nt.receiveShadow)&&(Vn.receiveShadow=nt.receiveShadow,st.setValue(Ee,"receiveShadow",nt.receiveShadow)),Je.isMeshGouraudMaterial&&Je.envMap!==null&&(Ue.envMap.value=Yt,Ue.flipEnvMap.value=Yt.isCubeTexture&&Yt.isRenderTargetTexture===!1?-1:1),pe&&(st.setValue(Ee,"toneMappingExposure",S.toneMappingExposure),Vn.needsLights&&pr(Ue,Oe),Kt&&Je.fog===!0&&Qe.refreshFogUniforms(Ue,Kt),Qe.refreshMaterialUniforms(Ue,Je,J,B,Ie),Dv.upload(Ee,no(Vn),Ue,zt)),Je.isShaderMaterial&&Je.uniformsNeedUpdate===!0&&(Dv.upload(Ee,no(Vn),Ue,zt),Je.uniformsNeedUpdate=!1),Je.isSpriteMaterial&&st.setValue(Ee,"center",nt.center),st.setValue(Ee,"modelViewMatrix",nt.modelViewMatrix),st.setValue(Ee,"normalMatrix",nt.normalMatrix),st.setValue(Ee,"modelMatrix",nt.matrixWorld),Je.isShaderMaterial||Je.isRawShaderMaterial){const mt=Je.uniformsGroups;for(let qt=0,Tn=mt.length;qt<Tn;qt++)if(vt.isWebGL2){const Jn=mt[qt];bt.update(Jn,H),bt.bind(Jn,H)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return H}function pr(oe,We){oe.ambientLightColor.needsUpdate=We,oe.lightProbe.needsUpdate=We,oe.directionalLights.needsUpdate=We,oe.directionalLightShadows.needsUpdate=We,oe.pointLights.needsUpdate=We,oe.pointLightShadows.needsUpdate=We,oe.spotLights.needsUpdate=We,oe.spotLightShadows.needsUpdate=We,oe.rectAreaLights.needsUpdate=We,oe.hemisphereLights.needsUpdate=We}function Co(oe){return oe.isMeshLambertMaterial||oe.isMeshToonMaterial||oe.isMeshPhongMaterial||oe.isMeshStandardMaterial||oe.isShadowMaterial||oe.isShaderMaterial&&oe.lights===!0}this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return k},this.getRenderTarget=function(){return R},this.setRenderTargetTextures=function(oe,We,Ze){It.get(oe.texture).__webglTexture=We,It.get(oe.depthTexture).__webglTexture=Ze;const Je=It.get(oe);Je.__hasExternalTextures=!0,Je.__hasExternalTextures&&(Je.__autoAllocateDepthBuffer=Ze===void 0,Je.__autoAllocateDepthBuffer||gt.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Je.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(oe,We){const Ze=It.get(oe);Ze.__webglFramebuffer=We,Ze.__useDefaultFramebuffer=We===void 0},this.setRenderTarget=function(oe,We=0,Ze=0){R=oe,E=We,k=Ze;let Je=!0,nt=null,Kt=!1,on=!1;if(oe){const Yt=It.get(oe);Yt.__useDefaultFramebuffer!==void 0?(wt.bindFramebuffer(Ee.FRAMEBUFFER,null),Je=!1):Yt.__webglFramebuffer===void 0?zt.setupRenderTarget(oe):Yt.__hasExternalTextures&&zt.rebindTextures(oe,It.get(oe.texture).__webglTexture,It.get(oe.depthTexture).__webglTexture);const Bn=oe.texture;(Bn.isData3DTexture||Bn.isDataArrayTexture||Bn.isCompressedArrayTexture)&&(on=!0);const _n=It.get(oe).__webglFramebuffer;oe.isWebGLCubeRenderTarget?(Array.isArray(_n[We])?nt=_n[We][Ze]:nt=_n[We],Kt=!0):vt.isWebGL2&&oe.samples>0&&zt.useMultisampledRTT(oe)===!1?nt=It.get(oe).__webglMultisampledFramebuffer:Array.isArray(_n)?nt=_n[Ze]:nt=_n,T.copy(oe.viewport),M.copy(oe.scissor),j=oe.scissorTest}else T.copy(ne).multiplyScalar(J).floor(),M.copy(V).multiplyScalar(J).floor(),j=Z;if(wt.bindFramebuffer(Ee.FRAMEBUFFER,nt)&&vt.drawBuffers&&Je&&wt.drawBuffers(oe,nt),wt.viewport(T),wt.scissor(M),wt.setScissorTest(j),Kt){const Yt=It.get(oe.texture);Ee.framebufferTexture2D(Ee.FRAMEBUFFER,Ee.COLOR_ATTACHMENT0,Ee.TEXTURE_CUBE_MAP_POSITIVE_X+We,Yt.__webglTexture,Ze)}else if(on){const Yt=It.get(oe.texture),Bn=We||0;Ee.framebufferTextureLayer(Ee.FRAMEBUFFER,Ee.COLOR_ATTACHMENT0,Yt.__webglTexture,Ze||0,Bn)}L=-1},this.readRenderTargetPixels=function(oe,We,Ze,Je,nt,Kt,on){if(!(oe&&oe.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let bn=It.get(oe).__webglFramebuffer;if(oe.isWebGLCubeRenderTarget&&on!==void 0&&(bn=bn[on]),bn){wt.bindFramebuffer(Ee.FRAMEBUFFER,bn);try{const Yt=oe.texture,Bn=Yt.format,_n=Yt.type;if(Bn!==ta&&kt.convert(Bn)!==Ee.getParameter(Ee.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const En=_n===Rg&&(gt.has("EXT_color_buffer_half_float")||vt.isWebGL2&&gt.has("EXT_color_buffer_float"));if(_n!==eu&&kt.convert(_n)!==Ee.getParameter(Ee.IMPLEMENTATION_COLOR_READ_TYPE)&&!(_n===sc&&(vt.isWebGL2||gt.has("OES_texture_float")||gt.has("WEBGL_color_buffer_float")))&&!En){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}We>=0&&We<=oe.width-Je&&Ze>=0&&Ze<=oe.height-nt&&Ee.readPixels(We,Ze,Je,nt,kt.convert(Bn),kt.convert(_n),Kt)}finally{const Yt=R!==null?It.get(R).__webglFramebuffer:null;wt.bindFramebuffer(Ee.FRAMEBUFFER,Yt)}}},this.copyFramebufferToTexture=function(oe,We,Ze=0){const Je=Math.pow(2,-Ze),nt=Math.floor(We.image.width*Je),Kt=Math.floor(We.image.height*Je);zt.setTexture2D(We,0),Ee.copyTexSubImage2D(Ee.TEXTURE_2D,Ze,0,0,oe.x,oe.y,nt,Kt),wt.unbindTexture()},this.copyTextureToTexture=function(oe,We,Ze,Je=0){const nt=We.image.width,Kt=We.image.height,on=kt.convert(Ze.format),bn=kt.convert(Ze.type);zt.setTexture2D(Ze,0),Ee.pixelStorei(Ee.UNPACK_FLIP_Y_WEBGL,Ze.flipY),Ee.pixelStorei(Ee.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Ze.premultiplyAlpha),Ee.pixelStorei(Ee.UNPACK_ALIGNMENT,Ze.unpackAlignment),We.isDataTexture?Ee.texSubImage2D(Ee.TEXTURE_2D,Je,oe.x,oe.y,nt,Kt,on,bn,We.image.data):We.isCompressedTexture?Ee.compressedTexSubImage2D(Ee.TEXTURE_2D,Je,oe.x,oe.y,We.mipmaps[0].width,We.mipmaps[0].height,on,We.mipmaps[0].data):Ee.texSubImage2D(Ee.TEXTURE_2D,Je,oe.x,oe.y,on,bn,We.image),Je===0&&Ze.generateMipmaps&&Ee.generateMipmap(Ee.TEXTURE_2D),wt.unbindTexture()},this.copyTextureToTexture3D=function(oe,We,Ze,Je,nt=0){if(S.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Kt=oe.max.x-oe.min.x+1,on=oe.max.y-oe.min.y+1,bn=oe.max.z-oe.min.z+1,Yt=kt.convert(Je.format),Bn=kt.convert(Je.type);let _n;if(Je.isData3DTexture)zt.setTexture3D(Je,0),_n=Ee.TEXTURE_3D;else if(Je.isDataArrayTexture)zt.setTexture2DArray(Je,0),_n=Ee.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Ee.pixelStorei(Ee.UNPACK_FLIP_Y_WEBGL,Je.flipY),Ee.pixelStorei(Ee.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Je.premultiplyAlpha),Ee.pixelStorei(Ee.UNPACK_ALIGNMENT,Je.unpackAlignment);const En=Ee.getParameter(Ee.UNPACK_ROW_LENGTH),fs=Ee.getParameter(Ee.UNPACK_IMAGE_HEIGHT),ws=Ee.getParameter(Ee.UNPACK_SKIP_PIXELS),Ws=Ee.getParameter(Ee.UNPACK_SKIP_ROWS),Mi=Ee.getParameter(Ee.UNPACK_SKIP_IMAGES),ss=Ze.isCompressedTexture?Ze.mipmaps[0]:Ze.image;Ee.pixelStorei(Ee.UNPACK_ROW_LENGTH,ss.width),Ee.pixelStorei(Ee.UNPACK_IMAGE_HEIGHT,ss.height),Ee.pixelStorei(Ee.UNPACK_SKIP_PIXELS,oe.min.x),Ee.pixelStorei(Ee.UNPACK_SKIP_ROWS,oe.min.y),Ee.pixelStorei(Ee.UNPACK_SKIP_IMAGES,oe.min.z),Ze.isDataTexture||Ze.isData3DTexture?Ee.texSubImage3D(_n,nt,We.x,We.y,We.z,Kt,on,bn,Yt,Bn,ss.data):Ze.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Ee.compressedTexSubImage3D(_n,nt,We.x,We.y,We.z,Kt,on,bn,Yt,ss.data)):Ee.texSubImage3D(_n,nt,We.x,We.y,We.z,Kt,on,bn,Yt,Bn,ss),Ee.pixelStorei(Ee.UNPACK_ROW_LENGTH,En),Ee.pixelStorei(Ee.UNPACK_IMAGE_HEIGHT,fs),Ee.pixelStorei(Ee.UNPACK_SKIP_PIXELS,ws),Ee.pixelStorei(Ee.UNPACK_SKIP_ROWS,Ws),Ee.pixelStorei(Ee.UNPACK_SKIP_IMAGES,Mi),nt===0&&Je.generateMipmaps&&Ee.generateMipmap(_n),wt.unbindTexture()},this.initTexture=function(oe){oe.isCubeTexture?zt.setTextureCube(oe,0):oe.isData3DTexture?zt.setTexture3D(oe,0):oe.isDataArrayTexture||oe.isCompressedArrayTexture?zt.setTexture2DArray(oe,0):zt.setTexture2D(oe,0),wt.unbindTexture()},this.resetState=function(){E=0,k=0,R=null,wt.reset(),Et.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return ic}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===ME?"display-p3":"srgb",t.unpackColorSpace=Ps.workingColorSpace===iy?"display-p3":"srgb"}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(e){console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!e}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===hi?hd:qF}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===hd?hi:yr}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class cne extends pO{}cne.prototype.isWebGL1Renderer=!0;class une extends mi{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class dne{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=LC,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Aa()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[s+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Aa()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Aa()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Vr=new Ne;class $E{constructor(e,t,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)Vr.fromBufferAttribute(this,t),Vr.applyMatrix4(e),this.setXYZ(t,Vr.x,Vr.y,Vr.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Vr.fromBufferAttribute(this,t),Vr.applyNormalMatrix(e),this.setXYZ(t,Vr.x,Vr.y,Vr.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Vr.fromBufferAttribute(this,t),Vr.transformDirection(e),this.setXYZ(t,Vr.x,Vr.y,Vr.z);return this}setX(e,t){return this.normalized&&(t=Us(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Us(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Us(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Us(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=ll(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=ll(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=ll(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=ll(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Us(t,this.array),s=Us(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Us(t,this.array),s=Us(s,this.array),i=Us(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Us(t,this.array),s=Us(s,this.array),i=Us(i,this.array),r=Us(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Kr(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new $E(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const dN=new Ne,hN=new qs,fN=new qs,hne=new Ne,pN=new us,Qx=new Ne,bS=new Rl,mN=new us,SS=new r0;class fne extends Mo{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=KR,this.bindMatrix=new us,this.bindMatrixInverse=new us,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new La),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,Qx),this.boundingBox.expandByPoint(Qx)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Rl),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,Qx),this.boundingSphere.expandByPoint(Qx)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const s=this.material,i=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),bS.copy(this.boundingSphere),bS.applyMatrix4(i),e.ray.intersectsSphere(bS)!==!1&&(mN.copy(i).invert(),SS.copy(e.ray).applyMatrix4(mN),!(this.boundingBox!==null&&SS.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,SS)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new qs,t=this.geometry.attributes.skinWeight;for(let s=0,i=t.count;s<i;s++){e.fromBufferAttribute(t,s);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===KR?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===_Y?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const s=this.skeleton,i=this.geometry;hN.fromBufferAttribute(i.attributes.skinIndex,e),fN.fromBufferAttribute(i.attributes.skinWeight,e),dN.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const o=fN.getComponent(r);if(o!==0){const a=hN.getComponent(r);pN.multiplyMatrices(s.bones[a].matrixWorld,s.boneInverses[a]),t.addScaledVector(hne.copy(dN).applyMatrix4(pN),o)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class mO extends mi{constructor(){super(),this.isBone=!0,this.type="Bone"}}class pne extends vr{constructor(e=null,t=1,s=1,i,r,o,a,l,c=ar,u=ar,d,h){super(null,o,a,l,c,u,i,r,d,h),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const gN=new us,mne=new us;class FE{constructor(e=[],t=[]){this.uuid=Aa(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,i=this.bones.length;s<i;s++)this.boneInverses.push(new us)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new us;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,i=this.boneTexture;for(let r=0,o=e.length;r<o;r++){const a=e[r]?e[r].matrixWorld:mne;gN.multiplyMatrices(a,t[r]),gN.toArray(s,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new FE(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=YF(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new pne(t,e,e,ta,sc);return s.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=s,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,i=e.bones.length;s<i;s++){const r=e.bones[s];let o=t[r];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new mO),this.bones.push(o),this.boneInverses.push(new us().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const o=t[i];e.bones.push(o.uuid);const a=s[i];e.boneInverses.push(a.toArray())}return e}}class zC extends Kr{constructor(e,t,s,i=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Uh=new us,xN=new us,Jx=[],vN=new La,gne=new us,Um=new Mo,Vm=new Rl;class xne extends Mo{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new zC(new Float32Array(s*16),16),this.instanceColor=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<s;i++)this.setMatrixAt(i,gne)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new La),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,Uh),vN.copy(e.boundingBox).applyMatrix4(Uh),this.boundingBox.union(vN)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new Rl),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,Uh),Vm.copy(e.boundingSphere).applyMatrix4(Uh),this.boundingSphere.union(Vm)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const s=this.matrixWorld,i=this.count;if(Um.geometry=this.geometry,Um.material=this.material,Um.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Vm.copy(this.boundingSphere),Vm.applyMatrix4(s),e.ray.intersectsSphere(Vm)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,Uh),xN.multiplyMatrices(s,Uh),Um.matrixWorld=xN,Um.raycast(e,Jx);for(let o=0,a=Jx.length;o<a;o++){const l=Jx[o];l.instanceId=r,l.object=this,t.push(l)}Jx.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new zC(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class OE extends ml{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Kn(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const yN=new Ne,wN=new Ne,bN=new us,CS=new r0,ev=new Rl;class zE extends mi{constructor(e=new Va,t=new OE){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let i=1,r=t.count;i<r;i++)yN.fromBufferAttribute(t,i-1),wN.fromBufferAttribute(t,i),s[i]=s[i-1],s[i]+=yN.distanceTo(wN);e.setAttribute("lineDistance",new Ra(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),ev.copy(s.boundingSphere),ev.applyMatrix4(i),ev.radius+=r,e.ray.intersectsSphere(ev)===!1)return;bN.copy(i).invert(),CS.copy(e.ray).applyMatrix4(bN);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new Ne,u=new Ne,d=new Ne,h=new Ne,p=this.isLineSegments?2:1,g=s.index,x=s.attributes.position;if(g!==null){const v=Math.max(0,o.start),b=Math.min(g.count,o.start+o.count);for(let S=v,C=b-1;S<C;S+=p){const E=g.getX(S),k=g.getX(S+1);if(c.fromBufferAttribute(x,E),u.fromBufferAttribute(x,k),CS.distanceSqToSegment(c,u,h,d)>l)continue;h.applyMatrix4(this.matrixWorld);const L=e.ray.origin.distanceTo(h);L<e.near||L>e.far||t.push({distance:L,point:d.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}else{const v=Math.max(0,o.start),b=Math.min(x.count,o.start+o.count);for(let S=v,C=b-1;S<C;S+=p){if(c.fromBufferAttribute(x,S),u.fromBufferAttribute(x,S+1),CS.distanceSqToSegment(c,u,h,d)>l)continue;h.applyMatrix4(this.matrixWorld);const k=e.ray.origin.distanceTo(h);k<e.near||k>e.far||t.push({distance:k,point:d.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}const SN=new Ne,CN=new Ne;class gO extends zE{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let i=0,r=t.count;i<r;i+=2)SN.fromBufferAttribute(t,i),CN.fromBufferAttribute(t,i+1),s[i]=i===0?0:s[i-1],s[i+1]=s[i]+SN.distanceTo(CN);e.setAttribute("lineDistance",new Ra(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class vne extends zE{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class xO extends ml{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Kn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const _N=new us,BC=new r0,tv=new Rl,nv=new Ne;class yne extends mi{constructor(e=new Va,t=new xO){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),tv.copy(s.boundingSphere),tv.applyMatrix4(i),tv.radius+=r,e.ray.intersectsSphere(tv)===!1)return;_N.copy(i).invert(),BC.copy(e.ray).applyMatrix4(_N);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=s.index,d=s.attributes.position;if(c!==null){const h=Math.max(0,o.start),p=Math.min(c.count,o.start+o.count);for(let g=h,y=p;g<y;g++){const x=c.getX(g);nv.fromBufferAttribute(d,x),EN(nv,x,l,i,e,t,this)}}else{const h=Math.max(0,o.start),p=Math.min(d.count,o.start+o.count);for(let g=h,y=p;g<y;g++)nv.fromBufferAttribute(d,g),EN(nv,g,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=i.length;r<o;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}function EN(n,e,t,s,i,r,o){const a=BC.distanceSqToPoint(n);if(a<t){const l=new Ne;BC.closestPointToPoint(n,l),l.applyMatrix4(s);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class ly extends ml{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Kn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Kn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=KF,this.normalScale=new Zn(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class fu extends ly{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Zn(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return xr(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Kn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Kn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Kn(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}function sv(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function wne(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function bne(n){function e(i,r){return n[i]-n[r]}const t=n.length,s=new Array(t);for(let i=0;i!==t;++i)s[i]=i;return s.sort(e),s}function TN(n,e,t){const s=n.length,i=new n.constructor(s);for(let r=0,o=0;o!==s;++r){const a=t[r]*e;for(let l=0;l!==e;++l)i[o++]=n[a+l]}return i}function vO(n,e,t,s){let i=1,r=n[0];for(;r!==void 0&&r[s]===void 0;)r=n[i++];if(r===void 0)return;let o=r[s];if(o!==void 0)if(Array.isArray(o))do o=r[s],o!==void 0&&(e.push(r.time),t.push.apply(t,o)),r=n[i++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[s],o!==void 0&&(e.push(r.time),o.toArray(t,t.length)),r=n[i++];while(r!==void 0);else do o=r[s],o!==void 0&&(e.push(r.time),t.push(o)),r=n[i++];while(r!==void 0)}class a0{constructor(e,t,s,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,i=t[s],r=t[s-1];e:{t:{let o;n:{s:if(!(e<i)){for(let a=s+2;;){if(i===void 0){if(e<r)break s;return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===a)break;if(r=i,i=t[++s],e<i)break t}o=t.length;break n}if(!(e>=r)){const a=t[1];e<a&&(s=2,r=a);for(let l=s-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(i=r,r=t[--s-1],e>=r)break t}o=s,s=0;break n}break e}for(;s<o;){const a=s+o>>>1;e<t[a]?o=a:s=a+1}if(i=t[s],r=t[s-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,r,i)}return this.interpolate_(s,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i;for(let o=0;o!==i;++o)t[o]=s[r+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Sne extends a0{constructor(e,t,s,i){super(e,t,s,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:bM,endingEnd:bM}}intervalChanged_(e,t,s){const i=this.parameterPositions;let r=e-2,o=e+1,a=i[r],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case SM:r=e,a=2*t-s;break;case CM:r=i.length-2,a=t+i[r]-i[r+1];break;default:r=e,a=s}if(l===void 0)switch(this.getSettings_().endingEnd){case SM:o=e,l=2*s-t;break;case CM:o=1,l=s+i[1]-i[0];break;default:o=e-1,l=t}const c=(s-t)*.5,u=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-s),this._offsetPrev=r*u,this._offsetNext=o*u}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=this._offsetPrev,d=this._offsetNext,h=this._weightPrev,p=this._weightNext,g=(s-t)/(i-t),y=g*g,x=y*g,v=-h*x+2*h*y-h*g,b=(1+h)*x+(-1.5-2*h)*y+(-.5+h)*g+1,S=(-1-p)*x+(1.5+p)*y+.5*g,C=p*x-p*y;for(let E=0;E!==a;++E)r[E]=v*o[u+E]+b*o[c+E]+S*o[l+E]+C*o[d+E];return r}}class Cne extends a0{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=(s-t)/(i-t),d=1-u;for(let h=0;h!==a;++h)r[h]=o[c+h]*d+o[l+h]*u;return r}}class _ne extends a0{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Ml{constructor(e,t,s,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=sv(t,this.TimeBufferType),this.values=sv(s,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:sv(e.times,Array),values:sv(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(s.interpolation=i)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new _ne(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Cne(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Sne(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Mg:t=this.InterpolantFactoryMethodDiscrete;break;case bf:t=this.InterpolantFactoryMethodLinear;break;case Z3:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Mg;case this.InterpolantFactoryMethodLinear:return bf;case this.InterpolantFactoryMethodSmooth:return Z3}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]*=e}return this}trim(e,t){const s=this.times,i=s.length;let r=0,o=i-1;for(;r!==i&&s[r]<e;)++r;for(;o!==-1&&s[o]>t;)--o;if(++o,r!==0||o!==i){r>=o&&(o=Math.max(o,1),r=o-1);const a=this.getValueSize();this.times=s.slice(r,o),this.values=this.values.slice(r*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,i=this.values,r=s.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==r;a++){const l=s[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(i!==void 0&&wne(i))for(let a=0,l=i.length;a!==l;++a){const c=i[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),s=this.getValueSize(),i=this.getInterpolation()===Z3,r=e.length-1;let o=1;for(let a=1;a<r;++a){let l=!1;const c=e[a],u=e[a+1];if(c!==u&&(a!==1||c!==e[0]))if(i)l=!0;else{const d=a*s,h=d-s,p=d+s;for(let g=0;g!==s;++g){const y=t[d+g];if(y!==t[h+g]||y!==t[p+g]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const d=a*s,h=o*s;for(let p=0;p!==s;++p)t[h+p]=t[d+p]}++o}}if(r>0){e[o]=e[r];for(let a=r*s,l=o*s,c=0;c!==s;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*s)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),s=this.constructor,i=new s(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}Ml.prototype.TimeBufferType=Float32Array;Ml.prototype.ValueBufferType=Float32Array;Ml.prototype.DefaultInterpolation=bf;class jf extends Ml{}jf.prototype.ValueTypeName="bool";jf.prototype.ValueBufferType=Array;jf.prototype.DefaultInterpolation=Mg;jf.prototype.InterpolantFactoryMethodLinear=void 0;jf.prototype.InterpolantFactoryMethodSmooth=void 0;class yO extends Ml{}yO.prototype.ValueTypeName="color";class _f extends Ml{}_f.prototype.ValueTypeName="number";class Ene extends a0{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(s-t)/(i-t);let c=e*a;for(let u=c+a;c!==u;c+=4)Sl.slerpFlat(r,0,o,c-a,o,c,l);return r}}class bd extends Ml{InterpolantFactoryMethodLinear(e){return new Ene(this.times,this.values,this.getValueSize(),e)}}bd.prototype.ValueTypeName="quaternion";bd.prototype.DefaultInterpolation=bf;bd.prototype.InterpolantFactoryMethodSmooth=void 0;class Xf extends Ml{}Xf.prototype.ValueTypeName="string";Xf.prototype.ValueBufferType=Array;Xf.prototype.DefaultInterpolation=Mg;Xf.prototype.InterpolantFactoryMethodLinear=void 0;Xf.prototype.InterpolantFactoryMethodSmooth=void 0;class Ef extends Ml{}Ef.prototype.ValueTypeName="vector";class Tne{constructor(e,t=-1,s,i=DY){this.name=e,this.tracks=s,this.duration=t,this.blendMode=i,this.uuid=Aa(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,i=1/(e.fps||1);for(let o=0,a=s.length;o!==a;++o)t.push(kne(s[o]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],s=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,o=s.length;r!==o;++r)t.push(Ml.toJSON(s[r]));return i}static CreateFromMorphTargetSequence(e,t,s,i){const r=t.length,o=[];for(let a=0;a<r;a++){let l=[],c=[];l.push((a+r-1)%r,a,(a+1)%r),c.push(0,1,0);const u=bne(l);l=TN(l,1,u),c=TN(c,1,u),!i&&l[0]===0&&(l.push(r),c.push(c[0])),o.push(new _f(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/s))}return new this(e,-1,o)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const i=e;s=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<s.length;i++)if(s[i].name===t)return s[i];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const i={},r=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],u=c.name.match(r);if(u&&u.length>1){const d=u[1];let h=i[d];h||(i[d]=h=[]),h.push(c)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],t,s));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(d,h,p,g,y){if(p.length!==0){const x=[],v=[];vO(p,x,v,g),x.length!==0&&y.push(new d(h,x,v))}},i=[],r=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let d=0;d<c.length;d++){const h=c[d].keys;if(!(!h||h.length===0))if(h[0].morphTargets){const p={};let g;for(g=0;g<h.length;g++)if(h[g].morphTargets)for(let y=0;y<h[g].morphTargets.length;y++)p[h[g].morphTargets[y]]=-1;for(const y in p){const x=[],v=[];for(let b=0;b!==h[g].morphTargets.length;++b){const S=h[g];x.push(S.time),v.push(S.morphTarget===y?1:0)}i.push(new _f(".morphTargetInfluence["+y+"]",x,v))}l=p.length*o}else{const p=".bones["+t[d].name+"]";s(Ef,p+".position",h,"pos",i),s(bd,p+".quaternion",h,"rot",i),s(Ef,p+".scale",h,"scl",i)}}return i.length===0?null:new this(r,l,i,a)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,i=e.length;s!==i;++s){const r=this.tracks[s];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Ine(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return _f;case"vector":case"vector2":case"vector3":case"vector4":return Ef;case"color":return yO;case"quaternion":return bd;case"bool":case"boolean":return jf;case"string":return Xf}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function kne(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Ine(n.type);if(n.times===void 0){const t=[],s=[];vO(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const Tf={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class Ane{constructor(e,t,s){const i=this;let r=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.itemStart=function(u){a++,r===!1&&i.onStart!==void 0&&i.onStart(u,o,a),r=!0},this.itemEnd=function(u){o++,i.onProgress!==void 0&&i.onProgress(u,o,a),o===a&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,d){return c.push(u,d),this},this.removeHandler=function(u){const d=c.indexOf(u);return d!==-1&&c.splice(d,2),this},this.getHandler=function(u){for(let d=0,h=c.length;d<h;d+=2){const p=c[d],g=c[d+1];if(p.global&&(p.lastIndex=0),p.test(u))return g}return null}}}const Rne=new Ane;class qf{constructor(e){this.manager=e!==void 0?e:Rne,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(i,r){s.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}qf.DEFAULT_MATERIAL_NAME="__DEFAULT";const Kl={};class Mne extends Error{constructor(e,t){super(e),this.response=t}}class wO extends qf{constructor(e){super(e)}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=Tf.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(Kl[e]!==void 0){Kl[e].push({onLoad:t,onProgress:s,onError:i});return}Kl[e]=[],Kl[e].push({onLoad:t,onProgress:s,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=Kl[e],d=c.body.getReader(),h=c.headers.get("Content-Length")||c.headers.get("X-File-Size"),p=h?parseInt(h):0,g=p!==0;let y=0;const x=new ReadableStream({start(v){b();function b(){d.read().then(({done:S,value:C})=>{if(S)v.close();else{y+=C.byteLength;const E=new ProgressEvent("progress",{lengthComputable:g,loaded:y,total:p});for(let k=0,R=u.length;k<R;k++){const L=u[k];L.onProgress&&L.onProgress(E)}v.enqueue(C),b()}})}}});return new Response(x)}else throw new Mne(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return c.json();default:if(a===void 0)return c.text();{const d=/charset="?([^;"\s]*)"?/i.exec(a),h=d&&d[1]?d[1].toLowerCase():void 0,p=new TextDecoder(h);return c.arrayBuffer().then(g=>p.decode(g))}}}).then(c=>{Tf.add(e,c);const u=Kl[e];delete Kl[e];for(let d=0,h=u.length;d<h;d++){const p=u[d];p.onLoad&&p.onLoad(c)}}).catch(c=>{const u=Kl[e];if(u===void 0)throw this.manager.itemError(e),c;delete Kl[e];for(let d=0,h=u.length;d<h;d++){const p=u[d];p.onError&&p.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Nne extends qf{constructor(e){super(e)}load(e,t,s,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=Tf.get(e);if(o!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const a=Ng("img");function l(){u(),Tf.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(d){u(),i&&i(d),r.manager.itemError(e),r.manager.itemEnd(e)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(e),a.src=e,a}}class Pne extends qf{constructor(e){super(e)}load(e,t,s,i){const r=new vr,o=new Nne(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){r.image=a,r.needsUpdate=!0,t!==void 0&&t(r)},s,i),r}}class cy extends mi{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Kn(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}const _S=new us,IN=new Ne,kN=new Ne;class BE{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Zn(512,512),this.map=null,this.mapPass=null,this.matrix=new us,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new PE,this._frameExtents=new Zn(1,1),this._viewportCount=1,this._viewports=[new qs(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;IN.setFromMatrixPosition(e.matrixWorld),t.position.copy(IN),kN.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(kN),t.updateMatrixWorld(),_S.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_S),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(_S)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class Dne extends BE{constructor(){super(new Hr(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,s=Sf*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(s!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=s,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class Lne extends cy{constructor(e,t,s=0,i=Math.PI/3,r=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(mi.DEFAULT_UP),this.updateMatrix(),this.target=new mi,this.distance=s,this.angle=i,this.penumbra=r,this.decay=o,this.map=null,this.shadow=new Dne}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const AN=new us,Wm=new Ne,ES=new Ne;class $ne extends BE{constructor(){super(new Hr(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Zn(4,2),this._viewportCount=6,this._viewports=[new qs(2,1,1,1),new qs(0,1,1,1),new qs(3,1,1,1),new qs(1,1,1,1),new qs(3,0,1,1),new qs(1,0,1,1)],this._cubeDirections=[new Ne(1,0,0),new Ne(-1,0,0),new Ne(0,0,1),new Ne(0,0,-1),new Ne(0,1,0),new Ne(0,-1,0)],this._cubeUps=[new Ne(0,1,0),new Ne(0,1,0),new Ne(0,1,0),new Ne(0,1,0),new Ne(0,0,1),new Ne(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,i=this.matrix,r=e.distance||s.far;r!==s.far&&(s.far=r,s.updateProjectionMatrix()),Wm.setFromMatrixPosition(e.matrixWorld),s.position.copy(Wm),ES.copy(s.position),ES.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(ES),s.updateMatrixWorld(),i.makeTranslation(-Wm.x,-Wm.y,-Wm.z),AN.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(AN)}}class Fne extends cy{constructor(e,t,s=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=i,this.shadow=new $ne}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class One extends BE{constructor(){super(new DE(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class UC extends cy{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(mi.DEFAULT_UP),this.updateMatrix(),this.target=new mi,this.shadow=new One}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class zne extends cy{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class VC{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class Bne extends qf{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,o=Tf.get(e);if(o!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(o),r.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){Tf.add(e,l),t&&t(l),r.manager.itemEnd(e)}).catch(function(l){i&&i(l),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}const UE="\\[\\]\\.:\\/",Une=new RegExp("["+UE+"]","g"),VE="[^"+UE+"]",Vne="[^"+UE.replace("\\.","")+"]",Wne=/((?:WC+[\/:])*)/.source.replace("WC",VE),Gne=/(WCOD+)?/.source.replace("WCOD",Vne),Hne=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",VE),jne=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",VE),Xne=new RegExp("^"+Wne+Gne+Hne+jne+"$"),qne=["material","materials","bones","map"];class Kne{constructor(e,t,s){const i=s||$s.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,i=this._bindings[s];i!==void 0&&i.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=s.length;i!==r;++i)s[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class $s{constructor(e,t,s){this.path=t,this.parsedPath=s||$s.parseTrackName(t),this.node=$s.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new $s.Composite(e,t,s):new $s(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(Une,"")}static parseTrackName(e){const t=Xne.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=s.nodeName&&s.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=s.nodeName.substring(i+1);qne.indexOf(r)!==-1&&(s.nodeName=s.nodeName.substring(0,i),s.objectName=r)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(r){for(let o=0;o<r.length;o++){const a=r[o];if(a.name===t||a.uuid===t)return a;const l=s(a.children);if(l)return l}return null},i=s(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)e[t++]=s[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=$s.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let c=t.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[i];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}$s.Composite=Kne;$s.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};$s.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};$s.prototype.GetterByBindingType=[$s.prototype._getValue_direct,$s.prototype._getValue_array,$s.prototype._getValue_arrayElement,$s.prototype._getValue_toArray];$s.prototype.SetterByBindingTypeAndVersioning=[[$s.prototype._setValue_direct,$s.prototype._setValue_direct_setNeedsUpdate,$s.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[$s.prototype._setValue_array,$s.prototype._setValue_array_setNeedsUpdate,$s.prototype._setValue_array_setMatrixWorldNeedsUpdate],[$s.prototype._setValue_arrayElement,$s.prototype._setValue_arrayElement_setNeedsUpdate,$s.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[$s.prototype._setValue_fromArray,$s.prototype._setValue_fromArray_setNeedsUpdate,$s.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class RN{constructor(e=1,t=0,s=0){return this.radius=e,this.phi=t,this.theta=s,this}set(e,t,s){return this.radius=e,this.phi=t,this.theta=s,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,s){return this.radius=Math.sqrt(e*e+t*t+s*s),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,s),this.phi=Math.acos(xr(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Yne extends gO{constructor(e=10,t=10,s=4473924,i=8947848){s=new Kn(s),i=new Kn(i);const r=t/2,o=e/t,a=e/2,l=[],c=[];for(let h=0,p=0,g=-a;h<=t;h++,g+=o){l.push(-a,0,g,a,0,g),l.push(g,0,-a,g,0,a);const y=h===r?s:i;y.toArray(c,p),p+=3,y.toArray(c,p),p+=3,y.toArray(c,p),p+=3,y.toArray(c,p),p+=3}const u=new Va;u.setAttribute("position",new Ra(l,3)),u.setAttribute("color",new Ra(c,3));const d=new OE({vertexColors:!0,toneMapped:!1});super(u,d),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:AE}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=AE);const MN={type:"change"},TS={type:"start"},NN={type:"end"},iv=new r0,PN=new Gc,Zne=Math.cos(70*ZF.DEG2RAD);class Qne extends Fd{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new Ne,this.cursor=new Ne,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:Ch.ROTATE,MIDDLE:Ch.DOLLY,RIGHT:Ch.PAN},this.touches={ONE:_h.ROTATE,TWO:_h.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return a.phi},this.getAzimuthalAngle=function(){return a.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(xe){xe.addEventListener("keydown",Y),this._domElementKeyEvents=xe},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",Y),this._domElementKeyEvents=null},this.saveState=function(){s.target0.copy(s.target),s.position0.copy(s.object.position),s.zoom0=s.object.zoom},this.reset=function(){s.target.copy(s.target0),s.object.position.copy(s.position0),s.object.zoom=s.zoom0,s.object.updateProjectionMatrix(),s.dispatchEvent(MN),s.update(),r=i.NONE},this.update=function(){const xe=new Ne,xt=new Sl().setFromUnitVectors(e.up,new Ne(0,1,0)),Ye=xt.clone().invert(),kt=new Ne,Et=new Sl,bt=new Ne,Wt=2*Math.PI;return function(Ht=null){const Ce=s.object.position;xe.copy(Ce).sub(s.target),xe.applyQuaternion(xt),a.setFromVector3(xe),s.autoRotate&&r===i.NONE&&M(I(Ht)),s.enableDamping?(a.theta+=l.theta*s.dampingFactor,a.phi+=l.phi*s.dampingFactor):(a.theta+=l.theta,a.phi+=l.phi);let St=s.minAzimuthAngle,dt=s.maxAzimuthAngle;isFinite(St)&&isFinite(dt)&&(St<-Math.PI?St+=Wt:St>Math.PI&&(St-=Wt),dt<-Math.PI?dt+=Wt:dt>Math.PI&&(dt-=Wt),St<=dt?a.theta=Math.max(St,Math.min(dt,a.theta)):a.theta=a.theta>(St+dt)/2?Math.max(St,a.theta):Math.min(dt,a.theta)),a.phi=Math.max(s.minPolarAngle,Math.min(s.maxPolarAngle,a.phi)),a.makeSafe(),s.enableDamping===!0?s.target.addScaledVector(u,s.dampingFactor):s.target.add(u),s.target.sub(s.cursor),s.target.clampLength(s.minTargetRadius,s.maxTargetRadius),s.target.add(s.cursor),s.zoomToCursor&&k||s.object.isOrthographicCamera?a.radius=ee(a.radius):a.radius=ee(a.radius*c),xe.setFromSpherical(a),xe.applyQuaternion(Ye),Ce.copy(s.target).add(xe),s.object.lookAt(s.target),s.enableDamping===!0?(l.theta*=1-s.dampingFactor,l.phi*=1-s.dampingFactor,u.multiplyScalar(1-s.dampingFactor)):(l.set(0,0,0),u.set(0,0,0));let Be=!1;if(s.zoomToCursor&&k){let Rt=null;if(s.object.isPerspectiveCamera){const rn=xe.length();Rt=ee(rn*c);const In=rn-Rt;s.object.position.addScaledVector(C,In),s.object.updateMatrixWorld()}else if(s.object.isOrthographicCamera){const rn=new Ne(E.x,E.y,0);rn.unproject(s.object),s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/c)),s.object.updateProjectionMatrix(),Be=!0;const In=new Ne(E.x,E.y,0);In.unproject(s.object),s.object.position.sub(In).add(rn),s.object.updateMatrixWorld(),Rt=xe.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),s.zoomToCursor=!1;Rt!==null&&(this.screenSpacePanning?s.target.set(0,0,-1).transformDirection(s.object.matrix).multiplyScalar(Rt).add(s.object.position):(iv.origin.copy(s.object.position),iv.direction.set(0,0,-1).transformDirection(s.object.matrix),Math.abs(s.object.up.dot(iv.direction))<Zne?e.lookAt(s.target):(PN.setFromNormalAndCoplanarPoint(s.object.up,s.target),iv.intersectPlane(PN,s.target))))}else s.object.isOrthographicCamera&&(s.object.zoom=Math.max(s.minZoom,Math.min(s.maxZoom,s.object.zoom/c)),s.object.updateProjectionMatrix(),Be=!0);return c=1,k=!1,Be||kt.distanceToSquared(s.object.position)>o||8*(1-Et.dot(s.object.quaternion))>o||bt.distanceToSquared(s.target)>0?(s.dispatchEvent(MN),kt.copy(s.object.position),Et.copy(s.object.quaternion),bt.copy(s.target),Be=!1,!0):!1}}(),this.dispose=function(){s.domElement.removeEventListener("contextmenu",tt),s.domElement.removeEventListener("pointerdown",It),s.domElement.removeEventListener("pointercancel",Gt),s.domElement.removeEventListener("wheel",ce),s.domElement.removeEventListener("pointermove",zt),s.domElement.removeEventListener("pointerup",Gt),s._domElementKeyEvents!==null&&(s._domElementKeyEvents.removeEventListener("keydown",Y),s._domElementKeyEvents=null)};const s=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let r=i.NONE;const o=1e-6,a=new RN,l=new RN;let c=1;const u=new Ne,d=new Zn,h=new Zn,p=new Zn,g=new Zn,y=new Zn,x=new Zn,v=new Zn,b=new Zn,S=new Zn,C=new Ne,E=new Zn;let k=!1;const R=[],L={};function I(xe){return xe!==null?2*Math.PI/60*s.autoRotateSpeed*xe:2*Math.PI/60/60*s.autoRotateSpeed}function T(){return Math.pow(.95,s.zoomSpeed)}function M(xe){l.theta-=xe}function j(xe){l.phi-=xe}const W=function(){const xe=new Ne;return function(Ye,kt){xe.setFromMatrixColumn(kt,0),xe.multiplyScalar(-Ye),u.add(xe)}}(),z=function(){const xe=new Ne;return function(Ye,kt){s.screenSpacePanning===!0?xe.setFromMatrixColumn(kt,1):(xe.setFromMatrixColumn(kt,0),xe.crossVectors(s.object.up,xe)),xe.multiplyScalar(Ye),u.add(xe)}}(),X=function(){const xe=new Ne;return function(Ye,kt){const Et=s.domElement;if(s.object.isPerspectiveCamera){const bt=s.object.position;xe.copy(bt).sub(s.target);let Wt=xe.length();Wt*=Math.tan(s.object.fov/2*Math.PI/180),W(2*Ye*Wt/Et.clientHeight,s.object.matrix),z(2*kt*Wt/Et.clientHeight,s.object.matrix)}else s.object.isOrthographicCamera?(W(Ye*(s.object.right-s.object.left)/s.object.zoom/Et.clientWidth,s.object.matrix),z(kt*(s.object.top-s.object.bottom)/s.object.zoom/Et.clientHeight,s.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),s.enablePan=!1)}}();function B(xe){s.object.isPerspectiveCamera||s.object.isOrthographicCamera?c/=xe:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function J(xe){s.object.isPerspectiveCamera||s.object.isOrthographicCamera?c*=xe:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),s.enableZoom=!1)}function K(xe){if(!s.zoomToCursor)return;k=!0;const xt=s.domElement.getBoundingClientRect(),Ye=xe.clientX-xt.left,kt=xe.clientY-xt.top,Et=xt.width,bt=xt.height;E.x=Ye/Et*2-1,E.y=-(kt/bt)*2+1,C.set(E.x,E.y,1).unproject(s.object).sub(s.object.position).normalize()}function ee(xe){return Math.max(s.minDistance,Math.min(s.maxDistance,xe))}function ne(xe){d.set(xe.clientX,xe.clientY)}function V(xe){K(xe),v.set(xe.clientX,xe.clientY)}function Z(xe){g.set(xe.clientX,xe.clientY)}function he(xe){h.set(xe.clientX,xe.clientY),p.subVectors(h,d).multiplyScalar(s.rotateSpeed);const xt=s.domElement;M(2*Math.PI*p.x/xt.clientHeight),j(2*Math.PI*p.y/xt.clientHeight),d.copy(h),s.update()}function ve(xe){b.set(xe.clientX,xe.clientY),S.subVectors(b,v),S.y>0?B(T()):S.y<0&&J(T()),v.copy(b),s.update()}function be(xe){y.set(xe.clientX,xe.clientY),x.subVectors(y,g).multiplyScalar(s.panSpeed),X(x.x,x.y),g.copy(y),s.update()}function Ie(xe){K(xe),xe.deltaY<0?J(T()):xe.deltaY>0&&B(T()),s.update()}function Xe(xe){let xt=!1;switch(xe.code){case s.keys.UP:xe.ctrlKey||xe.metaKey||xe.shiftKey?j(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):X(0,s.keyPanSpeed),xt=!0;break;case s.keys.BOTTOM:xe.ctrlKey||xe.metaKey||xe.shiftKey?j(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):X(0,-s.keyPanSpeed),xt=!0;break;case s.keys.LEFT:xe.ctrlKey||xe.metaKey||xe.shiftKey?M(2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):X(s.keyPanSpeed,0),xt=!0;break;case s.keys.RIGHT:xe.ctrlKey||xe.metaKey||xe.shiftKey?M(-2*Math.PI*s.rotateSpeed/s.domElement.clientHeight):X(-s.keyPanSpeed,0),xt=!0;break}xt&&(xe.preventDefault(),s.update())}function Fe(){if(R.length===1)d.set(R[0].pageX,R[0].pageY);else{const xe=.5*(R[0].pageX+R[1].pageX),xt=.5*(R[0].pageY+R[1].pageY);d.set(xe,xt)}}function Pe(){if(R.length===1)g.set(R[0].pageX,R[0].pageY);else{const xe=.5*(R[0].pageX+R[1].pageX),xt=.5*(R[0].pageY+R[1].pageY);g.set(xe,xt)}}function ct(){const xe=R[0].pageX-R[1].pageX,xt=R[0].pageY-R[1].pageY,Ye=Math.sqrt(xe*xe+xt*xt);v.set(0,Ye)}function at(){s.enableZoom&&ct(),s.enablePan&&Pe()}function Ee(){s.enableZoom&&ct(),s.enableRotate&&Fe()}function nn(xe){if(R.length==1)h.set(xe.pageX,xe.pageY);else{const Ye=At(xe),kt=.5*(xe.pageX+Ye.x),Et=.5*(xe.pageY+Ye.y);h.set(kt,Et)}p.subVectors(h,d).multiplyScalar(s.rotateSpeed);const xt=s.domElement;M(2*Math.PI*p.x/xt.clientHeight),j(2*Math.PI*p.y/xt.clientHeight),d.copy(h)}function gt(xe){if(R.length===1)y.set(xe.pageX,xe.pageY);else{const xt=At(xe),Ye=.5*(xe.pageX+xt.x),kt=.5*(xe.pageY+xt.y);y.set(Ye,kt)}x.subVectors(y,g).multiplyScalar(s.panSpeed),X(x.x,x.y),g.copy(y)}function vt(xe){const xt=At(xe),Ye=xe.pageX-xt.x,kt=xe.pageY-xt.y,Et=Math.sqrt(Ye*Ye+kt*kt);b.set(0,Et),S.set(0,Math.pow(b.y/v.y,s.zoomSpeed)),B(S.y),v.copy(b)}function wt(xe){s.enableZoom&&vt(xe),s.enablePan&&gt(xe)}function Vt(xe){s.enableZoom&&vt(xe),s.enableRotate&&nn(xe)}function It(xe){s.enabled!==!1&&(R.length===0&&(s.domElement.setPointerCapture(xe.pointerId),s.domElement.addEventListener("pointermove",zt),s.domElement.addEventListener("pointerup",Gt)),rt(xe),xe.pointerType==="touch"?ye(xe):dn(xe))}function zt(xe){s.enabled!==!1&&(xe.pointerType==="touch"?Qe(xe):vn(xe))}function Gt(xe){Pt(xe),R.length===0&&(s.domElement.releasePointerCapture(xe.pointerId),s.domElement.removeEventListener("pointermove",zt),s.domElement.removeEventListener("pointerup",Gt)),s.dispatchEvent(NN),r=i.NONE}function dn(xe){let xt;switch(xe.button){case 0:xt=s.mouseButtons.LEFT;break;case 1:xt=s.mouseButtons.MIDDLE;break;case 2:xt=s.mouseButtons.RIGHT;break;default:xt=-1}switch(xt){case Ch.DOLLY:if(s.enableZoom===!1)return;V(xe),r=i.DOLLY;break;case Ch.ROTATE:if(xe.ctrlKey||xe.metaKey||xe.shiftKey){if(s.enablePan===!1)return;Z(xe),r=i.PAN}else{if(s.enableRotate===!1)return;ne(xe),r=i.ROTATE}break;case Ch.PAN:if(xe.ctrlKey||xe.metaKey||xe.shiftKey){if(s.enableRotate===!1)return;ne(xe),r=i.ROTATE}else{if(s.enablePan===!1)return;Z(xe),r=i.PAN}break;default:r=i.NONE}r!==i.NONE&&s.dispatchEvent(TS)}function vn(xe){switch(r){case i.ROTATE:if(s.enableRotate===!1)return;he(xe);break;case i.DOLLY:if(s.enableZoom===!1)return;ve(xe);break;case i.PAN:if(s.enablePan===!1)return;be(xe);break}}function ce(xe){s.enabled===!1||s.enableZoom===!1||r!==i.NONE||(xe.preventDefault(),s.dispatchEvent(TS),Ie(xe),s.dispatchEvent(NN))}function Y(xe){s.enabled===!1||s.enablePan===!1||Xe(xe)}function ye(xe){switch(pt(xe),R.length){case 1:switch(s.touches.ONE){case _h.ROTATE:if(s.enableRotate===!1)return;Fe(),r=i.TOUCH_ROTATE;break;case _h.PAN:if(s.enablePan===!1)return;Pe(),r=i.TOUCH_PAN;break;default:r=i.NONE}break;case 2:switch(s.touches.TWO){case _h.DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;at(),r=i.TOUCH_DOLLY_PAN;break;case _h.DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Ee(),r=i.TOUCH_DOLLY_ROTATE;break;default:r=i.NONE}break;default:r=i.NONE}r!==i.NONE&&s.dispatchEvent(TS)}function Qe(xe){switch(pt(xe),r){case i.TOUCH_ROTATE:if(s.enableRotate===!1)return;nn(xe),s.update();break;case i.TOUCH_PAN:if(s.enablePan===!1)return;gt(xe),s.update();break;case i.TOUCH_DOLLY_PAN:if(s.enableZoom===!1&&s.enablePan===!1)return;wt(xe),s.update();break;case i.TOUCH_DOLLY_ROTATE:if(s.enableZoom===!1&&s.enableRotate===!1)return;Vt(xe),s.update();break;default:r=i.NONE}}function tt(xe){s.enabled!==!1&&xe.preventDefault()}function rt(xe){R.push(xe)}function Pt(xe){delete L[xe.pointerId];for(let xt=0;xt<R.length;xt++)if(R[xt].pointerId==xe.pointerId){R.splice(xt,1);return}}function pt(xe){let xt=L[xe.pointerId];xt===void 0&&(xt=new Zn,L[xe.pointerId]=xt),xt.set(xe.pageX,xe.pageY)}function At(xe){const xt=xe.pointerId===R[0].pointerId?R[1]:R[0];return L[xt.pointerId]}s.domElement.addEventListener("contextmenu",tt),s.domElement.addEventListener("pointerdown",It),s.domElement.addEventListener("pointercancel",Gt),s.domElement.addEventListener("wheel",ce,{passive:!1}),this.update()}}function DN(n,e){if(e===LY)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===DC||e===XF){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const s=t.count-2,i=[];if(e===DC)for(let o=1;o<=s;o++)i.push(t.getX(0)),i.push(t.getX(o)),i.push(t.getX(o+1));else for(let o=0;o<s;o++)o%2===0?(i.push(t.getX(o)),i.push(t.getX(o+1)),i.push(t.getX(o+2))):(i.push(t.getX(o+2)),i.push(t.getX(o+1)),i.push(t.getX(o)));i.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=n.clone();return r.setIndex(i),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}class Jne extends qf{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new ise(t)}),this.register(function(t){return new hse(t)}),this.register(function(t){return new fse(t)}),this.register(function(t){return new pse(t)}),this.register(function(t){return new ose(t)}),this.register(function(t){return new ase(t)}),this.register(function(t){return new lse(t)}),this.register(function(t){return new cse(t)}),this.register(function(t){return new sse(t)}),this.register(function(t){return new use(t)}),this.register(function(t){return new rse(t)}),this.register(function(t){return new dse(t)}),this.register(function(t){return new tse(t)}),this.register(function(t){return new mse(t)}),this.register(function(t){return new gse(t)})}load(e,t,s,i){const r=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=VC.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){i?i(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},l=new wO(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{r.parse(c,o,function(u){t(u),r.manager.itemEnd(e)},a)}catch(u){a(u)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,i){let r;const o={},a={},l=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===bO){try{o[ms.KHR_BINARY_GLTF]=new xse(e)}catch(d){i&&i(d);return}r=JSON.parse(o[ms.KHR_BINARY_GLTF].content)}else r=JSON.parse(l.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new Rse(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const d=this.pluginCallbacks[u](c);d.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[d.name]=d,o[d.name]=!0}if(r.extensionsUsed)for(let u=0;u<r.extensionsUsed.length;++u){const d=r.extensionsUsed[u],h=r.extensionsRequired||[];switch(d){case ms.KHR_MATERIALS_UNLIT:o[d]=new nse;break;case ms.KHR_DRACO_MESH_COMPRESSION:o[d]=new vse(r,this.dracoLoader);break;case ms.KHR_TEXTURE_TRANSFORM:o[d]=new yse;break;case ms.KHR_MESH_QUANTIZATION:o[d]=new wse;break;default:h.indexOf(d)>=0&&a[d]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+d+'".')}}c.setExtensions(o),c.setPlugins(a),c.parse(s,i)}parseAsync(e,t){const s=this;return new Promise(function(i,r){s.parse(e,t,i,r)})}}function ese(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const ms={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class tse{constructor(e){this.parser=e,this.name=ms.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,i=t.length;s<i;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let i=t.cache.get(s);if(i)return i;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let c;const u=new Kn(16777215);l.color!==void 0&&u.setRGB(l.color[0],l.color[1],l.color[2],yr);const d=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new UC(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Fne(u),c.distance=d;break;case"spot":c=new Lne(u),c.distance=d,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,Hc(c,l),l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),t.cache.add(s,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],a=(r.extensions&&r.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return s._getNodeRef(t.cache,a,l)})}}class nse{constructor(){this.name=ms.KHR_MATERIALS_UNLIT}getMaterialType(){return qc}extendParams(e,t,s){const i=[];e.color=new Kn(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const o=r.baseColorFactor;e.color.setRGB(o[0],o[1],o[2],yr),e.opacity=o[3]}r.baseColorTexture!==void 0&&i.push(s.assignTexture(e,"map",r.baseColorTexture,hi))}return Promise.all(i)}}class sse{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class ise{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],o=i.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Zn(a,a)}return Promise.all(r)}}class rse{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],o=i.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(r)}}class ose{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new Kn(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=i.extensions[this.name];if(o.sheenColorFactor!==void 0){const a=o.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],yr)}return o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",o.sheenColorTexture,hi)),o.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(r)}}class ase{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],o=i.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(r)}}class lse{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],o=i.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new Kn().setRGB(a[0],a[1],a[2],yr),Promise.all(r)}}class cse{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class use{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],o=i.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new Kn().setRGB(a[0],a[1],a[2],yr),o.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",o.specularColorTexture,hi)),Promise.all(r)}}class dse{constructor(e){this.parser=e,this.name=ms.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:fu}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],o=i.extensions[this.name];return o.anisotropyStrength!==void 0&&(t.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(t.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",o.anisotropyTexture)),Promise.all(r)}}class hse{constructor(e){this.parser=e,this.name=ms.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,i=s.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const r=i.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,o)}}class fse{constructor(e){this.parser=e,this.name=ms.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],a=i.images[o.source];let l=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,o.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class pse{constructor(e){this.parser=e,this.name=ms.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const o=r.extensions[t],a=i.images[o.source];let l=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,o.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class mse{constructor(e){this.name=ms.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const i=s.extensions[this.name],r=this.parser.getDependency("buffer",i.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(a){const l=i.byteOffset||0,c=i.byteLength||0,u=i.count,d=i.byteStride,h=new Uint8Array(a,l,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(u,d,h,i.mode,i.filter).then(function(p){return p.buffer}):o.ready.then(function(){const p=new ArrayBuffer(u*d);return o.decodeGltfBuffer(new Uint8Array(p),u,d,h,i.mode,i.filter),p})})}else return null}}class gse{constructor(e){this.name=ms.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const i=t.meshes[s.mesh];for(const c of i.primitives)if(c.mode!==Qo.TRIANGLES&&c.mode!==Qo.TRIANGLE_STRIP&&c.mode!==Qo.TRIANGLE_FAN&&c.mode!==void 0)return null;const o=s.extensions[this.name].attributes,a=[],l={};for(const c in o)a.push(this.parser.getDependency("accessor",o[c]).then(u=>(l[c]=u,l[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(c=>{const u=c.pop(),d=u.isGroup?u.children:[u],h=c[0].count,p=[];for(const g of d){const y=new us,x=new Ne,v=new Sl,b=new Ne(1,1,1),S=new xne(g.geometry,g.material,h);for(let C=0;C<h;C++)l.TRANSLATION&&x.fromBufferAttribute(l.TRANSLATION,C),l.ROTATION&&v.fromBufferAttribute(l.ROTATION,C),l.SCALE&&b.fromBufferAttribute(l.SCALE,C),S.setMatrixAt(C,y.compose(x,v,b));for(const C in l)if(C==="_COLOR_0"){const E=l[C];S.instanceColor=new zC(E.array,E.itemSize,E.normalized)}else C!=="TRANSLATION"&&C!=="ROTATION"&&C!=="SCALE"&&g.geometry.setAttribute(C,l[C]);mi.prototype.copy.call(S,g),this.parser.assignFinalMaterial(S),p.push(S)}return u.isGroup?(u.clear(),u.add(...p),u):p[0]}))}}const bO="glTF",Gm=12,LN={JSON:1313821514,BIN:5130562};class xse{constructor(e){this.name=ms.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Gm),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==bO)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-Gm,r=new DataView(e,Gm);let o=0;for(;o<i;){const a=r.getUint32(o,!0);o+=4;const l=r.getUint32(o,!0);if(o+=4,l===LN.JSON){const c=new Uint8Array(e,Gm+o,a);this.content=s.decode(c)}else if(l===LN.BIN){const c=Gm+o;this.body=e.slice(c,c+a)}o+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class vse{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ms.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,i=this.dracoLoader,r=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const u in o){const d=WC[u]||u.toLowerCase();a[d]=o[u]}for(const u in e.attributes){const d=WC[u]||u.toLowerCase();if(o[u]!==void 0){const h=s.accessors[e.attributes[u]],p=lf[h.componentType];c[d]=p.name,l[d]=h.normalized===!0}}return t.getDependency("bufferView",r).then(function(u){return new Promise(function(d){i.decodeDracoFile(u,function(h){for(const p in h.attributes){const g=h.attributes[p],y=l[p];y!==void 0&&(g.normalized=y)}d(h)},a,c)})})}}class yse{constructor(){this.name=ms.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class wse{constructor(){this.name=ms.KHR_MESH_QUANTIZATION}}class SO extends a0{constructor(e,t,s,i){super(e,t,s,i)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i*3+i;for(let o=0;o!==i;o++)t[o]=s[r+o];return t}interpolate_(e,t,s,i){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,c=a*3,u=i-t,d=(s-t)/u,h=d*d,p=h*d,g=e*c,y=g-c,x=-2*p+3*h,v=p-h,b=1-x,S=v-h+d;for(let C=0;C!==a;C++){const E=o[y+C+a],k=o[y+C+l]*u,R=o[g+C+a],L=o[g+C]*u;r[C]=b*E+S*k+x*R+v*L}return r}}const bse=new Sl;class Sse extends SO{interpolate_(e,t,s,i){const r=super.interpolate_(e,t,s,i);return bse.fromArray(r).normalize().toArray(r),r}}const Qo={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},lf={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},$N={9728:ar,9729:po,9984:PC,9985:BF,9986:Pv,9987:vd},FN={33071:ea,33648:i2,10497:yf},IS={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},WC={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},zc={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Cse={CUBICSPLINE:void 0,LINEAR:bf,STEP:Mg},kS={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function _se(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new ly({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:dc})),n.DefaultMaterial}function Uu(n,e,t){for(const s in t.extensions)n[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Hc(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Ese(n,e,t){let s=!1,i=!1,r=!1;for(let c=0,u=e.length;c<u;c++){const d=e[c];if(d.POSITION!==void 0&&(s=!0),d.NORMAL!==void 0&&(i=!0),d.COLOR_0!==void 0&&(r=!0),s&&i&&r)break}if(!s&&!i&&!r)return Promise.resolve(n);const o=[],a=[],l=[];for(let c=0,u=e.length;c<u;c++){const d=e[c];if(s){const h=d.POSITION!==void 0?t.getDependency("accessor",d.POSITION):n.attributes.position;o.push(h)}if(i){const h=d.NORMAL!==void 0?t.getDependency("accessor",d.NORMAL):n.attributes.normal;a.push(h)}if(r){const h=d.COLOR_0!==void 0?t.getDependency("accessor",d.COLOR_0):n.attributes.color;l.push(h)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const u=c[0],d=c[1],h=c[2];return s&&(n.morphAttributes.position=u),i&&(n.morphAttributes.normal=d),r&&(n.morphAttributes.color=h),n.morphTargetsRelative=!0,n})}function Tse(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let s=0,i=t.length;s<i;s++)n.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Ise(n){let e;const t=n.extensions&&n.extensions[ms.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+AS(t.attributes):e=n.indices+":"+AS(n.attributes)+":"+n.mode,n.targets!==void 0)for(let s=0,i=n.targets.length;s<i;s++)e+=":"+AS(n.targets[s]);return e}function AS(n){let e="";const t=Object.keys(n).sort();for(let s=0,i=t.length;s<i;s++)e+=t[s]+":"+n[t[s]]+";";return e}function GC(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function kse(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Ase=new us;class Rse{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new ese,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,i=!1,r=-1;typeof navigator<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,r=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||i&&r<98?this.textureLoader=new Pne(this.options.manager):this.textureLoader=new Bne(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new wO(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,i=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(o){const a={scene:o[0][i.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:i.asset,parser:s,userData:{}};return Uu(r,a,i),Hc(a,i),Promise.all(s._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let i=0,r=t.length;i<r;i++){const o=t[i].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let i=0,r=e.length;i<r;i++){const o=e[i];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(s[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const i=s.clone(),r=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,u]of o.children.entries())r(u,a.children[c])};return r(s,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const i=e(t[s]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let i=0;i<t.length;i++){const r=e(t[i]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let i=this.cache.get(s);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":i=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(s,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(r,o){return s.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[ms.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(r,o){s.load(VC.resolveURL(t.uri,i.path),r,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const i=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+i)})}loadAccessor(e){const t=this,s=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const o=IS[i.type],a=lf[i.componentType],l=i.normalized===!0,c=new a(i.count*o);return Promise.resolve(new Kr(c,o,l))}const r=[];return i.bufferView!==void 0?r.push(this.getDependency("bufferView",i.bufferView)):r.push(null),i.sparse!==void 0&&(r.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(r).then(function(o){const a=o[0],l=IS[i.type],c=lf[i.componentType],u=c.BYTES_PER_ELEMENT,d=u*l,h=i.byteOffset||0,p=i.bufferView!==void 0?s.bufferViews[i.bufferView].byteStride:void 0,g=i.normalized===!0;let y,x;if(p&&p!==d){const v=Math.floor(h/p),b="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+v+":"+i.count;let S=t.cache.get(b);S||(y=new c(a,v*p,i.count*p/u),S=new dne(y,p/u),t.cache.add(b,S)),x=new $E(S,l,h%p/u,g)}else a===null?y=new c(i.count*l):y=new c(a,h,i.count*l),x=new Kr(y,l,g);if(i.sparse!==void 0){const v=IS.SCALAR,b=lf[i.sparse.indices.componentType],S=i.sparse.indices.byteOffset||0,C=i.sparse.values.byteOffset||0,E=new b(o[1],S,i.sparse.count*v),k=new c(o[2],C,i.sparse.count*l);a!==null&&(x=new Kr(x.array.slice(),x.itemSize,x.normalized));for(let R=0,L=E.length;R<L;R++){const I=E[R];if(x.setX(I,k[R*l]),l>=2&&x.setY(I,k[R*l+1]),l>=3&&x.setZ(I,k[R*l+2]),l>=4&&x.setW(I,k[R*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return x})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,o=t.images[r];let a=this.textureLoader;if(o.uri){const l=s.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,r,a)}loadTextureImage(e,t,s){const i=this,r=this.json,o=r.textures[e],a=r.images[t],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,s).then(function(u){u.flipY=!1,u.name=o.name||a.name||"",u.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(u.name=a.uri);const h=(r.samplers||{})[o.sampler]||{};return u.magFilter=$N[h.magFilter]||po,u.minFilter=$N[h.minFilter]||vd,u.wrapS=FN[h.wrapS]||yf,u.wrapT=FN[h.wrapT]||yf,i.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const s=this,i=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const o=i.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",c=!1;if(o.bufferView!==void 0)l=s.getDependency("bufferView",o.bufferView).then(function(d){c=!0;const h=new Blob([d],{type:o.mimeType});return l=a.createObjectURL(h),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(l).then(function(d){return new Promise(function(h,p){let g=h;t.isImageBitmapLoader===!0&&(g=function(y){const x=new vr(y);x.needsUpdate=!0,h(x)}),t.load(VC.resolveURL(d,r.path),g,void 0,p)})}).then(function(d){return c===!0&&a.revokeObjectURL(l),d.userData.mimeType=o.mimeType||kse(o.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),d});return this.sourceCache[e]=u,u}assignTexture(e,t,s,i){const r=this;return this.getDependency("texture",s.index).then(function(o){if(!o)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(o=o.clone(),o.channel=s.texCoord),r.extensions[ms.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[ms.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=r.associations.get(o);o=r.extensions[ms.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),r.associations.set(o,l)}}return i!==void 0&&(o.colorSpace=i),e[t]=o,o})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const i=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new xO,ml.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,l.sizeAttenuation=!1,this.cache.add(a,l)),s=l}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new OE,ml.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,this.cache.add(a,l)),s=l}if(i||r||o){let a="ClonedMaterial:"+s.uuid+":";i&&(a+="derivative-tangents:"),r&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=s.clone(),r&&(l.vertexColors=!0),o&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(s))),s=l}e.material=s}getMaterialType(){return ly}loadMaterial(e){const t=this,s=this.json,i=this.extensions,r=s.materials[e];let o;const a={},l=r.extensions||{},c=[];if(l[ms.KHR_MATERIALS_UNLIT]){const d=i[ms.KHR_MATERIALS_UNLIT];o=d.getMaterialType(),c.push(d.extendParams(a,r,t))}else{const d=r.pbrMetallicRoughness||{};if(a.color=new Kn(1,1,1),a.opacity=1,Array.isArray(d.baseColorFactor)){const h=d.baseColorFactor;a.color.setRGB(h[0],h[1],h[2],yr),a.opacity=h[3]}d.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",d.baseColorTexture,hi)),a.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,a.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",d.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",d.metallicRoughnessTexture))),o=this._invokeOne(function(h){return h.getMaterialType&&h.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(h){return h.extendMaterialParams&&h.extendMaterialParams(e,a)})))}r.doubleSided===!0&&(a.side=al);const u=r.alphaMode||kS.OPAQUE;if(u===kS.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,u===kS.MASK&&(a.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&o!==qc&&(c.push(t.assignTexture(a,"normalMap",r.normalTexture)),a.normalScale=new Zn(1,1),r.normalTexture.scale!==void 0)){const d=r.normalTexture.scale;a.normalScale.set(d,d)}if(r.occlusionTexture!==void 0&&o!==qc&&(c.push(t.assignTexture(a,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&o!==qc){const d=r.emissiveFactor;a.emissive=new Kn().setRGB(d[0],d[1],d[2],yr)}return r.emissiveTexture!==void 0&&o!==qc&&c.push(t.assignTexture(a,"emissiveMap",r.emissiveTexture,hi)),Promise.all(c).then(function(){const d=new o(a);return r.name&&(d.name=r.name),Hc(d,r),t.associations.set(d,{materials:e}),r.extensions&&Uu(i,d,r),d})}createUniqueName(e){const t=$s.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,i=this.primitiveCache;function r(a){return s[ms.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return ON(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],u=Ise(c),d=i[u];if(d)o.push(d.promise);else{let h;c.extensions&&c.extensions[ms.KHR_DRACO_MESH_COMPRESSION]?h=r(c):h=ON(new Va,c,t),i[u]={primitive:c,promise:h},o.push(h)}}return Promise.all(o)}loadMesh(e){const t=this,s=this.json,i=this.extensions,r=s.meshes[e],o=r.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const u=o[l].material===void 0?_se(this.cache):this.getDependency("material",o[l].material);a.push(u)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),u=l[l.length-1],d=[];for(let p=0,g=u.length;p<g;p++){const y=u[p],x=o[p];let v;const b=c[p];if(x.mode===Qo.TRIANGLES||x.mode===Qo.TRIANGLE_STRIP||x.mode===Qo.TRIANGLE_FAN||x.mode===void 0)v=r.isSkinnedMesh===!0?new fne(y,b):new Mo(y,b),v.isSkinnedMesh===!0&&v.normalizeSkinWeights(),x.mode===Qo.TRIANGLE_STRIP?v.geometry=DN(v.geometry,XF):x.mode===Qo.TRIANGLE_FAN&&(v.geometry=DN(v.geometry,DC));else if(x.mode===Qo.LINES)v=new gO(y,b);else if(x.mode===Qo.LINE_STRIP)v=new zE(y,b);else if(x.mode===Qo.LINE_LOOP)v=new vne(y,b);else if(x.mode===Qo.POINTS)v=new yne(y,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+x.mode);Object.keys(v.geometry.morphAttributes).length>0&&Tse(v,r),v.name=t.createUniqueName(r.name||"mesh_"+e),Hc(v,r),x.extensions&&Uu(i,v,x),t.assignFinalMaterial(v),d.push(v)}for(let p=0,g=d.length;p<g;p++)t.associations.set(d[p],{meshes:e,primitives:p});if(d.length===1)return r.extensions&&Uu(i,d[0],r),d[0];const h=new rd;r.extensions&&Uu(i,h,r),t.associations.set(h,{meshes:e});for(let p=0,g=d.length;p<g;p++)h.add(d[p]);return h})}loadCamera(e){let t;const s=this.json.cameras[e],i=s[s.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Hr(ZF.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):s.type==="orthographic"&&(t=new DE(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Hc(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let i=0,r=t.joints.length;i<r;i++)s.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(i){const r=i.pop(),o=i,a=[],l=[];for(let c=0,u=o.length;c<u;c++){const d=o[c];if(d){a.push(d);const h=new us;r!==null&&h.fromArray(r.array,c*16),l.push(h)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new FE(a,l)})}loadAnimation(e){const t=this.json,s=this,i=t.animations[e],r=i.name?i.name:"animation_"+e,o=[],a=[],l=[],c=[],u=[];for(let d=0,h=i.channels.length;d<h;d++){const p=i.channels[d],g=i.samplers[p.sampler],y=p.target,x=y.node,v=i.parameters!==void 0?i.parameters[g.input]:g.input,b=i.parameters!==void 0?i.parameters[g.output]:g.output;y.node!==void 0&&(o.push(this.getDependency("node",x)),a.push(this.getDependency("accessor",v)),l.push(this.getDependency("accessor",b)),c.push(g),u.push(y))}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(c),Promise.all(u)]).then(function(d){const h=d[0],p=d[1],g=d[2],y=d[3],x=d[4],v=[];for(let b=0,S=h.length;b<S;b++){const C=h[b],E=p[b],k=g[b],R=y[b],L=x[b];if(C===void 0)continue;C.updateMatrix&&C.updateMatrix();const I=s._createAnimationTracks(C,E,k,R,L);if(I)for(let T=0;T<I.length;T++)v.push(I[T])}return new Tne(r,void 0,v)})}createNodeMesh(e){const t=this.json,s=this,i=t.nodes[e];return i.mesh===void 0?null:s.getDependency("mesh",i.mesh).then(function(r){const o=s._getNodeRef(s.meshCache,i.mesh,r);return i.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,c=i.weights.length;l<c;l++)a.morphTargetInfluences[l]=i.weights[l]}),o})}loadNode(e){const t=this.json,s=this,i=t.nodes[e],r=s._loadNodeShallow(e),o=[],a=i.children||[];for(let c=0,u=a.length;c<u;c++)o.push(s.getDependency("node",a[c]));const l=i.skin===void 0?Promise.resolve(null):s.getDependency("skin",i.skin);return Promise.all([r,Promise.all(o),l]).then(function(c){const u=c[0],d=c[1],h=c[2];h!==null&&u.traverse(function(p){p.isSkinnedMesh&&p.bind(h,Ase)});for(let p=0,g=d.length;p<g;p++)u.add(d[p]);return u})}_loadNodeShallow(e){const t=this.json,s=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],o=r.name?i.createUniqueName(r.name):"",a=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),r.camera!==void 0&&a.push(i.getDependency("camera",r.camera).then(function(c){return i._getNodeRef(i.cameraCache,r.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),this.nodeCache[e]=Promise.all(a).then(function(c){let u;if(r.isBone===!0?u=new mO:c.length>1?u=new rd:c.length===1?u=c[0]:u=new mi,u!==c[0])for(let d=0,h=c.length;d<h;d++)u.add(c[d]);if(r.name&&(u.userData.name=r.name,u.name=o),Hc(u,r),r.extensions&&Uu(s,u,r),r.matrix!==void 0){const d=new us;d.fromArray(r.matrix),u.applyMatrix4(d)}else r.translation!==void 0&&u.position.fromArray(r.translation),r.rotation!==void 0&&u.quaternion.fromArray(r.rotation),r.scale!==void 0&&u.scale.fromArray(r.scale);return i.associations.has(u)||i.associations.set(u,{}),i.associations.get(u).nodes=e,u}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],i=this,r=new rd;s.name&&(r.name=i.createUniqueName(s.name)),Hc(r,s),s.extensions&&Uu(t,r,s);const o=s.nodes||[],a=[];for(let l=0,c=o.length;l<c;l++)a.push(i.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let u=0,d=l.length;u<d;u++)r.add(l[u]);const c=u=>{const d=new Map;for(const[h,p]of i.associations)(h instanceof ml||h instanceof vr)&&d.set(h,p);return u.traverse(h=>{const p=i.associations.get(h);p!=null&&d.set(h,p)}),d};return i.associations=c(r),r})}_createAnimationTracks(e,t,s,i,r){const o=[],a=e.name?e.name:e.uuid,l=[];zc[r.path]===zc.weights?e.traverse(function(h){h.morphTargetInfluences&&l.push(h.name?h.name:h.uuid)}):l.push(a);let c;switch(zc[r.path]){case zc.weights:c=_f;break;case zc.rotation:c=bd;break;case zc.position:case zc.scale:c=Ef;break;default:switch(s.itemSize){case 1:c=_f;break;case 2:case 3:default:c=Ef;break}break}const u=i.interpolation!==void 0?Cse[i.interpolation]:bf,d=this._getArrayFromAccessor(s);for(let h=0,p=l.length;h<p;h++){const g=new c(l[h]+"."+zc[r.path],t.array,d,u);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(g),o.push(g)}return o}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=GC(t.constructor),i=new Float32Array(t.length);for(let r=0,o=t.length;r<o;r++)i[r]=t[r]*s;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const i=this instanceof bd?Sse:SO;return new i(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Mse(n,e,t){const s=e.attributes,i=new La;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],l=a.min,c=a.max;if(l!==void 0&&c!==void 0){if(i.set(new Ne(l[0],l[1],l[2]),new Ne(c[0],c[1],c[2])),a.normalized){const u=GC(lf[a.componentType]);i.min.multiplyScalar(u),i.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const a=new Ne,l=new Ne;for(let c=0,u=r.length;c<u;c++){const d=r[c];if(d.POSITION!==void 0){const h=t.json.accessors[d.POSITION],p=h.min,g=h.max;if(p!==void 0&&g!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(g[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(g[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(g[2]))),h.normalized){const y=GC(lf[h.componentType]);l.multiplyScalar(y)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(a)}n.boundingBox=i;const o=new Rl;i.getCenter(o.center),o.radius=i.min.distanceTo(i.max)/2,n.boundingSphere=o}function ON(n,e,t){const s=e.attributes,i=[];function r(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}for(const o in s){const a=WC[o]||o.toLowerCase();a in n.attributes||i.push(r(s[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});i.push(o)}return Ps.workingColorSpace!==yr&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ps.workingColorSpace}" not supported.`),Hc(n,e),Mse(n,e,t),Promise.all(i).then(function(){return e.targets!==void 0?Ese(n,e.targets,t):n})}var wg=function(){var n=0,e=document.createElement("div");e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(u){u.preventDefault(),s(++n%e.children.length)},!1);function t(u){return e.appendChild(u.dom),u}function s(u){for(var d=0;d<e.children.length;d++)e.children[d].style.display=d===u?"block":"none";n=u}var i=(performance||Date).now(),r=i,o=0,a=t(new wg.Panel("FPS","#0ff","#002")),l=t(new wg.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=t(new wg.Panel("MB","#f08","#201"));return s(0),{REVISION:16,dom:e,addPanel:t,showPanel:s,begin:function(){i=(performance||Date).now()},end:function(){o++;var u=(performance||Date).now();if(l.update(u-i,200),u>=r+1e3&&(a.update(o*1e3/(u-r),100),r=u,o=0,c)){var d=performance.memory;c.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return u},update:function(){i=this.end()},domElement:e,setMode:s}};wg.Panel=function(n,e,t){var s=1/0,i=0,r=Math.round,o=r(window.devicePixelRatio||1),a=80*o,l=48*o,c=3*o,u=2*o,d=3*o,h=15*o,p=74*o,g=30*o,y=document.createElement("canvas");y.width=a,y.height=l,y.style.cssText="width:80px;height:48px";var x=y.getContext("2d");return x.font="bold "+9*o+"px Helvetica,Arial,sans-serif",x.textBaseline="top",x.fillStyle=t,x.fillRect(0,0,a,l),x.fillStyle=e,x.fillText(n,c,u),x.fillRect(d,h,p,g),x.fillStyle=t,x.globalAlpha=.9,x.fillRect(d,h,p,g),{dom:y,update:function(v,b){s=Math.min(s,v),i=Math.max(i,v),x.fillStyle=t,x.globalAlpha=1,x.fillRect(0,0,a,h),x.fillStyle=e,x.fillText(r(v)+" "+n+" ("+r(s)+"-"+r(i)+")",c,u),x.drawImage(y,d+o,h,p-o,g,d,h,p-o,g),x.fillRect(d+p-o,h,o,g),x.fillStyle=t,x.globalAlpha=.9,x.fillRect(d+p-o,h,o,r((1-v/b)*g))}}};class Ia{constructor(e){e===void 0&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){e===void 0&&(e=new se);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){t===void 0&&(t=new se);const s=this.elements,i=e.x,r=e.y,o=e.z;return t.x=s[0]*i+s[1]*r+s[2]*o,t.y=s[3]*i+s[4]*r+s[5]*o,t.z=s[6]*i+s[7]*r+s[8]*o,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){t===void 0&&(t=new Ia);const s=this.elements,i=e.elements,r=t.elements,o=s[0],a=s[1],l=s[2],c=s[3],u=s[4],d=s[5],h=s[6],p=s[7],g=s[8],y=i[0],x=i[1],v=i[2],b=i[3],S=i[4],C=i[5],E=i[6],k=i[7],R=i[8];return r[0]=o*y+a*b+l*E,r[1]=o*x+a*S+l*k,r[2]=o*v+a*C+l*R,r[3]=c*y+u*b+d*E,r[4]=c*x+u*S+d*k,r[5]=c*v+u*C+d*R,r[6]=h*y+p*b+g*E,r[7]=h*x+p*S+g*k,r[8]=h*v+p*C+g*R,t}scale(e,t){t===void 0&&(t=new Ia);const s=this.elements,i=t.elements;for(let r=0;r!==3;r++)i[3*r+0]=e.x*s[3*r+0],i[3*r+1]=e.y*s[3*r+1],i[3*r+2]=e.z*s[3*r+2];return t}solve(e,t){t===void 0&&(t=new se);const s=3,i=4,r=[];let o,a;for(o=0;o<s*i;o++)r.push(0);for(o=0;o<3;o++)for(a=0;a<3;a++)r[o+i*a]=this.elements[o+3*a];r[3+4*0]=e.x,r[3+4*1]=e.y,r[3+4*2]=e.z;let l=3;const c=l;let u;const d=4;let h;do{if(o=c-l,r[o+i*o]===0){for(a=o+1;a<c;a++)if(r[o+i*a]!==0){u=d;do h=d-u,r[h+i*o]+=r[h+i*a];while(--u);break}}if(r[o+i*o]!==0)for(a=o+1;a<c;a++){const p=r[o+i*a]/r[o+i*o];u=d;do h=d-u,r[h+i*a]=h<=o?0:r[h+i*a]-r[h+i*o]*p;while(--u)}}while(--l);if(t.z=r[2*i+3]/r[2*i+2],t.y=(r[1*i+3]-r[1*i+2]*t.z)/r[1*i+1],t.x=(r[0*i+3]-r[0*i+2]*t.z-r[0*i+1]*t.y)/r[0*i+0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,s){if(s===void 0)return this.elements[t+3*e];this.elements[t+3*e]=s}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";const t=",";for(let s=0;s<9;s++)e+=this.elements[s]+t;return e}reverse(e){e===void 0&&(e=new Ia);const t=3,s=6,i=Nse;let r,o;for(r=0;r<3;r++)for(o=0;o<3;o++)i[r+s*o]=this.elements[r+3*o];i[3+6*0]=1,i[3+6*1]=0,i[3+6*2]=0,i[4+6*0]=0,i[4+6*1]=1,i[4+6*2]=0,i[5+6*0]=0,i[5+6*1]=0,i[5+6*2]=1;let a=3;const l=a;let c;const u=s;let d;do{if(r=l-a,i[r+s*r]===0){for(o=r+1;o<l;o++)if(i[r+s*o]!==0){c=u;do d=u-c,i[d+s*r]+=i[d+s*o];while(--c);break}}if(i[r+s*r]!==0)for(o=r+1;o<l;o++){const h=i[r+s*o]/i[r+s*r];c=u;do d=u-c,i[d+s*o]=d<=r?0:i[d+s*o]-i[d+s*r]*h;while(--c)}}while(--a);r=2;do{o=r-1;do{const h=i[r+s*o]/i[r+s*r];c=s;do d=s-c,i[d+s*o]=i[d+s*o]-i[d+s*r]*h;while(--c)}while(o--)}while(--r);r=2;do{const h=1/i[r+s*r];c=s;do d=s-c,i[d+s*r]=i[d+s*r]*h;while(--c)}while(r--);r=2;do{o=2;do{if(d=i[t+o+s*r],isNaN(d)||d===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(r,o,d)}while(o--)}while(r--);return e}setRotationFromQuaternion(e){const t=e.x,s=e.y,i=e.z,r=e.w,o=t+t,a=s+s,l=i+i,c=t*o,u=t*a,d=t*l,h=s*a,p=s*l,g=i*l,y=r*o,x=r*a,v=r*l,b=this.elements;return b[3*0+0]=1-(h+g),b[3*0+1]=u-v,b[3*0+2]=d+x,b[3*1+0]=u+v,b[3*1+1]=1-(c+g),b[3*1+2]=p-y,b[3*2+0]=d-x,b[3*2+1]=p+y,b[3*2+2]=1-(c+h),this}transpose(e){e===void 0&&(e=new Ia);const t=this.elements,s=e.elements;let i;return s[0]=t[0],s[4]=t[4],s[8]=t[8],i=t[1],s[1]=t[3],s[3]=i,i=t[2],s[2]=t[6],s[6]=i,i=t[5],s[5]=t[7],s[7]=i,e}}const Nse=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class se{constructor(e,t,s){e===void 0&&(e=0),t===void 0&&(t=0),s===void 0&&(s=0),this.x=e,this.y=t,this.z=s}cross(e,t){t===void 0&&(t=new se);const s=e.x,i=e.y,r=e.z,o=this.x,a=this.y,l=this.z;return t.x=a*r-l*i,t.y=l*s-o*r,t.z=o*i-a*s,t}set(e,t,s){return this.x=e,this.y=t,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(t)t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z;else return new se(this.x+e.x,this.y+e.y,this.z+e.z)}vsub(e,t){if(t)t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z;else return new se(this.x-e.x,this.y-e.y,this.z-e.z)}crossmat(){return new Ia([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,s=this.z,i=Math.sqrt(e*e+t*t+s*s);if(i>0){const r=1/i;this.x*=r,this.y*=r,this.z*=r}else this.x=0,this.y=0,this.z=0;return i}unit(e){e===void 0&&(e=new se);const t=this.x,s=this.y,i=this.z;let r=Math.sqrt(t*t+s*s+i*i);return r>0?(r=1/r,e.x=t*r,e.y=s*r,e.z=i*r):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,s=this.z;return Math.sqrt(e*e+t*t+s*s)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,s=this.y,i=this.z,r=e.x,o=e.y,a=e.z;return Math.sqrt((r-t)*(r-t)+(o-s)*(o-s)+(a-i)*(a-i))}distanceSquared(e){const t=this.x,s=this.y,i=this.z,r=e.x,o=e.y,a=e.z;return(r-t)*(r-t)+(o-s)*(o-s)+(a-i)*(a-i)}scale(e,t){t===void 0&&(t=new se);const s=this.x,i=this.y,r=this.z;return t.x=e*s,t.y=e*i,t.z=e*r,t}vmul(e,t){return t===void 0&&(t=new se),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,s){return s===void 0&&(s=new se),s.x=this.x+e*t.x,s.y=this.y+e*t.y,s.z=this.z+e*t.z,s}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return this.x===0&&this.y===0&&this.z===0}negate(e){return e===void 0&&(e=new se),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const s=this.length();if(s>0){const i=Pse,r=1/s;i.set(this.x*r,this.y*r,this.z*r);const o=Dse;Math.abs(i.x)<.9?(o.set(1,0,0),i.cross(o,e)):(o.set(0,1,0),i.cross(o,e)),i.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,s){const i=this.x,r=this.y,o=this.z;s.x=i+(e.x-i)*t,s.y=r+(e.y-r)*t,s.z=o+(e.z-o)*t}almostEquals(e,t){return t===void 0&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return e===void 0&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(zN),zN.almostEquals(e,t)}clone(){return new se(this.x,this.y,this.z)}}se.ZERO=new se(0,0,0);se.UNIT_X=new se(1,0,0);se.UNIT_Y=new se(0,1,0);se.UNIT_Z=new se(0,0,1);const Pse=new se,Dse=new se,zN=new se;class $o{constructor(e){e===void 0&&(e={}),this.lowerBound=new se,this.upperBound=new se,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,s,i){const r=this.lowerBound,o=this.upperBound,a=s;r.copy(e[0]),a&&a.vmult(r,r),o.copy(r);for(let l=1;l<e.length;l++){let c=e[l];a&&(a.vmult(c,BN),c=BN),c.x>o.x&&(o.x=c.x),c.x<r.x&&(r.x=c.x),c.y>o.y&&(o.y=c.y),c.y<r.y&&(r.y=c.y),c.z>o.z&&(o.z=c.z),c.z<r.z&&(r.z=c.z)}return t&&(t.vadd(r,r),t.vadd(o,o)),i&&(r.x-=i,r.y-=i,r.z-=i,o.x+=i,o.y+=i,o.z+=i),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return new $o().copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,s=this.upperBound,i=e.lowerBound,r=e.upperBound,o=i.x<=s.x&&s.x<=r.x||t.x<=r.x&&r.x<=s.x,a=i.y<=s.y&&s.y<=r.y||t.y<=r.y&&r.y<=s.y,l=i.z<=s.z&&s.z<=r.z||t.z<=r.z&&r.z<=s.z;return o&&a&&l}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,s=this.upperBound,i=e.lowerBound,r=e.upperBound;return t.x<=i.x&&s.x>=r.x&&t.y<=i.y&&s.y>=r.y&&t.z<=i.z&&s.z>=r.z}getCorners(e,t,s,i,r,o,a,l){const c=this.lowerBound,u=this.upperBound;e.copy(c),t.set(u.x,c.y,c.z),s.set(u.x,u.y,c.z),i.set(c.x,u.y,u.z),r.set(u.x,c.y,u.z),o.set(c.x,u.y,c.z),a.set(c.x,c.y,u.z),l.copy(u)}toLocalFrame(e,t){const s=UN,i=s[0],r=s[1],o=s[2],a=s[3],l=s[4],c=s[5],u=s[6],d=s[7];this.getCorners(i,r,o,a,l,c,u,d);for(let h=0;h!==8;h++){const p=s[h];e.pointToLocal(p,p)}return t.setFromPoints(s)}toWorldFrame(e,t){const s=UN,i=s[0],r=s[1],o=s[2],a=s[3],l=s[4],c=s[5],u=s[6],d=s[7];this.getCorners(i,r,o,a,l,c,u,d);for(let h=0;h!==8;h++){const p=s[h];e.pointToWorld(p,p)}return t.setFromPoints(s)}overlapsRay(e){const{direction:t,from:s}=e,i=1/t.x,r=1/t.y,o=1/t.z,a=(this.lowerBound.x-s.x)*i,l=(this.upperBound.x-s.x)*i,c=(this.lowerBound.y-s.y)*r,u=(this.upperBound.y-s.y)*r,d=(this.lowerBound.z-s.z)*o,h=(this.upperBound.z-s.z)*o,p=Math.max(Math.max(Math.min(a,l),Math.min(c,u)),Math.min(d,h)),g=Math.min(Math.min(Math.max(a,l),Math.max(c,u)),Math.max(d,h));return!(g<0||p>g)}}const BN=new se,UN=[new se,new se,new se,new se,new se,new se,new se,new se];class VN{constructor(){this.matrix=[]}get(e,t){let{index:s}=e,{index:i}=t;if(i>s){const r=i;i=s,s=r}return this.matrix[(s*(s+1)>>1)+i-1]}set(e,t,s){let{index:i}=e,{index:r}=t;if(r>i){const o=r;r=i,i=o}this.matrix[(i*(i+1)>>1)+r-1]=s?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class CO{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;return s[e]===void 0&&(s[e]=[]),s[e].includes(t)||s[e].push(t),this}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return!!(s[e]!==void 0&&s[e].includes(t))}hasAnyEventListener(e){return this._listeners===void 0?!1:this._listeners[e]!==void 0}removeEventListener(e,t){if(this._listeners===void 0)return this;const s=this._listeners;if(s[e]===void 0)return this;const i=s[e].indexOf(t);return i!==-1&&s[e].splice(i,1),this}dispatchEvent(e){if(this._listeners===void 0)return this;const s=this._listeners[e.type];if(s!==void 0){e.target=this;for(let i=0,r=s.length;i<r;i++)s[i].call(this,e)}return this}}class $i{constructor(e,t,s,i){e===void 0&&(e=0),t===void 0&&(t=0),s===void 0&&(s=0),i===void 0&&(i=1),this.x=e,this.y=t,this.z=s,this.w=i}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const s=Math.sin(t*.5);return this.x=e.x*s,this.y=e.y*s,this.z=e.z*s,this.w=Math.cos(t*.5),this}toAxisAngle(e){e===void 0&&(e=new se),this.normalize();const t=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/s,e.y=this.y/s,e.z=this.z/s),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const s=Lse,i=$se;e.tangents(s,i),this.setFromAxisAngle(s,Math.PI)}else{const s=e.cross(t);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){t===void 0&&(t=new $i);const s=this.x,i=this.y,r=this.z,o=this.w,a=e.x,l=e.y,c=e.z,u=e.w;return t.x=s*u+o*a+i*c-r*l,t.y=i*u+o*l+r*a-s*c,t.z=r*u+o*c+s*l-i*a,t.w=o*u-s*a-i*l-r*c,t}inverse(e){e===void 0&&(e=new $i);const t=this.x,s=this.y,i=this.z,r=this.w;this.conjugate(e);const o=1/(t*t+s*s+i*i+r*r);return e.x*=o,e.y*=o,e.z*=o,e.w*=o,e}conjugate(e){return e===void 0&&(e=new $i),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return e===0?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return e===0?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){t===void 0&&(t=new se);const s=e.x,i=e.y,r=e.z,o=this.x,a=this.y,l=this.z,c=this.w,u=c*s+a*r-l*i,d=c*i+l*s-o*r,h=c*r+o*i-a*s,p=-o*s-a*i-l*r;return t.x=u*c+p*-o+d*-l-h*-a,t.y=d*c+p*-a+h*-o-u*-l,t.z=h*c+p*-l+u*-a-d*-o,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){t===void 0&&(t="YZX");let s,i,r;const o=this.x,a=this.y,l=this.z,c=this.w;switch(t){case"YZX":const u=o*a+l*c;if(u>.499&&(s=2*Math.atan2(o,c),i=Math.PI/2,r=0),u<-.499&&(s=-2*Math.atan2(o,c),i=-Math.PI/2,r=0),s===void 0){const d=o*o,h=a*a,p=l*l;s=Math.atan2(2*a*c-2*o*l,1-2*h-2*p),i=Math.asin(2*u),r=Math.atan2(2*o*c-2*a*l,1-2*d-2*p)}break;default:throw new Error(`Euler order ${t} not supported yet.`)}e.y=s,e.z=i,e.x=r}setFromEuler(e,t,s,i){i===void 0&&(i="XYZ");const r=Math.cos(e/2),o=Math.cos(t/2),a=Math.cos(s/2),l=Math.sin(e/2),c=Math.sin(t/2),u=Math.sin(s/2);return i==="XYZ"?(this.x=l*o*a+r*c*u,this.y=r*c*a-l*o*u,this.z=r*o*u+l*c*a,this.w=r*o*a-l*c*u):i==="YXZ"?(this.x=l*o*a+r*c*u,this.y=r*c*a-l*o*u,this.z=r*o*u-l*c*a,this.w=r*o*a+l*c*u):i==="ZXY"?(this.x=l*o*a-r*c*u,this.y=r*c*a+l*o*u,this.z=r*o*u+l*c*a,this.w=r*o*a-l*c*u):i==="ZYX"?(this.x=l*o*a-r*c*u,this.y=r*c*a+l*o*u,this.z=r*o*u-l*c*a,this.w=r*o*a+l*c*u):i==="YZX"?(this.x=l*o*a+r*c*u,this.y=r*c*a+l*o*u,this.z=r*o*u-l*c*a,this.w=r*o*a-l*c*u):i==="XZY"&&(this.x=l*o*a-r*c*u,this.y=r*c*a-l*o*u,this.z=r*o*u+l*c*a,this.w=r*o*a+l*c*u),this}clone(){return new $i(this.x,this.y,this.z,this.w)}slerp(e,t,s){s===void 0&&(s=new $i);const i=this.x,r=this.y,o=this.z,a=this.w;let l=e.x,c=e.y,u=e.z,d=e.w,h,p,g,y,x;return p=i*l+r*c+o*u+a*d,p<0&&(p=-p,l=-l,c=-c,u=-u,d=-d),1-p>1e-6?(h=Math.acos(p),g=Math.sin(h),y=Math.sin((1-t)*h)/g,x=Math.sin(t*h)/g):(y=1-t,x=t),s.x=y*i+x*l,s.y=y*r+x*c,s.z=y*o+x*u,s.w=y*a+x*d,s}integrate(e,t,s,i){i===void 0&&(i=new $i);const r=e.x*s.x,o=e.y*s.y,a=e.z*s.z,l=this.x,c=this.y,u=this.z,d=this.w,h=t*.5;return i.x+=h*(r*d+o*u-a*c),i.y+=h*(o*d+a*l-r*u),i.z+=h*(a*d+r*c-o*l),i.w+=h*(-r*l-o*c-a*u),i}}const Lse=new se,$se=new se,Fse={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class fn{constructor(e){e===void 0&&(e={}),this.id=fn.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=e.collisionResponse?e.collisionResponse:!0,this.collisionFilterGroup=e.collisionFilterGroup!==void 0?e.collisionFilterGroup:1,this.collisionFilterMask=e.collisionFilterMask!==void 0?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,s,i){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}fn.idCounter=0;fn.types=Fse;let Bs=class HC{constructor(e){e===void 0&&(e={}),this.position=new se,this.quaternion=new $i,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return HC.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return HC.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return t===void 0&&(t=new se),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,s,i){return i===void 0&&(i=new se),s.vsub(e,i),t.conjugate(WN),WN.vmult(i,i),i}static pointToWorldFrame(e,t,s,i){return i===void 0&&(i=new se),t.vmult(s,i),i.vadd(e,i),i}static vectorToWorldFrame(e,t,s){return s===void 0&&(s=new se),e.vmult(t,s),s}static vectorToLocalFrame(e,t,s,i){return i===void 0&&(i=new se),t.w*=-1,t.vmult(s,i),t.w*=-1,i}};const WN=new $i;class bg extends fn{constructor(e){e===void 0&&(e={});const{vertices:t=[],faces:s=[],normals:i=[],axes:r,boundingSphereRadius:o}=e;super({type:fn.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=s,this.faceNormals=i,this.faceNormals.length===0&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=r?r.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,s=this.uniqueEdges;s.length=0;const i=new se;for(let r=0;r!==e.length;r++){const o=e[r],a=o.length;for(let l=0;l!==a;l++){const c=(l+1)%a;t[o[l]].vsub(t[o[c]],i),i.normalize();let u=!1;for(let d=0;d!==s.length;d++)if(s[d].almostEquals(i)||s[d].almostEquals(i)){u=!0;break}u||s.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let i=0;i<this.faces[e].length;i++)if(!this.vertices[this.faces[e][i]])throw new Error(`Vertex ${this.faces[e][i]} not found!`);const t=this.faceNormals[e]||new se;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const s=this.vertices[this.faces[e][0]];if(t.dot(s)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let i=0;i<this.faces[e].length;i++)console.warn(`.vertices[${this.faces[e][i]}] = Vec3(${this.vertices[this.faces[e][i]].toString()})`)}}}getFaceNormal(e,t){const s=this.faces[e],i=this.vertices[s[0]],r=this.vertices[s[1]],o=this.vertices[s[2]];bg.computeNormal(i,r,o,t)}static computeNormal(e,t,s,i){const r=new se,o=new se;t.vsub(e,o),s.vsub(t,r),r.cross(o,i),i.isZero()||i.normalize()}clipAgainstHull(e,t,s,i,r,o,a,l,c){const u=new se;let d=-1,h=-Number.MAX_VALUE;for(let g=0;g<s.faces.length;g++){u.copy(s.faceNormals[g]),r.vmult(u,u);const y=u.dot(o);y>h&&(h=y,d=g)}const p=[];for(let g=0;g<s.faces[d].length;g++){const y=s.vertices[s.faces[d][g]],x=new se;x.copy(y),r.vmult(x,x),i.vadd(x,x),p.push(x)}d>=0&&this.clipFaceAgainstHull(o,e,t,p,a,l,c)}findSeparatingAxis(e,t,s,i,r,o,a,l){const c=new se,u=new se,d=new se,h=new se,p=new se,g=new se;let y=Number.MAX_VALUE;const x=this;if(x.uniqueAxes)for(let v=0;v!==x.uniqueAxes.length;v++){s.vmult(x.uniqueAxes[v],c);const b=x.testSepAxis(c,e,t,s,i,r);if(b===!1)return!1;b<y&&(y=b,o.copy(c))}else{const v=a?a.length:x.faces.length;for(let b=0;b<v;b++){const S=a?a[b]:b;c.copy(x.faceNormals[S]),s.vmult(c,c);const C=x.testSepAxis(c,e,t,s,i,r);if(C===!1)return!1;C<y&&(y=C,o.copy(c))}}if(e.uniqueAxes)for(let v=0;v!==e.uniqueAxes.length;v++){r.vmult(e.uniqueAxes[v],u);const b=x.testSepAxis(u,e,t,s,i,r);if(b===!1)return!1;b<y&&(y=b,o.copy(u))}else{const v=l?l.length:e.faces.length;for(let b=0;b<v;b++){const S=l?l[b]:b;u.copy(e.faceNormals[S]),r.vmult(u,u);const C=x.testSepAxis(u,e,t,s,i,r);if(C===!1)return!1;C<y&&(y=C,o.copy(u))}}for(let v=0;v!==x.uniqueEdges.length;v++){s.vmult(x.uniqueEdges[v],h);for(let b=0;b!==e.uniqueEdges.length;b++)if(r.vmult(e.uniqueEdges[b],p),h.cross(p,g),!g.almostZero()){g.normalize();const S=x.testSepAxis(g,e,t,s,i,r);if(S===!1)return!1;S<y&&(y=S,o.copy(g))}}return i.vsub(t,d),d.dot(o)>0&&o.negate(o),!0}testSepAxis(e,t,s,i,r,o){const a=this;bg.project(a,e,s,i,RS),bg.project(t,e,r,o,MS);const l=RS[0],c=RS[1],u=MS[0],d=MS[1];if(l<d||u<c)return!1;const h=l-d,p=u-c;return h<p?h:p}calculateLocalInertia(e,t){const s=new se,i=new se;this.computeLocalAABB(i,s);const r=s.x-i.x,o=s.y-i.y,a=s.z-i.z;t.x=1/12*e*(2*o*2*o+2*a*2*a),t.y=1/12*e*(2*r*2*r+2*a*2*a),t.z=1/12*e*(2*o*2*o+2*r*2*r)}getPlaneConstantOfFace(e){const t=this.faces[e],s=this.faceNormals[e],i=this.vertices[t[0]];return-s.dot(i)}clipFaceAgainstHull(e,t,s,i,r,o,a){const l=new se,c=new se,u=new se,d=new se,h=new se,p=new se,g=new se,y=new se,x=this,v=[],b=i,S=v;let C=-1,E=Number.MAX_VALUE;for(let T=0;T<x.faces.length;T++){l.copy(x.faceNormals[T]),s.vmult(l,l);const M=l.dot(e);M<E&&(E=M,C=T)}if(C<0)return;const k=x.faces[C];k.connectedFaces=[];for(let T=0;T<x.faces.length;T++)for(let M=0;M<x.faces[T].length;M++)k.indexOf(x.faces[T][M])!==-1&&T!==C&&k.connectedFaces.indexOf(T)===-1&&k.connectedFaces.push(T);const R=k.length;for(let T=0;T<R;T++){const M=x.vertices[k[T]],j=x.vertices[k[(T+1)%R]];M.vsub(j,c),u.copy(c),s.vmult(u,u),t.vadd(u,u),d.copy(this.faceNormals[C]),s.vmult(d,d),t.vadd(d,d),u.cross(d,h),h.negate(h),p.copy(M),s.vmult(p,p),t.vadd(p,p);const W=k.connectedFaces[T];g.copy(this.faceNormals[W]);const z=this.getPlaneConstantOfFace(W);y.copy(g),s.vmult(y,y);const X=z-y.dot(t);for(this.clipFaceAgainstPlane(b,S,y,X);b.length;)b.shift();for(;S.length;)b.push(S.shift())}g.copy(this.faceNormals[C]);const L=this.getPlaneConstantOfFace(C);y.copy(g),s.vmult(y,y);const I=L-y.dot(t);for(let T=0;T<b.length;T++){let M=y.dot(b[T])+I;if(M<=r&&(console.log(`clamped: depth=${M} to minDist=${r}`),M=r),M<=o){const j=b[T];if(M<=1e-6){const W={point:j,normal:y,depth:M};a.push(W)}}}}clipFaceAgainstPlane(e,t,s,i){let r,o;const a=e.length;if(a<2)return t;let l=e[e.length-1],c=e[0];r=s.dot(l)+i;for(let u=0;u<a;u++){if(c=e[u],o=s.dot(c)+i,r<0)if(o<0){const d=new se;d.copy(c),t.push(d)}else{const d=new se;l.lerp(c,r/(r-o),d),t.push(d)}else if(o<0){const d=new se;l.lerp(c,r/(r-o),d),t.push(d),t.push(c)}l=c,r=o}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new se);const s=this.vertices,i=this.worldVertices;for(let r=0;r!==this.vertices.length;r++)t.vmult(s[r],i[r]),e.vadd(i[r],i[r]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const s=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const r=s[i];r.x<e.x?e.x=r.x:r.x>t.x&&(t.x=r.x),r.y<e.y?e.y=r.y:r.y>t.y&&(t.y=r.y),r.z<e.z?e.z=r.z:r.z>t.z&&(t.z=r.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new se);const s=this.faceNormals,i=this.worldFaceNormals;for(let r=0;r!==t;r++)e.vmult(s[r],i[r]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let s=0;s!==t.length;s++){const i=t[s].lengthSquared();i>e&&(e=i)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,s,i){const r=this.vertices;let o,a,l,c,u,d,h=new se;for(let p=0;p<r.length;p++){h.copy(r[p]),t.vmult(h,h),e.vadd(h,h);const g=h;(o===void 0||g.x<o)&&(o=g.x),(c===void 0||g.x>c)&&(c=g.x),(a===void 0||g.y<a)&&(a=g.y),(u===void 0||g.y>u)&&(u=g.y),(l===void 0||g.z<l)&&(l=g.z),(d===void 0||g.z>d)&&(d=g.z)}s.set(o,a,l),i.set(c,u,d)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){e===void 0&&(e=new se);const t=this.vertices;for(let s=0;s<t.length;s++)e.vadd(t[s],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const s=this.vertices.length,i=this.vertices;if(t){for(let r=0;r<s;r++){const o=i[r];t.vmult(o,o)}for(let r=0;r<this.faceNormals.length;r++){const o=this.faceNormals[r];t.vmult(o,o)}}if(e)for(let r=0;r<s;r++){const o=i[r];o.vadd(e,o)}}pointIsInside(e){const t=this.vertices,s=this.faces,i=this.faceNormals,r=new se;this.getAveragePointLocal(r);for(let o=0;o<this.faces.length;o++){let a=i[o];const l=t[s[o][0]],c=new se;e.vsub(l,c);const u=a.dot(c),d=new se;r.vsub(l,d);const h=a.dot(d);if(u<0&&h>0||u>0&&h<0)return!1}return-1}static project(e,t,s,i,r){const o=e.vertices.length,a=Ose;let l=0,c=0;const u=zse,d=e.vertices;u.setZero(),Bs.vectorToLocalFrame(s,i,t,a),Bs.pointToLocalFrame(s,i,u,u);const h=u.dot(a);c=l=d[0].dot(a);for(let p=1;p<o;p++){const g=d[p].dot(a);g>l&&(l=g),g<c&&(c=g)}if(c-=h,l-=h,c>l){const p=c;c=l,l=p}r[0]=l,r[1]=c}}const RS=[],MS=[];new se;const Ose=new se,zse=new se;class WE extends fn{constructor(e){super({type:fn.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,s=this.halfExtents.z,i=se,r=[new i(-e,-t,-s),new i(e,-t,-s),new i(e,t,-s),new i(-e,t,-s),new i(-e,-t,s),new i(e,-t,s),new i(e,t,s),new i(-e,t,s)],o=[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],a=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],l=new bg({vertices:r,faces:o,axes:a});this.convexPolyhedronRepresentation=l,l.material=this.material}calculateLocalInertia(e,t){return t===void 0&&(t=new se),WE.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,s){const i=e;s.x=1/12*t*(2*i.y*2*i.y+2*i.z*2*i.z),s.y=1/12*t*(2*i.x*2*i.x+2*i.z*2*i.z),s.z=1/12*t*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(e,t){const s=e,i=this.halfExtents;if(s[0].set(i.x,0,0),s[1].set(0,i.y,0),s[2].set(0,0,i.z),s[3].set(-i.x,0,0),s[4].set(0,-i.y,0),s[5].set(0,0,-i.z),t!==void 0)for(let r=0;r!==s.length;r++)t.vmult(s[r],s[r]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,s){const i=this.halfExtents,r=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let o=0;o<r.length;o++)Bc.set(r[o][0],r[o][1],r[o][2]),t.vmult(Bc,Bc),e.vadd(Bc,Bc),s(Bc.x,Bc.y,Bc.z)}calculateWorldAABB(e,t,s,i){const r=this.halfExtents;Za[0].set(r.x,r.y,r.z),Za[1].set(-r.x,r.y,r.z),Za[2].set(-r.x,-r.y,r.z),Za[3].set(-r.x,-r.y,-r.z),Za[4].set(r.x,-r.y,-r.z),Za[5].set(r.x,r.y,-r.z),Za[6].set(-r.x,r.y,-r.z),Za[7].set(r.x,-r.y,r.z);const o=Za[0];t.vmult(o,o),e.vadd(o,o),i.copy(o),s.copy(o);for(let a=1;a<8;a++){const l=Za[a];t.vmult(l,l),e.vadd(l,l);const c=l.x,u=l.y,d=l.z;c>i.x&&(i.x=c),u>i.y&&(i.y=u),d>i.z&&(i.z=d),c<s.x&&(s.x=c),u<s.y&&(s.y=u),d<s.z&&(s.z=d)}}}const Bc=new se,Za=[new se,new se,new se,new se,new se,new se,new se,new se],uy={DYNAMIC:1,STATIC:2,KINEMATIC:4},GE={AWAKE:0,SLEEPY:1,SLEEPING:2};class pn extends CO{constructor(e){e===void 0&&(e={}),super(),this.id=pn.idCounter++,this.index=-1,this.world=null,this.vlambda=new se,this.collisionFilterGroup=typeof e.collisionFilterGroup=="number"?e.collisionFilterGroup:1,this.collisionFilterMask=typeof e.collisionFilterMask=="number"?e.collisionFilterMask:-1,this.collisionResponse=typeof e.collisionResponse=="boolean"?e.collisionResponse:!0,this.position=new se,this.previousPosition=new se,this.interpolatedPosition=new se,this.initPosition=new se,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new se,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new se,this.force=new se;const t=typeof e.mass=="number"?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping=typeof e.linearDamping=="number"?e.linearDamping:.01,this.type=t<=0?pn.STATIC:pn.DYNAMIC,typeof e.type==typeof pn.STATIC&&(this.type=e.type),this.allowSleep=typeof e.allowSleep<"u"?e.allowSleep:!0,this.sleepState=pn.AWAKE,this.sleepSpeedLimit=typeof e.sleepSpeedLimit<"u"?e.sleepSpeedLimit:.1,this.sleepTimeLimit=typeof e.sleepTimeLimit<"u"?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new se,this.quaternion=new $i,this.initQuaternion=new $i,this.previousQuaternion=new $i,this.interpolatedQuaternion=new $i,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new se,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new se,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new se,this.invInertia=new se,this.invInertiaWorld=new Ia,this.invMassSolve=0,this.invInertiaSolve=new se,this.invInertiaWorldSolve=new Ia,this.fixedRotation=typeof e.fixedRotation<"u"?e.fixedRotation:!1,this.angularDamping=typeof e.angularDamping<"u"?e.angularDamping:.01,this.linearFactor=new se(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new se(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new $o,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new se,this.isTrigger=!!e.isTrigger,e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=pn.AWAKE,this.wakeUpAfterNarrowphase=!1,e===pn.SLEEPING&&this.dispatchEvent(pn.wakeupEvent)}sleep(){this.sleepState=pn.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;t===pn.AWAKE&&s<i?(this.sleepState=pn.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(pn.sleepyEvent)):t===pn.SLEEPY&&s>i?this.wakeUp():t===pn.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(pn.sleepEvent))}}updateSolveMassProperties(){this.sleepState===pn.SLEEPING||this.type===pn.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return t===void 0&&(t=new se),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return t===void 0&&(t=new se),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return t===void 0&&(t=new se),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return t===void 0&&(t=new se),this.quaternion.vmult(e,t),t}addShape(e,t,s){const i=new se,r=new $i;return t&&i.copy(t),s&&r.copy(s),this.shapes.push(e),this.shapeOffsets.push(i),this.shapeOrientations.push(r),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return t===-1?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,s=e.length;let i=0;for(let r=0;r!==s;r++){const o=e[r];o.updateBoundingSphereRadius();const a=t[r].length(),l=o.boundingSphereRadius;a+l>i&&(i=a+l)}this.boundingRadius=i}updateAABB(){const e=this.shapes,t=this.shapeOffsets,s=this.shapeOrientations,i=e.length,r=Bse,o=Use,a=this.quaternion,l=this.aabb,c=Vse;for(let u=0;u!==i;u++){const d=e[u];a.vmult(t[u],r),r.vadd(this.position,r),a.mult(s[u],o),d.calculateWorldAABB(r,o,c.lowerBound,c.upperBound),u===0?l.copy(c):l.extend(c)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(!(t.x===t.y&&t.y===t.z&&!e)){const s=Wse,i=Gse;s.setRotationFromQuaternion(this.quaternion),s.transpose(i),s.scale(t,s),s.mmult(i,this.invInertiaWorld)}}applyForce(e,t){if(t===void 0&&(t=new se),this.type!==pn.DYNAMIC)return;this.sleepState===pn.SLEEPING&&this.wakeUp();const s=Hse;t.cross(e,s),this.force.vadd(e,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(e,t){if(t===void 0&&(t=new se),this.type!==pn.DYNAMIC)return;const s=jse,i=Xse;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,i),this.applyForce(s,i)}applyTorque(e){this.type===pn.DYNAMIC&&(this.sleepState===pn.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(t===void 0&&(t=new se),this.type!==pn.DYNAMIC)return;this.sleepState===pn.SLEEPING&&this.wakeUp();const s=t,i=qse;i.copy(e),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const r=Kse;s.cross(e,r),this.invInertiaWorld.vmult(r,r),this.angularVelocity.vadd(r,this.angularVelocity)}applyLocalImpulse(e,t){if(t===void 0&&(t=new se),this.type!==pn.DYNAMIC)return;const s=Yse,i=Zse;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,i),this.applyImpulse(s,i)}updateMassProperties(){const e=Qse;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,s=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),WE.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!s?1/t.x:0,t.y>0&&!s?1/t.y:0,t.z>0&&!s?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const s=new se;return e.vsub(this.position,s),this.angularVelocity.cross(s,t),this.velocity.vadd(t,t),t}integrate(e,t,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===pn.DYNAMIC||this.type===pn.KINEMATIC)||this.sleepState===pn.SLEEPING)return;const i=this.velocity,r=this.angularVelocity,o=this.position,a=this.force,l=this.torque,c=this.quaternion,u=this.invMass,d=this.invInertiaWorld,h=this.linearFactor,p=u*e;i.x+=a.x*p*h.x,i.y+=a.y*p*h.y,i.z+=a.z*p*h.z;const g=d.elements,y=this.angularFactor,x=l.x*y.x,v=l.y*y.y,b=l.z*y.z;r.x+=e*(g[0]*x+g[1]*v+g[2]*b),r.y+=e*(g[3]*x+g[4]*v+g[5]*b),r.z+=e*(g[6]*x+g[7]*v+g[8]*b),o.x+=i.x*e,o.y+=i.y*e,o.z+=i.z*e,c.integrate(this.angularVelocity,e,this.angularFactor,c),t&&(s?c.normalizeFast():c.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}pn.idCounter=0;pn.COLLIDE_EVENT_NAME="collide";pn.DYNAMIC=uy.DYNAMIC;pn.STATIC=uy.STATIC;pn.KINEMATIC=uy.KINEMATIC;pn.AWAKE=GE.AWAKE;pn.SLEEPY=GE.SLEEPY;pn.SLEEPING=GE.SLEEPING;pn.wakeupEvent={type:"wakeup"};pn.sleepyEvent={type:"sleepy"};pn.sleepEvent={type:"sleep"};const Bse=new se,Use=new $i,Vse=new $o,Wse=new Ia,Gse=new Ia;new Ia;const Hse=new se,jse=new se,Xse=new se,qse=new se,Kse=new se,Yse=new se,Zse=new se,Qse=new se;class _O{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,s){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return!((e.collisionFilterGroup&t.collisionFilterMask)===0||(t.collisionFilterGroup&e.collisionFilterMask)===0||((e.type&pn.STATIC)!==0||e.sleepState===pn.SLEEPING)&&((t.type&pn.STATIC)!==0||t.sleepState===pn.SLEEPING))}intersectionTest(e,t,s,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,s,i):this.doBoundingSphereBroadphase(e,t,s,i)}doBoundingSphereBroadphase(e,t,s,i){const r=Jse;t.position.vsub(e.position,r);const o=(e.boundingRadius+t.boundingRadius)**2;r.lengthSquared()<o&&(s.push(e),i.push(t))}doBoundingBoxBroadphase(e,t,s,i){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(s.push(e),i.push(t))}makePairsUnique(e,t){const s=eie,i=tie,r=nie,o=e.length;for(let a=0;a!==o;a++)i[a]=e[a],r[a]=t[a];e.length=0,t.length=0;for(let a=0;a!==o;a++){const l=i[a].id,c=r[a].id,u=l<c?`${l},${c}`:`${c},${l}`;s[u]=a,s.keys.push(u)}for(let a=0;a!==s.keys.length;a++){const l=s.keys.pop(),c=s[l];e.push(i[c]),t.push(r[c]),delete s[l]}}setWorld(e){}static boundingSphereCheck(e,t){const s=new se;e.position.vsub(t.position,s);const i=e.shapes[0],r=t.shapes[0];return Math.pow(i.boundingSphereRadius+r.boundingSphereRadius,2)>s.lengthSquared()}aabbQuery(e,t,s){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Jse=new se;new se;new $i;new se;const eie={keys:[]},tie=[],nie=[];new se;new se;new se;class sie extends _O{constructor(){super()}collisionPairs(e,t,s){const i=e.bodies,r=i.length;let o,a;for(let l=0;l!==r;l++)for(let c=0;c!==l;c++)o=i[l],a=i[c],this.needBroadphaseCollision(o,a)&&this.intersectionTest(o,a,t,s)}aabbQuery(e,t,s){s===void 0&&(s=[]);for(let i=0;i<e.bodies.length;i++){const r=e.bodies[i];r.aabbNeedsUpdate&&r.updateAABB(),r.aabb.overlaps(t)&&s.push(r)}return s}}class u2{constructor(){this.rayFromWorld=new se,this.rayToWorld=new se,this.hitNormalWorld=new se,this.hitPointWorld=new se,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,s,i,r,o,a){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(i),this.shape=r,this.body=o,this.distance=a}}let EO,TO,IO,kO,AO,RO,MO;const HE={CLOSEST:1,ANY:2,ALL:4};EO=fn.types.SPHERE;TO=fn.types.PLANE;IO=fn.types.BOX;kO=fn.types.CYLINDER;AO=fn.types.CONVEXPOLYHEDRON;RO=fn.types.HEIGHTFIELD;MO=fn.types.TRIMESH;class Li{get[EO](){return this._intersectSphere}get[TO](){return this._intersectPlane}get[IO](){return this._intersectBox}get[kO](){return this._intersectConvex}get[AO](){return this._intersectConvex}get[RO](){return this._intersectHeightfield}get[MO](){return this._intersectTrimesh}constructor(e,t){e===void 0&&(e=new se),t===void 0&&(t=new se),this.from=e.clone(),this.to=t.clone(),this.direction=new se,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Li.ANY,this.result=new u2,this.hasHit=!1,this.callback=s=>{}}intersectWorld(e,t){return this.mode=t.mode||Li.ANY,this.result=t.result||new u2,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=typeof t.collisionFilterMask<"u"?t.collisionFilterMask:-1,this.collisionFilterGroup=typeof t.collisionFilterGroup<"u"?t.collisionFilterGroup:-1,this.checkCollisionResponse=typeof t.checkCollisionResponse<"u"?t.checkCollisionResponse:!0,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(GN),NS.length=0,e.broadphase.aabbQuery(e,GN,NS),this.intersectBodies(NS),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!e.collisionResponse||(this.collisionFilterGroup&e.collisionFilterMask)===0||(e.collisionFilterGroup&this.collisionFilterMask)===0)return;const i=iie,r=rie;for(let o=0,a=e.shapes.length;o<a;o++){const l=e.shapes[o];if(!(s&&!l.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[o],r),e.quaternion.vmult(e.shapeOffsets[o],i),i.vadd(e.position,i),this.intersectShape(l,r,i,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let s=0,i=e.length;!this.result.shouldStop&&s<i;s++)this.intersectBody(e[s])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,s,i){const r=this.from;if(yie(r,this.direction,s)>e.boundingSphereRadius)return;const a=this[e.type];a&&a.call(this,e,t,s,i,e)}_intersectBox(e,t,s,i,r){return this._intersectConvex(e.convexPolyhedronRepresentation,t,s,i,r)}_intersectPlane(e,t,s,i,r){const o=this.from,a=this.to,l=this.direction,c=new se(0,0,1);t.vmult(c,c);const u=new se;o.vsub(s,u);const d=u.dot(c);a.vsub(s,u);const h=u.dot(c);if(d*h>0||o.distanceTo(a)<d)return;const p=c.dot(l);if(Math.abs(p)<this.precision)return;const g=new se,y=new se,x=new se;o.vsub(s,g);const v=-c.dot(g)/p;l.scale(v,y),o.vadd(y,x),this.reportIntersection(c,x,r,i,-1)}getAABB(e){const{lowerBound:t,upperBound:s}=e,i=this.to,r=this.from;t.x=Math.min(i.x,r.x),t.y=Math.min(i.y,r.y),t.z=Math.min(i.z,r.z),s.x=Math.max(i.x,r.x),s.y=Math.max(i.y,r.y),s.z=Math.max(i.z,r.z)}_intersectHeightfield(e,t,s,i,r){e.data,e.elementSize;const o=oie;o.from.copy(this.from),o.to.copy(this.to),Bs.pointToLocalFrame(s,t,o.from,o.from),Bs.pointToLocalFrame(s,t,o.to,o.to),o.updateDirection();const a=aie;let l,c,u,d;l=c=0,u=d=e.data.length-1;const h=new $o;o.getAABB(h),e.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,a,!0),l=Math.max(l,a[0]),c=Math.max(c,a[1]),e.getIndexOfPosition(h.upperBound.x,h.upperBound.y,a,!0),u=Math.min(u,a[0]+1),d=Math.min(d,a[1]+1);for(let p=l;p<u;p++)for(let g=c;g<d;g++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(p,g,h),!!h.overlapsRay(o)){if(e.getConvexTrianglePillar(p,g,!1),Bs.pointToWorldFrame(s,t,e.pillarOffset,rv),this._intersectConvex(e.pillarConvex,t,rv,i,r,HN),this.result.shouldStop)return;e.getConvexTrianglePillar(p,g,!0),Bs.pointToWorldFrame(s,t,e.pillarOffset,rv),this._intersectConvex(e.pillarConvex,t,rv,i,r,HN)}}}_intersectSphere(e,t,s,i,r){const o=this.from,a=this.to,l=e.radius,c=(a.x-o.x)**2+(a.y-o.y)**2+(a.z-o.z)**2,u=2*((a.x-o.x)*(o.x-s.x)+(a.y-o.y)*(o.y-s.y)+(a.z-o.z)*(o.z-s.z)),d=(o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2-l**2,h=u**2-4*c*d,p=lie,g=cie;if(!(h<0))if(h===0)o.lerp(a,h,p),p.vsub(s,g),g.normalize(),this.reportIntersection(g,p,r,i,-1);else{const y=(-u-Math.sqrt(h))/(2*c),x=(-u+Math.sqrt(h))/(2*c);if(y>=0&&y<=1&&(o.lerp(a,y,p),p.vsub(s,g),g.normalize(),this.reportIntersection(g,p,r,i,-1)),this.result.shouldStop)return;x>=0&&x<=1&&(o.lerp(a,x,p),p.vsub(s,g),g.normalize(),this.reportIntersection(g,p,r,i,-1))}}_intersectConvex(e,t,s,i,r,o){const a=uie,l=jN,c=o&&o.faceList||null,u=e.faces,d=e.vertices,h=e.faceNormals,p=this.direction,g=this.from,y=this.to,x=g.distanceTo(y),v=c?c.length:u.length,b=this.result;for(let S=0;!b.shouldStop&&S<v;S++){const C=c?c[S]:S,E=u[C],k=h[C],R=t,L=s;l.copy(d[E[0]]),R.vmult(l,l),l.vadd(L,l),l.vsub(g,l),R.vmult(k,a);const I=p.dot(a);if(Math.abs(I)<this.precision)continue;const T=a.dot(l)/I;if(!(T<0)){p.scale(T,ho),ho.vadd(g,ho),wa.copy(d[E[0]]),R.vmult(wa,wa),L.vadd(wa,wa);for(let M=1;!b.shouldStop&&M<E.length-1;M++){Qa.copy(d[E[M]]),Ja.copy(d[E[M+1]]),R.vmult(Qa,Qa),R.vmult(Ja,Ja),L.vadd(Qa,Qa),L.vadd(Ja,Ja);const j=ho.distanceTo(g);!(Li.pointInTriangle(ho,wa,Qa,Ja)||Li.pointInTriangle(ho,Qa,wa,Ja))||j>x||this.reportIntersection(a,ho,r,i,C)}}}}_intersectTrimesh(e,t,s,i,r,o){const a=die,l=xie,c=vie,u=jN,d=hie,h=fie,p=pie,g=gie,y=mie,x=e.indices;e.vertices;const v=this.from,b=this.to,S=this.direction;c.position.copy(s),c.quaternion.copy(t),Bs.vectorToLocalFrame(s,t,S,d),Bs.pointToLocalFrame(s,t,v,h),Bs.pointToLocalFrame(s,t,b,p),p.x*=e.scale.x,p.y*=e.scale.y,p.z*=e.scale.z,h.x*=e.scale.x,h.y*=e.scale.y,h.z*=e.scale.z,p.vsub(h,d),d.normalize();const C=h.distanceSquared(p);e.tree.rayQuery(this,c,l);for(let E=0,k=l.length;!this.result.shouldStop&&E!==k;E++){const R=l[E];e.getNormal(R,a),e.getVertex(x[R*3],wa),wa.vsub(h,u);const L=d.dot(a),I=a.dot(u)/L;if(I<0)continue;d.scale(I,ho),ho.vadd(h,ho),e.getVertex(x[R*3+1],Qa),e.getVertex(x[R*3+2],Ja);const T=ho.distanceSquared(h);!(Li.pointInTriangle(ho,Qa,wa,Ja)||Li.pointInTriangle(ho,wa,Qa,Ja))||T>C||(Bs.vectorToWorldFrame(t,a,y),Bs.pointToWorldFrame(s,t,ho,g),this.reportIntersection(y,g,r,i,R))}l.length=0}reportIntersection(e,t,s,i,r){const o=this.from,a=this.to,l=o.distanceTo(t),c=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(c.hitFaceIndex=typeof r<"u"?r:-1,this.mode){case Li.ALL:this.hasHit=!0,c.set(o,a,e,t,s,i,l),c.hasHit=!0,this.callback(c);break;case Li.CLOSEST:(l<c.distance||!c.hasHit)&&(this.hasHit=!0,c.hasHit=!0,c.set(o,a,e,t,s,i,l));break;case Li.ANY:this.hasHit=!0,c.hasHit=!0,c.set(o,a,e,t,s,i,l),c.shouldStop=!0;break}}static pointInTriangle(e,t,s,i){i.vsub(t,Qu),s.vsub(t,Hm),e.vsub(t,PS);const r=Qu.dot(Qu),o=Qu.dot(Hm),a=Qu.dot(PS),l=Hm.dot(Hm),c=Hm.dot(PS);let u,d;return(u=l*a-o*c)>=0&&(d=r*c-o*a)>=0&&u+d<r*l-o*o}}Li.CLOSEST=HE.CLOSEST;Li.ANY=HE.ANY;Li.ALL=HE.ALL;const GN=new $o,NS=[],Hm=new se,PS=new se,iie=new se,rie=new $i,ho=new se,wa=new se,Qa=new se,Ja=new se;new se;new u2;const HN={faceList:[0]},rv=new se,oie=new Li,aie=[],lie=new se,cie=new se,uie=new se;new se;new se;const jN=new se,die=new se,hie=new se,fie=new se,pie=new se,mie=new se,gie=new se;new $o;const xie=[],vie=new Bs,Qu=new se,ov=new se;function yie(n,e,t){t.vsub(n,Qu);const s=Qu.dot(e);return e.scale(s,ov),ov.vadd(n,ov),t.distanceTo(ov)}class rf extends _O{static checkBounds(e,t,s){let i,r;s===0?(i=e.position.x,r=t.position.x):s===1?(i=e.position.y,r=t.position.y):s===2&&(i=e.position.z,r=t.position.z);const o=e.boundingRadius,a=t.boundingRadius,l=i+o;return r-a<l}static insertionSortX(e){for(let t=1,s=e.length;t<s;t++){const i=e[t];let r;for(r=t-1;r>=0&&!(e[r].aabb.lowerBound.x<=i.aabb.lowerBound.x);r--)e[r+1]=e[r];e[r+1]=i}return e}static insertionSortY(e){for(let t=1,s=e.length;t<s;t++){const i=e[t];let r;for(r=t-1;r>=0&&!(e[r].aabb.lowerBound.y<=i.aabb.lowerBound.y);r--)e[r+1]=e[r];e[r+1]=i}return e}static insertionSortZ(e){for(let t=1,s=e.length;t<s;t++){const i=e[t];let r;for(r=t-1;r>=0&&!(e[r].aabb.lowerBound.z<=i.aabb.lowerBound.z);r--)e[r+1]=e[r];e[r+1]=i}return e}constructor(e){super(),this.axisList=[],this.world=null,this.axisIndex=0;const t=this.axisList;this._addBodyHandler=s=>{t.push(s.body)},this._removeBodyHandler=s=>{const i=t.indexOf(s.body);i!==-1&&t.splice(i,1)},e&&this.setWorld(e)}setWorld(e){this.axisList.length=0;for(let t=0;t<e.bodies.length;t++)this.axisList.push(e.bodies[t]);e.removeEventListener("addBody",this._addBodyHandler),e.removeEventListener("removeBody",this._removeBodyHandler),e.addEventListener("addBody",this._addBodyHandler),e.addEventListener("removeBody",this._removeBodyHandler),this.world=e,this.dirty=!0}collisionPairs(e,t,s){const i=this.axisList,r=i.length,o=this.axisIndex;let a,l;for(this.dirty&&(this.sortList(),this.dirty=!1),a=0;a!==r;a++){const c=i[a];for(l=a+1;l<r;l++){const u=i[l];if(this.needBroadphaseCollision(c,u)){if(!rf.checkBounds(c,u,o))break;this.intersectionTest(c,u,t,s)}}}}sortList(){const e=this.axisList,t=this.axisIndex,s=e.length;for(let i=0;i!==s;i++){const r=e[i];r.aabbNeedsUpdate&&r.updateAABB()}t===0?rf.insertionSortX(e):t===1?rf.insertionSortY(e):t===2&&rf.insertionSortZ(e)}autoDetectAxis(){let e=0,t=0,s=0,i=0,r=0,o=0;const a=this.axisList,l=a.length,c=1/l;for(let p=0;p!==l;p++){const g=a[p],y=g.position.x;e+=y,t+=y*y;const x=g.position.y;s+=x,i+=x*x;const v=g.position.z;r+=v,o+=v*v}const u=t-e*e*c,d=i-s*s*c,h=o-r*r*c;u>d?u>h?this.axisIndex=0:this.axisIndex=2:d>h?this.axisIndex=1:this.axisIndex=2}aabbQuery(e,t,s){s===void 0&&(s=[]),this.dirty&&(this.sortList(),this.dirty=!1);const i=this.axisIndex;let r="x";i===1&&(r="y"),i===2&&(r="z");const o=this.axisList;t.lowerBound[r],t.upperBound[r];for(let a=0;a<o.length;a++){const l=o[a];l.aabbNeedsUpdate&&l.updateAABB(),l.aabb.overlaps(t)&&s.push(l)}return s}}class NO{static defaults(e,t){e===void 0&&(e={});for(let s in t)s in e||(e[s]=t[s]);return e}}let PO=class DO{constructor(e,t,s){s===void 0&&(s={}),s=NO.defaults(s,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=DO.idCounter++,this.collideConnected=s.collideConnected,s.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}};PO.idCounter=0;class XN{constructor(){this.spatial=new se,this.rotational=new se}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class l0{constructor(e,t,s,i){s===void 0&&(s=-1e6),i===void 0&&(i=1e6),this.id=l0.idCounter++,this.minForce=s,this.maxForce=i,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new XN,this.jacobianElementB=new XN,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,s){const i=t,r=e,o=s;this.a=4/(o*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(o*o*r*(1+4*i))}computeB(e,t,s){const i=this.computeGW(),r=this.computeGq(),o=this.computeGiMf();return-r*e-i*t-o*s}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,r=s.position,o=i.position;return e.spatial.dot(r)+t.spatial.dot(o)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,r=s.velocity,o=i.velocity,a=s.angularVelocity,l=i.angularVelocity;return e.multiplyVectors(r,a)+t.multiplyVectors(o,l)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,r=s.vlambda,o=i.vlambda,a=s.wlambda,l=i.wlambda;return e.multiplyVectors(r,a)+t.multiplyVectors(o,l)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,r=s.force,o=s.torque,a=i.force,l=i.torque,c=s.invMassSolve,u=i.invMassSolve;return r.scale(c,qN),a.scale(u,KN),s.invInertiaWorldSolve.vmult(o,YN),i.invInertiaWorldSolve.vmult(l,ZN),e.multiplyVectors(qN,YN)+t.multiplyVectors(KN,ZN)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,r=s.invMassSolve,o=i.invMassSolve,a=s.invInertiaWorldSolve,l=i.invInertiaWorldSolve;let c=r+o;return a.vmult(e.rotational,av),c+=av.dot(e.rotational),l.vmult(t.rotational,av),c+=av.dot(t.rotational),c}addToWlambda(e){const t=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,r=this.bj,o=wie;i.vlambda.addScaledVector(i.invMassSolve*e,t.spatial,i.vlambda),r.vlambda.addScaledVector(r.invMassSolve*e,s.spatial,r.vlambda),i.invInertiaWorldSolve.vmult(t.rotational,o),i.wlambda.addScaledVector(e,o,i.wlambda),r.invInertiaWorldSolve.vmult(s.rotational,o),r.wlambda.addScaledVector(e,o,r.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}l0.idCounter=0;const qN=new se,KN=new se,YN=new se,ZN=new se,av=new se,wie=new se;class LO extends l0{constructor(e,t,s){s===void 0&&(s=1e6),super(e,t,0,s),this.restitution=0,this.ri=new se,this.rj=new se,this.ni=new se}computeB(e){const t=this.a,s=this.b,i=this.bi,r=this.bj,o=this.ri,a=this.rj,l=bie,c=Sie,u=i.velocity,d=i.angularVelocity;i.force,i.torque;const h=r.velocity,p=r.angularVelocity;r.force,r.torque;const g=Cie,y=this.jacobianElementA,x=this.jacobianElementB,v=this.ni;o.cross(v,l),a.cross(v,c),v.negate(y.spatial),l.negate(y.rotational),x.spatial.copy(v),x.rotational.copy(c),g.copy(r.position),g.vadd(a,g),g.vsub(i.position,g),g.vsub(o,g);const b=v.dot(g),S=this.restitution+1,C=S*h.dot(v)-S*u.dot(v)+p.dot(c)-d.dot(l),E=this.computeGiMf();return-b*t-C*s-e*E}getImpactVelocityAlongNormal(){const e=_ie,t=Eie,s=Tie,i=Iie,r=kie;return this.bi.position.vadd(this.ri,s),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(s,e),this.bj.getVelocityAtWorldPoint(i,t),e.vsub(t,r),this.ni.dot(r)}}const bie=new se,Sie=new se,Cie=new se,_ie=new se,Eie=new se,Tie=new se,Iie=new se,kie=new se;new se;new se;new se;new se;new se;new se;class QN extends PO{constructor(e,t,s,i){i===void 0&&(i=1e6),super(e,t),typeof s>"u"&&(s=e.position.distanceTo(t.position)),this.distance=s;const r=this.distanceEquation=new LO(e,t);this.equations.push(r),r.minForce=-i,r.maxForce=i}update(){const e=this.bodyA,t=this.bodyB,s=this.distanceEquation,i=this.distance*.5,r=s.ni;t.position.vsub(e.position,r),r.normalize(),r.scale(i,s.ri),r.scale(-i,s.rj)}}new se;new se;new se;new se;class JN extends l0{constructor(e,t,s){super(e,t,-s,s),this.ri=new se,this.rj=new se,this.t=new se}computeB(e){this.a;const t=this.b;this.bi,this.bj;const s=this.ri,i=this.rj,r=Aie,o=Rie,a=this.t;s.cross(a,r),i.cross(a,o);const l=this.jacobianElementA,c=this.jacobianElementB;a.negate(l.spatial),r.negate(l.rotational),c.spatial.copy(a),c.rotational.copy(o);const u=this.computeGW(),d=this.computeGiMf();return-u*t-e*d}}const Aie=new se,Rie=new se;class dy{constructor(e,t,s){s=NO.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=dy.idCounter++,this.materials=[e,t],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}dy.idCounter=0;class If{constructor(e){e===void 0&&(e={});let t="";typeof e=="string"&&(t=e,e={}),this.name=t,this.id=If.idCounter++,this.friction=typeof e.friction<"u"?e.friction:-1,this.restitution=typeof e.restitution<"u"?e.restitution:-1}}If.idCounter=0;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new Li;new se;new se;new se;new se(1,0,0),new se(0,1,0),new se(0,0,1);new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;class eP extends fn{constructor(e){if(super({type:fn.types.SPHERE}),this.radius=e!==void 0?e:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(e,t){t===void 0&&(t=new se);const s=2*e*this.radius*this.radius/5;return t.x=s,t.y=s,t.z=s,t}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(e,t,s,i){const r=this.radius,o=["x","y","z"];for(let a=0;a<o.length;a++){const l=o[a];s[l]=e[l]-r,i[l]=e[l]+r}}}new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new se;new $o;new se;new $o;new se;new se;new se;new se;new se;new se;new se;new $o;new se;new Bs;new $o;class Mie{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){e.enabled&&!e.bi.isTrigger&&!e.bj.isTrigger&&this.equations.push(e)}removeEquation(e){const t=this.equations,s=t.indexOf(e);s!==-1&&t.splice(s,1)}removeAllEquations(){this.equations.length=0}}class Nie extends Mie{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let s=0;const i=this.iterations,r=this.tolerance*this.tolerance,o=this.equations,a=o.length,l=t.bodies,c=l.length,u=e;let d,h,p,g,y,x;if(a!==0)for(let C=0;C!==c;C++)l[C].updateSolveMassProperties();const v=Die,b=Lie,S=Pie;v.length=a,b.length=a,S.length=a;for(let C=0;C!==a;C++){const E=o[C];S[C]=0,b[C]=E.computeB(u),v[C]=1/E.computeC()}if(a!==0){for(let k=0;k!==c;k++){const R=l[k],L=R.vlambda,I=R.wlambda;L.set(0,0,0),I.set(0,0,0)}for(s=0;s!==i;s++){g=0;for(let k=0;k!==a;k++){const R=o[k];d=b[k],h=v[k],x=S[k],y=R.computeGWlambda(),p=h*(d-y-R.eps*x),x+p<R.minForce?p=R.minForce-x:x+p>R.maxForce&&(p=R.maxForce-x),S[k]+=p,g+=p>0?p:-p,R.addToWlambda(p)}if(g*g<r)break}for(let k=0;k!==c;k++){const R=l[k],L=R.velocity,I=R.angularVelocity;R.vlambda.vmul(R.linearFactor,R.vlambda),L.vadd(R.vlambda,L),R.wlambda.vmul(R.angularFactor,R.wlambda),I.vadd(R.wlambda,I)}let C=o.length;const E=1/u;for(;C--;)o[C].multiplier=S[C]*E}return s}}const Pie=[],Die=[],Lie=[];class $ie{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return this.objects.length===0?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class Fie extends $ie{constructor(){super(...arguments),this.type=se}constructObject(){return new se}}const ni={sphereSphere:fn.types.SPHERE,spherePlane:fn.types.SPHERE|fn.types.PLANE,boxBox:fn.types.BOX|fn.types.BOX,sphereBox:fn.types.SPHERE|fn.types.BOX,planeBox:fn.types.PLANE|fn.types.BOX,convexConvex:fn.types.CONVEXPOLYHEDRON,sphereConvex:fn.types.SPHERE|fn.types.CONVEXPOLYHEDRON,planeConvex:fn.types.PLANE|fn.types.CONVEXPOLYHEDRON,boxConvex:fn.types.BOX|fn.types.CONVEXPOLYHEDRON,sphereHeightfield:fn.types.SPHERE|fn.types.HEIGHTFIELD,boxHeightfield:fn.types.BOX|fn.types.HEIGHTFIELD,convexHeightfield:fn.types.CONVEXPOLYHEDRON|fn.types.HEIGHTFIELD,sphereParticle:fn.types.PARTICLE|fn.types.SPHERE,planeParticle:fn.types.PLANE|fn.types.PARTICLE,boxParticle:fn.types.BOX|fn.types.PARTICLE,convexParticle:fn.types.PARTICLE|fn.types.CONVEXPOLYHEDRON,cylinderCylinder:fn.types.CYLINDER,sphereCylinder:fn.types.SPHERE|fn.types.CYLINDER,planeCylinder:fn.types.PLANE|fn.types.CYLINDER,boxCylinder:fn.types.BOX|fn.types.CYLINDER,convexCylinder:fn.types.CONVEXPOLYHEDRON|fn.types.CYLINDER,heightfieldCylinder:fn.types.HEIGHTFIELD|fn.types.CYLINDER,particleCylinder:fn.types.PARTICLE|fn.types.CYLINDER,sphereTrimesh:fn.types.SPHERE|fn.types.TRIMESH,planeTrimesh:fn.types.PLANE|fn.types.TRIMESH};class Oie{get[ni.sphereSphere](){return this.sphereSphere}get[ni.spherePlane](){return this.spherePlane}get[ni.boxBox](){return this.boxBox}get[ni.sphereBox](){return this.sphereBox}get[ni.planeBox](){return this.planeBox}get[ni.convexConvex](){return this.convexConvex}get[ni.sphereConvex](){return this.sphereConvex}get[ni.planeConvex](){return this.planeConvex}get[ni.boxConvex](){return this.boxConvex}get[ni.sphereHeightfield](){return this.sphereHeightfield}get[ni.boxHeightfield](){return this.boxHeightfield}get[ni.convexHeightfield](){return this.convexHeightfield}get[ni.sphereParticle](){return this.sphereParticle}get[ni.planeParticle](){return this.planeParticle}get[ni.boxParticle](){return this.boxParticle}get[ni.convexParticle](){return this.convexParticle}get[ni.cylinderCylinder](){return this.convexConvex}get[ni.sphereCylinder](){return this.sphereConvex}get[ni.planeCylinder](){return this.planeConvex}get[ni.boxCylinder](){return this.boxConvex}get[ni.convexCylinder](){return this.convexConvex}get[ni.heightfieldCylinder](){return this.heightfieldCylinder}get[ni.particleCylinder](){return this.particleCylinder}get[ni.sphereTrimesh](){return this.sphereTrimesh}get[ni.planeTrimesh](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Fie,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,s,i,r,o){let a;this.contactPointPool.length?(a=this.contactPointPool.pop(),a.bi=e,a.bj=t):a=new LO(e,t),a.enabled=e.collisionResponse&&t.collisionResponse&&s.collisionResponse&&i.collisionResponse;const l=this.currentContactMaterial;a.restitution=l.restitution,a.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);const c=s.material||e.material,u=i.material||t.material;return c&&u&&c.restitution>=0&&u.restitution>=0&&(a.restitution=c.restitution*u.restitution),a.si=r||s,a.sj=o||i,a}createFrictionEquationsFromContact(e,t){const s=e.bi,i=e.bj,r=e.si,o=e.sj,a=this.world,l=this.currentContactMaterial;let c=l.friction;const u=r.material||s.material,d=o.material||i.material;if(u&&d&&u.friction>=0&&d.friction>=0&&(c=u.friction*d.friction),c>0){const h=c*(a.frictionGravity||a.gravity).length();let p=s.invMass+i.invMass;p>0&&(p=1/p);const g=this.frictionEquationPool,y=g.length?g.pop():new JN(s,i,h*p),x=g.length?g.pop():new JN(s,i,h*p);return y.bi=x.bi=s,y.bj=x.bj=i,y.minForce=x.minForce=-h*p,y.maxForce=x.maxForce=h*p,y.ri.copy(e.ri),y.rj.copy(e.rj),x.ri.copy(e.ri),x.rj.copy(e.rj),e.ni.tangents(y.t,x.t),y.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,a.dt),x.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,a.dt),y.enabled=x.enabled=e.enabled,t.push(y,x),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||e===1)return;const s=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];Vu.setZero(),Vh.setZero(),Wh.setZero();const r=t.bi;t.bj;for(let a=0;a!==e;a++)t=this.result[this.result.length-1-a],t.bi!==r?(Vu.vadd(t.ni,Vu),Vh.vadd(t.ri,Vh),Wh.vadd(t.rj,Wh)):(Vu.vsub(t.ni,Vu),Vh.vadd(t.rj,Vh),Wh.vadd(t.ri,Wh));const o=1/e;Vh.scale(o,s.ri),Wh.scale(o,s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj),Vu.normalize(),Vu.tangents(s.t,i.t)}getContacts(e,t,s,i,r,o,a){this.contactPointPool=r,this.frictionEquationPool=a,this.result=i,this.frictionResult=o;const l=Uie,c=Vie,u=zie,d=Bie;for(let h=0,p=e.length;h!==p;h++){const g=e[h],y=t[h];let x=null;g.material&&y.material&&(x=s.getContactMaterial(g.material,y.material)||null);const v=g.type&pn.KINEMATIC&&y.type&pn.STATIC||g.type&pn.STATIC&&y.type&pn.KINEMATIC||g.type&pn.KINEMATIC&&y.type&pn.KINEMATIC;for(let b=0;b<g.shapes.length;b++){g.quaternion.mult(g.shapeOrientations[b],l),g.quaternion.vmult(g.shapeOffsets[b],u),u.vadd(g.position,u);const S=g.shapes[b];for(let C=0;C<y.shapes.length;C++){y.quaternion.mult(y.shapeOrientations[C],c),y.quaternion.vmult(y.shapeOffsets[C],d),d.vadd(y.position,d);const E=y.shapes[C];if(!(S.collisionFilterMask&E.collisionFilterGroup&&E.collisionFilterMask&S.collisionFilterGroup)||u.distanceTo(d)>S.boundingSphereRadius+E.boundingSphereRadius)continue;let k=null;S.material&&E.material&&(k=s.getContactMaterial(S.material,E.material)||null),this.currentContactMaterial=k||x||s.defaultContactMaterial;const R=S.type|E.type,L=this[R];if(L){let I=!1;S.type<E.type?I=L.call(this,S,E,u,d,l,c,g,y,S,E,v):I=L.call(this,E,S,d,u,c,l,y,g,S,E,v),I&&v&&(s.shapeOverlapKeeper.set(S.id,E.id),s.bodyOverlapKeeper.set(g.id,y.id))}}}}}sphereSphere(e,t,s,i,r,o,a,l,c,u,d){if(d)return s.distanceSquared(i)<(e.radius+t.radius)**2;const h=this.createContactEquation(a,l,e,t,c,u);i.vsub(s,h.ni),h.ni.normalize(),h.ri.copy(h.ni),h.rj.copy(h.ni),h.ri.scale(e.radius,h.ri),h.rj.scale(-t.radius,h.rj),h.ri.vadd(s,h.ri),h.ri.vsub(a.position,h.ri),h.rj.vadd(i,h.rj),h.rj.vsub(l.position,h.rj),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}spherePlane(e,t,s,i,r,o,a,l,c,u,d){const h=this.createContactEquation(a,l,e,t,c,u);if(h.ni.set(0,0,1),o.vmult(h.ni,h.ni),h.ni.negate(h.ni),h.ni.normalize(),h.ni.scale(e.radius,h.ri),s.vsub(i,lv),h.ni.scale(h.ni.dot(lv),tP),lv.vsub(tP,h.rj),-lv.dot(h.ni)<=e.radius){if(d)return!0;const p=h.ri,g=h.rj;p.vadd(s,p),p.vsub(a.position,p),g.vadd(i,g),g.vsub(l.position,g),this.result.push(h),this.createFrictionEquationsFromContact(h,this.frictionResult)}}boxBox(e,t,s,i,r,o,a,l,c,u,d){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,s,i,r,o,a,l,e,t,d)}sphereBox(e,t,s,i,r,o,a,l,c,u,d){const h=this.v3pool,p=pre;s.vsub(i,cv),t.getSideNormals(p,o);const g=e.radius;let y=!1;const x=gre,v=xre,b=vre;let S=null,C=0,E=0,k=0,R=null;for(let B=0,J=p.length;B!==J&&y===!1;B++){const K=dre;K.copy(p[B]);const ee=K.length();K.normalize();const ne=cv.dot(K);if(ne<ee+g&&ne>0){const V=hre,Z=fre;V.copy(p[(B+1)%3]),Z.copy(p[(B+2)%3]);const he=V.length(),ve=Z.length();V.normalize(),Z.normalize();const be=cv.dot(V),Ie=cv.dot(Z);if(be<he&&be>-he&&Ie<ve&&Ie>-ve){const Xe=Math.abs(ne-ee-g);if((R===null||Xe<R)&&(R=Xe,E=be,k=Ie,S=ee,x.copy(K),v.copy(V),b.copy(Z),C++,d))return!0}}}if(C){y=!0;const B=this.createContactEquation(a,l,e,t,c,u);x.scale(-g,B.ri),B.ni.copy(x),B.ni.negate(B.ni),x.scale(S,x),v.scale(E,v),x.vadd(v,x),b.scale(k,b),x.vadd(b,B.rj),B.ri.vadd(s,B.ri),B.ri.vsub(a.position,B.ri),B.rj.vadd(i,B.rj),B.rj.vsub(l.position,B.rj),this.result.push(B),this.createFrictionEquationsFromContact(B,this.frictionResult)}let L=h.get();const I=mre;for(let B=0;B!==2&&!y;B++)for(let J=0;J!==2&&!y;J++)for(let K=0;K!==2&&!y;K++)if(L.set(0,0,0),B?L.vadd(p[0],L):L.vsub(p[0],L),J?L.vadd(p[1],L):L.vsub(p[1],L),K?L.vadd(p[2],L):L.vsub(p[2],L),i.vadd(L,I),I.vsub(s,I),I.lengthSquared()<g*g){if(d)return!0;y=!0;const ee=this.createContactEquation(a,l,e,t,c,u);ee.ri.copy(I),ee.ri.normalize(),ee.ni.copy(ee.ri),ee.ri.scale(g,ee.ri),ee.rj.copy(L),ee.ri.vadd(s,ee.ri),ee.ri.vsub(a.position,ee.ri),ee.rj.vadd(i,ee.rj),ee.rj.vsub(l.position,ee.rj),this.result.push(ee),this.createFrictionEquationsFromContact(ee,this.frictionResult)}h.release(L),L=null;const T=h.get(),M=h.get(),j=h.get(),W=h.get(),z=h.get(),X=p.length;for(let B=0;B!==X&&!y;B++)for(let J=0;J!==X&&!y;J++)if(B%3!==J%3){p[J].cross(p[B],T),T.normalize(),p[B].vadd(p[J],M),j.copy(s),j.vsub(M,j),j.vsub(i,j);const K=j.dot(T);T.scale(K,W);let ee=0;for(;ee===B%3||ee===J%3;)ee++;z.copy(s),z.vsub(W,z),z.vsub(M,z),z.vsub(i,z);const ne=Math.abs(K),V=z.length();if(ne<p[ee].length()&&V<g){if(d)return!0;y=!0;const Z=this.createContactEquation(a,l,e,t,c,u);M.vadd(W,Z.rj),Z.rj.copy(Z.rj),z.negate(Z.ni),Z.ni.normalize(),Z.ri.copy(Z.rj),Z.ri.vadd(i,Z.ri),Z.ri.vsub(s,Z.ri),Z.ri.normalize(),Z.ri.scale(g,Z.ri),Z.ri.vadd(s,Z.ri),Z.ri.vsub(a.position,Z.ri),Z.rj.vadd(i,Z.rj),Z.rj.vsub(l.position,Z.rj),this.result.push(Z),this.createFrictionEquationsFromContact(Z,this.frictionResult)}}h.release(T,M,j,W,z)}planeBox(e,t,s,i,r,o,a,l,c,u,d){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,s,i,r,o,a,l,e,t,d)}convexConvex(e,t,s,i,r,o,a,l,c,u,d,h,p){const g=Pre;if(!(s.distanceTo(i)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,s,r,i,o,g,h,p)){const y=[],x=Dre;e.clipAgainstHull(s,r,t,i,o,g,-100,100,y);let v=0;for(let b=0;b!==y.length;b++){if(d)return!0;const S=this.createContactEquation(a,l,e,t,c,u),C=S.ri,E=S.rj;g.negate(S.ni),y[b].normal.negate(x),x.scale(y[b].depth,x),y[b].point.vadd(x,C),E.copy(y[b].point),C.vsub(s,C),E.vsub(i,E),C.vadd(s,C),C.vsub(a.position,C),E.vadd(i,E),E.vsub(l.position,E),this.result.push(S),v++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(S,this.frictionResult)}this.enableFrictionReduction&&v&&this.createFrictionFromAverage(v)}}sphereConvex(e,t,s,i,r,o,a,l,c,u,d){const h=this.v3pool;s.vsub(i,yre);const p=t.faceNormals,g=t.faces,y=t.vertices,x=e.radius;let v=!1;for(let b=0;b!==y.length;b++){const S=y[b],C=Cre;o.vmult(S,C),i.vadd(C,C);const E=Sre;if(C.vsub(s,E),E.lengthSquared()<x*x){if(d)return!0;v=!0;const k=this.createContactEquation(a,l,e,t,c,u);k.ri.copy(E),k.ri.normalize(),k.ni.copy(k.ri),k.ri.scale(x,k.ri),C.vsub(i,k.rj),k.ri.vadd(s,k.ri),k.ri.vsub(a.position,k.ri),k.rj.vadd(i,k.rj),k.rj.vsub(l.position,k.rj),this.result.push(k),this.createFrictionEquationsFromContact(k,this.frictionResult);return}}for(let b=0,S=g.length;b!==S&&v===!1;b++){const C=p[b],E=g[b],k=_re;o.vmult(C,k);const R=Ere;o.vmult(y[E[0]],R),R.vadd(i,R);const L=Tre;k.scale(-x,L),s.vadd(L,L);const I=Ire;L.vsub(R,I);const T=I.dot(k),M=kre;if(s.vsub(R,M),T<0&&M.dot(k)>0){const j=[];for(let W=0,z=E.length;W!==z;W++){const X=h.get();o.vmult(y[E[W]],X),i.vadd(X,X),j.push(X)}if(ure(j,k,s)){if(d)return!0;v=!0;const W=this.createContactEquation(a,l,e,t,c,u);k.scale(-x,W.ri),k.negate(W.ni);const z=h.get();k.scale(-T,z);const X=h.get();k.scale(-x,X),s.vsub(i,W.rj),W.rj.vadd(X,W.rj),W.rj.vadd(z,W.rj),W.rj.vadd(i,W.rj),W.rj.vsub(l.position,W.rj),W.ri.vadd(s,W.ri),W.ri.vsub(a.position,W.ri),h.release(z),h.release(X),this.result.push(W),this.createFrictionEquationsFromContact(W,this.frictionResult);for(let B=0,J=j.length;B!==J;B++)h.release(j[B]);return}else for(let W=0;W!==E.length;W++){const z=h.get(),X=h.get();o.vmult(y[E[(W+1)%E.length]],z),o.vmult(y[E[(W+2)%E.length]],X),i.vadd(z,z),i.vadd(X,X);const B=wre;X.vsub(z,B);const J=bre;B.unit(J);const K=h.get(),ee=h.get();s.vsub(z,ee);const ne=ee.dot(J);J.scale(ne,K),K.vadd(z,K);const V=h.get();if(K.vsub(s,V),ne>0&&ne*ne<B.lengthSquared()&&V.lengthSquared()<x*x){if(d)return!0;const Z=this.createContactEquation(a,l,e,t,c,u);K.vsub(i,Z.rj),K.vsub(s,Z.ni),Z.ni.normalize(),Z.ni.scale(x,Z.ri),Z.rj.vadd(i,Z.rj),Z.rj.vsub(l.position,Z.rj),Z.ri.vadd(s,Z.ri),Z.ri.vsub(a.position,Z.ri),this.result.push(Z),this.createFrictionEquationsFromContact(Z,this.frictionResult);for(let he=0,ve=j.length;he!==ve;he++)h.release(j[he]);h.release(z),h.release(X),h.release(K),h.release(V),h.release(ee);return}h.release(z),h.release(X),h.release(K),h.release(V),h.release(ee)}for(let W=0,z=j.length;W!==z;W++)h.release(j[W])}}}planeConvex(e,t,s,i,r,o,a,l,c,u,d){const h=Are,p=Rre;p.set(0,0,1),r.vmult(p,p);let g=0;const y=Mre;for(let x=0;x!==t.vertices.length;x++)if(h.copy(t.vertices[x]),o.vmult(h,h),i.vadd(h,h),h.vsub(s,y),p.dot(y)<=0){if(d)return!0;const b=this.createContactEquation(a,l,e,t,c,u),S=Nre;p.scale(p.dot(y),S),h.vsub(S,S),S.vsub(s,b.ri),b.ni.copy(p),h.vsub(i,b.rj),b.ri.vadd(s,b.ri),b.ri.vsub(a.position,b.ri),b.rj.vadd(i,b.rj),b.rj.vsub(l.position,b.rj),this.result.push(b),g++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(b,this.frictionResult)}this.enableFrictionReduction&&g&&this.createFrictionFromAverage(g)}boxConvex(e,t,s,i,r,o,a,l,c,u,d){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,s,i,r,o,a,l,e,t,d)}sphereHeightfield(e,t,s,i,r,o,a,l,c,u,d){const h=t.data,p=e.radius,g=t.elementSize,y=jre,x=Hre;Bs.pointToLocalFrame(i,o,s,x);let v=Math.floor((x.x-p)/g)-1,b=Math.ceil((x.x+p)/g)+1,S=Math.floor((x.y-p)/g)-1,C=Math.ceil((x.y+p)/g)+1;if(b<0||C<0||v>h.length||S>h[0].length)return;v<0&&(v=0),b<0&&(b=0),S<0&&(S=0),C<0&&(C=0),v>=h.length&&(v=h.length-1),b>=h.length&&(b=h.length-1),C>=h[0].length&&(C=h[0].length-1),S>=h[0].length&&(S=h[0].length-1);const E=[];t.getRectMinMax(v,S,b,C,E);const k=E[0],R=E[1];if(x.z-p>R||x.z+p<k)return;const L=this.result;for(let I=v;I<b;I++)for(let T=S;T<C;T++){const M=L.length;let j=!1;if(t.getConvexTrianglePillar(I,T,!1),Bs.pointToWorldFrame(i,o,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(j=this.sphereConvex(e,t.pillarConvex,s,y,r,o,a,l,e,t,d)),d&&j||(t.getConvexTrianglePillar(I,T,!0),Bs.pointToWorldFrame(i,o,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(j=this.sphereConvex(e,t.pillarConvex,s,y,r,o,a,l,e,t,d)),d&&j))return!0;if(L.length-M>2)return}}boxHeightfield(e,t,s,i,r,o,a,l,c,u,d){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,s,i,r,o,a,l,e,t,d)}convexHeightfield(e,t,s,i,r,o,a,l,c,u,d){const h=t.data,p=t.elementSize,g=e.boundingSphereRadius,y=Wre,x=Gre,v=Vre;Bs.pointToLocalFrame(i,o,s,v);let b=Math.floor((v.x-g)/p)-1,S=Math.ceil((v.x+g)/p)+1,C=Math.floor((v.y-g)/p)-1,E=Math.ceil((v.y+g)/p)+1;if(S<0||E<0||b>h.length||C>h[0].length)return;b<0&&(b=0),S<0&&(S=0),C<0&&(C=0),E<0&&(E=0),b>=h.length&&(b=h.length-1),S>=h.length&&(S=h.length-1),E>=h[0].length&&(E=h[0].length-1),C>=h[0].length&&(C=h[0].length-1);const k=[];t.getRectMinMax(b,C,S,E,k);const R=k[0],L=k[1];if(!(v.z-g>L||v.z+g<R))for(let I=b;I<S;I++)for(let T=C;T<E;T++){let M=!1;if(t.getConvexTrianglePillar(I,T,!1),Bs.pointToWorldFrame(i,o,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(M=this.convexConvex(e,t.pillarConvex,s,y,r,o,a,l,null,null,d,x,null)),d&&M||(t.getConvexTrianglePillar(I,T,!0),Bs.pointToWorldFrame(i,o,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(M=this.convexConvex(e,t.pillarConvex,s,y,r,o,a,l,null,null,d,x,null)),d&&M))return!0}}sphereParticle(e,t,s,i,r,o,a,l,c,u,d){const h=Ore;if(h.set(0,0,1),i.vsub(s,h),h.lengthSquared()<=e.radius*e.radius){if(d)return!0;const g=this.createContactEquation(l,a,t,e,c,u);h.normalize(),g.rj.copy(h),g.rj.scale(e.radius,g.rj),g.ni.copy(h),g.ni.negate(g.ni),g.ri.set(0,0,0),this.result.push(g),this.createFrictionEquationsFromContact(g,this.frictionResult)}}planeParticle(e,t,s,i,r,o,a,l,c,u,d){const h=Lre;h.set(0,0,1),a.quaternion.vmult(h,h);const p=$re;if(i.vsub(a.position,p),h.dot(p)<=0){if(d)return!0;const y=this.createContactEquation(l,a,t,e,c,u);y.ni.copy(h),y.ni.negate(y.ni),y.ri.set(0,0,0);const x=Fre;h.scale(h.dot(i),x),i.vsub(x,x),y.rj.copy(x),this.result.push(y),this.createFrictionEquationsFromContact(y,this.frictionResult)}}boxParticle(e,t,s,i,r,o,a,l,c,u,d){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,s,i,r,o,a,l,e,t,d)}convexParticle(e,t,s,i,r,o,a,l,c,u,d){let h=-1;const p=Bre,g=Ure;let y=null;const x=zre;if(x.copy(i),x.vsub(s,x),r.conjugate(nP),nP.vmult(x,x),e.pointIsInside(x)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(s,r),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(r);for(let v=0,b=e.faces.length;v!==b;v++){const S=[e.worldVertices[e.faces[v][0]]],C=e.worldFaceNormals[v];i.vsub(S[0],sP);const E=-C.dot(sP);if(y===null||Math.abs(E)<Math.abs(y)){if(d)return!0;y=E,h=v,p.copy(C)}}if(h!==-1){const v=this.createContactEquation(l,a,t,e,c,u);p.scale(y,g),g.vadd(i,g),g.vsub(s,g),v.rj.copy(g),p.negate(v.ni),v.ri.set(0,0,0);const b=v.ri,S=v.rj;b.vadd(i,b),b.vsub(l.position,b),S.vadd(s,S),S.vsub(a.position,S),this.result.push(v),this.createFrictionEquationsFromContact(v,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,s,i,r,o,a,l,c,u,d){return this.convexHeightfield(t,e,i,s,o,r,l,a,c,u,d)}particleCylinder(e,t,s,i,r,o,a,l,c,u,d){return this.convexParticle(t,e,i,s,o,r,l,a,c,u,d)}sphereTrimesh(e,t,s,i,r,o,a,l,c,u,d){const h=Yie,p=Zie,g=Qie,y=Jie,x=ere,v=tre,b=rre,S=Kie,C=Xie,E=ore;Bs.pointToLocalFrame(i,o,s,x);const k=e.radius;b.lowerBound.set(x.x-k,x.y-k,x.z-k),b.upperBound.set(x.x+k,x.y+k,x.z+k),t.getTrianglesInAABB(b,E);const R=qie,L=e.radius*e.radius;for(let W=0;W<E.length;W++)for(let z=0;z<3;z++)if(t.getVertex(t.indices[E[W]*3+z],R),R.vsub(x,C),C.lengthSquared()<=L){if(S.copy(R),Bs.pointToWorldFrame(i,o,S,R),R.vsub(s,C),d)return!0;let X=this.createContactEquation(a,l,e,t,c,u);X.ni.copy(C),X.ni.normalize(),X.ri.copy(X.ni),X.ri.scale(e.radius,X.ri),X.ri.vadd(s,X.ri),X.ri.vsub(a.position,X.ri),X.rj.copy(R),X.rj.vsub(l.position,X.rj),this.result.push(X),this.createFrictionEquationsFromContact(X,this.frictionResult)}for(let W=0;W<E.length;W++)for(let z=0;z<3;z++){t.getVertex(t.indices[E[W]*3+z],h),t.getVertex(t.indices[E[W]*3+(z+1)%3],p),p.vsub(h,g),x.vsub(p,v);const X=v.dot(g);x.vsub(h,v);let B=v.dot(g);if(B>0&&X<0&&(x.vsub(h,v),y.copy(g),y.normalize(),B=v.dot(y),y.scale(B,v),v.vadd(h,v),v.distanceTo(x)<e.radius)){if(d)return!0;const K=this.createContactEquation(a,l,e,t,c,u);v.vsub(x,K.ni),K.ni.normalize(),K.ni.scale(e.radius,K.ri),K.ri.vadd(s,K.ri),K.ri.vsub(a.position,K.ri),Bs.pointToWorldFrame(i,o,v,v),v.vsub(l.position,K.rj),Bs.vectorToWorldFrame(o,K.ni,K.ni),Bs.vectorToWorldFrame(o,K.ri,K.ri),this.result.push(K),this.createFrictionEquationsFromContact(K,this.frictionResult)}}const I=nre,T=sre,M=ire,j=jie;for(let W=0,z=E.length;W!==z;W++){t.getTriangleVertices(E[W],I,T,M),t.getNormal(E[W],j),x.vsub(I,v);let X=v.dot(j);if(j.scale(X,v),x.vsub(v,v),X=v.distanceTo(x),Li.pointInTriangle(v,I,T,M)&&X<e.radius){if(d)return!0;let B=this.createContactEquation(a,l,e,t,c,u);v.vsub(x,B.ni),B.ni.normalize(),B.ni.scale(e.radius,B.ri),B.ri.vadd(s,B.ri),B.ri.vsub(a.position,B.ri),Bs.pointToWorldFrame(i,o,v,v),v.vsub(l.position,B.rj),Bs.vectorToWorldFrame(o,B.ni,B.ni),Bs.vectorToWorldFrame(o,B.ri,B.ri),this.result.push(B),this.createFrictionEquationsFromContact(B,this.frictionResult)}}E.length=0}planeTrimesh(e,t,s,i,r,o,a,l,c,u,d){const h=new se,p=Wie;p.set(0,0,1),r.vmult(p,p);for(let g=0;g<t.vertices.length/3;g++){t.getVertex(g,h);const y=new se;y.copy(h),Bs.pointToWorldFrame(i,o,y,h);const x=Gie;if(h.vsub(s,x),p.dot(x)<=0){if(d)return!0;const b=this.createContactEquation(a,l,e,t,c,u);b.ni.copy(p);const S=Hie;p.scale(x.dot(p),S),h.vsub(S,S),b.ri.copy(S),b.ri.vsub(a.position,b.ri),b.rj.copy(h),b.rj.vsub(l.position,b.rj),this.result.push(b),this.createFrictionEquationsFromContact(b,this.frictionResult)}}}}const Vu=new se,Vh=new se,Wh=new se,zie=new se,Bie=new se,Uie=new $i,Vie=new $i,Wie=new se,Gie=new se,Hie=new se,jie=new se,Xie=new se;new se;const qie=new se,Kie=new se,Yie=new se,Zie=new se,Qie=new se,Jie=new se,ere=new se,tre=new se,nre=new se,sre=new se,ire=new se,rre=new $o,ore=[],lv=new se,tP=new se,are=new se,lre=new se,cre=new se;function ure(n,e,t){let s=null;const i=n.length;for(let r=0;r!==i;r++){const o=n[r],a=are;n[(r+1)%i].vsub(o,a);const l=lre;a.cross(e,l);const c=cre;t.vsub(o,c);const u=l.dot(c);if(s===null||u>0&&s===!0||u<=0&&s===!1){s===null&&(s=u>0);continue}else return!1}return!0}const cv=new se,dre=new se,hre=new se,fre=new se,pre=[new se,new se,new se,new se,new se,new se],mre=new se,gre=new se,xre=new se,vre=new se,yre=new se,wre=new se,bre=new se,Sre=new se,Cre=new se,_re=new se,Ere=new se,Tre=new se,Ire=new se,kre=new se;new se;new se;const Are=new se,Rre=new se,Mre=new se,Nre=new se,Pre=new se,Dre=new se,Lre=new se,$re=new se,Fre=new se,Ore=new se,nP=new $i,zre=new se;new se;const Bre=new se,sP=new se,Ure=new se,Vre=new se,Wre=new se,Gre=[0],Hre=new se,jre=new se;class iP{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const s=t;t=e,e=s}return e<<16|t}set(e,t){const s=this.getKey(e,t),i=this.current;let r=0;for(;s>i[r];)r++;if(s!==i[r]){for(let o=i.length-1;o>=r;o--)i[o+1]=i[o];i[r]=s}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const s=this.current,i=this.previous,r=s.length,o=i.length;let a=0;for(let l=0;l<r;l++){let c=!1;const u=s[l];for(;u>i[a];)a++;c=u===i[a],c||rP(e,u)}a=0;for(let l=0;l<o;l++){let c=!1;const u=i[l];for(;u>s[a];)a++;c=s[a]===u,c||rP(t,u)}}}function rP(n,e){n.push((e&4294901760)>>16,e&65535)}const DS=(n,e)=>n<e?`${n}-${e}`:`${e}-${n}`;class Xre{constructor(){this.data={keys:[]}}get(e,t){const s=DS(e,t);return this.data[s]}set(e,t,s){const i=DS(e,t);this.get(e,t)||this.data.keys.push(i),this.data[i]=s}delete(e,t){const s=DS(e,t),i=this.data.keys.indexOf(s);i!==-1&&this.data.keys.splice(i,1),delete this.data[s]}reset(){const e=this.data,t=e.keys;for(;t.length>0;){const s=t.pop();delete e[s]}}}class qre extends CO{constructor(e){e===void 0&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=e.quatNormalizeSkip!==void 0?e.quatNormalizeSkip:0,this.quatNormalizeFast=e.quatNormalizeFast!==void 0?e.quatNormalizeFast:!1,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new se,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new se,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=e.broadphase!==void 0?e.broadphase:new sie,this.bodies=[],this.hasActiveBodies=!1,this.solver=e.solver!==void 0?e.solver:new Nie,this.constraints=[],this.narrowphase=new Oie(this),this.collisionMatrix=new VN,this.collisionMatrixPrevious=new VN,this.bodyOverlapKeeper=new iP,this.shapeOverlapKeeper=new iP,this.contactmaterials=[],this.contactMaterialTable=new Xre,this.defaultMaterial=new If("default"),this.defaultContactMaterial=new dy(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);t!==-1&&this.constraints.splice(t,1)}rayTest(e,t,s){s instanceof u2?this.raycastClosest(e,t,{skipBackfaces:!0},s):this.raycastAll(e,t,{skipBackfaces:!0},s)}raycastAll(e,t,s,i){return s===void 0&&(s={}),s.mode=Li.ALL,s.from=e,s.to=t,s.callback=i,LS.intersectWorld(this,s)}raycastAny(e,t,s,i){return s===void 0&&(s={}),s.mode=Li.ANY,s.from=e,s.to=t,s.result=i,LS.intersectWorld(this,s)}raycastClosest(e,t,s,i){return s===void 0&&(s={}),s.mode=Li.CLOSEST,s.from=e,s.to=t,s.result=i,LS.intersectWorld(this,s)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof pn&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,s=this.bodies,i=s.indexOf(e);if(i!==-1){s.splice(i,1);for(let r=0;r!==s.length;r++)s[r].index=r;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let s=0;s<t.length;s++){const i=t[s].shapes;for(let r=0;r<i.length;r++){const o=i[r];if(o.id===e)return o}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);t!==-1&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){e===void 0&&(e=1/60),t===void 0&&(t=10);const s=Xi.now()/1e3;if(!this.lastCallTime)this.step(e,void 0,t);else{const i=s-this.lastCallTime;this.step(e,i,t)}this.lastCallTime=s}step(e,t,s){if(s===void 0&&(s=10),t===void 0)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const i=Xi.now();let r=0;for(;this.accumulator>=e&&r<s&&(this.internalStep(e),this.accumulator-=e,r++,!(Xi.now()-i>e*1e3)););this.accumulator=this.accumulator%e;const o=this.accumulator/e;for(let a=0;a!==this.bodies.length;a++){const l=this.bodies[a];l.previousPosition.lerp(l.position,o,l.interpolatedPosition),l.previousQuaternion.slerp(l.quaternion,o,l.interpolatedQuaternion),l.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,s=Jre,i=eoe,r=this.bodies.length,o=this.bodies,a=this.solver,l=this.gravity,c=this.doProfiling,u=this.profile,d=pn.DYNAMIC;let h=-1/0;const p=this.constraints,g=Qre;l.length();const y=l.x,x=l.y,v=l.z;let b=0;for(c&&(h=Xi.now()),b=0;b!==r;b++){const W=o[b];if(W.type===d){const z=W.force,X=W.mass;z.x+=X*y,z.y+=X*x,z.z+=X*v}}for(let W=0,z=this.subsystems.length;W!==z;W++)this.subsystems[W].update();c&&(h=Xi.now()),s.length=0,i.length=0,this.broadphase.collisionPairs(this,s,i),c&&(u.broadphase=Xi.now()-h);let S=p.length;for(b=0;b!==S;b++){const W=p[b];if(!W.collideConnected)for(let z=s.length-1;z>=0;z-=1)(W.bodyA===s[z]&&W.bodyB===i[z]||W.bodyB===s[z]&&W.bodyA===i[z])&&(s.splice(z,1),i.splice(z,1))}this.collisionMatrixTick(),c&&(h=Xi.now());const C=Zre,E=t.length;for(b=0;b!==E;b++)C.push(t[b]);t.length=0;const k=this.frictionEquations.length;for(b=0;b!==k;b++)g.push(this.frictionEquations[b]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(s,i,this,t,C,this.frictionEquations,g),c&&(u.narrowphase=Xi.now()-h),c&&(h=Xi.now()),b=0;b<this.frictionEquations.length;b++)a.addEquation(this.frictionEquations[b]);const R=t.length;for(let W=0;W!==R;W++){const z=t[W],X=z.bi,B=z.bj,J=z.si,K=z.sj;let ee;if(X.material&&B.material?ee=this.getContactMaterial(X.material,B.material)||this.defaultContactMaterial:ee=this.defaultContactMaterial,ee.friction,X.material&&B.material&&(X.material.friction>=0&&B.material.friction>=0&&X.material.friction*B.material.friction,X.material.restitution>=0&&B.material.restitution>=0&&(z.restitution=X.material.restitution*B.material.restitution)),a.addEquation(z),X.allowSleep&&X.type===pn.DYNAMIC&&X.sleepState===pn.SLEEPING&&B.sleepState===pn.AWAKE&&B.type!==pn.STATIC){const ne=B.velocity.lengthSquared()+B.angularVelocity.lengthSquared(),V=B.sleepSpeedLimit**2;ne>=V*2&&(X.wakeUpAfterNarrowphase=!0)}if(B.allowSleep&&B.type===pn.DYNAMIC&&B.sleepState===pn.SLEEPING&&X.sleepState===pn.AWAKE&&X.type!==pn.STATIC){const ne=X.velocity.lengthSquared()+X.angularVelocity.lengthSquared(),V=X.sleepSpeedLimit**2;ne>=V*2&&(B.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(X,B,!0),this.collisionMatrixPrevious.get(X,B)||(jm.body=B,jm.contact=z,X.dispatchEvent(jm),jm.body=X,B.dispatchEvent(jm)),this.bodyOverlapKeeper.set(X.id,B.id),this.shapeOverlapKeeper.set(J.id,K.id)}for(this.emitContactEvents(),c&&(u.makeContactConstraints=Xi.now()-h,h=Xi.now()),b=0;b!==r;b++){const W=o[b];W.wakeUpAfterNarrowphase&&(W.wakeUp(),W.wakeUpAfterNarrowphase=!1)}for(S=p.length,b=0;b!==S;b++){const W=p[b];W.update();for(let z=0,X=W.equations.length;z!==X;z++){const B=W.equations[z];a.addEquation(B)}}a.solve(e,this),c&&(u.solve=Xi.now()-h),a.removeAllEquations();const L=Math.pow;for(b=0;b!==r;b++){const W=o[b];if(W.type&d){const z=L(1-W.linearDamping,e),X=W.velocity;X.scale(z,X);const B=W.angularVelocity;if(B){const J=L(1-W.angularDamping,e);B.scale(J,B)}}}this.dispatchEvent(Yre),c&&(h=Xi.now());const T=this.stepnumber%(this.quatNormalizeSkip+1)===0,M=this.quatNormalizeFast;for(b=0;b!==r;b++)o[b].integrate(e,T,M);this.clearForces(),this.broadphase.dirty=!0,c&&(u.integrate=Xi.now()-h),this.stepnumber+=1,this.dispatchEvent(Kre);let j=!0;if(this.allowSleep)for(j=!1,b=0;b!==r;b++){const W=o[b];W.sleepTick(this.time),W.sleepState!==pn.SLEEPING&&(j=!0)}this.hasActiveBodies=j}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(Yl,Zl),e){for(let r=0,o=Yl.length;r<o;r+=2)Xm.bodyA=this.getBodyById(Yl[r]),Xm.bodyB=this.getBodyById(Yl[r+1]),this.dispatchEvent(Xm);Xm.bodyA=Xm.bodyB=null}if(t){for(let r=0,o=Zl.length;r<o;r+=2)qm.bodyA=this.getBodyById(Zl[r]),qm.bodyB=this.getBodyById(Zl[r+1]),this.dispatchEvent(qm);qm.bodyA=qm.bodyB=null}Yl.length=Zl.length=0;const s=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((s||i)&&this.shapeOverlapKeeper.getDiff(Yl,Zl),s){for(let r=0,o=Yl.length;r<o;r+=2){const a=this.getShapeById(Yl[r]),l=this.getShapeById(Yl[r+1]);Ql.shapeA=a,Ql.shapeB=l,a&&(Ql.bodyA=a.body),l&&(Ql.bodyB=l.body),this.dispatchEvent(Ql)}Ql.bodyA=Ql.bodyB=Ql.shapeA=Ql.shapeB=null}if(i){for(let r=0,o=Zl.length;r<o;r+=2){const a=this.getShapeById(Zl[r]),l=this.getShapeById(Zl[r+1]);Jl.shapeA=a,Jl.shapeB=l,a&&(Jl.bodyA=a.body),l&&(Jl.bodyB=l.body),this.dispatchEvent(Jl)}Jl.bodyA=Jl.bodyB=Jl.shapeA=Jl.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let s=0;s!==t;s++){const i=e[s];i.force,i.torque,i.force.set(0,0,0),i.torque.set(0,0,0)}}}new $o;const LS=new Li,Xi=globalThis.performance||{};if(!Xi.now){let n=Date.now();Xi.timing&&Xi.timing.navigationStart&&(n=Xi.timing.navigationStart),Xi.now=()=>Date.now()-n}new se;const Kre={type:"postStep"},Yre={type:"preStep"},jm={type:pn.COLLIDE_EVENT_NAME,body:null,contact:null},Zre=[],Qre=[],Jre=[],eoe=[],Yl=[],Zl=[],Xm={type:"beginContact",bodyA:null,bodyB:null},qm={type:"endContact",bodyA:null,bodyB:null},Ql={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},Jl={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},toe=({modelPath:n})=>{const e=le.useRef(null),[t,s]=le.useState(!0),[i,r]=le.useState(0),[o,a]=le.useState(0),[l,c]=le.useState(0),u=le.useRef(0),d=le.useRef(performance.now()),h=le.useRef(),p=le.useRef(),g=le.useRef(),y=le.useRef(),x=le.useRef(null),v=le.useRef({scaledHeight:0,scaledSize:new Ne}),b=le.useRef(null),S=le.useRef([]),C=le.useRef([]);return le.useEffect(()=>{if(!e.current)return;let E=!0;const k=new une;k.background=new Kn(2302755),p.current=k;const R=new Hr(45,e.current.clientWidth/e.current.clientHeight,.1,2e3);R.position.set(2,2,4),g.current=R;const L=new pO({antialias:!0,alpha:!0});L.setSize(e.current.clientWidth,e.current.clientHeight),L.shadowMap.enabled=!0,L.shadowMap.type=FF,L.outputColorSpace=hi,e.current.appendChild(L.domElement),y.current=L;const I=new wg;I.dom.style.position="absolute",I.dom.style.top="10px",I.dom.style.right="10px",e.current.appendChild(I.dom),h.current=I;const T=new Qne(R,L.domElement);T.enableDamping=!0,T.dampingFactor=.05,T.screenSpacePanning=!0,T.minDistance=1,T.maxDistance=50,T.minPolarAngle=Math.PI/2,T.maxPolarAngle=Math.PI/2,T.enablePan=!1;const M=100,j=100,W=new Yne(M,j);W.material.transparent=!0,W.material.opacity=.6,k.add(W);const z=new oy(M,M),X=new qc({color:2302755,transparent:!0,opacity:1}),B=new Mo(z,X);B.rotation.x=-Math.PI/2,B.position.y=-.001,k.add(B);const J=new zne(16777215,.5);k.add(J);const K=new UC(16777215,.8);K.position.set(5,5,5),K.castShadow=!0,K.shadow.mapSize.width=2048,K.shadow.mapSize.height=2048,k.add(K);const ee=new UC(16777215,.4);ee.position.set(-5,3,-5),k.add(ee);const ne=new qre({gravity:new se(0,-9.82,0)});ne.broadphase=new rf(ne),ne.allowSleep=!0,ne.solver.iterations=15,b.current=ne;const V=new Jne;V.load(n,Ie=>{const Xe=Ie.scene;k.add(Xe),Xe.traverse(vn=>{vn.isMesh&&(vn.castShadow=!0,vn.receiveShadow=!0)});const Fe=new La().setFromObject(Xe),Pe=Fe.getSize(new Ne),ct=Fe.getCenter(new Ne),Ee=2/Math.max(Pe.x,Pe.y,Pe.z);Xe.scale.set(Ee,Ee,Ee);const gt=new La().setFromObject(Xe).getSize(new Ne),vt=gt.y;v.current={scaledHeight:vt,scaledSize:gt},Xe.position.sub(ct.multiplyScalar(Ee)),Xe.position.y=vt/2;const wt=Math.max(gt.x,gt.z),Vt=wt*2;R.position.set(0,vt/2,Vt),R.lookAt(0,vt/2,0),T.target.set(0,vt/2,0),T.minDistance=wt,T.maxDistance=wt*4;const It=new se(0,vt*.12,0),zt=.5,Gt=new pn({type:uy.STATIC,shape:new eP(zt),position:It,material:new If({friction:100,restitution:.05})});ne.addBody(Gt),V.load("/assets/necklaxcetest.glb",vn=>{const ce=vn.scene.clone();ce.traverse(kt=>{if(kt.isMesh){const Et=kt;Et.geometry&&(Et.geometry=Et.geometry.clone().toNonIndexed()),Et.material&&(Et.material=new ly({metalness:.3,roughness:.7,flatShading:!0,dithering:!1}))}}),ce.scale.set(.35,.35,.35),k.add(ce),x.current=ce;const Y=15,ye=.05,Qe=vt*.7,tt=0,rt=0,Pt=[],pt=[];for(let kt=0;kt<Y;kt++){const Et=kt/Y*Math.PI*2,bt=tt+Math.cos(Et)*.3,Wt=rt+Math.sin(Et)*.3,ht=Qe+.5,Ht=new eP(ye),Ce=new pn({mass:.1,shape:Ht,position:new se(bt,ht,Wt),material:new If({friction:.6,restitution:0}),linearDamping:.3,angularDamping:.3});if(ne.addBody(Ce),Pt.push(Ce),kt>0){const St=Pt[kt-1],dt=ye*2,Be=new QN(Ce,St,dt);ne.addConstraint(Be),pt.push(Be)}}const At=ye*2,xe=Pt[0],xt=Pt[Y-1],Ye=new QN(xe,xt,At);ne.addConstraint(Ye),pt.push(Ye),Pt.forEach(kt=>{kt.applyImpulse(new se(0,-.5,0),kt.position)}),S.current=Pt,C.current=pt,s(!1)},void 0,vn=>{console.error("Erreur chargement collier:",vn)})},void 0,Ie=>{console.error("Erreur chargement modèle principal:",Ie)});let Z,he=0;const ve=()=>{if(!E)return;Z=requestAnimationFrame(ve);const Ie=performance.now(),Xe=(Ie-d.current)/1e3;if(d.current=Ie,he+=Xe,b.current){b.current.step(1/60,Xe,3),he>1&&S.current.forEach(Pe=>{Pe.velocity.set(0,0,0),Pe.angularVelocity.set(0,0,0),Pe.sleep()});const Fe=S.current;if(Fe.length>0&&x.current){const Pe=new Ne;Fe.forEach(ct=>{Pe.x+=ct.position.x,Pe.y+=ct.position.y,Pe.z+=ct.position.z}),Pe.multiplyScalar(1/Fe.length),x.current.position.copy(Pe)}}if(h.current&&h.current.update(),u.current++,u.current%10===0&&p.current){let Fe=0,Pe=0;p.current.traverse(ct=>{if(ct.isMesh){const at=ct;at.geometry&&(Fe+=at.geometry.index?at.geometry.index.count/3:at.geometry.attributes.position.count/3),Pe++}}),a(Fe),c(Pe)}if(Ie-d.current>=1e3){const Fe=Math.round(u.current*1e3/(Ie-d.current));r(Fe),u.current=0,d.current=Ie}g.current&&y.current&&p.current&&(g.current.updateProjectionMatrix(),y.current.render(p.current,g.current))};ve();const be=()=>{if(!e.current||!g.current||!y.current)return;const Ie=e.current.clientWidth,Xe=e.current.clientHeight;g.current.aspect=Ie/Xe,g.current.updateProjectionMatrix(),y.current.setSize(Ie,Xe)};return window.addEventListener("resize",be),()=>{E=!1,cancelAnimationFrame(Z),window.removeEventListener("resize",be),e.current&&y.current&&e.current.removeChild(y.current.domElement),p.current&&p.current.clear(),y.current&&y.current.dispose()}},[n]),G.jsx("div",{className:"w-full h-full p-4",children:G.jsxs("div",{className:"w-full h-full bg-gradient-to-br from-neutral-900/5 to-neutral-900/10 rounded-3xl border border-white/10 shadow-2xl shadow-black/5 backdrop-blur-sm overflow-hidden relative",children:[G.jsxs("div",{className:"absolute top-4 left-4 bg-black/50 p-2 rounded text-white text-xs font-mono z-10",children:[G.jsxs("div",{children:["FPS: ",i]}),G.jsxs("div",{children:["Triangles: ",o.toLocaleString()]}),G.jsxs("div",{children:["Draw Calls: ",l]})]}),G.jsx("div",{ref:e,className:"w-full h-full absolute inset-0"}),G.jsx(Xv,{children:t&&G.jsx(wn.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"absolute inset-0 bg-neutral-950/60 backdrop-blur-md flex items-center justify-center",children:G.jsxs("div",{className:"text-center",children:[G.jsxs("div",{className:"relative w-16 h-16",children:[G.jsx("div",{className:"w-16 h-16 border-4 border-emerald-500/20 border-t-emerald-500 rounded-full animate-spin"}),G.jsx("div",{className:"absolute inset-0 rounded-full bg-emerald-500/20 blur-md animate-pulse"})]}),G.jsx(wn.p,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},transition:{delay:.2},className:"mt-4 text-white/80 font-display text-sm tracking-wide",children:"Chargement du modèle..."})]})})}),G.jsx(wn.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{delay:.5},className:"absolute bottom-6 left-1/2 transform -translate-x-1/2",children:G.jsxs("div",{className:"group relative",children:[G.jsx("div",{className:"absolute inset-0 bg-emerald-500/20 rounded-full blur-xl transform group-hover:scale-110 transition-transform duration-300"}),G.jsx("div",{className:"relative px-6 py-3 bg-white/10 backdrop-blur-md rounded-full border border-white/20 shadow-lg shadow-black/5",children:G.jsxs("div",{className:"flex items-center space-x-3 text-white/70",children:[G.jsx("svg",{className:"w-4 h-4",fill:"currentColor",viewBox:"0 0 24 24",children:G.jsx("path",{d:"M12 1C7.03 1 3 5.03 3 10v4c0 4.97 4.03 9 9 9s9-4.03 9-9v-4c0-4.97-4.03-9-9-9zm0 2c3.86 0 7 3.14 7 7v4c0 3.86-3.14 7-7 7s-7-3.14-7-7v-4c0-3.86 3.14-7 7-7zm1 3v4h3l-4 6-4-6h3V6h2z"})}),G.jsx("span",{className:"font-display text-sm tracking-wide transform group-hover:scale-105 transition-transform duration-300",children:"Cliquez et glissez pour faire pivoter • Molette pour zoomer"})]})})]})})]})})};var $S={exports:{}},FS,oP;function noe(){if(oP)return FS;oP=1;var n="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";return FS=n,FS}var OS,aP;function soe(){if(aP)return OS;aP=1;var n=noe();function e(){}function t(){}return t.resetWarningCache=e,OS=function(){function s(o,a,l,c,u,d){if(d!==n){var h=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw h.name="Invariant Violation",h}}s.isRequired=s;function i(){return s}var r={array:s,bigint:s,bool:s,func:s,number:s,object:s,string:s,symbol:s,any:s,arrayOf:i,element:s,elementType:s,instanceOf:i,node:s,objectOf:i,oneOf:i,oneOfType:i,shape:i,exact:i,checkPropTypes:t,resetWarningCache:e};return r.PropTypes=r,r},OS}var lP;function ioe(){return lP||(lP=1,$S.exports=soe()()),$S.exports}var roe=ioe();const Hs=Zg(roe);function Od(n,e,t,s){function i(r){return r instanceof t?r:new t(function(o){o(r)})}return new(t||(t=Promise))(function(r,o){function a(u){try{c(s.next(u))}catch(d){o(d)}}function l(u){try{c(s.throw(u))}catch(d){o(d)}}function c(u){u.done?r(u.value):i(u.value).then(a,l)}c((s=s.apply(n,e||[])).next())})}const ooe=new Map([["1km","application/vnd.1000minds.decision-model+xml"],["3dml","text/vnd.in3d.3dml"],["3ds","image/x-3ds"],["3g2","video/3gpp2"],["3gp","video/3gp"],["3gpp","video/3gpp"],["3mf","model/3mf"],["7z","application/x-7z-compressed"],["7zip","application/x-7z-compressed"],["123","application/vnd.lotus-1-2-3"],["aab","application/x-authorware-bin"],["aac","audio/x-acc"],["aam","application/x-authorware-map"],["aas","application/x-authorware-seg"],["abw","application/x-abiword"],["ac","application/vnd.nokia.n-gage.ac+xml"],["ac3","audio/ac3"],["acc","application/vnd.americandynamics.acc"],["ace","application/x-ace-compressed"],["acu","application/vnd.acucobol"],["acutc","application/vnd.acucorp"],["adp","audio/adpcm"],["aep","application/vnd.audiograph"],["afm","application/x-font-type1"],["afp","application/vnd.ibm.modcap"],["ahead","application/vnd.ahead.space"],["ai","application/pdf"],["aif","audio/x-aiff"],["aifc","audio/x-aiff"],["aiff","audio/x-aiff"],["air","application/vnd.adobe.air-application-installer-package+zip"],["ait","application/vnd.dvb.ait"],["ami","application/vnd.amiga.ami"],["amr","audio/amr"],["apk","application/vnd.android.package-archive"],["apng","image/apng"],["appcache","text/cache-manifest"],["application","application/x-ms-application"],["apr","application/vnd.lotus-approach"],["arc","application/x-freearc"],["arj","application/x-arj"],["asc","application/pgp-signature"],["asf","video/x-ms-asf"],["asm","text/x-asm"],["aso","application/vnd.accpac.simply.aso"],["asx","video/x-ms-asf"],["atc","application/vnd.acucorp"],["atom","application/atom+xml"],["atomcat","application/atomcat+xml"],["atomdeleted","application/atomdeleted+xml"],["atomsvc","application/atomsvc+xml"],["atx","application/vnd.antix.game-component"],["au","audio/x-au"],["avi","video/x-msvideo"],["avif","image/avif"],["aw","application/applixware"],["azf","application/vnd.airzip.filesecure.azf"],["azs","application/vnd.airzip.filesecure.azs"],["azv","image/vnd.airzip.accelerator.azv"],["azw","application/vnd.amazon.ebook"],["b16","image/vnd.pco.b16"],["bat","application/x-msdownload"],["bcpio","application/x-bcpio"],["bdf","application/x-font-bdf"],["bdm","application/vnd.syncml.dm+wbxml"],["bdoc","application/x-bdoc"],["bed","application/vnd.realvnc.bed"],["bh2","application/vnd.fujitsu.oasysprs"],["bin","application/octet-stream"],["blb","application/x-blorb"],["blorb","application/x-blorb"],["bmi","application/vnd.bmi"],["bmml","application/vnd.balsamiq.bmml+xml"],["bmp","image/bmp"],["book","application/vnd.framemaker"],["box","application/vnd.previewsystems.box"],["boz","application/x-bzip2"],["bpk","application/octet-stream"],["bpmn","application/octet-stream"],["bsp","model/vnd.valve.source.compiled-map"],["btif","image/prs.btif"],["buffer","application/octet-stream"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["c","text/x-c"],["c4d","application/vnd.clonk.c4group"],["c4f","application/vnd.clonk.c4group"],["c4g","application/vnd.clonk.c4group"],["c4p","application/vnd.clonk.c4group"],["c4u","application/vnd.clonk.c4group"],["c11amc","application/vnd.cluetrust.cartomobile-config"],["c11amz","application/vnd.cluetrust.cartomobile-config-pkg"],["cab","application/vnd.ms-cab-compressed"],["caf","audio/x-caf"],["cap","application/vnd.tcpdump.pcap"],["car","application/vnd.curl.car"],["cat","application/vnd.ms-pki.seccat"],["cb7","application/x-cbr"],["cba","application/x-cbr"],["cbr","application/x-cbr"],["cbt","application/x-cbr"],["cbz","application/x-cbr"],["cc","text/x-c"],["cco","application/x-cocoa"],["cct","application/x-director"],["ccxml","application/ccxml+xml"],["cdbcmsg","application/vnd.contact.cmsg"],["cda","application/x-cdf"],["cdf","application/x-netcdf"],["cdfx","application/cdfx+xml"],["cdkey","application/vnd.mediastation.cdkey"],["cdmia","application/cdmi-capability"],["cdmic","application/cdmi-container"],["cdmid","application/cdmi-domain"],["cdmio","application/cdmi-object"],["cdmiq","application/cdmi-queue"],["cdr","application/cdr"],["cdx","chemical/x-cdx"],["cdxml","application/vnd.chemdraw+xml"],["cdy","application/vnd.cinderella"],["cer","application/pkix-cert"],["cfs","application/x-cfs-compressed"],["cgm","image/cgm"],["chat","application/x-chat"],["chm","application/vnd.ms-htmlhelp"],["chrt","application/vnd.kde.kchart"],["cif","chemical/x-cif"],["cii","application/vnd.anser-web-certificate-issue-initiation"],["cil","application/vnd.ms-artgalry"],["cjs","application/node"],["cla","application/vnd.claymore"],["class","application/octet-stream"],["clkk","application/vnd.crick.clicker.keyboard"],["clkp","application/vnd.crick.clicker.palette"],["clkt","application/vnd.crick.clicker.template"],["clkw","application/vnd.crick.clicker.wordbank"],["clkx","application/vnd.crick.clicker"],["clp","application/x-msclip"],["cmc","application/vnd.cosmocaller"],["cmdf","chemical/x-cmdf"],["cml","chemical/x-cml"],["cmp","application/vnd.yellowriver-custom-menu"],["cmx","image/x-cmx"],["cod","application/vnd.rim.cod"],["coffee","text/coffeescript"],["com","application/x-msdownload"],["conf","text/plain"],["cpio","application/x-cpio"],["cpp","text/x-c"],["cpt","application/mac-compactpro"],["crd","application/x-mscardfile"],["crl","application/pkix-crl"],["crt","application/x-x509-ca-cert"],["crx","application/x-chrome-extension"],["cryptonote","application/vnd.rig.cryptonote"],["csh","application/x-csh"],["csl","application/vnd.citationstyles.style+xml"],["csml","chemical/x-csml"],["csp","application/vnd.commonspace"],["csr","application/octet-stream"],["css","text/css"],["cst","application/x-director"],["csv","text/csv"],["cu","application/cu-seeme"],["curl","text/vnd.curl"],["cww","application/prs.cww"],["cxt","application/x-director"],["cxx","text/x-c"],["dae","model/vnd.collada+xml"],["daf","application/vnd.mobius.daf"],["dart","application/vnd.dart"],["dataless","application/vnd.fdsn.seed"],["davmount","application/davmount+xml"],["dbf","application/vnd.dbf"],["dbk","application/docbook+xml"],["dcr","application/x-director"],["dcurl","text/vnd.curl.dcurl"],["dd2","application/vnd.oma.dd2+xml"],["ddd","application/vnd.fujixerox.ddd"],["ddf","application/vnd.syncml.dmddf+xml"],["dds","image/vnd.ms-dds"],["deb","application/x-debian-package"],["def","text/plain"],["deploy","application/octet-stream"],["der","application/x-x509-ca-cert"],["dfac","application/vnd.dreamfactory"],["dgc","application/x-dgc-compressed"],["dic","text/x-c"],["dir","application/x-director"],["dis","application/vnd.mobius.dis"],["disposition-notification","message/disposition-notification"],["dist","application/octet-stream"],["distz","application/octet-stream"],["djv","image/vnd.djvu"],["djvu","image/vnd.djvu"],["dll","application/octet-stream"],["dmg","application/x-apple-diskimage"],["dmn","application/octet-stream"],["dmp","application/vnd.tcpdump.pcap"],["dms","application/octet-stream"],["dna","application/vnd.dna"],["doc","application/msword"],["docm","application/vnd.ms-word.template.macroEnabled.12"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["dot","application/msword"],["dotm","application/vnd.ms-word.template.macroEnabled.12"],["dotx","application/vnd.openxmlformats-officedocument.wordprocessingml.template"],["dp","application/vnd.osgi.dp"],["dpg","application/vnd.dpgraph"],["dra","audio/vnd.dra"],["drle","image/dicom-rle"],["dsc","text/prs.lines.tag"],["dssc","application/dssc+der"],["dtb","application/x-dtbook+xml"],["dtd","application/xml-dtd"],["dts","audio/vnd.dts"],["dtshd","audio/vnd.dts.hd"],["dump","application/octet-stream"],["dvb","video/vnd.dvb.file"],["dvi","application/x-dvi"],["dwd","application/atsc-dwd+xml"],["dwf","model/vnd.dwf"],["dwg","image/vnd.dwg"],["dxf","image/vnd.dxf"],["dxp","application/vnd.spotfire.dxp"],["dxr","application/x-director"],["ear","application/java-archive"],["ecelp4800","audio/vnd.nuera.ecelp4800"],["ecelp7470","audio/vnd.nuera.ecelp7470"],["ecelp9600","audio/vnd.nuera.ecelp9600"],["ecma","application/ecmascript"],["edm","application/vnd.novadigm.edm"],["edx","application/vnd.novadigm.edx"],["efif","application/vnd.picsel"],["ei6","application/vnd.pg.osasli"],["elc","application/octet-stream"],["emf","image/emf"],["eml","message/rfc822"],["emma","application/emma+xml"],["emotionml","application/emotionml+xml"],["emz","application/x-msmetafile"],["eol","audio/vnd.digital-winds"],["eot","application/vnd.ms-fontobject"],["eps","application/postscript"],["epub","application/epub+zip"],["es","application/ecmascript"],["es3","application/vnd.eszigno3+xml"],["esa","application/vnd.osgi.subsystem"],["esf","application/vnd.epson.esf"],["et3","application/vnd.eszigno3+xml"],["etx","text/x-setext"],["eva","application/x-eva"],["evy","application/x-envoy"],["exe","application/octet-stream"],["exi","application/exi"],["exp","application/express"],["exr","image/aces"],["ext","application/vnd.novadigm.ext"],["ez","application/andrew-inset"],["ez2","application/vnd.ezpix-album"],["ez3","application/vnd.ezpix-package"],["f","text/x-fortran"],["f4v","video/mp4"],["f77","text/x-fortran"],["f90","text/x-fortran"],["fbs","image/vnd.fastbidsheet"],["fcdt","application/vnd.adobe.formscentral.fcdt"],["fcs","application/vnd.isac.fcs"],["fdf","application/vnd.fdf"],["fdt","application/fdt+xml"],["fe_launch","application/vnd.denovo.fcselayout-link"],["fg5","application/vnd.fujitsu.oasysgp"],["fgd","application/x-director"],["fh","image/x-freehand"],["fh4","image/x-freehand"],["fh5","image/x-freehand"],["fh7","image/x-freehand"],["fhc","image/x-freehand"],["fig","application/x-xfig"],["fits","image/fits"],["flac","audio/x-flac"],["fli","video/x-fli"],["flo","application/vnd.micrografx.flo"],["flv","video/x-flv"],["flw","application/vnd.kde.kivio"],["flx","text/vnd.fmi.flexstor"],["fly","text/vnd.fly"],["fm","application/vnd.framemaker"],["fnc","application/vnd.frogans.fnc"],["fo","application/vnd.software602.filler.form+xml"],["for","text/x-fortran"],["fpx","image/vnd.fpx"],["frame","application/vnd.framemaker"],["fsc","application/vnd.fsc.weblaunch"],["fst","image/vnd.fst"],["ftc","application/vnd.fluxtime.clip"],["fti","application/vnd.anser-web-funds-transfer-initiation"],["fvt","video/vnd.fvt"],["fxp","application/vnd.adobe.fxp"],["fxpl","application/vnd.adobe.fxp"],["fzs","application/vnd.fuzzysheet"],["g2w","application/vnd.geoplan"],["g3","image/g3fax"],["g3w","application/vnd.geospace"],["gac","application/vnd.groove-account"],["gam","application/x-tads"],["gbr","application/rpki-ghostbusters"],["gca","application/x-gca-compressed"],["gdl","model/vnd.gdl"],["gdoc","application/vnd.google-apps.document"],["geo","application/vnd.dynageo"],["geojson","application/geo+json"],["gex","application/vnd.geometry-explorer"],["ggb","application/vnd.geogebra.file"],["ggt","application/vnd.geogebra.tool"],["ghf","application/vnd.groove-help"],["gif","image/gif"],["gim","application/vnd.groove-identity-message"],["glb","model/gltf-binary"],["gltf","model/gltf+json"],["gml","application/gml+xml"],["gmx","application/vnd.gmx"],["gnumeric","application/x-gnumeric"],["gpg","application/gpg-keys"],["gph","application/vnd.flographit"],["gpx","application/gpx+xml"],["gqf","application/vnd.grafeq"],["gqs","application/vnd.grafeq"],["gram","application/srgs"],["gramps","application/x-gramps-xml"],["gre","application/vnd.geometry-explorer"],["grv","application/vnd.groove-injector"],["grxml","application/srgs+xml"],["gsf","application/x-font-ghostscript"],["gsheet","application/vnd.google-apps.spreadsheet"],["gslides","application/vnd.google-apps.presentation"],["gtar","application/x-gtar"],["gtm","application/vnd.groove-tool-message"],["gtw","model/vnd.gtw"],["gv","text/vnd.graphviz"],["gxf","application/gxf"],["gxt","application/vnd.geonext"],["gz","application/gzip"],["gzip","application/gzip"],["h","text/x-c"],["h261","video/h261"],["h263","video/h263"],["h264","video/h264"],["hal","application/vnd.hal+xml"],["hbci","application/vnd.hbci"],["hbs","text/x-handlebars-template"],["hdd","application/x-virtualbox-hdd"],["hdf","application/x-hdf"],["heic","image/heic"],["heics","image/heic-sequence"],["heif","image/heif"],["heifs","image/heif-sequence"],["hej2","image/hej2k"],["held","application/atsc-held+xml"],["hh","text/x-c"],["hjson","application/hjson"],["hlp","application/winhlp"],["hpgl","application/vnd.hp-hpgl"],["hpid","application/vnd.hp-hpid"],["hps","application/vnd.hp-hps"],["hqx","application/mac-binhex40"],["hsj2","image/hsj2"],["htc","text/x-component"],["htke","application/vnd.kenameaapp"],["htm","text/html"],["html","text/html"],["hvd","application/vnd.yamaha.hv-dic"],["hvp","application/vnd.yamaha.hv-voice"],["hvs","application/vnd.yamaha.hv-script"],["i2g","application/vnd.intergeo"],["icc","application/vnd.iccprofile"],["ice","x-conference/x-cooltalk"],["icm","application/vnd.iccprofile"],["ico","image/x-icon"],["ics","text/calendar"],["ief","image/ief"],["ifb","text/calendar"],["ifm","application/vnd.shana.informed.formdata"],["iges","model/iges"],["igl","application/vnd.igloader"],["igm","application/vnd.insors.igm"],["igs","model/iges"],["igx","application/vnd.micrografx.igx"],["iif","application/vnd.shana.informed.interchange"],["img","application/octet-stream"],["imp","application/vnd.accpac.simply.imp"],["ims","application/vnd.ms-ims"],["in","text/plain"],["ini","text/plain"],["ink","application/inkml+xml"],["inkml","application/inkml+xml"],["install","application/x-install-instructions"],["iota","application/vnd.astraea-software.iota"],["ipfix","application/ipfix"],["ipk","application/vnd.shana.informed.package"],["irm","application/vnd.ibm.rights-management"],["irp","application/vnd.irepository.package+xml"],["iso","application/x-iso9660-image"],["itp","application/vnd.shana.informed.formtemplate"],["its","application/its+xml"],["ivp","application/vnd.immervision-ivp"],["ivu","application/vnd.immervision-ivu"],["jad","text/vnd.sun.j2me.app-descriptor"],["jade","text/jade"],["jam","application/vnd.jam"],["jar","application/java-archive"],["jardiff","application/x-java-archive-diff"],["java","text/x-java-source"],["jhc","image/jphc"],["jisp","application/vnd.jisp"],["jls","image/jls"],["jlt","application/vnd.hp-jlyt"],["jng","image/x-jng"],["jnlp","application/x-java-jnlp-file"],["joda","application/vnd.joost.joda-archive"],["jp2","image/jp2"],["jpe","image/jpeg"],["jpeg","image/jpeg"],["jpf","image/jpx"],["jpg","image/jpeg"],["jpg2","image/jp2"],["jpgm","video/jpm"],["jpgv","video/jpeg"],["jph","image/jph"],["jpm","video/jpm"],["jpx","image/jpx"],["js","application/javascript"],["json","application/json"],["json5","application/json5"],["jsonld","application/ld+json"],["jsonl","application/jsonl"],["jsonml","application/jsonml+json"],["jsx","text/jsx"],["jxr","image/jxr"],["jxra","image/jxra"],["jxrs","image/jxrs"],["jxs","image/jxs"],["jxsc","image/jxsc"],["jxsi","image/jxsi"],["jxss","image/jxss"],["kar","audio/midi"],["karbon","application/vnd.kde.karbon"],["kdb","application/octet-stream"],["kdbx","application/x-keepass2"],["key","application/x-iwork-keynote-sffkey"],["kfo","application/vnd.kde.kformula"],["kia","application/vnd.kidspiration"],["kml","application/vnd.google-earth.kml+xml"],["kmz","application/vnd.google-earth.kmz"],["kne","application/vnd.kinar"],["knp","application/vnd.kinar"],["kon","application/vnd.kde.kontour"],["kpr","application/vnd.kde.kpresenter"],["kpt","application/vnd.kde.kpresenter"],["kpxx","application/vnd.ds-keypoint"],["ksp","application/vnd.kde.kspread"],["ktr","application/vnd.kahootz"],["ktx","image/ktx"],["ktx2","image/ktx2"],["ktz","application/vnd.kahootz"],["kwd","application/vnd.kde.kword"],["kwt","application/vnd.kde.kword"],["lasxml","application/vnd.las.las+xml"],["latex","application/x-latex"],["lbd","application/vnd.llamagraphics.life-balance.desktop"],["lbe","application/vnd.llamagraphics.life-balance.exchange+xml"],["les","application/vnd.hhe.lesson-player"],["less","text/less"],["lgr","application/lgr+xml"],["lha","application/octet-stream"],["link66","application/vnd.route66.link66+xml"],["list","text/plain"],["list3820","application/vnd.ibm.modcap"],["listafp","application/vnd.ibm.modcap"],["litcoffee","text/coffeescript"],["lnk","application/x-ms-shortcut"],["log","text/plain"],["lostxml","application/lost+xml"],["lrf","application/octet-stream"],["lrm","application/vnd.ms-lrm"],["ltf","application/vnd.frogans.ltf"],["lua","text/x-lua"],["luac","application/x-lua-bytecode"],["lvp","audio/vnd.lucent.voice"],["lwp","application/vnd.lotus-wordpro"],["lzh","application/octet-stream"],["m1v","video/mpeg"],["m2a","audio/mpeg"],["m2v","video/mpeg"],["m3a","audio/mpeg"],["m3u","text/plain"],["m3u8","application/vnd.apple.mpegurl"],["m4a","audio/x-m4a"],["m4p","application/mp4"],["m4s","video/iso.segment"],["m4u","application/vnd.mpegurl"],["m4v","video/x-m4v"],["m13","application/x-msmediaview"],["m14","application/x-msmediaview"],["m21","application/mp21"],["ma","application/mathematica"],["mads","application/mads+xml"],["maei","application/mmt-aei+xml"],["mag","application/vnd.ecowin.chart"],["maker","application/vnd.framemaker"],["man","text/troff"],["manifest","text/cache-manifest"],["map","application/json"],["mar","application/octet-stream"],["markdown","text/markdown"],["mathml","application/mathml+xml"],["mb","application/mathematica"],["mbk","application/vnd.mobius.mbk"],["mbox","application/mbox"],["mc1","application/vnd.medcalcdata"],["mcd","application/vnd.mcd"],["mcurl","text/vnd.curl.mcurl"],["md","text/markdown"],["mdb","application/x-msaccess"],["mdi","image/vnd.ms-modi"],["mdx","text/mdx"],["me","text/troff"],["mesh","model/mesh"],["meta4","application/metalink4+xml"],["metalink","application/metalink+xml"],["mets","application/mets+xml"],["mfm","application/vnd.mfmp"],["mft","application/rpki-manifest"],["mgp","application/vnd.osgeo.mapguide.package"],["mgz","application/vnd.proteus.magazine"],["mid","audio/midi"],["midi","audio/midi"],["mie","application/x-mie"],["mif","application/vnd.mif"],["mime","message/rfc822"],["mj2","video/mj2"],["mjp2","video/mj2"],["mjs","application/javascript"],["mk3d","video/x-matroska"],["mka","audio/x-matroska"],["mkd","text/x-markdown"],["mks","video/x-matroska"],["mkv","video/x-matroska"],["mlp","application/vnd.dolby.mlp"],["mmd","application/vnd.chipnuts.karaoke-mmd"],["mmf","application/vnd.smaf"],["mml","text/mathml"],["mmr","image/vnd.fujixerox.edmics-mmr"],["mng","video/x-mng"],["mny","application/x-msmoney"],["mobi","application/x-mobipocket-ebook"],["mods","application/mods+xml"],["mov","video/quicktime"],["movie","video/x-sgi-movie"],["mp2","audio/mpeg"],["mp2a","audio/mpeg"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mp4a","audio/mp4"],["mp4s","application/mp4"],["mp4v","video/mp4"],["mp21","application/mp21"],["mpc","application/vnd.mophun.certificate"],["mpd","application/dash+xml"],["mpe","video/mpeg"],["mpeg","video/mpeg"],["mpg","video/mpeg"],["mpg4","video/mp4"],["mpga","audio/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["mpm","application/vnd.blueice.multipass"],["mpn","application/vnd.mophun.application"],["mpp","application/vnd.ms-project"],["mpt","application/vnd.ms-project"],["mpy","application/vnd.ibm.minipay"],["mqy","application/vnd.mobius.mqy"],["mrc","application/marc"],["mrcx","application/marcxml+xml"],["ms","text/troff"],["mscml","application/mediaservercontrol+xml"],["mseed","application/vnd.fdsn.mseed"],["mseq","application/vnd.mseq"],["msf","application/vnd.epson.msf"],["msg","application/vnd.ms-outlook"],["msh","model/mesh"],["msi","application/x-msdownload"],["msl","application/vnd.mobius.msl"],["msm","application/octet-stream"],["msp","application/octet-stream"],["msty","application/vnd.muvee.style"],["mtl","model/mtl"],["mts","model/vnd.mts"],["mus","application/vnd.musician"],["musd","application/mmt-usd+xml"],["musicxml","application/vnd.recordare.musicxml+xml"],["mvb","application/x-msmediaview"],["mvt","application/vnd.mapbox-vector-tile"],["mwf","application/vnd.mfer"],["mxf","application/mxf"],["mxl","application/vnd.recordare.musicxml"],["mxmf","audio/mobile-xmf"],["mxml","application/xv+xml"],["mxs","application/vnd.triscape.mxs"],["mxu","video/vnd.mpegurl"],["n-gage","application/vnd.nokia.n-gage.symbian.install"],["n3","text/n3"],["nb","application/mathematica"],["nbp","application/vnd.wolfram.player"],["nc","application/x-netcdf"],["ncx","application/x-dtbncx+xml"],["nfo","text/x-nfo"],["ngdat","application/vnd.nokia.n-gage.data"],["nitf","application/vnd.nitf"],["nlu","application/vnd.neurolanguage.nlu"],["nml","application/vnd.enliven"],["nnd","application/vnd.noblenet-directory"],["nns","application/vnd.noblenet-sealer"],["nnw","application/vnd.noblenet-web"],["npx","image/vnd.net-fpx"],["nq","application/n-quads"],["nsc","application/x-conference"],["nsf","application/vnd.lotus-notes"],["nt","application/n-triples"],["ntf","application/vnd.nitf"],["numbers","application/x-iwork-numbers-sffnumbers"],["nzb","application/x-nzb"],["oa2","application/vnd.fujitsu.oasys2"],["oa3","application/vnd.fujitsu.oasys3"],["oas","application/vnd.fujitsu.oasys"],["obd","application/x-msbinder"],["obgx","application/vnd.openblox.game+xml"],["obj","model/obj"],["oda","application/oda"],["odb","application/vnd.oasis.opendocument.database"],["odc","application/vnd.oasis.opendocument.chart"],["odf","application/vnd.oasis.opendocument.formula"],["odft","application/vnd.oasis.opendocument.formula-template"],["odg","application/vnd.oasis.opendocument.graphics"],["odi","application/vnd.oasis.opendocument.image"],["odm","application/vnd.oasis.opendocument.text-master"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogex","model/vnd.opengex"],["ogg","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["omdoc","application/omdoc+xml"],["onepkg","application/onenote"],["onetmp","application/onenote"],["onetoc","application/onenote"],["onetoc2","application/onenote"],["opf","application/oebps-package+xml"],["opml","text/x-opml"],["oprc","application/vnd.palm"],["opus","audio/ogg"],["org","text/x-org"],["osf","application/vnd.yamaha.openscoreformat"],["osfpvg","application/vnd.yamaha.openscoreformat.osfpvg+xml"],["osm","application/vnd.openstreetmap.data+xml"],["otc","application/vnd.oasis.opendocument.chart-template"],["otf","font/otf"],["otg","application/vnd.oasis.opendocument.graphics-template"],["oth","application/vnd.oasis.opendocument.text-web"],["oti","application/vnd.oasis.opendocument.image-template"],["otp","application/vnd.oasis.opendocument.presentation-template"],["ots","application/vnd.oasis.opendocument.spreadsheet-template"],["ott","application/vnd.oasis.opendocument.text-template"],["ova","application/x-virtualbox-ova"],["ovf","application/x-virtualbox-ovf"],["owl","application/rdf+xml"],["oxps","application/oxps"],["oxt","application/vnd.openofficeorg.extension"],["p","text/x-pascal"],["p7a","application/x-pkcs7-signature"],["p7b","application/x-pkcs7-certificates"],["p7c","application/pkcs7-mime"],["p7m","application/pkcs7-mime"],["p7r","application/x-pkcs7-certreqresp"],["p7s","application/pkcs7-signature"],["p8","application/pkcs8"],["p10","application/x-pkcs10"],["p12","application/x-pkcs12"],["pac","application/x-ns-proxy-autoconfig"],["pages","application/x-iwork-pages-sffpages"],["pas","text/x-pascal"],["paw","application/vnd.pawaafile"],["pbd","application/vnd.powerbuilder6"],["pbm","image/x-portable-bitmap"],["pcap","application/vnd.tcpdump.pcap"],["pcf","application/x-font-pcf"],["pcl","application/vnd.hp-pcl"],["pclxl","application/vnd.hp-pclxl"],["pct","image/x-pict"],["pcurl","application/vnd.curl.pcurl"],["pcx","image/x-pcx"],["pdb","application/x-pilot"],["pde","text/x-processing"],["pdf","application/pdf"],["pem","application/x-x509-user-cert"],["pfa","application/x-font-type1"],["pfb","application/x-font-type1"],["pfm","application/x-font-type1"],["pfr","application/font-tdpfr"],["pfx","application/x-pkcs12"],["pgm","image/x-portable-graymap"],["pgn","application/x-chess-pgn"],["pgp","application/pgp"],["php","application/x-httpd-php"],["php3","application/x-httpd-php"],["php4","application/x-httpd-php"],["phps","application/x-httpd-php-source"],["phtml","application/x-httpd-php"],["pic","image/x-pict"],["pkg","application/octet-stream"],["pki","application/pkixcmp"],["pkipath","application/pkix-pkipath"],["pkpass","application/vnd.apple.pkpass"],["pl","application/x-perl"],["plb","application/vnd.3gpp.pic-bw-large"],["plc","application/vnd.mobius.plc"],["plf","application/vnd.pocketlearn"],["pls","application/pls+xml"],["pm","application/x-perl"],["pml","application/vnd.ctc-posml"],["png","image/png"],["pnm","image/x-portable-anymap"],["portpkg","application/vnd.macports.portpkg"],["pot","application/vnd.ms-powerpoint"],["potm","application/vnd.ms-powerpoint.presentation.macroEnabled.12"],["potx","application/vnd.openxmlformats-officedocument.presentationml.template"],["ppa","application/vnd.ms-powerpoint"],["ppam","application/vnd.ms-powerpoint.addin.macroEnabled.12"],["ppd","application/vnd.cups-ppd"],["ppm","image/x-portable-pixmap"],["pps","application/vnd.ms-powerpoint"],["ppsm","application/vnd.ms-powerpoint.slideshow.macroEnabled.12"],["ppsx","application/vnd.openxmlformats-officedocument.presentationml.slideshow"],["ppt","application/powerpoint"],["pptm","application/vnd.ms-powerpoint.presentation.macroEnabled.12"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["pqa","application/vnd.palm"],["prc","application/x-pilot"],["pre","application/vnd.lotus-freelance"],["prf","application/pics-rules"],["provx","application/provenance+xml"],["ps","application/postscript"],["psb","application/vnd.3gpp.pic-bw-small"],["psd","application/x-photoshop"],["psf","application/x-font-linux-psf"],["pskcxml","application/pskc+xml"],["pti","image/prs.pti"],["ptid","application/vnd.pvi.ptid1"],["pub","application/x-mspublisher"],["pvb","application/vnd.3gpp.pic-bw-var"],["pwn","application/vnd.3m.post-it-notes"],["pya","audio/vnd.ms-playready.media.pya"],["pyv","video/vnd.ms-playready.media.pyv"],["qam","application/vnd.epson.quickanime"],["qbo","application/vnd.intu.qbo"],["qfx","application/vnd.intu.qfx"],["qps","application/vnd.publishare-delta-tree"],["qt","video/quicktime"],["qwd","application/vnd.quark.quarkxpress"],["qwt","application/vnd.quark.quarkxpress"],["qxb","application/vnd.quark.quarkxpress"],["qxd","application/vnd.quark.quarkxpress"],["qxl","application/vnd.quark.quarkxpress"],["qxt","application/vnd.quark.quarkxpress"],["ra","audio/x-realaudio"],["ram","audio/x-pn-realaudio"],["raml","application/raml+yaml"],["rapd","application/route-apd+xml"],["rar","application/x-rar"],["ras","image/x-cmu-raster"],["rcprofile","application/vnd.ipunplugged.rcprofile"],["rdf","application/rdf+xml"],["rdz","application/vnd.data-vision.rdz"],["relo","application/p2p-overlay+xml"],["rep","application/vnd.businessobjects"],["res","application/x-dtbresource+xml"],["rgb","image/x-rgb"],["rif","application/reginfo+xml"],["rip","audio/vnd.rip"],["ris","application/x-research-info-systems"],["rl","application/resource-lists+xml"],["rlc","image/vnd.fujixerox.edmics-rlc"],["rld","application/resource-lists-diff+xml"],["rm","audio/x-pn-realaudio"],["rmi","audio/midi"],["rmp","audio/x-pn-realaudio-plugin"],["rms","application/vnd.jcp.javame.midlet-rms"],["rmvb","application/vnd.rn-realmedia-vbr"],["rnc","application/relax-ng-compact-syntax"],["rng","application/xml"],["roa","application/rpki-roa"],["roff","text/troff"],["rp9","application/vnd.cloanto.rp9"],["rpm","audio/x-pn-realaudio-plugin"],["rpss","application/vnd.nokia.radio-presets"],["rpst","application/vnd.nokia.radio-preset"],["rq","application/sparql-query"],["rs","application/rls-services+xml"],["rsa","application/x-pkcs7"],["rsat","application/atsc-rsat+xml"],["rsd","application/rsd+xml"],["rsheet","application/urc-ressheet+xml"],["rss","application/rss+xml"],["rtf","text/rtf"],["rtx","text/richtext"],["run","application/x-makeself"],["rusd","application/route-usd+xml"],["rv","video/vnd.rn-realvideo"],["s","text/x-asm"],["s3m","audio/s3m"],["saf","application/vnd.yamaha.smaf-audio"],["sass","text/x-sass"],["sbml","application/sbml+xml"],["sc","application/vnd.ibm.secure-container"],["scd","application/x-msschedule"],["scm","application/vnd.lotus-screencam"],["scq","application/scvp-cv-request"],["scs","application/scvp-cv-response"],["scss","text/x-scss"],["scurl","text/vnd.curl.scurl"],["sda","application/vnd.stardivision.draw"],["sdc","application/vnd.stardivision.calc"],["sdd","application/vnd.stardivision.impress"],["sdkd","application/vnd.solent.sdkm+xml"],["sdkm","application/vnd.solent.sdkm+xml"],["sdp","application/sdp"],["sdw","application/vnd.stardivision.writer"],["sea","application/octet-stream"],["see","application/vnd.seemail"],["seed","application/vnd.fdsn.seed"],["sema","application/vnd.sema"],["semd","application/vnd.semd"],["semf","application/vnd.semf"],["senmlx","application/senml+xml"],["sensmlx","application/sensml+xml"],["ser","application/java-serialized-object"],["setpay","application/set-payment-initiation"],["setreg","application/set-registration-initiation"],["sfd-hdstx","application/vnd.hydrostatix.sof-data"],["sfs","application/vnd.spotfire.sfs"],["sfv","text/x-sfv"],["sgi","image/sgi"],["sgl","application/vnd.stardivision.writer-global"],["sgm","text/sgml"],["sgml","text/sgml"],["sh","application/x-sh"],["shar","application/x-shar"],["shex","text/shex"],["shf","application/shf+xml"],["shtml","text/html"],["sid","image/x-mrsid-image"],["sieve","application/sieve"],["sig","application/pgp-signature"],["sil","audio/silk"],["silo","model/mesh"],["sis","application/vnd.symbian.install"],["sisx","application/vnd.symbian.install"],["sit","application/x-stuffit"],["sitx","application/x-stuffitx"],["siv","application/sieve"],["skd","application/vnd.koan"],["skm","application/vnd.koan"],["skp","application/vnd.koan"],["skt","application/vnd.koan"],["sldm","application/vnd.ms-powerpoint.slide.macroenabled.12"],["sldx","application/vnd.openxmlformats-officedocument.presentationml.slide"],["slim","text/slim"],["slm","text/slim"],["sls","application/route-s-tsid+xml"],["slt","application/vnd.epson.salt"],["sm","application/vnd.stepmania.stepchart"],["smf","application/vnd.stardivision.math"],["smi","application/smil"],["smil","application/smil"],["smv","video/x-smv"],["smzip","application/vnd.stepmania.package"],["snd","audio/basic"],["snf","application/x-font-snf"],["so","application/octet-stream"],["spc","application/x-pkcs7-certificates"],["spdx","text/spdx"],["spf","application/vnd.yamaha.smaf-phrase"],["spl","application/x-futuresplash"],["spot","text/vnd.in3d.spot"],["spp","application/scvp-vp-response"],["spq","application/scvp-vp-request"],["spx","audio/ogg"],["sql","application/x-sql"],["src","application/x-wais-source"],["srt","application/x-subrip"],["sru","application/sru+xml"],["srx","application/sparql-results+xml"],["ssdl","application/ssdl+xml"],["sse","application/vnd.kodak-descriptor"],["ssf","application/vnd.epson.ssf"],["ssml","application/ssml+xml"],["sst","application/octet-stream"],["st","application/vnd.sailingtracker.track"],["stc","application/vnd.sun.xml.calc.template"],["std","application/vnd.sun.xml.draw.template"],["stf","application/vnd.wt.stf"],["sti","application/vnd.sun.xml.impress.template"],["stk","application/hyperstudio"],["stl","model/stl"],["stpx","model/step+xml"],["stpxz","model/step-xml+zip"],["stpz","model/step+zip"],["str","application/vnd.pg.format"],["stw","application/vnd.sun.xml.writer.template"],["styl","text/stylus"],["stylus","text/stylus"],["sub","text/vnd.dvb.subtitle"],["sus","application/vnd.sus-calendar"],["susp","application/vnd.sus-calendar"],["sv4cpio","application/x-sv4cpio"],["sv4crc","application/x-sv4crc"],["svc","application/vnd.dvb.service"],["svd","application/vnd.svd"],["svg","image/svg+xml"],["svgz","image/svg+xml"],["swa","application/x-director"],["swf","application/x-shockwave-flash"],["swi","application/vnd.aristanetworks.swi"],["swidtag","application/swid+xml"],["sxc","application/vnd.sun.xml.calc"],["sxd","application/vnd.sun.xml.draw"],["sxg","application/vnd.sun.xml.writer.global"],["sxi","application/vnd.sun.xml.impress"],["sxm","application/vnd.sun.xml.math"],["sxw","application/vnd.sun.xml.writer"],["t","text/troff"],["t3","application/x-t3vm-image"],["t38","image/t38"],["taglet","application/vnd.mynfc"],["tao","application/vnd.tao.intent-module-archive"],["tap","image/vnd.tencent.tap"],["tar","application/x-tar"],["tcap","application/vnd.3gpp2.tcap"],["tcl","application/x-tcl"],["td","application/urc-targetdesc+xml"],["teacher","application/vnd.smart.teacher"],["tei","application/tei+xml"],["teicorpus","application/tei+xml"],["tex","application/x-tex"],["texi","application/x-texinfo"],["texinfo","application/x-texinfo"],["text","text/plain"],["tfi","application/thraud+xml"],["tfm","application/x-tex-tfm"],["tfx","image/tiff-fx"],["tga","image/x-tga"],["tgz","application/x-tar"],["thmx","application/vnd.ms-officetheme"],["tif","image/tiff"],["tiff","image/tiff"],["tk","application/x-tcl"],["tmo","application/vnd.tmobile-livetv"],["toml","application/toml"],["torrent","application/x-bittorrent"],["tpl","application/vnd.groove-tool-template"],["tpt","application/vnd.trid.tpt"],["tr","text/troff"],["tra","application/vnd.trueapp"],["trig","application/trig"],["trm","application/x-msterminal"],["ts","video/mp2t"],["tsd","application/timestamped-data"],["tsv","text/tab-separated-values"],["ttc","font/collection"],["ttf","font/ttf"],["ttl","text/turtle"],["ttml","application/ttml+xml"],["twd","application/vnd.simtech-mindmapper"],["twds","application/vnd.simtech-mindmapper"],["txd","application/vnd.genomatix.tuxedo"],["txf","application/vnd.mobius.txf"],["txt","text/plain"],["u8dsn","message/global-delivery-status"],["u8hdr","message/global-headers"],["u8mdn","message/global-disposition-notification"],["u8msg","message/global"],["u32","application/x-authorware-bin"],["ubj","application/ubjson"],["udeb","application/x-debian-package"],["ufd","application/vnd.ufdl"],["ufdl","application/vnd.ufdl"],["ulx","application/x-glulx"],["umj","application/vnd.umajin"],["unityweb","application/vnd.unity"],["uoml","application/vnd.uoml+xml"],["uri","text/uri-list"],["uris","text/uri-list"],["urls","text/uri-list"],["usdz","model/vnd.usdz+zip"],["ustar","application/x-ustar"],["utz","application/vnd.uiq.theme"],["uu","text/x-uuencode"],["uva","audio/vnd.dece.audio"],["uvd","application/vnd.dece.data"],["uvf","application/vnd.dece.data"],["uvg","image/vnd.dece.graphic"],["uvh","video/vnd.dece.hd"],["uvi","image/vnd.dece.graphic"],["uvm","video/vnd.dece.mobile"],["uvp","video/vnd.dece.pd"],["uvs","video/vnd.dece.sd"],["uvt","application/vnd.dece.ttml+xml"],["uvu","video/vnd.uvvu.mp4"],["uvv","video/vnd.dece.video"],["uvva","audio/vnd.dece.audio"],["uvvd","application/vnd.dece.data"],["uvvf","application/vnd.dece.data"],["uvvg","image/vnd.dece.graphic"],["uvvh","video/vnd.dece.hd"],["uvvi","image/vnd.dece.graphic"],["uvvm","video/vnd.dece.mobile"],["uvvp","video/vnd.dece.pd"],["uvvs","video/vnd.dece.sd"],["uvvt","application/vnd.dece.ttml+xml"],["uvvu","video/vnd.uvvu.mp4"],["uvvv","video/vnd.dece.video"],["uvvx","application/vnd.dece.unspecified"],["uvvz","application/vnd.dece.zip"],["uvx","application/vnd.dece.unspecified"],["uvz","application/vnd.dece.zip"],["vbox","application/x-virtualbox-vbox"],["vbox-extpack","application/x-virtualbox-vbox-extpack"],["vcard","text/vcard"],["vcd","application/x-cdlink"],["vcf","text/x-vcard"],["vcg","application/vnd.groove-vcard"],["vcs","text/x-vcalendar"],["vcx","application/vnd.vcx"],["vdi","application/x-virtualbox-vdi"],["vds","model/vnd.sap.vds"],["vhd","application/x-virtualbox-vhd"],["vis","application/vnd.visionary"],["viv","video/vnd.vivo"],["vlc","application/videolan"],["vmdk","application/x-virtualbox-vmdk"],["vob","video/x-ms-vob"],["vor","application/vnd.stardivision.writer"],["vox","application/x-authorware-bin"],["vrml","model/vrml"],["vsd","application/vnd.visio"],["vsf","application/vnd.vsf"],["vss","application/vnd.visio"],["vst","application/vnd.visio"],["vsw","application/vnd.visio"],["vtf","image/vnd.valve.source.texture"],["vtt","text/vtt"],["vtu","model/vnd.vtu"],["vxml","application/voicexml+xml"],["w3d","application/x-director"],["wad","application/x-doom"],["wadl","application/vnd.sun.wadl+xml"],["war","application/java-archive"],["wasm","application/wasm"],["wav","audio/x-wav"],["wax","audio/x-ms-wax"],["wbmp","image/vnd.wap.wbmp"],["wbs","application/vnd.criticaltools.wbs+xml"],["wbxml","application/wbxml"],["wcm","application/vnd.ms-works"],["wdb","application/vnd.ms-works"],["wdp","image/vnd.ms-photo"],["weba","audio/webm"],["webapp","application/x-web-app-manifest+json"],["webm","video/webm"],["webmanifest","application/manifest+json"],["webp","image/webp"],["wg","application/vnd.pmi.widget"],["wgt","application/widget"],["wks","application/vnd.ms-works"],["wm","video/x-ms-wm"],["wma","audio/x-ms-wma"],["wmd","application/x-ms-wmd"],["wmf","image/wmf"],["wml","text/vnd.wap.wml"],["wmlc","application/wmlc"],["wmls","text/vnd.wap.wmlscript"],["wmlsc","application/vnd.wap.wmlscriptc"],["wmv","video/x-ms-wmv"],["wmx","video/x-ms-wmx"],["wmz","application/x-msmetafile"],["woff","font/woff"],["woff2","font/woff2"],["word","application/msword"],["wpd","application/vnd.wordperfect"],["wpl","application/vnd.ms-wpl"],["wps","application/vnd.ms-works"],["wqd","application/vnd.wqd"],["wri","application/x-mswrite"],["wrl","model/vrml"],["wsc","message/vnd.wfa.wsc"],["wsdl","application/wsdl+xml"],["wspolicy","application/wspolicy+xml"],["wtb","application/vnd.webturbo"],["wvx","video/x-ms-wvx"],["x3d","model/x3d+xml"],["x3db","model/x3d+fastinfoset"],["x3dbz","model/x3d+binary"],["x3dv","model/x3d-vrml"],["x3dvz","model/x3d+vrml"],["x3dz","model/x3d+xml"],["x32","application/x-authorware-bin"],["x_b","model/vnd.parasolid.transmit.binary"],["x_t","model/vnd.parasolid.transmit.text"],["xaml","application/xaml+xml"],["xap","application/x-silverlight-app"],["xar","application/vnd.xara"],["xav","application/xcap-att+xml"],["xbap","application/x-ms-xbap"],["xbd","application/vnd.fujixerox.docuworks.binder"],["xbm","image/x-xbitmap"],["xca","application/xcap-caps+xml"],["xcs","application/calendar+xml"],["xdf","application/xcap-diff+xml"],["xdm","application/vnd.syncml.dm+xml"],["xdp","application/vnd.adobe.xdp+xml"],["xdssc","application/dssc+xml"],["xdw","application/vnd.fujixerox.docuworks"],["xel","application/xcap-el+xml"],["xenc","application/xenc+xml"],["xer","application/patch-ops-error+xml"],["xfdf","application/vnd.adobe.xfdf"],["xfdl","application/vnd.xfdl"],["xht","application/xhtml+xml"],["xhtml","application/xhtml+xml"],["xhvml","application/xv+xml"],["xif","image/vnd.xiff"],["xl","application/excel"],["xla","application/vnd.ms-excel"],["xlam","application/vnd.ms-excel.addin.macroEnabled.12"],["xlc","application/vnd.ms-excel"],["xlf","application/xliff+xml"],["xlm","application/vnd.ms-excel"],["xls","application/vnd.ms-excel"],["xlsb","application/vnd.ms-excel.sheet.binary.macroEnabled.12"],["xlsm","application/vnd.ms-excel.sheet.macroEnabled.12"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xlt","application/vnd.ms-excel"],["xltm","application/vnd.ms-excel.template.macroEnabled.12"],["xltx","application/vnd.openxmlformats-officedocument.spreadsheetml.template"],["xlw","application/vnd.ms-excel"],["xm","audio/xm"],["xml","application/xml"],["xns","application/xcap-ns+xml"],["xo","application/vnd.olpc-sugar"],["xop","application/xop+xml"],["xpi","application/x-xpinstall"],["xpl","application/xproc+xml"],["xpm","image/x-xpixmap"],["xpr","application/vnd.is-xpr"],["xps","application/vnd.ms-xpsdocument"],["xpw","application/vnd.intercon.formnet"],["xpx","application/vnd.intercon.formnet"],["xsd","application/xml"],["xsl","application/xml"],["xslt","application/xslt+xml"],["xsm","application/vnd.syncml+xml"],["xspf","application/xspf+xml"],["xul","application/vnd.mozilla.xul+xml"],["xvm","application/xv+xml"],["xvml","application/xv+xml"],["xwd","image/x-xwindowdump"],["xyz","chemical/x-xyz"],["xz","application/x-xz"],["yaml","text/yaml"],["yang","application/yang"],["yin","application/yin+xml"],["yml","text/yaml"],["ymp","text/x-suse-ymp"],["z","application/x-compress"],["z1","application/x-zmachine"],["z2","application/x-zmachine"],["z3","application/x-zmachine"],["z4","application/x-zmachine"],["z5","application/x-zmachine"],["z6","application/x-zmachine"],["z7","application/x-zmachine"],["z8","application/x-zmachine"],["zaz","application/vnd.zzazz.deck+xml"],["zip","application/zip"],["zir","application/vnd.zul"],["zirz","application/vnd.zul"],["zmm","application/vnd.handheld-entertainment+xml"],["zsh","text/x-scriptzsh"]]);function kf(n,e,t){const s=aoe(n),{webkitRelativePath:i}=n,r=typeof e=="string"?e:typeof i=="string"&&i.length>0?i:`./${n.name}`;return typeof s.path!="string"&&cP(s,"path",r),cP(s,"relativePath",r),s}function aoe(n){const{name:e}=n;if(e&&e.lastIndexOf(".")!==-1&&!n.type){const s=e.split(".").pop().toLowerCase(),i=ooe.get(s);i&&Object.defineProperty(n,"type",{value:i,writable:!1,configurable:!1,enumerable:!0})}return n}function cP(n,e,t){Object.defineProperty(n,e,{value:t,writable:!1,configurable:!1,enumerable:!0})}const loe=[".DS_Store","Thumbs.db"];function coe(n){return Od(this,void 0,void 0,function*(){return d2(n)&&uoe(n.dataTransfer)?poe(n.dataTransfer,n.type):doe(n)?hoe(n):Array.isArray(n)&&n.every(e=>"getFile"in e&&typeof e.getFile=="function")?foe(n):[]})}function uoe(n){return d2(n)}function doe(n){return d2(n)&&d2(n.target)}function d2(n){return typeof n=="object"&&n!==null}function hoe(n){return jC(n.target.files).map(e=>kf(e))}function foe(n){return Od(this,void 0,void 0,function*(){return(yield Promise.all(n.map(t=>t.getFile()))).map(t=>kf(t))})}function poe(n,e){return Od(this,void 0,void 0,function*(){if(n.items){const t=jC(n.items).filter(i=>i.kind==="file");if(e!=="drop")return t;const s=yield Promise.all(t.map(moe));return uP($O(s))}return uP(jC(n.files).map(t=>kf(t)))})}function uP(n){return n.filter(e=>loe.indexOf(e.name)===-1)}function jC(n){if(n===null)return[];const e=[];for(let t=0;t<n.length;t++){const s=n[t];e.push(s)}return e}function moe(n){if(typeof n.webkitGetAsEntry!="function")return dP(n);const e=n.webkitGetAsEntry();return e&&e.isDirectory?FO(e):dP(n,e)}function $O(n){return n.reduce((e,t)=>[...e,...Array.isArray(t)?$O(t):[t]],[])}function dP(n,e){return Od(this,void 0,void 0,function*(){var t;if(globalThis.isSecureContext&&typeof n.getAsFileSystemHandle=="function"){const r=yield n.getAsFileSystemHandle();if(r===null)throw new Error(`${n} is not a File`);if(r!==void 0){const o=yield r.getFile();return o.handle=r,kf(o)}}const s=n.getAsFile();if(!s)throw new Error(`${n} is not a File`);return kf(s,(t=e==null?void 0:e.fullPath)!==null&&t!==void 0?t:void 0)})}function goe(n){return Od(this,void 0,void 0,function*(){return n.isDirectory?FO(n):xoe(n)})}function FO(n){const e=n.createReader();return new Promise((t,s)=>{const i=[];function r(){e.readEntries(o=>Od(this,void 0,void 0,function*(){if(o.length){const a=Promise.all(o.map(goe));i.push(a),r()}else try{const a=yield Promise.all(i);t(a)}catch(a){s(a)}}),o=>{s(o)})}r()})}function xoe(n){return Od(this,void 0,void 0,function*(){return new Promise((e,t)=>{n.file(s=>{const i=kf(s,n.fullPath);e(i)},s=>{t(s)})})})}var uv={},hP;function voe(){return hP||(hP=1,uv.__esModule=!0,uv.default=function(n,e){if(n&&e){var t=Array.isArray(e)?e:e.split(",");if(t.length===0)return!0;var s=n.name||"",i=(n.type||"").toLowerCase(),r=i.replace(/\/.*$/,"");return t.some(function(o){var a=o.trim().toLowerCase();return a.charAt(0)==="."?s.toLowerCase().endsWith(a):a.endsWith("/*")?r===a.replace(/\/.*$/,""):i===a})}return!0}),uv}var yoe=voe();const zS=Zg(yoe);function fP(n){return Soe(n)||boe(n)||zO(n)||woe()}function woe(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function boe(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function Soe(n){if(Array.isArray(n))return XC(n)}function pP(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(i){return Object.getOwnPropertyDescriptor(n,i).enumerable})),t.push.apply(t,s)}return t}function mP(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?pP(Object(t),!0).forEach(function(s){OO(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):pP(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}function OO(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function Pg(n,e){return Eoe(n)||_oe(n,e)||zO(n,e)||Coe()}function Coe(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function zO(n,e){if(n){if(typeof n=="string")return XC(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);if(t==="Object"&&n.constructor&&(t=n.constructor.name),t==="Map"||t==="Set")return Array.from(n);if(t==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return XC(n,e)}}function XC(n,e){(e==null||e>n.length)&&(e=n.length);for(var t=0,s=new Array(e);t<e;t++)s[t]=n[t];return s}function _oe(n,e){var t=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(t!=null){var s=[],i=!0,r=!1,o,a;try{for(t=t.call(n);!(i=(o=t.next()).done)&&(s.push(o.value),!(e&&s.length===e));i=!0);}catch(l){r=!0,a=l}finally{try{!i&&t.return!=null&&t.return()}finally{if(r)throw a}}return s}}function Eoe(n){if(Array.isArray(n))return n}var Toe=typeof zS=="function"?zS:zS.default,Ioe="file-invalid-type",koe="file-too-large",Aoe="file-too-small",Roe="too-many-files",Moe=function(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",t=e.split(","),s=t.length>1?"one of ".concat(t.join(", ")):t[0];return{code:Ioe,message:"File type must be ".concat(s)}},gP=function(e){return{code:koe,message:"File is larger than ".concat(e," ").concat(e===1?"byte":"bytes")}},xP=function(e){return{code:Aoe,message:"File is smaller than ".concat(e," ").concat(e===1?"byte":"bytes")}},Noe={code:Roe,message:"Too many files"};function BO(n,e){var t=n.type==="application/x-moz-file"||Toe(n,e);return[t,t?null:Moe(e)]}function UO(n,e,t){if(Ju(n.size))if(Ju(e)&&Ju(t)){if(n.size>t)return[!1,gP(t)];if(n.size<e)return[!1,xP(e)]}else{if(Ju(e)&&n.size<e)return[!1,xP(e)];if(Ju(t)&&n.size>t)return[!1,gP(t)]}return[!0,null]}function Ju(n){return n!=null}function Poe(n){var e=n.files,t=n.accept,s=n.minSize,i=n.maxSize,r=n.multiple,o=n.maxFiles,a=n.validator;return!r&&e.length>1||r&&o>=1&&e.length>o?!1:e.every(function(l){var c=BO(l,t),u=Pg(c,1),d=u[0],h=UO(l,s,i),p=Pg(h,1),g=p[0],y=a?a(l):null;return d&&g&&!y})}function h2(n){return typeof n.isPropagationStopped=="function"?n.isPropagationStopped():typeof n.cancelBubble<"u"?n.cancelBubble:!1}function dv(n){return n.dataTransfer?Array.prototype.some.call(n.dataTransfer.types,function(e){return e==="Files"||e==="application/x-moz-file"}):!!n.target&&!!n.target.files}function vP(n){n.preventDefault()}function Doe(n){return n.indexOf("MSIE")!==-1||n.indexOf("Trident/")!==-1}function Loe(n){return n.indexOf("Edge/")!==-1}function $oe(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return Doe(n)||Loe(n)}function el(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return function(s){for(var i=arguments.length,r=new Array(i>1?i-1:0),o=1;o<i;o++)r[o-1]=arguments[o];return e.some(function(a){return!h2(s)&&a&&a.apply(void 0,[s].concat(r)),h2(s)})}}function Foe(){return"showOpenFilePicker"in window}function Ooe(n){if(Ju(n)){var e=Object.entries(n).filter(function(t){var s=Pg(t,2),i=s[0],r=s[1],o=!0;return VO(i)||(console.warn('Skipped "'.concat(i,'" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')),o=!1),(!Array.isArray(r)||!r.every(WO))&&(console.warn('Skipped "'.concat(i,'" because an invalid file extension was provided.')),o=!1),o}).reduce(function(t,s){var i=Pg(s,2),r=i[0],o=i[1];return mP(mP({},t),{},OO({},r,o))},{});return[{description:"Files",accept:e}]}return n}function zoe(n){if(Ju(n))return Object.entries(n).reduce(function(e,t){var s=Pg(t,2),i=s[0],r=s[1];return[].concat(fP(e),[i],fP(r))},[]).filter(function(e){return VO(e)||WO(e)}).join(",")}function Boe(n){return n instanceof DOMException&&(n.name==="AbortError"||n.code===n.ABORT_ERR)}function Uoe(n){return n instanceof DOMException&&(n.name==="SecurityError"||n.code===n.SECURITY_ERR)}function VO(n){return n==="audio/*"||n==="video/*"||n==="image/*"||n==="text/*"||n==="application/*"||/\w+\/[-+.\w]+/g.test(n)}function WO(n){return/^.*\.[\w]+$/.test(n)}var Voe=["children"],Woe=["open"],Goe=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],Hoe=["refKey","onChange","onClick"];function joe(n){return Koe(n)||qoe(n)||GO(n)||Xoe()}function Xoe(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function qoe(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function Koe(n){if(Array.isArray(n))return qC(n)}function BS(n,e){return Qoe(n)||Zoe(n,e)||GO(n,e)||Yoe()}function Yoe(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function GO(n,e){if(n){if(typeof n=="string")return qC(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);if(t==="Object"&&n.constructor&&(t=n.constructor.name),t==="Map"||t==="Set")return Array.from(n);if(t==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return qC(n,e)}}function qC(n,e){(e==null||e>n.length)&&(e=n.length);for(var t=0,s=new Array(e);t<e;t++)s[t]=n[t];return s}function Zoe(n,e){var t=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(t!=null){var s=[],i=!0,r=!1,o,a;try{for(t=t.call(n);!(i=(o=t.next()).done)&&(s.push(o.value),!(e&&s.length===e));i=!0);}catch(l){r=!0,a=l}finally{try{!i&&t.return!=null&&t.return()}finally{if(r)throw a}}return s}}function Qoe(n){if(Array.isArray(n))return n}function yP(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter(function(i){return Object.getOwnPropertyDescriptor(n,i).enumerable})),t.push.apply(t,s)}return t}function di(n){for(var e=1;e<arguments.length;e++){var t=arguments[e]!=null?arguments[e]:{};e%2?yP(Object(t),!0).forEach(function(s){KC(n,s,t[s])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):yP(Object(t)).forEach(function(s){Object.defineProperty(n,s,Object.getOwnPropertyDescriptor(t,s))})}return n}function KC(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function f2(n,e){if(n==null)return{};var t=Joe(n,e),s,i;if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)s=r[i],!(e.indexOf(s)>=0)&&Object.prototype.propertyIsEnumerable.call(n,s)&&(t[s]=n[s])}return t}function Joe(n,e){if(n==null)return{};var t={},s=Object.keys(n),i,r;for(r=0;r<s.length;r++)i=s[r],!(e.indexOf(i)>=0)&&(t[i]=n[i]);return t}var jE=le.forwardRef(function(n,e){var t=n.children,s=f2(n,Voe),i=jO(s),r=i.open,o=f2(i,Woe);return le.useImperativeHandle(e,function(){return{open:r}},[r]),AL.createElement(le.Fragment,null,t(di(di({},o),{},{open:r})))});jE.displayName="Dropzone";var HO={disabled:!1,getFilesFromEvent:coe,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!1,autoFocus:!1};jE.defaultProps=HO;jE.propTypes={children:Hs.func,accept:Hs.objectOf(Hs.arrayOf(Hs.string)),multiple:Hs.bool,preventDropOnDocument:Hs.bool,noClick:Hs.bool,noKeyboard:Hs.bool,noDrag:Hs.bool,noDragEventsBubbling:Hs.bool,minSize:Hs.number,maxSize:Hs.number,maxFiles:Hs.number,disabled:Hs.bool,getFilesFromEvent:Hs.func,onFileDialogCancel:Hs.func,onFileDialogOpen:Hs.func,useFsAccessApi:Hs.bool,autoFocus:Hs.bool,onDragEnter:Hs.func,onDragLeave:Hs.func,onDragOver:Hs.func,onDrop:Hs.func,onDropAccepted:Hs.func,onDropRejected:Hs.func,onError:Hs.func,validator:Hs.func};var YC={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,acceptedFiles:[],fileRejections:[]};function jO(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},e=di(di({},HO),n),t=e.accept,s=e.disabled,i=e.getFilesFromEvent,r=e.maxSize,o=e.minSize,a=e.multiple,l=e.maxFiles,c=e.onDragEnter,u=e.onDragLeave,d=e.onDragOver,h=e.onDrop,p=e.onDropAccepted,g=e.onDropRejected,y=e.onFileDialogCancel,x=e.onFileDialogOpen,v=e.useFsAccessApi,b=e.autoFocus,S=e.preventDropOnDocument,C=e.noClick,E=e.noKeyboard,k=e.noDrag,R=e.noDragEventsBubbling,L=e.onError,I=e.validator,T=le.useMemo(function(){return zoe(t)},[t]),M=le.useMemo(function(){return Ooe(t)},[t]),j=le.useMemo(function(){return typeof x=="function"?x:wP},[x]),W=le.useMemo(function(){return typeof y=="function"?y:wP},[y]),z=le.useRef(null),X=le.useRef(null),B=le.useReducer(eae,YC),J=BS(B,2),K=J[0],ee=J[1],ne=K.isFocused,V=K.isFileDialogActive,Z=le.useRef(typeof window<"u"&&window.isSecureContext&&v&&Foe()),he=function(){!Z.current&&V&&setTimeout(function(){if(X.current){var ye=X.current.files;ye.length||(ee({type:"closeDialog"}),W())}},300)};le.useEffect(function(){return window.addEventListener("focus",he,!1),function(){window.removeEventListener("focus",he,!1)}},[X,V,W,Z]);var ve=le.useRef([]),be=function(ye){z.current&&z.current.contains(ye.target)||(ye.preventDefault(),ve.current=[])};le.useEffect(function(){return S&&(document.addEventListener("dragover",vP,!1),document.addEventListener("drop",be,!1)),function(){S&&(document.removeEventListener("dragover",vP),document.removeEventListener("drop",be))}},[z,S]),le.useEffect(function(){return!s&&b&&z.current&&z.current.focus(),function(){}},[z,b,s]);var Ie=le.useCallback(function(Y){L?L(Y):console.error(Y)},[L]),Xe=le.useCallback(function(Y){Y.preventDefault(),Y.persist(),Gt(Y),ve.current=[].concat(joe(ve.current),[Y.target]),dv(Y)&&Promise.resolve(i(Y)).then(function(ye){if(!(h2(Y)&&!R)){var Qe=ye.length,tt=Qe>0&&Poe({files:ye,accept:T,minSize:o,maxSize:r,multiple:a,maxFiles:l,validator:I}),rt=Qe>0&&!tt;ee({isDragAccept:tt,isDragReject:rt,isDragActive:!0,type:"setDraggedFiles"}),c&&c(Y)}}).catch(function(ye){return Ie(ye)})},[i,c,Ie,R,T,o,r,a,l,I]),Fe=le.useCallback(function(Y){Y.preventDefault(),Y.persist(),Gt(Y);var ye=dv(Y);if(ye&&Y.dataTransfer)try{Y.dataTransfer.dropEffect="copy"}catch{}return ye&&d&&d(Y),!1},[d,R]),Pe=le.useCallback(function(Y){Y.preventDefault(),Y.persist(),Gt(Y);var ye=ve.current.filter(function(tt){return z.current&&z.current.contains(tt)}),Qe=ye.indexOf(Y.target);Qe!==-1&&ye.splice(Qe,1),ve.current=ye,!(ye.length>0)&&(ee({type:"setDraggedFiles",isDragActive:!1,isDragAccept:!1,isDragReject:!1}),dv(Y)&&u&&u(Y))},[z,u,R]),ct=le.useCallback(function(Y,ye){var Qe=[],tt=[];Y.forEach(function(rt){var Pt=BO(rt,T),pt=BS(Pt,2),At=pt[0],xe=pt[1],xt=UO(rt,o,r),Ye=BS(xt,2),kt=Ye[0],Et=Ye[1],bt=I?I(rt):null;if(At&&kt&&!bt)Qe.push(rt);else{var Wt=[xe,Et];bt&&(Wt=Wt.concat(bt)),tt.push({file:rt,errors:Wt.filter(function(ht){return ht})})}}),(!a&&Qe.length>1||a&&l>=1&&Qe.length>l)&&(Qe.forEach(function(rt){tt.push({file:rt,errors:[Noe]})}),Qe.splice(0)),ee({acceptedFiles:Qe,fileRejections:tt,isDragReject:tt.length>0,type:"setFiles"}),h&&h(Qe,tt,ye),tt.length>0&&g&&g(tt,ye),Qe.length>0&&p&&p(Qe,ye)},[ee,a,T,o,r,l,h,p,g,I]),at=le.useCallback(function(Y){Y.preventDefault(),Y.persist(),Gt(Y),ve.current=[],dv(Y)&&Promise.resolve(i(Y)).then(function(ye){h2(Y)&&!R||ct(ye,Y)}).catch(function(ye){return Ie(ye)}),ee({type:"reset"})},[i,ct,Ie,R]),Ee=le.useCallback(function(){if(Z.current){ee({type:"openDialog"}),j();var Y={multiple:a,types:M};window.showOpenFilePicker(Y).then(function(ye){return i(ye)}).then(function(ye){ct(ye,null),ee({type:"closeDialog"})}).catch(function(ye){Boe(ye)?(W(ye),ee({type:"closeDialog"})):Uoe(ye)?(Z.current=!1,X.current?(X.current.value=null,X.current.click()):Ie(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))):Ie(ye)});return}X.current&&(ee({type:"openDialog"}),j(),X.current.value=null,X.current.click())},[ee,j,W,v,ct,Ie,M,a]),nn=le.useCallback(function(Y){!z.current||!z.current.isEqualNode(Y.target)||(Y.key===" "||Y.key==="Enter"||Y.keyCode===32||Y.keyCode===13)&&(Y.preventDefault(),Ee())},[z,Ee]),gt=le.useCallback(function(){ee({type:"focus"})},[]),vt=le.useCallback(function(){ee({type:"blur"})},[]),wt=le.useCallback(function(){C||($oe()?setTimeout(Ee,0):Ee())},[C,Ee]),Vt=function(ye){return s?null:ye},It=function(ye){return E?null:Vt(ye)},zt=function(ye){return k?null:Vt(ye)},Gt=function(ye){R&&ye.stopPropagation()},dn=le.useMemo(function(){return function(){var Y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},ye=Y.refKey,Qe=ye===void 0?"ref":ye,tt=Y.role,rt=Y.onKeyDown,Pt=Y.onFocus,pt=Y.onBlur,At=Y.onClick,xe=Y.onDragEnter,xt=Y.onDragOver,Ye=Y.onDragLeave,kt=Y.onDrop,Et=f2(Y,Goe);return di(di(KC({onKeyDown:It(el(rt,nn)),onFocus:It(el(Pt,gt)),onBlur:It(el(pt,vt)),onClick:Vt(el(At,wt)),onDragEnter:zt(el(xe,Xe)),onDragOver:zt(el(xt,Fe)),onDragLeave:zt(el(Ye,Pe)),onDrop:zt(el(kt,at)),role:typeof tt=="string"&&tt!==""?tt:"presentation"},Qe,z),!s&&!E?{tabIndex:0}:{}),Et)}},[z,nn,gt,vt,wt,Xe,Fe,Pe,at,E,k,s]),vn=le.useCallback(function(Y){Y.stopPropagation()},[]),ce=le.useMemo(function(){return function(){var Y=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},ye=Y.refKey,Qe=ye===void 0?"ref":ye,tt=Y.onChange,rt=Y.onClick,Pt=f2(Y,Hoe),pt=KC({accept:T,multiple:a,type:"file",style:{border:0,clip:"rect(0, 0, 0, 0)",clipPath:"inset(50%)",height:"1px",margin:"0 -1px -1px 0",overflow:"hidden",padding:0,position:"absolute",width:"1px",whiteSpace:"nowrap"},onChange:Vt(el(tt,at)),onClick:Vt(el(rt,vn)),tabIndex:-1},Qe,X);return di(di({},pt),Pt)}},[X,t,a,at,s]);return di(di({},K),{},{isFocused:ne&&!s,getRootProps:dn,getInputProps:ce,rootRef:z,inputRef:X,open:Vt(Ee)})}function eae(n,e){switch(e.type){case"focus":return di(di({},n),{},{isFocused:!0});case"blur":return di(di({},n),{},{isFocused:!1});case"openDialog":return di(di({},YC),{},{isFileDialogActive:!0});case"closeDialog":return di(di({},n),{},{isFileDialogActive:!1});case"setDraggedFiles":return di(di({},n),{},{isDragActive:e.isDragActive,isDragAccept:e.isDragAccept,isDragReject:e.isDragReject});case"setFiles":return di(di({},n),{},{acceptedFiles:e.acceptedFiles,fileRejections:e.fileRejections,isDragReject:e.isDragReject});case"reset":return di({},YC);default:return n}}function wP(){}const US=[{name:"Collier 1",path:"collier1.png"},{name:"Collier 2",path:"collier2.png"},{name:"Collier 3",path:"collier3.png"},{name:"Collier 4",path:"collier4.png"}],tae=[{name:"Mannequin 1",src:"/assets/examples/example1.jpeg"},{name:"Mannequin 2",src:"/assets/examples/example2.jpg"}],XO=()=>{const[n,e]=le.useState(null),[t,s]=le.useState(null),[i,r]=le.useState(!1),[o,a]=le.useState(null),[l,c]=le.useState(US[0].path),[u,d]=le.useState("photo"),[h,p]=le.useState(!1);le.useEffect(()=>{const S=()=>{console.log("Vérification de MediaPipe..."),console.log("window.FaceMesh:",window.FaceMesh),typeof window.FaceMesh<"u"?(console.log("MediaPipe FaceMesh chargé avec succès"),p(!0)):(console.log("Attente du chargement de MediaPipe..."),setTimeout(S,500))};setTimeout(S,1e3)},[]);async function g(S){return new Promise((C,E)=>{if(typeof window.FaceMesh>"u"){E(new Error("MediaPipe FaceMesh n'est pas chargé. Veuillez attendre le chargement de la page."));return}try{const k=new window.FaceMesh({locateFile:R=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${R}`});k.setOptions({maxNumFaces:1,refineLandmarks:!0,minDetectionConfidence:.5,minTrackingConfidence:.5}),k.onResults(R=>{if(!R.multiFaceLandmarks||R.multiFaceLandmarks.length===0){E(new Error("Aucun visage détecté."));return}const L=R.multiFaceLandmarks[0],I=L[234],T=L[454],M=L[152];C({left_ear:[I.x*S.width,I.y*S.height],right_ear:[T.x*S.width,T.y*S.height],chin:[M.x*S.width,M.y*S.height]})}),k.send({image:S})}catch(k){console.error("Erreur lors de l'initialisation de FaceMesh:",k),E(new Error("Erreur lors de l'initialisation de MediaPipe FaceMesh"))}})}const y=le.useCallback(S=>{if(S.length>0){const C=new FileReader;C.onload=()=>{e(C.result),s(null),a(null)},C.readAsDataURL(S[0])}},[]),{getRootProps:x,getInputProps:v,isDragActive:b}=jO({onDrop:y,accept:{"image/*":[".jpeg",".jpg",".png"]},multiple:!1});return le.useEffect(()=>{if(u!=="photo"||!n||!h)return;(async()=>{r(!0),a(null);try{let C;const E=new Image;E.src=n,await E.decode();const k=await g(E),R=document.createElement("canvas");R.width=E.width,R.height=E.height;const L=R.getContext("2d");L==null||L.drawImage(E,0,0),C=await new Promise((j,W)=>R.toBlob(z=>{z?j(z):W(new Error("Impossible de générer le blob."))},"image/jpeg"));const I=new FormData;I.append("image",new File([C],"photo.jpg")),I.append("necklace",l),I.append("landmarks",JSON.stringify(k));const T=await fetch("https://br-online.onrender.com/apply-necklace",{method:"POST",body:I});if(!T.ok){const j=await T.json();throw new Error(j.error||"Erreur lors du traitement.")}const M=await T.blob();s(URL.createObjectURL(M))}catch(C){console.error(C),a(C.message||"Erreur lors du traitement.")}finally{r(!1)}})()},[n,l,u,h]),G.jsxs("div",{className:"flex flex-col items-center justify-center min-h-screen p-6 bg-gray-50 relative",children:[!h&&G.jsx("div",{className:"fixed inset-0 bg-black/50 flex items-center justify-center z-50",children:G.jsxs("div",{className:"bg-white rounded-lg p-6 text-center",children:[G.jsx("p",{className:"text-lg font-semibold mb-2",children:"Chargement de MediaPipe..."}),G.jsx("p",{className:"text-gray-600",children:"Veuillez patienter pendant le chargement des modèles."})]})}),G.jsxs("div",{className:"text-center mb-8",children:[G.jsx("h1",{className:"text-4xl font-bold text-gray-800 mb-2",children:"Essayage Virtuel de Colliers"}),G.jsx("p",{className:"text-lg text-gray-600",children:"Choisissez un collier et découvrez comment il vous va"})]}),G.jsx("div",{style:{position:"absolute",top:20,right:20},children:G.jsx("button",{onClick:()=>d("photo"),className:"px-4 py-2 rounded-lg bg-emerald-500 text-white",children:"Photo"})}),u==="photo"&&!n&&G.jsxs(G.Fragment,{children:[G.jsxs("div",{...x(),className:`border-2 border-dashed rounded-xl p-12 cursor-pointer text-center ${b?"border-emerald-400":"border-gray-300"}`,children:[G.jsx("input",{...v()}),G.jsx("p",{children:"Cliquez ou glissez une photo pour essayer un collier virtuellement"})]}),G.jsxs("div",{className:"mt-8 w-full max-w-4xl",children:[G.jsx("h2",{className:"text-2xl font-bold text-center mb-6 text-gray-800",children:"Colliers disponibles"}),G.jsx("div",{className:"grid grid-cols-2 md:grid-cols-4 gap-4",children:US.map(S=>G.jsxs("div",{className:`p-4 rounded-lg border-2 cursor-pointer transition-all ${l===S.path?"border-emerald-500 bg-emerald-50 shadow-lg":"border-gray-300 bg-white hover:border-gray-400 hover:shadow-md"}`,onClick:()=>c(S.path),children:[G.jsx("div",{className:"aspect-square mb-3 bg-gray-100 rounded-lg overflow-hidden",children:G.jsx("img",{src:`/data/usefull_necklace/${S.path}`,alt:S.name,className:"w-full h-full object-contain"})}),G.jsx("p",{className:"text-center font-medium text-gray-700",children:S.name}),l===S.path&&G.jsx("div",{className:"mt-2 text-center",children:G.jsx("span",{className:"inline-block px-2 py-1 bg-emerald-500 text-white text-sm rounded-full",children:"Sélectionné"})})]},S.path))})]})]}),u==="photo"&&G.jsxs("div",{className:"mt-8 w-full max-w-4xl",children:[G.jsx("h2",{className:"text-xl font-semibold text-center mb-4 text-gray-800",children:"Ou essayez avec nos mannequins"}),G.jsx("div",{className:"flex gap-6 justify-center",children:tae.map(S=>G.jsxs("div",{className:"flex flex-col items-center",children:[G.jsxs("div",{className:"relative group cursor-pointer",onClick:()=>{e(S.src),s(null),a(null)},children:[G.jsx("img",{src:S.src,alt:S.name,className:"w-24 h-24 object-cover rounded-lg border-2 border-gray-200 group-hover:border-emerald-400 group-hover:scale-105 transition-all duration-200 shadow-md"}),G.jsx("div",{className:"absolute inset-0 bg-black/0 group-hover:bg-black/10 rounded-lg transition-all duration-200 flex items-center justify-center",children:G.jsx("span",{className:"text-white opacity-0 group-hover:opacity-100 font-semibold text-sm bg-black/50 px-2 py-1 rounded",children:"Essayer"})})]}),G.jsx("span",{className:"mt-2 text-sm font-medium text-gray-700",children:S.name})]},S.name))})]}),u==="photo"&&n&&G.jsxs("div",{className:"relative mt-4 w-full max-w-xl bg-white rounded-xl shadow-lg p-4",children:[G.jsx("img",{src:t||n,alt:"Prévisualisation",className:"w-full rounded-lg border"}),G.jsx("div",{className:"flex gap-2 mt-4 justify-center",children:US.map(S=>G.jsx("button",{onClick:()=>c(S.path),className:`p-1 rounded border-2 ${l===S.path?"border-emerald-500 bg-emerald-50":"border-gray-300 bg-white"}`,children:G.jsx("img",{src:`/data/usefull_necklace/${S.path}`,alt:S.name,className:"w-16 h-16 object-contain rounded"})},S.path))}),i&&G.jsx("div",{className:"absolute inset-0 bg-black/50 flex items-center justify-center",children:G.jsx("p",{className:"text-white",children:"Traitement en cours..."})}),o&&G.jsx("div",{className:"absolute inset-0 bg-black/70 flex items-center justify-center p-4 text-center",children:G.jsx("p",{className:"text-white",children:o})}),G.jsx("button",{onClick:()=>{e(null),s(null),a(null)},className:"absolute top-2 right-2 px-3 py-1 bg-black/70 text-white text-sm rounded",children:"Changer"})]})]})},nae=()=>{const[n,e]=le.useState("photo"),[t,s]=le.useState("femme"),[i,r]=le.useState(1),o=()=>t==="homme"?"/assets/man3.glb":i===1?"/assets/woman2.glb":"/models/modelwoman2.glb";return G.jsx("div",{className:"w-full px-12 py-8",children:G.jsx("div",{className:"w-full rounded-3xl bg-[rgb(20,3,8)] shadow-2xl shadow-black/20 overflow-hidden",children:G.jsxs("div",{className:"flex min-h-[800px]",children:[G.jsxs("div",{className:"w-1/5 border-r border-white/10 p-8",children:[G.jsx("h2",{className:"text-white/90 text-2xl font-display mb-8",children:"Essayage Virtuel"}),G.jsxs("div",{className:"space-y-6 mb-12",children:[G.jsx(wn.button,{whileHover:{scale:1.02,x:5},whileTap:{scale:.98},onClick:()=>e("photo"),className:`w-full px-6 py-4 rounded-xl text-left transition-all duration-300 ${n==="photo"?"bg-[rgb(100,255,162)]/10 border border-[rgb(100,255,162)]/30":"bg-white/5 hover:bg-white/10 border border-white/10"}`,children:G.jsxs("div",{className:"flex items-center space-x-4",children:[G.jsx("div",{className:`w-10 h-10 rounded-lg flex items-center justify-center ${n==="photo"?"bg-[rgb(100,255,162)]/20":"bg-white/5"}`,children:G.jsx("svg",{className:`w-5 h-5 ${n==="photo"?"text-[rgb(100,255,162)]":"text-white/40"}`,fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:1.5,d:"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"})})}),G.jsxs("div",{children:[G.jsx("p",{className:"font-heading text-sm text-white/80",children:"Mode Photo"}),G.jsx("p",{className:"text-xs text-white/40",children:"Essayez avec votre photo"})]})]})}),G.jsx(wn.button,{whileHover:{scale:1.02,x:5},whileTap:{scale:.98},onClick:()=>e("3d"),className:`w-full px-6 py-4 rounded-xl text-left transition-all duration-300 ${n==="3d"?"bg-[rgb(100,255,162)]/10 border border-[rgb(100,255,162)]/30":"bg-white/5 hover:bg-white/10 border border-white/10"}`,children:G.jsxs("div",{className:"flex items-center space-x-4",children:[G.jsx("div",{className:`w-10 h-10 rounded-lg flex items-center justify-center ${n==="3d"?"bg-[rgb(100,255,162)]/20":"bg-white/5"}`,children:G.jsx("svg",{className:`w-5 h-5 ${n==="3d"?"text-[rgb(100,255,162)]":"text-white/40"}`,fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:1.5,d:"M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"})})}),G.jsxs("div",{children:[G.jsx("p",{className:"font-heading text-sm text-white/80",children:"Mode 3D"}),G.jsx("p",{className:"text-xs text-white/40",children:"Visualisation sur modèle"})]})]})})]}),G.jsx(Xv,{children:n==="3d"&&G.jsxs(wn.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},exit:{opacity:0,y:20},className:"mb-12",children:[G.jsx("p",{className:"text-sm text-white/40 mb-4 font-display",children:"Choisir le modèle"}),G.jsxs("div",{className:"flex space-x-4",children:[G.jsx(wn.button,{whileHover:{scale:1.05},whileTap:{scale:.95},onClick:()=>s("homme"),className:`flex-1 py-3 rounded-xl transition-all duration-300 ${t==="homme"?"bg-[rgb(100,255,162)]/10 border border-[rgb(100,255,162)]/30":"bg-white/5 hover:bg-white/10 border border-white/10"}`,children:G.jsx("span",{className:`text-sm font-display ${t==="homme"?"text-white/80":"text-white/40"}`,children:"Pour homme"})}),G.jsx(wn.button,{whileHover:{scale:1.05},whileTap:{scale:.95},onClick:()=>s("femme"),className:`flex-1 py-3 rounded-xl transition-all duration-300 ${t==="femme"?"bg-[rgb(100,255,162)]/10 border border-[rgb(100,255,162)]/30":"bg-white/5 hover:bg-white/10 border border-white/10"}`,children:G.jsx("span",{className:`text-sm font-display ${t==="femme"?"text-white/80":"text-white/40"}`,children:"Pour femme"})})]}),t==="femme"&&G.jsxs(wn.div,{initial:{opacity:0,y:10},animate:{opacity:1,y:0},exit:{opacity:0,y:10},className:"mt-4",children:[G.jsx("p",{className:"text-sm text-white/40 mb-3 font-display",children:"Style"}),G.jsxs("div",{className:"flex space-x-4",children:[G.jsx(wn.button,{whileHover:{scale:1.05},whileTap:{scale:.95},onClick:()=>r(1),className:`flex-1 py-2 rounded-xl transition-all duration-300 ${i===1?"bg-[rgb(100,255,162)]/10 border border-[rgb(100,255,162)]/30":"bg-white/5 hover:bg-white/10 border border-white/10"}`,children:G.jsx("span",{className:`text-sm font-display ${i===1?"text-white/80":"text-white/40"}`,children:"Avatar 1"})}),G.jsx(wn.button,{whileHover:{scale:1.05},whileTap:{scale:.95},onClick:()=>r(2),className:`flex-1 py-2 rounded-xl transition-all duration-300 ${i===2?"bg-[rgb(100,255,162)]/10 border border-[rgb(100,255,162)]/30":"bg-white/5 hover:bg-white/10 border border-white/10"}`,children:G.jsx("span",{className:`text-sm font-display ${i===2?"text-white/80":"text-white/40"}`,children:"Avatar 2"})})]})]})]})})]}),G.jsx("div",{className:"w-4/5 p-8",children:G.jsxs(Xv,{mode:"wait",children:[n==="photo"&&G.jsx(wn.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"w-full h-full",children:G.jsx(XO,{})},"photo"),n==="3d"&&G.jsx(wn.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"w-full h-full",children:G.jsx(toe,{modelPath:o()})},"3d")]})})]})})})};let VS=!1;const sae=()=>{const[n,e]=le.useState(VS?100:0),[t,s]=le.useState("Initialisation...");return le.useEffect(()=>{if(VS){e(100);return}(async()=>{try{s("Chargement des modèles...");const r=setInterval(()=>{e(o=>o>=100?(clearInterval(r),VS=!0,100):o+1)},20);return()=>clearInterval(r)}catch(r){console.error("Erreur lors du préchargement:",r),s("Erreur de chargement des modèles")}})()},[]),G.jsxs(wn.div,{className:"fixed inset-0 z-50 flex items-center justify-center",style:{backgroundColor:"#140308"},initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},children:[G.jsx("div",{className:"absolute inset-0 overflow-hidden opacity-20",children:G.jsx("div",{className:"absolute inset-0",style:{backgroundImage:`url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%2364ffa2' fill-opacity='0.1'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E")`,opacity:.5}})}),G.jsxs("div",{className:"relative z-10 w-full max-w-md px-4",children:[G.jsxs(wn.div,{initial:{scale:.8,opacity:0},animate:{scale:1,opacity:1},transition:{duration:.5},className:"text-center mb-12",children:[G.jsx(wn.h1,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5,delay:.2},className:"font-['TT_Ramillas'] text-4xl sm:text-5xl text-white mb-4",children:"BLEUREFLET"}),G.jsx(wn.p,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{duration:.5,delay:.3},className:"font-['Atyp_Display'] text-xl text-[#64ffa2] tracking-wider",children:"ESSAYAGE VIRTUEL DE COLLIERS"})]}),G.jsxs("div",{className:"relative",children:[G.jsx("div",{className:"h-[2px] w-full bg-white/10 overflow-hidden",children:G.jsx(wn.div,{className:"h-full bg-[#64ffa2]",initial:{width:"0%"},animate:{width:`${n}%`},transition:{duration:.1}})}),G.jsxs("div",{className:"mt-4 flex justify-between items-center",children:[G.jsxs("div",{className:"flex items-baseline gap-1",children:[G.jsx("span",{className:"font-heading text-4xl text-white",children:n}),G.jsx("span",{className:"font-display text-white/60 text-sm",children:"%"})]}),G.jsxs("div",{className:"flex items-center gap-2",children:[G.jsx("div",{className:"w-2 h-2 bg-[#64ffa2] rounded-full animate-pulse"}),G.jsx("span",{className:"font-display text-sm text-white/60",children:t})]})]})]}),G.jsx(wn.div,{initial:{opacity:0,y:20},animate:{opacity:1,y:0},transition:{delay:.5},className:"mt-12 text-center",children:G.jsxs("p",{className:"font-display text-white/40 text-sm",children:[n<33&&"Initialisation du système...",n>=33&&n<66&&"Chargement des modèles...",n>=66&&n<100&&"Configuration finale...",n===100&&"Prêt !"]})})]})]})},iae=()=>{const n=le.useRef(null),e=le.useRef(null),[t,s]=le.useState(!1),[i,r]=le.useState(null),[o,a]=le.useState(null),[l,c]=le.useState(null),[u,d]=le.useState(!1),h=async()=>{try{console.log("Starting camera...");const v=await navigator.mediaDevices.getUserMedia({video:{width:{ideal:1280},height:{ideal:720},facingMode:"user",frameRate:{ideal:30}},audio:!1});n.current&&(n.current.srcObject=v,n.current.onloadedmetadata=()=>{n.current.play().then(()=>{console.log("Video playback started"),s(!0),r(v)}).catch(b=>{console.error("Error starting video playback:",b)})})}catch(v){console.error("Camera error:",v),alert("Impossible d’accéder à la caméra. Vérifiez vos autorisations.")}},p=()=>{console.log("Stopping camera..."),i&&i.getTracks().forEach(v=>{v.stop(),console.log("Track stopped:",v.kind)}),n.current&&(n.current.srcObject=null),s(!1),r(null)},g=()=>{if(!t||!n.current)return;const v=n.current.videoWidth,b=n.current.videoHeight;v&&b&&(e.current.width=v,e.current.height=b,e.current.getContext("2d").drawImage(n.current,0,0,v,b),e.current.toBlob(C=>{if(C){const E=new File([C],"photo.jpg",{type:"image/jpeg"});a(E),console.log("Photo capturée !")}},"image/jpeg"))},y=v=>{v.target.files&&v.target.files[0]&&(a(v.target.files[0]),p())},x=async()=>{if(!o){alert("Veuillez sélectionner ou prendre une photo avant d’envoyer.");return}d(!0),c(null);try{const v=new FormData;v.append("image",o);const b=await fetch("http://localhost:5000/apply-necklace",{method:"POST",body:v});if(!b.ok)throw new Error("Erreur du serveur lors de la réception de la photo traitée.");const S=await b.blob(),C=URL.createObjectURL(S);c(C)}catch(v){console.error("Erreur lors de l’envoi ou la réception de l’image:",v),alert("Une erreur est survenue lors du traitement.")}finally{d(!1)}};return le.useEffect(()=>()=>{p()},[]),G.jsxs(wn.div,{initial:{opacity:0},animate:{opacity:1},className:"min-h-screen bg-white text-black flex flex-col items-center p-4",children:[G.jsx(cd,{to:"/",className:"self-start mb-4 p-2 rounded-full hover:bg-black/5 transition-colors",children:G.jsx("svg",{className:"w-6 h-6 text-black",fill:"none",viewBox:"0 0 24 24",stroke:"currentColor",children:G.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M10 19l-7-7m0 0l7-7m-7 7h18"})})}),G.jsx("h1",{className:"text-2xl font-bold mb-6",children:"TestPage – Essai Collier 2D"}),G.jsxs("div",{className:"w-full max-w-3xl grid grid-cols-1 sm:grid-cols-2 gap-6 mb-6",children:[G.jsxs("div",{className:"flex flex-col items-center gap-4 bg-gray-50 p-4 rounded-md",children:[G.jsx("h2",{className:"font-semibold",children:"Caméra"}),G.jsxs("div",{className:"relative w-full h-48 bg-black overflow-hidden rounded-md flex justify-center items-center",children:[G.jsx("video",{ref:n,className:"absolute top-0 left-0 w-full h-full object-cover",playsInline:!0,muted:!0}),!t&&G.jsx("div",{className:"text-white/60 text-sm",children:"Caméra non activée"})]}),G.jsxs("div",{className:"flex gap-2",children:[t?G.jsx("button",{className:"bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600",onClick:p,children:"Arrêter Caméra"}):G.jsx("button",{className:"bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600",onClick:h,children:"Démarrer Caméra"}),t&&G.jsx("button",{className:"bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600",onClick:g,children:"Prendre une photo"})]})]}),G.jsxs("div",{className:"flex flex-col items-center gap-4 bg-gray-50 p-4 rounded-md",children:[G.jsx("h2",{className:"font-semibold",children:"Téléverser une image"}),G.jsx("input",{type:"file",accept:"image/*",onChange:y,className:"text-sm"}),G.jsxs("p",{className:"text-sm text-gray-500 text-center",children:["Vous pouvez prendre une photo avec la caméra",G.jsx("br",{})," ou choisir un fichier local."]})]})]}),G.jsx("div",{className:"mb-6",children:G.jsx("button",{onClick:x,className:"bg-purple-500 text-white px-6 py-2 rounded hover:bg-purple-600 transition-colors",children:"Envoyer au Backend"})}),u&&G.jsx("div",{className:"relative w-64 h-2 bg-gray-200 rounded mb-6",children:G.jsx("div",{className:"absolute left-0 top-0 h-2 w-1/2 bg-purple-500 animate-pulse"})}),l&&!u&&G.jsxs("div",{children:[G.jsx("h2",{className:"text-lg font-semibold mb-2",children:"Résultat :"}),G.jsx("img",{src:l,alt:"Processed",className:"max-w-xs border border-gray-300 rounded shadow"})]}),G.jsx("canvas",{ref:e,className:"hidden"})]})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rae=1e-7,oae=1e-4;class XE{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class hy{refCount(e){return fo("refCount")}incRef(e){return fo("incRef")}timerAvailable(){return!0}time(e){return fo("time")}read(e){return fo("read")}readSync(e){return fo("readSync")}readToGPU(e,t){return fo("readToGPU")}numDataIds(){return fo("numDataIds")}disposeData(e,t){return fo("disposeData")}write(e,t,s){return fo("write")}move(e,t,s,i,r){return fo("move")}createTensorFromGPUData(e,t,s){return fo("createTensorFromGPUData")}memory(){return fo("memory")}floatPrecision(){return fo("floatPrecision")}epsilon(){return this.floatPrecision()===32?rae:oae}dispose(){return fo("dispose")}}function fo(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aae(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Kh(n,e,t)}function Sd(n,e,t){return Math.max(n,Math.min(e,t))}function qE(n){return n%2===0?n:n+1}function Kh(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function qO(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function re(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function fy(n,e,t=""){re(ds(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function KO(n){re(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Le(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function bP(n){return n.length===0}function ds(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Af(n){return n%1===0}function ZC(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function cf(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function SP(n,e=i=>0,t,s){return new Promise((i,r)=>{let o=0;const a=()=>{if(n()){i();return}o++;const l=e(o);if(t!=null&&o>=t){r();return}s!=null?s(a,l):setTimeout(a,l)};a()})}function KE(n,e){let t=1,s=-1;for(let r=0;r<n.length;++r)if(n[r]>=0)t*=n[r];else if(n[r]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);s=r}else if(n[r]<0)throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[s]=e/t,i}function Hn(n,e){const t=e.length;return n=n==null?e.map((s,i)=>i):[].concat(n),re(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),re(n.every(s=>Af(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function pu(n,e){const t=[],s=[],i=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||i?null:Hn(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(r!=null){if(r[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(r[o]==null||r[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),r[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Qi(n,e){return fi(n,e)}function fi(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function lae(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function cae(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function YE(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function p2(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function uae(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Kf(n){return typeof n=="string"||n instanceof String}function dae(n){return typeof n=="boolean"}function QC(n){return typeof n=="number"}function zd(n){return Array.isArray(n)?zd(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":QC(n)?"float32":Kf(n)?"string":dae(n)?"bool":"float32"}function JC(n){return!!(n&&n.constructor&&n.call&&n.apply)}function e_(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function gn(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function YO(n,e,t,s=!1){const i=new Array;if(e.length===1){const r=e[0]*(s?2:1);for(let o=0;o<r;o++)i[o]=t[n+o]}else{const r=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<r;l++)i[l]=YO(n+l*a,o,t,s)}return i}function Ma(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((i,r)=>i*r)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return YO(0,n,e,t)}function Lv(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function ZE(n,e){const t=dr(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function dr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function ZO(n,e){const t=n.reduce((s,i)=>s*i,1);if(e==null||e==="float32")return Ma(n,new Float32Array(t));if(e==="int32")return Ma(n,new Int32Array(t));if(e==="bool")return Ma(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function gc(n){n.forEach(e=>{re(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function gl(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=t[i]*n[i];return s}function Yf(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/t[i]),n-=s[i]*t[i];return s[s.length-1]=n,s}function QE(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CP="tfjsflags";class hae{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fae,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ze().getBool("IS_TEST")||ze().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const i=this.urlFlags[e];ze().getBool("IS_TEST")||ze().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(QE(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);CP in e&&e[CP].split(",").forEach(s=>{const[i,r]=s.split(":");this.urlFlags[i]=mae(i,r)})}}function fae(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(pae(e,s[0],s[1]),s.join("="))),e}function pae(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function mae(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ze(){return QO}let QO=null;function gae(n){QO=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let WS;function JO(){if(WS==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");WS=n}return WS}function xae(){const n=JO();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function JE(n,e){const t=xae();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const c0="Abs",Zf="Acos",Qf="Acosh",Bd="Add",py="AddN",my="All",gy="Any",u0="ArgMax",d0="ArgMin",Jf="Asin",ep="Asinh",tp="Atan",np="Atanh",sp="Atan2",h0="AvgPool",xy="AvgPoolGrad",f0="AvgPool3D",vy="AvgPool3DGrad",p0="BatchMatMul",m0="BatchToSpaceND",yy="Bincount",eT="BitwiseAnd",vae="BroadcastTo",tT="BroadcastArgs",ip="Cast",rp="Ceil",op="ClipByValue",wy="Complex",g0="ComplexAbs",x0="Concat",v0="Conv2D",by="Conv2DBackpropFilter",y0="Conv2DBackpropInput",w0="Conv3D",Sy="Conv3DBackpropFilterV2",Cy="Conv3DBackpropInputV2",ap="Cos",lp="Cosh",_y="Cumprod",b0="Cumsum",Ey="CropAndResize",Ty="DenseBincount",Iy="DepthToSpace",S0="DepthwiseConv2dNative",ky="DepthwiseConv2dNativeBackpropFilter",Ay="DepthwiseConv2dNativeBackpropInput",nT="Diag",C0="Dilation2D",m2="Dilation2DBackpropInput",g2="Dilation2DBackpropFilter",e5="Draw",cp="RealDiv",Ry="Einsum",up="Elu",My="EluGrad",dp="Erf",_0="Equal",hp="Exp",E0="ExpandDims",fp="Expm1",Ny="FFT",Py="Fill",Dy="FlipLeftRight",pp="Floor",mp="FloorDiv",T0="FusedBatchNorm",I0="GatherV2",sT="GatherNd",k0="Greater",gp="GreaterEqual",xp="Identity",Ly="IFFT",$y="Imag",vp="IsFinite",yp="IsInf",wp="IsNan",A0="LeakyRelu",R0="Less",M0="LessEqual",iT="LinSpace",bp="Log",Sp="Log1p",N0="LogicalAnd",P0="LogicalNot",D0="LogicalOr",yae="LogSoftmax",L0="LRN",Fy="LRNGrad",$0="Max",Cp="Maximum",F0="MaxPool",Oy="MaxPoolGrad",O0="MaxPool3D",zy="MaxPool3DGrad",rT="MaxPoolWithArgmax",z0="Mean",B0="Min",_p="Minimum",U0="MirrorPad",Ep="Mod",oT="Multinomial",Tp="Multiply",V0="Neg",W0="NotEqual",By="NonMaxSuppressionV3",aT="NonMaxSuppressionV4",Uy="NonMaxSuppressionV5",G0="OnesLike",H0="OneHot",j0="Pack",X0="PadV2",Ip="Pow",q0="Prelu",K0="Prod",t5="RaggedGather",n5="RaggedRange",s5="RaggedTensorToTensor",Vy="Range",Wy="Real",kp="Reciprocal",Ap="Relu",Y0="Reshape",Z0="ResizeNearestNeighbor",Gy="ResizeNearestNeighborGrad",Q0="ResizeBilinear",Hy="ResizeBilinearGrad",Rp="Relu6",J0="Reverse",Mp="Round",Np="Rsqrt",lT="ScatterNd",cT="TensorScatterUpdate",uT="SearchSorted",e1="Select",Pp="Selu",t1="Slice",Dp="Sin",Lp="Sinh",$p="Sign",Fp="Sigmoid",Op="Softplus",zp="Sqrt",n1="Sum",s1="SpaceToBatchND",i1="SplitV",r1="Softmax",i5="SparseFillEmptyRows",r5="SparseReshape",dT="SparseSegmentMean",hT="SparseSegmentSum",fT="SparseToDense",Bp="SquaredDifference",jy="Square",pT="StaticRegexReplace",Xy="StridedSlice",mT="StringNGrams",o5="StringSplit",a5="StringToHashBucketFast",Up="Sub",Vp="Tan",Wp="Tanh",Gp="Tile",qy="TopK",Ky="Transform",fd="Transpose",gT="Unique",o1="Unpack",a1="UnsortedSegmentSum",l1="ZerosLike",Hp="Step",l5="FromPixels",Yy="RotateWithOffset",Dg="_FusedMatMul",Lg="FusedConv2D",xT="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ro(...n){ze().getBool("IS_TEST")||ze().getBool("PROD")||console.warn(...n)}function wae(...n){ze().getBool("IS_TEST")||ze().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x2=JE("kernelRegistry",()=>new Map),t_=JE("gradRegistry",()=>new Map);function _P(n,e){const t=c5(n,e);return x2.get(t)}function EP(n){return t_.get(n)}function TP(n){const e=x2.entries(),t=[];for(;;){const{done:s,value:i}=e.next();if(s)break;const[r,o]=i,[a]=r.split("_");a===n&&t.push(o)}return t}function vT(n){const{kernelName:e,backendName:t}=n,s=c5(e,t);x2.has(s)&&Ro(`The kernel '${e}' for backend '${t}' is already registered`),x2.set(s,n)}function bae(n){const{kernelName:e}=n;t_.has(e)&&ze().getBool("DEBUG")&&Ro(`Overriding the gradient for '${e}'`),t_.set(e,n)}function c5(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u5(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var GS,IP;function Sae(){if(IP)return GS;IP=1,GS=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(T,M,j){this.low=T|0,this.high=M|0,this.unsigned=!!j}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(T){return(T&&T.__isLong__)===!0}e.isLong=t;var s={},i={};function r(T,M){var j,W,z;return M?(T>>>=0,(z=0<=T&&T<256)&&(W=i[T],W)?W:(j=a(T,(T|0)<0?-1:0,!0),z&&(i[T]=j),j)):(T|=0,(z=-128<=T&&T<128)&&(W=s[T],W)?W:(j=a(T,T<0?-1:0,!1),z&&(s[T]=j),j))}e.fromInt=r;function o(T,M){if(isNaN(T))return M?b:v;if(M){if(T<0)return b;if(T>=g)return R}else{if(T<=-y)return L;if(T+1>=y)return k}return T<0?o(-T,M).neg():a(T%p|0,T/p|0,M)}e.fromNumber=o;function a(T,M,j){return new e(T,M,j)}e.fromBits=a;var l=Math.pow;function c(T,M,j){if(T.length===0)throw Error("empty string");if(T==="NaN"||T==="Infinity"||T==="+Infinity"||T==="-Infinity")return v;if(typeof M=="number"?(j=M,M=!1):M=!!M,j=j||10,j<2||36<j)throw RangeError("radix");var W;if((W=T.indexOf("-"))>0)throw Error("interior hyphen");if(W===0)return c(T.substring(1),M,j).neg();for(var z=o(l(j,8)),X=v,B=0;B<T.length;B+=8){var J=Math.min(8,T.length-B),K=parseInt(T.substring(B,B+J),j);if(J<8){var ee=o(l(j,J));X=X.mul(ee).add(o(K))}else X=X.mul(z),X=X.add(o(K))}return X.unsigned=M,X}e.fromString=c;function u(T,M){return typeof T=="number"?o(T,M):typeof T=="string"?c(T,M):a(T.low,T.high,typeof M=="boolean"?M:T.unsigned)}e.fromValue=u;var d=65536,h=1<<24,p=d*d,g=p*p,y=g/2,x=r(h),v=r(0);e.ZERO=v;var b=r(0,!0);e.UZERO=b;var S=r(1);e.ONE=S;var C=r(1,!0);e.UONE=C;var E=r(-1);e.NEG_ONE=E;var k=a(-1,2147483647,!1);e.MAX_VALUE=k;var R=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=R;var L=a(0,-2147483648,!1);e.MIN_VALUE=L;var I=e.prototype;return I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},I.toString=function(M){if(M=M||10,M<2||36<M)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(L)){var j=o(M),W=this.div(j),z=W.mul(j).sub(this);return W.toString(M)+z.toInt().toString(M)}else return"-"+this.neg().toString(M);for(var X=o(l(M,6),this.unsigned),B=this,J="";;){var K=B.div(X),ee=B.sub(K.mul(X)).toInt()>>>0,ne=ee.toString(M);if(B=K,B.isZero())return ne+J;for(;ne.length<6;)ne="0"+ne;J=""+ne+J}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(L)?64:this.neg().getNumBitsAbs();for(var M=this.high!=0?this.high:this.low,j=31;j>0&&(M&1<<j)==0;j--);return this.high!=0?j+33:j+1},I.isZero=function(){return this.high===0&&this.low===0},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return(this.low&1)===1},I.isEven=function(){return(this.low&1)===0},I.equals=function(M){return t(M)||(M=u(M)),this.unsigned!==M.unsigned&&this.high>>>31===1&&M.high>>>31===1?!1:this.high===M.high&&this.low===M.low},I.eq=I.equals,I.notEquals=function(M){return!this.eq(M)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(M){return this.comp(M)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(M){return this.comp(M)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(M){return this.comp(M)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(M){return this.comp(M)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(M){if(t(M)||(M=u(M)),this.eq(M))return 0;var j=this.isNegative(),W=M.isNegative();return j&&!W?-1:!j&&W?1:this.unsigned?M.high>>>0>this.high>>>0||M.high===this.high&&M.low>>>0>this.low>>>0?-1:1:this.sub(M).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(L)?L:this.not().add(S)},I.neg=I.negate,I.add=function(M){t(M)||(M=u(M));var j=this.high>>>16,W=this.high&65535,z=this.low>>>16,X=this.low&65535,B=M.high>>>16,J=M.high&65535,K=M.low>>>16,ee=M.low&65535,ne=0,V=0,Z=0,he=0;return he+=X+ee,Z+=he>>>16,he&=65535,Z+=z+K,V+=Z>>>16,Z&=65535,V+=W+J,ne+=V>>>16,V&=65535,ne+=j+B,ne&=65535,a(Z<<16|he,ne<<16|V,this.unsigned)},I.subtract=function(M){return t(M)||(M=u(M)),this.add(M.neg())},I.sub=I.subtract,I.multiply=function(M){if(this.isZero())return v;if(t(M)||(M=u(M)),n){var j=n.mul(this.low,this.high,M.low,M.high);return a(j,n.get_high(),this.unsigned)}if(M.isZero())return v;if(this.eq(L))return M.isOdd()?L:v;if(M.eq(L))return this.isOdd()?L:v;if(this.isNegative())return M.isNegative()?this.neg().mul(M.neg()):this.neg().mul(M).neg();if(M.isNegative())return this.mul(M.neg()).neg();if(this.lt(x)&&M.lt(x))return o(this.toNumber()*M.toNumber(),this.unsigned);var W=this.high>>>16,z=this.high&65535,X=this.low>>>16,B=this.low&65535,J=M.high>>>16,K=M.high&65535,ee=M.low>>>16,ne=M.low&65535,V=0,Z=0,he=0,ve=0;return ve+=B*ne,he+=ve>>>16,ve&=65535,he+=X*ne,Z+=he>>>16,he&=65535,he+=B*ee,Z+=he>>>16,he&=65535,Z+=z*ne,V+=Z>>>16,Z&=65535,Z+=X*ee,V+=Z>>>16,Z&=65535,Z+=B*K,V+=Z>>>16,Z&=65535,V+=W*ne+z*ee+X*K+B*J,V&=65535,a(he<<16|ve,V<<16|Z,this.unsigned)},I.mul=I.multiply,I.divide=function(M){if(t(M)||(M=u(M)),M.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&M.low===-1&&M.high===-1)return this;var j=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,M.low,M.high);return a(j,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?b:v;var W,z,X;if(this.unsigned){if(M.unsigned||(M=M.toUnsigned()),M.gt(this))return b;if(M.gt(this.shru(1)))return C;X=b}else{if(this.eq(L)){if(M.eq(S)||M.eq(E))return L;if(M.eq(L))return S;var B=this.shr(1);return W=B.div(M).shl(1),W.eq(v)?M.isNegative()?S:E:(z=this.sub(M.mul(W)),X=W.add(z.div(M)),X)}else if(M.eq(L))return this.unsigned?b:v;if(this.isNegative())return M.isNegative()?this.neg().div(M.neg()):this.neg().div(M).neg();if(M.isNegative())return this.div(M.neg()).neg();X=v}for(z=this;z.gte(M);){W=Math.max(1,Math.floor(z.toNumber()/M.toNumber()));for(var J=Math.ceil(Math.log(W)/Math.LN2),K=J<=48?1:l(2,J-48),ee=o(W),ne=ee.mul(M);ne.isNegative()||ne.gt(z);)W-=K,ee=o(W,this.unsigned),ne=ee.mul(M);ee.isZero()&&(ee=S),X=X.add(ee),z=z.sub(ne)}return X},I.div=I.divide,I.modulo=function(M){if(t(M)||(M=u(M)),n){var j=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,M.low,M.high);return a(j,n.get_high(),this.unsigned)}return this.sub(this.div(M).mul(M))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return a(~this.low,~this.high,this.unsigned)},I.and=function(M){return t(M)||(M=u(M)),a(this.low&M.low,this.high&M.high,this.unsigned)},I.or=function(M){return t(M)||(M=u(M)),a(this.low|M.low,this.high|M.high,this.unsigned)},I.xor=function(M){return t(M)||(M=u(M)),a(this.low^M.low,this.high^M.high,this.unsigned)},I.shiftLeft=function(M){return t(M)&&(M=M.toInt()),(M&=63)===0?this:M<32?a(this.low<<M,this.high<<M|this.low>>>32-M,this.unsigned):a(0,this.low<<M-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(M){return t(M)&&(M=M.toInt()),(M&=63)===0?this:M<32?a(this.low>>>M|this.high<<32-M,this.high>>M,this.unsigned):a(this.high>>M-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(M){if(t(M)&&(M=M.toInt()),M&=63,M===0)return this;var j=this.high;if(M<32){var W=this.low;return a(W>>>M|j<<32-M,j>>>M,this.unsigned)}else return M===32?a(j,0,this.unsigned):a(j>>>M-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},I.toBytes=function(M){return M?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var M=this.high,j=this.low;return[j&255,j>>>8&255,j>>>16&255,j>>>24,M&255,M>>>8&255,M>>>16&255,M>>>24]},I.toBytesBE=function(){var M=this.high,j=this.low;return[M>>>24,M>>>16&255,M>>>8&255,M&255,j>>>24,j>>>16&255,j>>>8&255,j&255]},e.fromBytes=function(M,j,W){return W?e.fromBytesLE(M,j):e.fromBytesBE(M,j)},e.fromBytesLE=function(M,j){return new e(M[0]|M[1]<<8|M[2]<<16|M[3]<<24,M[4]|M[5]<<8|M[6]<<16|M[7]<<24,j)},e.fromBytesBE=function(M,j){return new e(M[4]<<24|M[5]<<16|M[6]<<8|M[7],M[0]<<24|M[1]<<16|M[2]<<8|M[3],j)},GS}var d5=Sae();const h5=Zg(d5),Cae=x9({__proto__:null,default:h5},[d5]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ed=h5||Cae;function Zy(n){return ed.fromString(n,!0,16)}const f5=Zy("c3a5c85c97cb3127"),qu=Zy("b492b66fbe98f273"),Pr=Zy("9ae16a3b2f90404f");function n_(n){return n.xor(n.shru(47))}function p5(n,e,t){const s=n.slice(e,e+t);return ed.fromBytes(Array.from(s),!0,!0)}function js(n,e){return p5(n,e,8)}function kP(n,e){return p5(n,e,4)}function qi(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function tu(n,e,t=Zy("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let i=e.xor(s).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function _ae(n,e,t,s,i,r){i=i.add(n),r=qi(r.add(i).add(s),21);const o=i;return i=i.add(e),i=i.add(t),r=r.add(qi(i,44)),[i.add(s),r.add(o)]}function hv(n,e,t,s){return _ae(js(n,e),js(n,e+8),js(n,e+16),js(n,e+24),t,s)}function Eae(n,e=n.length){if(e>=8){const t=Pr.add(e*2),s=js(n,0).add(Pr),i=js(n,e-8),r=qi(i,37).mul(t).add(s),o=qi(s,25).add(i).mul(t);return tu(r,o,t)}if(e>=4){const t=Pr.add(e*2),s=kP(n,0);return tu(s.shl(3).add(e),kP(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],i=n[e-1],r=t+(s<<8),o=e+(i<<2);return n_(Pr.mul(r).xor(f5.mul(o))).mul(Pr)}return Pr}function Tae(n,e=n.length){const t=Pr.add(e*2),s=js(n,0).mul(qu),i=js(n,8),r=js(n,e-8).mul(t),o=js(n,e-16).mul(Pr);return tu(qi(s.add(i),43).add(qi(r,30)).add(o),s.add(qi(i.add(Pr),18)).add(r),t)}function Iae(n,e=n.length){const t=Pr.add(e*2),s=js(n,0).mul(Pr),i=js(n,8),r=js(n,e-8).mul(t),o=js(n,e-16).mul(Pr),a=qi(s.add(i),43).add(qi(r,30)).add(o),l=tu(a,s.add(qi(i.add(Pr),18)).add(r),t),c=js(n,16).mul(t),u=js(n,24),d=a.add(js(n,e-32)).mul(t),h=l.add(js(n,e-24)).mul(t);return tu(qi(c.add(u),43).add(qi(d,30)).add(h),c.add(qi(u.add(s),18)).add(d),t)}function kae(n,e=n.length){const t=ed.fromNumber(81,!0);if(e<=32)return e<=16?Eae(n,e):Tae(n,e);if(e<=64)return Iae(n,e);let s=t,i=t.mul(qu).add(113),r=n_(i.mul(Pr).add(113)).mul(Pr),o=[ed.UZERO,ed.UZERO],a=[ed.UZERO,ed.UZERO];s=s.mul(Pr).add(js(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do s=qi(s.add(i).add(o[0]).add(js(n,l+8)),37).mul(qu),i=qi(i.add(o[1]).add(js(n,l+48)),42).mul(qu),s=s.xor(a[1]),i=i.add(o[0]).add(js(n,l+40)),r=qi(r.add(a[0]),33).mul(qu),o=hv(n,l,o[1].mul(qu),s.add(a[0])),a=hv(n,l+32,r.add(a[1]),i.add(js(n,l+16))),[r,s]=[s,r],l+=64;while(l!==c);const d=qu.add(r.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=qi(s.add(i).add(o[0]).add(js(n,l+8)),37).mul(d),i=qi(i.add(o[1]).add(js(n,l+48)),42).mul(d),s=s.xor(a[1].mul(9)),i=i.add(o[0].mul(9).add(js(n,l+40))),r=qi(r.add(a[0]),33).mul(d),o=hv(n,l,o[1].mul(d),s.add(a[0])),a=hv(n,l+32,r.add(a[1]),i.add(js(n,l+16))),[r,s]=[s,r],tu(tu(o[0],a[0],d).add(n_(i).mul(f5)).add(r),tu(o[1],a[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(n,e){return e==="string"?ac(n):Ud([n],e)}function Aae(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Ud(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=hc(n)),ze().getBool("DEBUG")&&lae(n,e),Aae(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Gr(){return ze().platform.now()}function ac(n,e="utf-8"){return e=e||"utf-8",ze().platform.encode(n,e)}function $a(n,e="utf-8"){return e=e||"utf-8",ze().platform.decode(n,e)}function oa(n){return ze().platform.isTypedArray!=null?ze().platform.isTypedArray(n):u5(n)}function hc(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||QE(n)||n==null||oa(n)&&t)e.push(n);else if(Array.isArray(n)||oa(n))for(let s=0;s<n.length;++s)hc(n[s],e,t);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)hc(n[i],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rae{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Nae)}profileKernel(e,t,s){let i;const r=()=>{i=s()};let o;const a=Gr();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(r);else{r();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:Gr()-a})}if(ze().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const u=i[c];u.data().then(d=>{Mae(d,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:i,inputs:r,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],r,l[2])})})}}function Mae(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class Nae{logKernelProfile(e,t,s,i,r,o){const a=typeof i=="number"?cf(`${i}ms`,9):i.error,l=cf(e,25),c=t.rank,u=t.size,d=cf(t.shape.toString(),14);let h="";for(const p in r){const g=r[p];if(g!=null){const y=g.shape||t.shape,x=y.length;h+=`${p}: ${x}D ${x>0?y:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${d}	%c${u}	%c${h}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pae(n,e,t){const s={},i={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const d in u){const h=u[d];let p=!1;for(let g=0;g<e.length;g++)if(s[h.id]){c.outputs.forEach(y=>s[y.id]=!0),p=!0,i[c.id]=!0;break}if(p)break}}const r={};r[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(r[c.outputs[d].id]){for(const h in u)r[u[h].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&o[c.id]){const u={};for(const h in c.inputs){const p=c.inputs[h];s[p.id]&&(u[h]=p)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,a.push(d)}}return a}function Dae(n,e,t,s){for(let i=e.length-1;i>=0;i--){const r=e[i],o=[];if(r.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const a=r.gradient(o);for(const l in r.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=r.inputs[l];if(!ds(c.shape,u.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const d=n[u.id];n[u.id]=s(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AP=20,Km=3,HS=7;function Lae(n,e,t,s){const i=gn(e),r=$ae(n,e,t,i),o=e.length,a=$v(n,e,t,i,r),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function $ae(n,e,t,s){const i=Le(e),r=s[s.length-1],o=new Array(r).fill(0),a=e.length,l=t==="complex64"?ig(n):n;if(a>1)for(let c=0;c<i/r;c++){const u=c*r;for(let d=0;d<r;d++)o[d]=Math.max(o[d],sg(l[u+d],0,t).length)}return o}function sg(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(HS))} + ${parseFloat(n[1].toFixed(HS))}j`:Kf(n)?s=`'${n}'`:t==="bool"?s=m5(n):s=parseFloat(n.toFixed(HS)).toString(),cf(s,e)}function m5(n){return n===0?"false":"true"}function $v(n,e,t,s,i,r=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const y=ig(n);return[sg(y[0],0,t)]}return t==="bool"?[m5(n[0])]:[n[0].toString()]}if(l===1){if(a>AP){const x=Km*o;let v=Array.from(n.slice(0,x)),b=Array.from(n.slice((a-Km)*o,a*o));return t==="complex64"&&(v=ig(v),b=ig(b)),["["+v.map((S,C)=>sg(S,i[C],t)).join(", ")+", ..., "+b.map((S,C)=>sg(S,i[a-Km+C],t)).join(", ")+"]"]}return["["+(t==="complex64"?ig(n):Array.from(n)).map((x,v)=>sg(x,i[v],t)).join(", ")+"]"]}const c=e.slice(1),u=s.slice(1),d=s[0]*o,h=[];if(a>AP){for(let y=0;y<Km;y++){const x=y*d,v=x+d;h.push(...$v(n.slice(x,v),c,t,u,i,!1))}h.push("...");for(let y=a-Km;y<a;y++){const x=y*d,v=x+d;h.push(...$v(n.slice(x,v),c,t,u,i,y===a-1))}}else for(let y=0;y<a;y++){const x=y*d,v=x+d;h.push(...$v(n.slice(x,v),c,t,u,i,y===a-1))}const p=l===2?",":"";h[0]="["+(a>0?h[0]+p:"");for(let y=1;y<h.length-1;y++)h[y]=" "+h[y]+p;let g=`,
`;for(let y=2;y<l;y++)g+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(r?"":g),h}function ig(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ur{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Le(e),s!=null){const i=s.length;re(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||fi(t,this.size),this.strides=gn(e)}set(e,...t){t.length===0&&(t=[0]),re(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let s=e[e.length-1];for(let i=0;i<e.length-1;++i)s+=this.strides[i]*e[i];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ea().makeTensor(this.values,this.shape,this.dtype)}}let Ea=null,Yh=null;function Fae(n){Ea=n}function Oae(n){Yh=n}class Fi{constructor(e,t,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Le(e),this.strides=gn(e),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Yh.buffer(this.shape,this.dtype,e)}bufferSync(){return Yh.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Ma(this.shape,e,this.dtype==="complex64")}arraySync(){return Ma(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ea().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>$a(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ea().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ea().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>$a(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ea().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ea().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Yh.print(this,e)}clone(){return this.throwIfDisposed(),Yh.clone(this)}toString(e=!1){const t=this.dataSync();return Lae(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Yh.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Ea().makeVariable(this,e,t,s)}}Object.defineProperty(Fi,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function it(){return JE("Tensor",()=>Fi)}it();class v2 extends Fi{constructor(e,t,s,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ds(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ea().disposeTensor(this),this.dataId=e.dataId,Ea().incRef(this,null)}dispose(){Ea().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(v2,Symbol.hasInstance,{value:n=>n instanceof Fi&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var RP;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(RP||(RP={}));var s_;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(s_||(s_={}));var i_;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(i_||(i_={}));var r_;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(r_||(r_={}));var o_;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(o_||(o_={}));const zae={float32:r_,int32:s_,bool:i_,complex64:o_};function Ji(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return zae[n][e]}function Qy(n){return Ji(n,"int32")}function g5(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function x5(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bi(n,e){if(n.dtype===e.dtype)return[n,e];const t=Ji(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function v5(n){const e=[];return y5(n,e,new Set),e}function y5(n,e,t){if(n==null)return;if(n instanceof Fi){e.push(n);return}if(!Bae(n))return;const s=n;for(const i in s){const r=s[i];t.has(r)||(t.add(r),y5(r,e,t))}}function Bae(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(n){return n.kernelName!=null}class MP{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Rf{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new MP}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Ro(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Rae(this.backendInstance),!0}setupRegisteredKernels(){TP(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){TP(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof hy)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Ro(`Initialization of backend ${e} failed`),Ro(o.stack||o.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Ro(`Initialization of backend ${e} failed`),Ro(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),i=s.backend,r=this.readSync(t),o=i.refCount(t);i.disposeData(t,!0),s.backend=e,e.move(t,r,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,s){e();try{const i=s();return t(),i}catch(i){throw t(),i}}nextTensorId(){return Rf.nextTensorId++}nextVariableId(){return Rf.nextVariableId++}clone(e){const t=Re.runKernel(xp,{x:e}),s={x:e},i=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return Re.runKernel(ip,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[t],i,r,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(_P(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const i=this.backend.numDataIds();let r=0;s.forEach(l=>{r+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-t-r-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const i=this.isTapeOn(),r=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=jS(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(jS(e)){const{kernelName:g,inputs:y,attrs:x}=e;this.backendName==null&&this.backend;const v=_P(g,this.backendName);re(v!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=v.kernelFunc({inputs:y,attrs:x,backend:this.backend});const S=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,b,S);const C=S.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(i){const E=this.getTensorsForGradient(g,y,C);s=this.saveTensorsForBackwardMode(E)}return C}}else{const{forwardFunc:g}=e,y=x=>{i&&(s=x.map(v=>this.keep(this.clone(v))))};a=()=>{const x=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,y));const v=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,x,v),v}}const{inputs:u,attrs:d}=e,h=jS(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),i&&this.addTapeNode(c,u,t,h,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(g=>u[g]!=null?u[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const i=EP(e);if(i!=null){const r=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(re(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=r.map(c=>t[c]);const l=s.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,s,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=e;s==="string"&&Kf(e[0])&&(r=e.map(l=>ac(l)));const o=i.write(r,t,s),a=new Fi(t,s,o,this.nextTensorId());if(this.trackTensor(a,i),s==="string"){const l=this.state.tensorInfo.get(o),c=uae(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,s,i){s=s||"float32";const r={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:i,dtype:r}=e,o=new Fi(i,r,s,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const r=new v2(e,t,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*p2(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof v2||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*p2(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,i,r,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:r},l=EP(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=c=>(c=c.map((u,d)=>{if(u==null){const h=s[d],p=dr(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return u}),i(c.length>1?c:c[0],r,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=v5(e),s=new Set(t.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const o=this.state.activeScope.track[r];!o.kept&&!s.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(e,t,s,i=!1){if(re(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));re(r instanceof Fi,()=>"The result y returned by f() must be a tensor.");const o=Pae(this.state.activeTape,t,r);if(!i&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[r.id]=s??Uae(r.shape),Dae(a,o,c=>this.tidy(c),Vae);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(e){return re(JC(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{re(t.every(a=>a instanceof Fi),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};t.forEach((a,l)=>{i[l]=a});const r=(a,l)=>(s=e(...t,l),re(s.value instanceof Fi,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),re(JC(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),u=Array.isArray(c)?c:[c];re(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),re(u.every(h=>h instanceof Fi),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return u.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:r,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Gr(),s=await this.backend.time(e);return s.wallMs=Gr()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new MP;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Rf.nextTensorId=0;Rf.nextVariableId=0;function Uae(n){const e=ZE(Le(n),"float32");return Re.makeTensor(e,n,"float32")}function w5(){const n=JO();if(n._tfengine==null){const e=new hae(n);n._tfengine=new Rf(e)}return gae(n._tfengine.ENV),Fae(()=>n._tfengine),n._tfengine}const Re=w5();function Vae(n,e){const t={a:n,b:e};return Re.runKernel(Bd,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wae(){return typeof navigator<"u"&&navigator!=null}function b5(n){if(n||Wae()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function S5(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jr=ze();Jr.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Jr.registerFlag("IS_BROWSER",()=>S5());Jr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Jr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Jr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Jr.registerFlag("PROD",()=>!1);Jr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Jr.getBool("DEBUG"));Jr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Jr.registerFlag("IS_TEST",()=>!1);Jr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Jr.getBool("DEBUG"));Jr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Jr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Jr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n,e){let t=n;if(oa(n))return e==="string"?[]:[n.length];if(g5(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(x5(n))return[n.buffer.size/(e==null?4:p2(e))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||oa(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ze().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&C5(n,s,[]),s}function C5(n,e,t){if(t=t||[],!Array.isArray(n)&&!oa(n)){re(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}re(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),re(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let i=0;i<n.length;++i)C5(n[i],s,t.concat(i))}function NP(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function ge(n,e,t,s="numeric"){if(n instanceof it())return NP(s,n.dtype,e,t),n;let i=zd(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),NP(s,i,e,t),n==null||!oa(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const r=Jy(n,i);!oa(n)&&!Array.isArray(n)&&(n=[n]);const a=i!=="string"?Ud(n,i):hc(n,[],!0);return Re.makeTensor(a,r,i)}function _5(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((r,o)=>ge(r,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gae="__op";function $e(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Gae;const i=(...r)=>{Re.startScope(t);try{const o=s(...r);return QE(o)&&console.error("Cannot return a Promise inside of tidy."),Re.endScope(o),o}catch(o){throw Re.endScope(null),o}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hae(n,e){const t=ge(n,"real","complex"),s=ge(e,"imag","complex");fy(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:t,imag:s};return Re.runKernel(wy,i)}const Mf=$e({complex_:Hae});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(n,e,t,s){if(s==null)s=zd(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(x5(n)||g5(n)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Re.backend.createTensorFromGPUData(n,e||t,s)}if(!oa(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){gc(e);const i=Le(e),r=Le(t);re(i===r,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${r}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Le(e.slice(o)):!0;re(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!oa(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Ud(n,s):hc(n,[],!0),Re.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5(n,e,t){const s=Jy(n,t);return ew(n,e,s,t)}class jp{static join(e){return new jp(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>oa(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let s=0;s<e.length;s++){const i=e[s];s!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+i.byteLength;this.shards.push({buffer:i,start:t,end:r}),t=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,r=new ArrayBuffer(i),o=new Uint8Array(r);let a=0;for(let l=s;l<this.shards.length;l++){const c=this.shards[l],d=e+a-c.start,h=a,g=Math.min(t,c.end)-c.start,y=new Uint8Array(c.buffer,d,g-d);if(o.set(y,h),a+=y.length,t<c.end)break}return r}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=jae(this.shards,t);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function jae(n,e){let t=0,s=n.length;for(;t<=s;){const i=Math.floor((s-t)/2)+t,r=e(n[i]);if(r===0)return i;r<0?s=i:t=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ao(){return Re}function PP(){return Re.memory()}function je(n,e){return Re.tidy(n,e)}function os(n){v5(n).forEach(t=>t.dispose())}function xl(n){return Re.keep(n)}function Fv(n){return Re.setBackend(n)}function a_(){return Re.ready()}function Xae(n){return Re.findBackend(n)}function yT(n,e,t=1){return Re.registerBackend(n,e,t)}function qae(){return Re.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DP=4;async function LP(n,e){const t=[],s=[],i=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<i.length;++o){const a=i[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async d=>{const h=await l.bytes(),p=h.reduce((x,v)=>x+v.length,0)+DP*h.length,g=new Uint8Array(p);let y=0;for(let x=0;x<h.length;x++){const v=h[x],b=new Uint8Array(new Uint32Array([v.length]).buffer);g.set(b,y),y+=DP,g.set(v,y),y+=v.length}d(g)});s.push(u)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const r=await Promise.all(s);return{data:Kae(r),specs:t}}function Kae(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(r=>{if(e+=r.byteLength,t.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(e);let i=0;return t.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const wT=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function $P(n){return wT?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Yae(n){if(wT)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function Zae(n){if(wT){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function Qae(n){return jp.join(n)}function T5(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:$P(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:$P(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new jp(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Mr.instance==null&&(Mr.instance=new Mr),Mr.instance}static registerSaveRouter(e){Mr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Mr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Mr.getHandlers(e,"save")}static getLoadHandlers(e,t){return Mr.getHandlers(e,"load",t)}static getHandlers(e,t,s){const i=[];return(t==="load"?Mr.getInstance().loadRouters:Mr.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&i.push(a)}),i}}const Jae=n=>Mr.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l_="tensorflowjs",c_=1,od="models_store",Kc="model_info_store";function I5(){if(!ze().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function u_(n){const e=n.result;e.createObjectStore(od,{keyPath:"modelPath"}),e.createObjectStore(Kc,{keyPath:"modelPath"})}class Cd{constructor(e){if(this.indexedDB=I5(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,i)=>{const r=this.indexedDB.open(l_,c_);r.onupgradeneeded=()=>u_(r),r.onsuccess=()=>{const o=r.result;if(t==null){const a=o.transaction(od,"readonly"),c=a.objectStore(od).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=u=>(o.close(),i(c.error)),a.oncomplete=()=>o.close()}else{t.weightData=jp.join(t.weightData);const a=T5(t),l=o.transaction(Kc,"readwrite");let c=l.objectStore(Kc),u;try{u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(h){return i(h)}let d;u.onsuccess=()=>{d=o.transaction(od,"readwrite");const h=d.objectStore(od);let p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(g){return i(g)}p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=g=>{c=l.objectStore(Kc);const y=c.delete(this.modelPath);y.onsuccess=()=>(o.close(),i(p.error)),y.onerror=x=>(o.close(),i(p.error))}},u.onerror=h=>(o.close(),i(u.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},r.onerror=o=>i(r.error)})}}Cd.URL_SCHEME="indexeddb://";const k5=n=>ze().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Cd.URL_SCHEME)?ele(n.slice(Cd.URL_SCHEME.length)):null;Mr.registerSaveRouter(k5);Mr.registerLoadRouter(k5);function ele(n){return new Cd(n)}function tle(n){return n.startsWith(Cd.URL_SCHEME)?n.slice(Cd.URL_SCHEME.length):n}class nle{constructor(){this.indexedDB=I5()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(l_,c_);s.onupgradeneeded=()=>u_(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(Kc,"readonly"),a=r.objectStore(Kc).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(i.close(),t(a.error)),r.oncomplete=()=>i.close()},s.onerror=i=>t(s.error)})}async removeModel(e){return e=tle(e),new Promise((t,s)=>{const i=this.indexedDB.open(l_,c_);i.onupgradeneeded=()=>u_(i),i.onsuccess=()=>{const r=i.result,o=r.transaction(Kc,"readwrite"),a=o.objectStore(Kc),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),d=()=>{c=r.transaction(od,"readwrite");const p=c.objectStore(od).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=g=>s(l.error)};u.onsuccess=d,u.onerror=h=>(d(),r.close(),s(l.error))}},l.onerror=u=>(r.close(),s(l.error)),o.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nc="/",Zh="tensorflowjs_models",A5="info",sle="model_topology",ile="weight_specs",rle="weight_data",ole="model_metadata";function R5(n){return{info:[Zh,n,A5].join(nc),topology:[Zh,n,sle].join(nc),weightSpecs:[Zh,n,ile].join(nc),weightData:[Zh,n,rle].join(nc),modelMetadata:[Zh,n,ole].join(nc)}}function M5(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function ale(n){const e=n.split(nc);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(nc)}function lle(n){return n.startsWith(_d.URL_SCHEME)?n.slice(_d.URL_SCHEME.length):n}class _d{constructor(e){if(!ze().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=R5(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),i=T5(e),r=jp.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Yae(r));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:i}}catch{throw M5(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const a=JSON.parse(r);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Zae(o),t}}_d.URL_SCHEME="localstorage://";const N5=n=>ze().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(_d.URL_SCHEME)?cle(n.slice(_d.URL_SCHEME.length)):null;Mr.registerSaveRouter(N5);Mr.registerLoadRouter(N5);function cle(n){return new _d(n)}class ule{constructor(){re(ze().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),re(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Zh+nc,s=nc+A5;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(s)){const o=ale(r);e[o]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=lle(e);const t=R5(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return M5(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FP="://";class nl{constructor(){this.managers={}}static getInstance(){return nl.instance==null&&(nl.instance=new nl),nl.instance}static registerManager(e,t){re(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(FP)&&(e=e.slice(0,e.indexOf(FP))),re(e.length>0,()=>"scheme must not be an empty string.");const s=nl.getInstance();re(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=nl.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(nl.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dle{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ze().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return u5(e)}}if(ze().get("IS_BROWSER")){ze().setPlatform("browser",new dle);try{nl.registerManager(_d.URL_SCHEME,new ule)}catch{}try{nl.registerManager(Cd.URL_SCHEME,new nle)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle={importFetch:()=>require("node-fetch")};let XS;class fle{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ze().global.fetch!=null?ze().global.fetch(e,t):(XS==null&&(XS=hle.importFetch()),XS(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ze().get("IS_NODE")&&!ze().get("IS_BROWSER")&&ze().setPlatform("node",new fle);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yn(n,e="float32",t){return e=e||"float32",gc(n),new ur(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ple(n,e){const t=ge(n,"x","cast");if(!cae(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},i={dtype:e};return Re.runKernel(ip,s,i)}const Jt=$e({cast_:ple});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mle(n){const t={x:ge(n,"x","clone","string_or_numeric")};return Re.runKernel(xp,t)}const pd=$e({clone_:mle});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gle(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */w5();const xle={buffer:Yn,cast:Jt,clone:pd,print:gle};Oae(xle);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vle(n,e){let t=ge(n,"a","add"),s=ge(e,"b","add");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(Bd,i)}const Mt=$e({add_:vle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yle(n,e){let t=ge(n,"a","floorDiv"),s=ge(e,"b","floorDiv");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(mp,i)}const P5=$e({floorDiv_:yle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wle(n,e){let t=ge(n,"a","div"),s=ge(e,"b","div");if([t,s]=bi(t,s),t.dtype==="int32"&&s.dtype==="int32")return P5(t,s);const i={a:t,b:s},r={};return Re.runKernel(cp,i,r)}const Cn=$e({div_:wle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ble(n,e){let t=ge(n,"a","mul"),s=ge(e,"b","mul");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(Tp,i)}const ke=$e({mul_:ble});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sle(n){const e=ge(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Re.runKernel(g0,t)}else{const t={x:e};return Re.runKernel(c0,t)}}const Nr=$e({abs_:Sle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cle(n){const t={x:ge(n,"x","acos")};return Re.runKernel(Zf,t)}const _le=$e({acos_:Cle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ele(n){const t={x:ge(n,"x","acosh")};return Re.runKernel(Qf,t)}const Tle=$e({acosh_:Ele});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ile(n,e=null,t=!1){const i={x:ge(n,"x","all","bool")},r={axis:e,keepDims:t};return Re.runKernel(my,i,r)}const D5=$e({all_:Ile});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kle(n,e=null,t=!1){const i={x:ge(n,"x","any","bool")},r={axis:e,keepDims:t};return Re.runKernel(gy,i,r)}const d_=$e({any_:kle});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ale(n,e=0){const s={x:ge(n,"x","argMax")},i={axis:e};return Re.runKernel(u0,s,i)}const $g=$e({argMax_:Ale});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rle(n,e=0){const s={x:ge(n,"x","argMin")},i={axis:e};return Re.runKernel(d0,s,i)}const Mle=$e({argMin_:Rle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nle(n){const t={x:ge(n,"x","asin")};return Re.runKernel(Jf,t)}const Ple=$e({asin_:Nle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dle(n){const t={x:ge(n,"x","asinh")};return Re.runKernel(ep,t)}const Lle=$e({asinh_:Dle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $le(n){const t={x:ge(n,"x","atan")};return Re.runKernel(tp,t)}const Fle=$e({atan_:$le});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ole(n,e){let t=ge(n,"a","atan2"),s=ge(e,"b","atan2");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(sp,i)}const zle=$e({atan2_:Ole});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ble(n){const t={x:ge(n,"x","atanh")};return Re.runKernel(np,t)}const Ule=$e({atanh_:Ble});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gu(n,e,t,s,i="NHWC",r){const o=n[3],a=[...e,o],l=bo(i);return Js(n,a,t,r,s,null,null,l)}function br(n,e,t,s,i,r,o="channelsLast"){const[a,l]=Fg(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Js(n,c,t,s,i,r,!1,o)}function Fo(n,e,t,s,i,r,o="NDHWC"){const[a,l,c]=h_(e);let u,d;if(o==="NDHWC")d="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")d="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Wa(n,u,t,s,i,!1,d,r)}function Js(n,e,t,s,i,r,o=!1,a="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,d]=n;else if(a==="channelsFirst")[l,d,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[h,p,,g]=e,[y,x]=Fg(t),[v,b]=Fg(s),S=uf(h,v),C=uf(p,b),{padInfo:E,outHeight:k,outWidth:R}=Gle(i,c,u,y,x,S,C,r,a),L=o?g*d:g;let I;return a==="channelsFirst"?I=[l,L,k,R]:a==="channelsLast"&&(I=[l,k,R,L]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:d,outHeight:k,outWidth:R,outChannels:L,padInfo:E,strideHeight:y,strideWidth:x,filterHeight:h,filterWidth:p,effectiveFilterHeight:S,effectiveFilterWidth:C,dilationHeight:v,dilationWidth:b,inShape:n,outShape:I,filterShape:e}}function Wa(n,e,t,s,i,r=!1,o="channelsLast",a){let[l,c,u,d,h]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,d,h]=n;else if(o==="channelsFirst")[l,h,c,u,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,y,,x]=e,[v,b,S]=h_(t),[C,E,k]=h_(s),R=uf(p,C),L=uf(g,E),I=uf(y,k),{padInfo:T,outDepth:M,outHeight:j,outWidth:W}=Hle(i,c,u,d,v,b,S,R,L,I,a),z=r?x*h:x;let X;return o==="channelsFirst"?X=[l,z,M,j,W]:o==="channelsLast"&&(X=[l,M,j,W,z]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:d,inChannels:h,outDepth:M,outHeight:j,outWidth:W,outChannels:z,padInfo:T,strideDepth:v,strideHeight:b,strideWidth:S,filterDepth:p,filterHeight:g,filterWidth:y,effectiveFilterDepth:R,effectiveFilterHeight:L,effectiveFilterWidth:I,dilationDepth:C,dilationHeight:E,dilationWidth:k,inShape:n,outShape:X,filterShape:e}}function Vle(n,e,t,s,i){s==null&&(s=bT(n,e,t));const r=n[0],o=n[1],a=Og((r-e+2*s)/t+1,i),l=Og((o-e+2*s)/t+1,i);return[a,l]}function Wle(n,e,t,s,i,r){i==null&&(i=bT(n,e[0],s[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*i>=e[a]&&(o[a]=Og((n[a]-e[a]+2*i)/s[a]+1,r));return o}function bT(n,e,t,s=1){const i=uf(e,s);return Math.floor((n[0]*(t-1)-t+i)/2)}function Fg(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function h_(n){return typeof n=="number"?[n,n,n]:n}function uf(n,e){return e<=1?n:n+(n-1)*(e-1)}function Gle(n,e,t,s,i,r,o,a,l){let c,u,d;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=Vle([e,t],r,s,n,a);u=p[0],d=p[1]}else if(n==="same"){u=Math.ceil(e/s),d=Math.ceil(t/i);const h=Math.max(0,(u-1)*s+r-e),p=Math.max(0,(d-1)*i+o-t),g=Math.floor(h/2),y=h-g,x=Math.floor(p/2),v=p-x;c={top:g,bottom:y,left:x,right:v,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-r+1)/s),d=Math.ceil((t-o+1)/i);else if(typeof n=="object"){const h=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],g=l==="channelsLast"?n[2][0]:n[3][0],y=l==="channelsLast"?n[2][1]:n[3][1];c={top:h,bottom:p,left:g,right:y,type:h===0&&p===0&&g===0&&y===0?"VALID":"EXPLICIT"},u=Og((e-r+h+p)/s+1,a),d=Og((t-o+g+y)/i+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:d}}function Hle(n,e,t,s,i,r,o,a,l,c,u){let d,h,p,g;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const x=Wle([e,t,s,1],[a,l,c],1,[i,r,o],n,u);h=x[0],p=x[1],g=x[2]}else if(n==="same"){h=Math.ceil(e/i),p=Math.ceil(t/r),g=Math.ceil(s/o);const y=(h-1)*i+a-e,x=(p-1)*r+l-t,v=(g-1)*o+c-s,b=Math.floor(y/2),S=y-b,C=Math.floor(x/2),E=x-C,k=Math.floor(v/2),R=v-k;d={top:C,bottom:E,left:k,right:R,front:b,back:S,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:g}}function Og(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ed(n){const[e,t,s]=Fg(n);return e===1&&t===1&&s===1}function er(n,e){return Ed(n)||Ed(e)}function Td(n){return Fg(n).every(e=>e>0)}function bo(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function to(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")re(Af(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(i=>{re(Af(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jle(n,e){const s={x:ge(n,"x","reshape","string_or_numeric")},i={shape:e};return Re.runKernel(Y0,s,i)}const De=$e({reshape_:jle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xle(n,e,t,s,i){const r=ge(n,"x","avgPool","float32"),o=1;re(er(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=r,l=!1;r.rank===3&&(l=!0,a=De(r,[1,r.shape[0],r.shape[1],r.shape[2]])),re(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),to("avgPool",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i};let d=Re.runKernel(h0,c,u);return d=Jt(d,r.dtype),l?De(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ST=$e({avgPool_:Xle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qle(n,e,t,s,i,r="NDHWC"){const o=ge(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=De(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),re(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),re(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),re(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),to("avgPool3d",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r};let d=Re.runKernel(f0,c,u);return d=Jt(d,a.dtype),l?De(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Kle=$e({avgPool3d_:qle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yle(n,e=0){re(n.length>=1,()=>"Pass at least one tensor to concat");const t=_5(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),t.length===1)return pd(t[0]);const s=t,i={axis:e};return Re.runKernel(x0,s,i)}const Yr=$e({concat_:Yle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zle(n,e,t=!1,s=!1){let i=ge(n,"a","matMul"),r=ge(e,"b","matMul");[i,r]=bi(i,r);const o={a:i,b:r},a={transposeA:t,transposeB:s};return Re.runKernel(p0,o,a)}const Ts=$e({matMul_:Zle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qle(n){const t={x:ge(n,"x","sigmoid","float32")};return Re.runKernel(Fp,t)}const Xp=$e({sigmoid_:Qle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jle(n,e,t){const s=ge(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:e,size:t};return Re.runKernel(t1,i,r)}const Xs=$e({slice_:Jle});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ece(n){const t={x:ge(n,"x","tanh","float32")};return Re.runKernel(Wp,t)}const tw=$e({tanh_:ece});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tce(n,e,t){const s=ge(n,"x","batchToSpaceND"),i=e.reduce((a,l)=>a*l);re(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),re(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),re(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const r={x:s},o={blockShape:e,crops:t};return Re.runKernel(m0,r,o)}const CT=$e({batchToSpaceND_:tce});function nce(n){let e;return n.rank===0||n.rank===1?e=De(n,[1,1,1,n.size]):n.rank===2?e=De(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=De(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sce(n,e,t,s,i,r){r==null&&(r=.001);const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let c;i!=null&&(c=ge(i,"scale","batchNorm"));let u;s!=null&&(u=ge(s,"offset","batchNorm")),re(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),re(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),re(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:nce(o),scale:c,offset:u,mean:a,variance:l},p={varianceEpsilon:r},g=Re.runKernel(T0,h,p);return De(g,o.shape)}const nw=$e({batchNorm_:sce});function ice(n,e,t,s,i,r){const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let c;i!=null&&(c=ge(i,"scale","batchNorm"));let u;return s!=null&&(u=ge(s,"offset","batchNorm")),re(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),re(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),re(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&re(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&re(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),nw(o,a,l,u,c,r)}const rce=$e({batchNorm2d_:ice});function oce(n,e,t,s,i,r){const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let c;i!=null&&(c=ge(i,"scale","batchNorm"));let u;return s!=null&&(u=ge(s,"offset","batchNorm")),re(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),re(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),re(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&re(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&re(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),nw(o,a,l,u,c,r)}const ace=$e({batchNorm3d_:oce});function lce(n,e,t,s,i,r){const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let c;i!=null&&(c=ge(i,"scale","batchNorm"));let u;return s!=null&&(u=ge(s,"offset","batchNorm")),re(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),re(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),re(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&re(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&re(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),nw(o,a,l,u,c,r)}const cce=$e({batchNorm4d_:lce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uce(n,e,t){const s=ge(n,"x","bincount"),i=ge(e,"weights","bincount");re(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),re(t>=0,()=>`size must be non-negative, but got ${t}.`),re(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},o={size:t};return Re.runKernel(yy,r,o)}const dce=$e({bincount_:uce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hce(n,e){let t=ge(n,"broadcastTo","x");const s=t.shape;if(gc(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=De(t,c)}const i=t.shape,r=Array.from(e);for(let c=e.length-1;c>=0;c--)if(i[c]===e[c])r[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(r.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return pd(t);const a={x:t},l={reps:r};return Re.runKernel(Gp,a,l)}const Sg=$e({broadcastTo_:hce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fce(n){const t={x:ge(n,"x","ceil","float32")};return Re.runKernel(rp,t)}const pce=$e({ceil_:fce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(n,e,t){gc(n),t=t||zd(e);const s={shape:n,value:e,dtype:t};return Re.runKernel(Py,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mce(n,e,t){const s=ge(n,"x","clipByValue");if(re(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return sw(s.shape,e,s.dtype);const i={x:s},r={clipValueMin:e,clipValueMax:t};return Re.runKernel(op,i,r)}const Lo=$e({clipByValue_:mce});function gce(n){return Yr(n,0)}const xce=$e({concat1d_:gce});function vce(n,e){return Yr(n,e)}const yce=$e({concat2d_:vce});function wce(n,e){return Yr(n,e)}const bce=$e({concat3d_:wce});function Sce(n,e){return Yr(n,e)}const Cce=$e({concat4d_:Sce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ce(n,e,t,s,i="NHWC",r=[1,1],o){const a=ge(n,"x","conv2d","float32"),l=ge(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=De(a,[1,a.shape[0],a.shape[1],a.shape[2]])),re(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),re(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),to("conv2d",s,o);const d=i==="NHWC"?c.shape[3]:c.shape[1];re(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),re(er(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),re(Td(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),re(Td(t),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:c,filter:l},p={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},g=Re.runKernel(v0,h,p);return u?De(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Id=$e({conv2d_:_ce});function Ece(n,e,t,s,i="NWC",r=1,o){const a=ge(n,"x","conv1d"),l=ge(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=De(a,[1,a.shape[0],a.shape[1]])),re(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),re(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),to("conv1d",s,o),re(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),re(er(t,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${r}'`),re(Td(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),re(Td(t),()=>"Error in conv1D: Stride should be larger than 0."),re(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const d=De(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=De(c,[c.shape[0],1,c.shape[1],c.shape[2]]),x=Id(h,d,[1,t],s,"NHWC",[1,r],o);return u?De(x,[x.shape[2],x.shape[3]]):De(x,[x.shape[0],x.shape[2],x.shape[3]])}const L5=$e({conv1d_:Ece});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tce(n,e,t,s,i,r="NHWC",o){re(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=De(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),re(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),re(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),re(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=r==="NHWC"?a[3]:a[1],d=r==="NHWC"?l.shape[3]:l.shape[1];re(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),re(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),to("conv2dDerInput",i,o);const h={dy:l,filter:t},p={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,inputShape:a},g=Re.runKernel(y0,h,p);return c?De(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const _T=$e({conv2DBackpropInput_:Tce});function Ice(n,e,t,s,i,r){const o=ge(n,"x","conv2dTranspose"),a=ge(e,"filter","conv2dTranspose");return _T(t,o,a,s,i,"NHWC",r)}const $5=$e({conv2dTranspose_:Ice});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kce(n,e,t,s,i="NDHWC",r=[1,1,1]){const o=ge(n,"x","conv3d"),a=ge(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=De(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),re(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),re(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),re(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),re(er(t,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),re(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),re(Td(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),re(Td(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:a},d={strides:t,pad:s,dataFormat:i,dilations:r},h=Re.runKernel(w0,u,d);return c?De(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Ace=$e({conv3d_:kce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rce(n,e,t,s,i){re(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let r=n,o=e,a=!1;e.rank===4&&(a=!0,o=De(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const l=r[4],c=o.shape[4];re(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),re(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),re(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),re(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),re(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},d={pad:i,strides:s,inputShape:r},h=Re.runKernel(Cy,u,d);return a?De(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const F5=$e({conv3DBackpropInput_:Rce});function Mce(n,e,t,s,i){const r=ge(n,"x","conv3dTranspose"),o=ge(e,"filter","conv3dTranspose");return F5(t,r,o,s,i)}const Nce=$e({conv3dTranspose_:Mce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pce(n){const t={x:ge(n,"x","cos","float32")};return Re.runKernel(ap,t)}const ET=$e({cos_:Pce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dce(n){const t={x:ge(n,"x","cosh","float32")};return Re.runKernel(lp,t)}const O5=$e({cosh_:Dce});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lce(n,e=0,t=!1,s=!1){const r={x:ge(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:s};return Re.runKernel(_y,r,o)}const f_=$e({cumprod_:Lce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ce(n,e=0,t=!1,s=!1){const r={x:ge(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return Re.runKernel(b0,r,o)}const z5=$e({cumsum_:$ce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fce(n,e,t,s=!1){const i=ge(n,"x","denseBincount"),r=ge(e,"weights","denseBincount");re(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),re(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),re(t>=0,()=>`size must be non-negative, but got ${t}.`),re(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const o={x:i,weights:r},a={size:t,binaryOutput:s};return Re.runKernel(Ty,o,a)}const OP=$e({denseBincount_:Fce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oce(n,e,t="NHWC"){const s=ge(n,"x","depthToSpace","float32"),i=t==="NHWC"?s.shape[1]:s.shape[2],r=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];re(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),re(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${s.shape}`),re(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e} for depthToSpace with input shape
        ${s.shape}`),re(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return Re.runKernel(Iy,a,l)}const zce=$e({depthToSpace_:Oce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bce(n,e,t,s,i="NHWC",r=[1,1],o){const a=ge(n,"x","depthwiseConv2d","float32"),l=ge(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=De(a,[1,a.shape[0],a.shape[1],a.shape[2]])),re(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),re(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=i==="NHWC"?c.shape[3]:c.shape[1];re(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),to("depthwiseConv2d",s,o);const h={x:c,filter:l},p={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o},g=Re.runKernel(S0,h,p);return u?De(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const TT=$e({depthwiseConv2d_:Bce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uce(n,e,t,s,i=[1,1],r="NHWC"){const o=ge(n,"x","dilation2d"),a=ge(e,"filter","dilation2d");re(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),re(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),re(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=o,c=!1;o.rank===3&&(l=De(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0),re(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const u={x:l,filter:a},d={strides:t,pad:s,dilations:i},h=Re.runKernel(C0,u,d);return c?De(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Vce=$e({dilation2d_:Uce});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ou(n,e){const t=n.length,s=[];for(let i=0;i<t;i++){const r=t-1-i,o=n[r]||1;(e[e.length-1-i]||1)>1&&o===1&&s.unshift(r)}return s}function Wi(n,e){const t=[];for(let s=0;s<e.length;s++){const i=n[n.length-s-1],r=e.length-s-1,o=e[r];(i==null||i===1&&o>1)&&t.unshift(r)}return t}function Mn(n,e){const t=Math.max(n.length,e.length),s=new Array(t);for(let i=0;i<t;i++){let r=n[n.length-i-1];r==null&&(r=1);let o=e[e.length-i-1];if(o==null&&(o=1),r===1)s[t-i-1]=o;else if(o===1)s[t-i-1]=r;else if(r!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else s[t-i-1]=r}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wce(n,e){let t=ge(n,"a","equal","string_or_numeric"),s=ge(e,"b","equal","string_or_numeric");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(_0,i)}const Cl=$e({equal_:Wce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gce(n,e,t){const s=ge(e,"a","where"),i=ge(t,"b","where"),r=ge(n,"condition","where","bool"),o=Mn(Mn(r.shape,s.shape),i.shape),a=Sg(r,o),l=Sg(s,o),c=Sg(i,o),u={condition:a,t:l,e:c};return Re.runKernel(e1,u)}const Lr=$e({where_:Gce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hce(n){const t={x:ge(n,"x","zerosLike")};return Re.runKernel(l1,t)}const xs=$e({zerosLike_:Hce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jce(n,e){let t=ge(n,"a","div"),s=ge(e,"b","div");[t,s]=bi(t,s);const i=Cn(t,s),r=xs(i),o=Cl(s,r);return Lr(o,r,i)}const Xce=$e({divNoNan_:jce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qce(n,e){const t=ge(n,"t1","dot"),s=ge(e,"t2","dot");re((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const i=t.rank===1?t.size:t.shape[1],r=s.rank===1?s.size:s.shape[0];if(re(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),t.rank===1&&s.rank===1){const o=De(t,[1,-1]),a=De(s,[-1,1]),l=Ts(o,a);return De(l,[])}else if(t.rank===1&&s.rank===2){const o=De(t,[1,-1]),a=De(s,[s.shape[0],s.shape[1]]),l=Ts(o,a);return De(l,[l.size])}else if(t.rank===2&&s.rank===1){const o=De(s,[-1,1]),a=Ts(t,o);return De(a,[a.size])}else{const o=De(s,[s.shape[0],s.shape[1]]);return Ts(t,o)}}const Kce=$e({dot_:qce});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yce(n,...e){const t=e.map((i,r)=>ge(i,`tensors${r}`,"einsum")),s={equation:n};return Re.runKernel(Ry,t,s)}const Ym=$e({einsum_:Yce});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zce(n){const t={x:ge(n,"x","elu","float32")};return Re.runKernel(up,t)}const iw=$e({elu_:Zce});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qce(n){let e=ge(n,"x","erf");re(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Jt(e,"float32"));const t={x:e};return Re.runKernel(dp,t)}const B5=$e({erf_:Qce});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IT(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function U5(n,e,t){const s=n.length+e.length,i=[];let r=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?i.push(n[r++]):i.push(e[o++]);return i}function Ci(n,e){const t=[],s=n.length;for(let r=0;r<s;r++)e.indexOf(r)===-1&&t.push(n[r]);const i=e.map(r=>n[r]);return[t,i]}function Si(n,e){const t=e.map(s=>1);return U5(n,t,e)}function Ai(n,e,t){re(IT(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Os(n,e){if(IT(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Nl(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Ys(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jce(n,e=null,t=!1){const i={x:ge(n,"x","max")},r={reductionIndices:e,keepDims:t};return Re.runKernel($0,i,r)}const Na=$e({max_:Jce});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eue(n,e=null,t=!1){const i={x:ge(n,"x","min")},r={axis:e,keepDims:t};return Re.runKernel(B0,i,r)}const y2=$e({min_:eue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tue(n,e){let t=ge(n,"base","pow"),s=ge(e,"exp","pow");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(Ip,i)}const kd=$e({pow_:tue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Is(n,e){if((oa(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&oa(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ew(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nue(n){const t={x:ge(n,"x","sqrt","float32")};return Re.runKernel(zp,t)}const wr=$e({sqrt_:nue});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sue(n){const e=ge(n,"x","square"),t={};return Re.runKernel("Square",{x:e},t)}const Qs=$e({square_:sue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iue(n,e=null,t=!1){let s=ge(n,"x","sum");s.dtype==="bool"&&(s=Jt(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return Re.runKernel(n1,i,r)}const Sn=$e({sum_:iue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rue(n,e="euclidean",t=null,s=!1){n=ge(n,"x","norm");const i=V5(n,e,t);let r=i.shape;if(s){const o=Hn(t,n.shape);r=Si(i.shape,o)}return De(i,r)}function V5(n,e,t=null){if(n.rank===0)return Nr(n);if(n.rank!==1&&t===null)return V5(De(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Sn(Nr(n),t);if(e===1/0)return Na(Nr(n),t);if(e===-1/0)return y2(Nr(n),t);if(e==="euclidean"||e===2)return wr(Sn(kd(Nr(n),Is(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Na(Sn(Nr(n),t[0]),t[1]-1);if(e===1/0)return Na(Sn(Nr(n),t[1]),t[0]);if(e===-1/0)return y2(Sn(Nr(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return wr(Sn(Qs(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const rw=$e({norm_:rue});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oue(n,e=null,t=!1){return rw(n,"euclidean",e,t)}const aue=$e({euclideanNorm_:oue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lue(n){const t={x:ge(n,"x","exp")};return Re.runKernel(hp,t)}const _l=$e({exp_:lue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cue(n,e=0){const t=ge(n,"x","expandDims","string_or_numeric");re(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},i={dim:e};return Re.runKernel(E0,s,i)}const jr=$e({expandDims_:cue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uue(n){const t={x:ge(n,"x","expm1")};return Re.runKernel(fp,t)}const due=$e({expm1_:uue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hue(n,e){const t=ge(n,"x","tile","string_or_numeric");re(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},i={reps:e};return Re.runKernel(Gp,s,i)}const ka=$e({tile_:hue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fue(n,e,t,s="float32"){e==null&&(e=n);const i=Yn([n,e],s),r=n<=e?n:e;for(let a=0;a<r;++a)i.set(1,a,a);const o=De(i.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return ka(jr(o,0),[t[0],1,1]);if(t.length===2)return ka(jr(jr(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return ka(jr(jr(jr(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const W5=$e({eye_:fue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pue(n){const t={x:ge(n,"x","floor","float32")};return Re.runKernel(pp,t)}const ow=$e({floor_:pue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mue(n,e,t=0,s=0){const i=ge(n,"x","gather"),r=ge(e,"indices","gather","int32"),o={x:i,indices:r},a={axis:t,batchDims:s};return Re.runKernel(I0,o,a)}const kT=$e({gather_:mue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gue(n,e){let t=ge(n,"a","greater","string_or_numeric"),s=ge(e,"b","greater","string_or_numeric");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(k0,i)}const Oo=$e({greater_:gue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xue(n,e){let t=ge(n,"a","greaterEqual","string_or_numeric"),s=ge(e,"b","greaterEqual","string_or_numeric");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(gp,i)}const Vd=$e({greaterEqual_:xue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vue(n){const t={input:ge(n,"input","imag")};return Re.runKernel($y,t)}const AT=$e({imag_:vue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yue(n){const t={x:ge(n,"x","isFinite")};return Re.runKernel(vp,t)}const wue=$e({isFinite_:yue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bue(n){const t={x:ge(n,"x","isInf")};return Re.runKernel(yp,t)}const Sue=$e({isInf_:bue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cue(n){const t={x:ge(n,"x","isNaN")};return Re.runKernel(wp,t)}const _ue=$e({isNaN_:Cue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eue(n,e=.2){const s={x:ge(n,"x","leakyRelu")},i={alpha:e};return Re.runKernel(A0,s,i)}const RT=$e({leakyRelu_:Eue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tue(n,e){let t=ge(n,"a","less","string_or_numeric"),s=ge(e,"b","less","string_or_numeric");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(R0,i)}const w2=$e({less_:Tue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iue(n,e){let t=ge(n,"a","lessEqual","string_or_numeric"),s=ge(e,"b","lessEqual","string_or_numeric");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(M0,i)}const qp=$e({lessEqual_:Iue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kue(n,e=5,t=1,s=1,i=.5){const r=ge(n,"x","localResponseNormalization");re(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),re(Af(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=r,a=!1;r.rank===3&&(a=!0,o=De(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:s,beta:i},u=Re.runKernel(L0,l,c);return a?De(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Aue=$e({localResponseNormalization_:kue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rue(n){const t={x:ge(n,"x","log","float32")};return Re.runKernel(bp,t)}const El=$e({log_:Rue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mue(n){const t={x:ge(n,"x","log1p")};return Re.runKernel(Sp,t)}const G5=$e({log1p_:Mue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nue(n,e){re(JC(n),()=>"The f passed in variableGrads(f) must be a function"),re(e==null||Array.isArray(e)&&e.every(c=>c instanceof v2),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in Re.registeredVariables)e.push(Re.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,i=e.length;e=e.filter(c=>c.trainable),re(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:o,grads:a}=Re.gradients(n,e,null,r);re(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),re(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:o,grads:l}}function Nf(n){return Re.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pue(n){const t={x:ge(n,"x","neg")};return Re.runKernel(V0,t)}const wi=$e({neg_:Pue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Due(n){const t={x:ge(n,"x","softplus")};return Re.runKernel(Op,t)}const c1=$e({softplus_:Due});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lue(n){const e=ge(n,"x","logSigmoid");return Nf(s=>({value:wi(c1(wi(s))),gradFunc:o=>ke(o,Xp(wi(s)))}))(e)}const $ue=$e({logSigmoid_:Lue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fue(n,e){let t=ge(n,"a","sub"),s=ge(e,"b","sub");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(Up,i)}const Pn=$e({sub_:Fue});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oue(n,e=-1){const t=ge(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Nf((i,r)=>{const a=Na(i,e,!0),l=Pn(i,a),c=Pn(Jt(l,"float32"),El(Sn(_l(l),e,!0)));return r([c]),{value:c,gradFunc:(d,h)=>{const[p]=h,g=!0,y=_l(p);return Pn(d,ke(Sn(d,e,g),y))}}})(t)}const H5=$e({logSoftmax_:Oue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zue(n,e=null,t=!1){const s=ge(n,"x","logSumExp"),i=Hn(e,s.shape),r=Na(s,i,!0),o=Pn(s,r),a=_l(o),l=Sn(a,i),c=El(l),u=Mt(De(r,c.shape),c);if(t){const d=Si(u.shape,i);return De(u,d)}return u}const j5=$e({logSumExp_:zue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bue(n,e){const t=ge(n,"a","logicalAnd","bool"),s=ge(e,"b","logicalAnd","bool");Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(N0,i)}const fc=$e({logicalAnd_:Bue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uue(n){const t={x:ge(n,"x","logicalNot","bool")};return Re.runKernel(P0,t)}const MT=$e({logicalNot_:Uue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vue(n,e){const t=ge(n,"a","logicalOr","bool"),s=ge(e,"b","logicalOr","bool");Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(D0,i)}const X5=$e({logicalOr_:Vue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wue(n,e){const t=ge(n,"a","logicalXor","bool"),s=ge(e,"b","logicalXor","bool");return Mn(t.shape,s.shape),fc(X5(n,e),MT(fc(n,e)))}const Gue=$e({logicalXor_:Wue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hue(n,e,t,s,i){const r=ge(n,"x","maxPool"),o=1;let a=r,l=!1;r.rank===3&&(l=!0,a=De(r,[1,r.shape[0],r.shape[1],r.shape[2]])),re(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),re(er(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),to("maxPool",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i},d=Re.runKernel(F0,c,u);return l?De(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const NT=$e({maxPool_:Hue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jue(n,e=[1,1,1],t,s,i,r="NDHWC"){const o=ge(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=De(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),re(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),re(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),to("maxPool3d",s,i);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r},d=Re.runKernel(O0,c,u);return l?De(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Xue=$e({maxPool3d_:jue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function que(n,e){let t=ge(n,"a","maximum"),s=ge(e,"b","maximum");[t,s]=bi(t,s),t.dtype==="bool"&&(t=Jt(t,"int32"),s=Jt(s,"int32")),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(Cp,i)}const xu=$e({maximum_:que});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kue(n,e=null,t=!1){const i={x:ge(n,"x","mean")},r={axis:e,keepDims:t};return Re.runKernel(z0,i,r)}const ki=$e({mean_:Kue});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oi(n,e="float32"){if(gc(n),e==="complex64"){const s=Oi(n,"float32"),i=Oi(n,"float32");return Mf(s,i)}const t=dr(Le(n),e);return Re.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vu(n,e="float32"){if(gc(n),e==="complex64"){const s=vu(n,"float32"),i=Oi(n,"float32");return Mf(s,i)}const t=ZE(Le(n),e);return Re.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yue(n,e){let t=ge(n,"a","minimum"),s=ge(e,"b","minimum");[t,s]=bi(t,s),t.dtype==="bool"&&(t=Jt(t,"int32"),s=Jt(s,"int32")),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(_p,i)}const zg=$e({minimum_:Yue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zue(n,e,t){re(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=ge(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");re(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)re(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),re(e[a][0]>=0&&e[a][0]<=s.shape[a]-i&&e[a][1]>=0&&e[a][1]<=s.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:e,mode:t},o={x:s};return Re.runKernel(U0,o,r)}const Que=$e({mirrorPad_:Zue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jue(n,e){let t=ge(n,"a","mod"),s=ge(e,"b","mod");[t,s]=bi(t,s);const i={a:t,b:s};return Re.runKernel(Ep,i)}const ede=$e({mod_:Jue});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tde(n,e=null,t=!1){n=ge(n,"x","moments");const s=Hn(e,n.shape),i=ki(n,s,t);let r=i.shape;t||(r=Si(i.shape,s));const o=Qs(Pn(Jt(n,"float32"),De(i,r))),a=ki(o,s,t);return{mean:i,variance:a}}const PT=$e({moments_:tde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nde(n,e){let t=ge(n,"a","notEqual","string_or_numeric"),s=ge(e,"b","notEqual","string_or_numeric");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s};return Re.runKernel(W0,i)}const b2=$e({notEqual_:nde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sde(n,e,t=1,s=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:ge(n,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:t,offValue:s};return Re.runKernel(H0,o,a)}const q5=$e({oneHot_:sde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(n){const t={x:ge(n,"x","onesLike")};return Re.runKernel(G0,t)}const aa=$e({onesLike_:ide});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rde(n,e,t=0){const s=ge(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},r={x:s};return Re.runKernel(X0,r,i)}const DT=$e({pad_:rde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ode(n,e,t){const s=ge(n,"x","spaceToBatchND");re(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),re(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),re(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:s},r={blockShape:e,paddings:t};return Re.runKernel(s1,i,r)}const LT=$e({spaceToBatchND_:ode});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(n,e,t,s,i,r,o){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const a=ge(n,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=De(a,[1,a.shape[0],a.shape[1],a.shape[2]])),re(er(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const u=br(l.shape,e,r,i,s),d=[u.dilationHeight,u.dilationWidth];let h;s==="same"?h=cde([u.filterHeight,u.filterWidth],d):h=[[0,0],[0,0]];const p=d[0]===1&&d[1]===1,[g,y]=lde([u.inHeight,u.inWidth],d,h),x=p?s:"valid",v=p?l:LT(l,d,g),S=(t==="avg"?()=>ST(v,e,r,x,o):()=>NT(v,e,r,x,o))(),C=p?S:CT(S,d,y);return c?De(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function lde(n,e,t){const s=t.map(u=>u[0]),i=t.map(u=>u[1]),r=n.concat(s,i),o=e.map((u,d)=>(u-r[d]%u)%u),a=i.map((u,d)=>u+o[d]),l=e.map((u,d)=>[s[d],a[d]]),c=e.map((u,d)=>[0,o[d]]);return[l,c]}function cde(n,e){const s=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),i=s.map(o=>Math.floor(o/2)),r=s.map((o,a)=>o-i[a]);return s.map((o,a)=>[i[a],r[a]])}const ude=$e({pool_:ade});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dde(n,e){const t=ge(n,"x","prelu"),s=ge(e,"alpha","prelu"),i={x:t,alpha:s};return Re.runKernel(q0,i)}const $T=$e({prelu_:dde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(n,e=null,t=!1){let s=ge(n,"x","prod");s.dtype==="bool"&&(s=Jt(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return Re.runKernel(K0,i,r)}const fde=$e({prod_:hde});var Ov={exports:{}},pde=Ov.exports,zP;function mde(){return zP||(zP=1,function(n){(function(e,t,s){function i(l){var c=this,u=a();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function r(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new i(l),d=c&&c.state,h=u.next;return h.int32=function(){return u.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&r(d,u),h.state=function(){return r(u,{})}),h}function a(){var l=4022871197,c=function(u){u=String(u);for(var d=0;d<u.length;d++){l+=u.charCodeAt(d);var h=.02519603282416938*l;l=h>>>0,h-=l,h*=l,l=h>>>0,h-=l,l+=h*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:this.alea=o})(pde,n)}(Ov)),Ov.exports}var zv={exports:{}},gde=zv.exports,BP;function xde(){return BP||(BP=1,function(n){(function(e,t,s){function i(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function r(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,g=(h+p)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&r(u,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=o:this.xor128=o})(gde,n)}(zv)),zv.exports}var Bv={exports:{}},vde=Bv.exports,UP;function yde(){return UP||(UP=1,function(n){(function(e,t,s){function i(a){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,g=(h+p)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&r(u,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=o:this.xorwow=o})(vde,n)}(Bv)),Bv.exports}var Uv={exports:{}},wde=Uv.exports,VP;function bde(){return VP||(VP=1,function(n){(function(e,t,s){function i(a){var l=this;l.next=function(){var u=l.x,d=l.i,h,p;return h=u[d],h^=h>>>7,p=h^h<<24,h=u[d+1&7],p^=h^h>>>10,h=u[d+3&7],p^=h^h>>>3,h=u[d+4&7],p^=h^h<<7,h=u[d+7&7],h=h^h<<13,p^=h^h<<9,u[d]=p,l.i=d+1&7,p};function c(u,d){var h,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,h=0;h<d.length;++h)p[h&7]=p[h&7]<<15^d.charCodeAt(h)+p[h+1&7]<<13;for(;p.length<8;)p.push(0);for(h=0;h<8&&p[h]===0;++h);for(h==8?p[7]=-1:p[h],u.x=p,u.i=0,h=256;h>0;--h)u.next()}c(l,a)}function r(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,g=(h+p)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,u&&(u.x&&r(u,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=o:this.xorshift7=o})(wde,n)}(Uv)),Uv.exports}var Vv={exports:{}},Sde=Vv.exports,WP;function Cde(){return WP||(WP=1,function(n){(function(e,t,s){function i(a){var l=this;l.next=function(){var u=l.w,d=l.X,h=l.i,p,g;return l.w=u=u+1640531527|0,g=d[h+34&127],p=d[h=h+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,g=d[h]=g^p,l.i=h,g+(u^u>>>16)|0};function c(u,d){var h,p,g,y,x,v=[],b=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,b=Math.max(b,d.length)),g=0,y=-32;y<b;++y)d&&(p^=d.charCodeAt((y+32)%d.length)),y===0&&(x=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,y>=0&&(x=x+1640531527|0,h=v[y&127]^=p+x,g=h==0?g+1:0);for(g>=128&&(v[(d&&d.length||0)&127]=-1),g=127,y=4*128;y>0;--y)p=v[g+34&127],h=v[g=g+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,v[g]=p^h;u.w=x,u.X=v,u.i=g}c(l,a)}function r(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,g=(h+p)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,u&&(u.X&&r(u,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=o:this.xor4096=o})(Sde,n)}(Vv)),Vv.exports}var Wv={exports:{}},_de=Wv.exports,GP;function Ede(){return GP||(GP=1,function(n){(function(e,t,s){function i(a){var l=this,c="";l.next=function(){var d=l.b,h=l.c,p=l.d,g=l.a;return d=d<<25^d>>>7^h,h=h-p|0,p=p<<24^p>>>8^g,g=g-d|0,l.b=d=d<<20^d>>>12^h,l.c=h=h-p|0,l.d=p<<16^h>>>16^g,l.a=g-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function r(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,g=(h+p)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&r(u,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=o:this.tychei=o})(_de,n)}(Wv)),Wv.exports}var Gv={exports:{}};const Tde={},Ide=Object.freeze(Object.defineProperty({__proto__:null,default:Tde},Symbol.toStringTag,{value:"Module"})),kde=v9(Ide);var Ade=Gv.exports,HP;function Rde(){return HP||(HP=1,function(n){(function(e,t,s){var i=256,r=6,o=52,a="random",l=s.pow(i,r),c=s.pow(2,o),u=c*2,d=i-1,h;function p(C,E,k){var R=[];E=E==!0?{entropy:!0}:E||{};var L=v(x(E.entropy?[C,S(t)]:C??b(),3),R),I=new g(R),T=function(){for(var M=I.g(r),j=l,W=0;M<c;)M=(M+W)*i,j*=i,W=I.g(1);for(;M>=u;)M/=2,j/=2,W>>>=1;return(M+W)/j};return T.int32=function(){return I.g(4)|0},T.quick=function(){return I.g(4)/4294967296},T.double=T,v(S(I.S),t),(E.pass||k||function(M,j,W,z){return z&&(z.S&&y(z,I),M.state=function(){return y(I,{})}),W?(s[a]=M,j):M})(T,L,"global"in E?E.global:this==s,E.state)}function g(C){var E,k=C.length,R=this,L=0,I=R.i=R.j=0,T=R.S=[];for(k||(C=[k++]);L<i;)T[L]=L++;for(L=0;L<i;L++)T[L]=T[I=d&I+C[L%k]+(E=T[L])],T[I]=E;(R.g=function(M){for(var j,W=0,z=R.i,X=R.j,B=R.S;M--;)j=B[z=d&z+1],W=W*i+B[d&(B[z]=B[X=d&X+j])+(B[X]=j)];return R.i=z,R.j=X,W})(i)}function y(C,E){return E.i=C.i,E.j=C.j,E.S=C.S.slice(),E}function x(C,E){var k=[],R=typeof C,L;if(E&&R=="object")for(L in C)try{k.push(x(C[L],E-1))}catch{}return k.length?k:R=="string"?C:C+"\0"}function v(C,E){for(var k=C+"",R,L=0;L<k.length;)E[d&L]=d&(R^=E[d&L]*19)+k.charCodeAt(L++);return S(E)}function b(){try{var C;return h&&(C=h.randomBytes)?C=C(i):(C=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(C)),S(C)}catch{var E=e.navigator,k=E&&E.plugins;return[+new Date,e,k,e.screen,S(t)]}}function S(C){return String.fromCharCode.apply(0,C)}if(v(s.random(),t),n.exports){n.exports=p;try{h=kde}catch{}}else s["seed"+a]=p})(typeof self<"u"?self:Ade,[],Math)}(Gv)),Gv.exports}var qS,jP;function Mde(){if(jP)return qS;jP=1;var n=mde(),e=xde(),t=yde(),s=bde(),i=Cde(),r=Ede(),o=Rde();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=s,o.xor4096=i,o.tychei=r,qS=o,qS}var FT=Mde();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K5{constructor(e,t,s,i,r){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=r||Math.random();this.random=FT.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,s=!1;for(;!s;){let i,r,o;do i=2*this.random()-1,r=2*this.random()-1,o=i*i+r*r;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*i*a,t=this.mean+this.stdDev*r*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Nde{constructor(e=0,t=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=FT.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pde(n,e=0,t=1,s,i){if(gc(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new K5(e,t,s,!1,i),o=Yn(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const Dde=$e({randomNormal_:Pde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lde(n,e=0,t=1,s="float32",i){gc(n);const r=Yn(n,s),o=new Nde(e,t,null,i);for(let a=0;a<r.values.length;a++)r.values[a]=o.nextValue();return r.toTensor()}const u1=$e({randomUniform_:Lde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:s};return Re.runKernel(Vy,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $de(n){const t={input:ge(n,"input","real")};return Re.runKernel(Wy,t)}const S2=$e({real_:$de});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fde(n){const t={x:ge(n,"x","reciprocal")};return Re.runKernel(kp,t)}const Ode=$e({reciprocal_:Fde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zde(n){const t={x:ge(n,"x","relu")};return Re.runKernel(Ap,t)}const Wd=$e({relu_:zde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bde(n){const t={x:ge(n,"x","relu6")};return Re.runKernel(Rp,t)}const Y5=$e({relu6_:Bde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ude(n,e){const s={x:ge(n,"x","reverse")},i={dims:e};return Re.runKernel(J0,s,i)}const Ad=$e({reverse_:Ude});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vde(n){const t={x:ge(n,"x","round")};return Re.runKernel(Mp,t)}const Z5=$e({round_:Vde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wde(n){const t={x:ge(n,"x","rsqrt","float32")};return Re.runKernel(Np,t)}const Q5=$e({rsqrt_:Wde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gde(n){const t={x:ge(n,"x","selu")};return Re.runKernel(Pp,t)}const J5=$e({selu_:Gde});function Hde(n,e,t,s,i,r=[1,1],o="NHWC"){const a=ge(n,"x","separableConv2d"),l=ge(e,"depthwiseFilter","separableConv2d"),c=ge(t,"pointwiseFilter","separableConv2d");let u=a,d=!1;if(a.rank===3&&(d=!0,u=De(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");re(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),re(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),re(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),re(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),re(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2],p=l.shape[3];re(c.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${c.shape[2]}.`);const g=TT(u,l,s,i,o,r),x=Id(g,c,1,"valid",o);return d?De(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const e6=$e({separableConv2d_:Hde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jde(n){const t={x:ge(n,"x","sign")};return Re.runKernel($p,t)}const Xde=$e({sign_:jde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qde(n){const t={x:ge(n,"x","sin","float32")};return Re.runKernel(Dp,t)}const t6=$e({sin_:qde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kde(n){const t={x:ge(n,"x","sinh")};return Re.runKernel(Lp,t)}const n6=$e({sinh_:Kde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yde(n,e,t){const s=ge(n,"x","slice1d");return re(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Xs(s,[e],[t])}const OT=$e({slice1d_:Yde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zde(n,e,t){const s=ge(n,"x","slice2d");return re(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Xs(s,e,t)}const s6=$e({slice2d_:Zde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qde(n,e,t){const s=ge(n,"x","slice3d");return re(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Xs(s,e,t)}const zT=$e({slice3d_:Qde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jde(n,e,t){const s=ge(n,"x","slice4d");return re(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Xs(s,e,t)}const C2=$e({slice4d_:Jde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ehe(n,e=-1){const t=ge(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},i={dim:e};return Re.runKernel(r1,s,i)}const BT=$e({softmax_:ehe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function the(n){re(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Re.runKernel(Ny,e)}const i6=$e({fft_:the});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nhe(n){re(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Re.runKernel(Ly,e)}const p_=$e({ifft_:nhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function she(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const i=De(n,[t,e]);s=p_(i)}else{const i=[t,2*(e-1)],r=De(S2(n),[t,e]),o=De(AT(n),[t,e]),a=Ad(Xs(r,[0,1],[t,e-2]),1),l=ke(Ad(Xs(o,[0,1],[t,e-2]),1),Is(-1)),c=Yr([r,a],1),u=Yr([o,l],1),d=De(Mf(c,u),[i[0],i[1]]);s=p_(d)}if(s=S2(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=De(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const ihe=$e({irfft_:she});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rhe(n,e,t=0){const i={x:ge(n,"x","split")},r={numOrSizeSplits:e,axis:t};return Re.runKernel(i1,i,r)}const Po=$e({split_:rhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ohe(n,e){re(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let i;if(e!=null&&e<t){const g=n.shape.map(x=>0),y=n.shape.map(x=>x);y[n.shape.length-1]=e,i=Xs(n,g,y),t=e}else if(e!=null&&e>t){const g=n.shape.map(y=>y);g[n.shape.length-1]=e-t,i=Yr([n,Oi(g)],n.shape.length-1),t=e}else i=n;const r=xs(i),o=De(Mf(i,r),[s,t]),a=i6(o),l=Math.floor(t/2)+1,c=S2(a),u=AT(a),d=Po(c,[l,t-l],c.shape.length-1),h=Po(u,[l,t-l],u.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=l,De(Mf(d[0],h[0]),p)}const ahe=$e({rfft_:ohe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lhe(n,e){let t=ge(n,"a","squaredDifference"),s=ge(e,"b","squaredDifference");[t,s]=bi(t,s),Mn(t.shape,s.shape);const i={a:t,b:s},r={};return Re.runKernel(Bp,i,r)}const che=$e({squaredDifference_:lhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uhe(n,e){const t=ge(n,"x","squeeze","string_or_numeric");return De(t,pu(t.shape,e).newShape)}const d1=$e({squeeze_:uhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dhe(n,e=0){const t=_5(n,"tensors","stack","string_or_numeric");re(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&re(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,i={axis:e};return Re.runKernel(j0,s,i)}const pc=$e({stack_:dhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hhe(n,e=0){const s={x:ge(n,"x","step")},i={alpha:e};return Re.runKernel(Hp,s,i)}const h1=$e({step_:hhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fhe(n,e,t,s,i=0,r=0,o=0,a=0,l=0){const u={x:ge(n,"x","stridedSlice","string_or_numeric")},d={begin:e,end:t,strides:s,beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return Re.runKernel(Xy,u,d)}const phe=$e({stridedSlice_:fhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mhe(n){const t={x:ge(n,"x","tan","float32")};return Re.runKernel(Vp,t)}const ghe=$e({tan_:mhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function go(n,e){KO(n);const t=Jy(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ew(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KS(n,e,t){if(KO(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Jy(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ew(n,e,s,t)}function r6(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(t.rank-i))throw new Error(r+` Output shape length < ${s+(t.rank-i)}`);if(t.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let o=0;o<i;++o)if(t.shape[o]!==e.shape[o])throw new Error(r+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-i;++o)if(t.shape[o+i]!==n[o+s])throw new Error(r+` updates.shape[${o+i}] (${t.shape[o+i]}) != shape[${o+i}] (${n[o+i]})`)}function xhe(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}r6(t,e,n)}function Pl(n,e,t){const s=e.shape.length,i=s>1?e.shape[s-1]:1,r=t.length;let o=1;for(let d=i;d<r;++d)o*=t[d];const a=i<1?1:i,l=Le(e.shape)/a,c=[...gn(t.slice(0,i)),1],u=Le(t);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vhe(n,e=1,t=!0){const s=ge(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const r={x:s},o={k:e,sorted:t},[a,l]=Re.runKernel(qy,r,o);return{values:a,indices:l}}const yhe=$e({topk_:vhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whe(n,e=0,t=1,s,i){if(gc(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new K5(e,t,s,!0,i),o=Yn(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=r.nextValue();return o.toTensor()}const o6=$e({truncatedNormal_:whe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bhe(n,e=0){const t=ge(n,"x","unique","string_or_numeric");re(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},i={axis:e},[r,o]=Re.runKernel(gT,s,i);return{values:r,indices:o}}const She=$e({unique_:bhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Che(n,e,t){const s=ge(n,"x","unsortedSegmentSum"),i=ge(e,"segmentIds","unsortedSegmentSum","int32");re(Af(t),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},o={numSegments:t};return Re.runKernel(a1,r,o)}const a6=$e({unsortedSegmentSum_:Che});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _he(n,e=0){const t=ge(n,"x","unstack","string_or_numeric");re(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},i={axis:e};return Re.runKernel(o1,s,i)}const Rd=$e({unstack_:_he});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ehe(n,e=!0,t,s){return Re.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6(n,e){const t=[];for(let r=0;r<e.length;r++)e[r]&&t.push(r);const s=Yn(n,"int32"),i=Yn([t.length,n.length],"int32");for(let r=0;r<t.length;r++){const o=s.indexToLoc(t[r]),a=r*n.length;i.values.set(o,a)}return i.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function The(n,e,t){const s=ge(n,"x","transpose");if(e==null&&(e=s.shape.map((o,a)=>a).reverse()),re(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(o=>{re(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:e};return s.dtype==="complex64"?je(()=>{let o=S2(s),a=AT(s);return o=Re.runKernel(fd,{x:o},r),a=Re.runKernel(fd,{x:a},r),t&&(a=wi(a)),Mf(o,a)}):Re.runKernel(fd,i,r)}const gs=$e({transpose_:The});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ihe(n,e){if(e==null)return n.shape.slice();if(ds(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function khe(n,e,t,s){const i=ge(n,"x","dropout");if(re(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),re(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Fi?i.clone():i;const r=Ihe(i,t),o=1-e,a=Cn(ow(Mt(u1(r,0,1,"float32",s),o)),o);return ke(i,a)}const Ahe=$e({dropout_:khe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rhe(n,e,t,s,i,r="NHWC",o){let a=n;n.rank===3&&(a=De(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=De(e,[1,e.shape[0],e.shape[1],e.shape[2]])),re(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),re(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),re(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=r==="NHWC"?a.shape[3]:a.shape[1],u=r==="NHWC"?l.shape[3]:l.shape[1];re(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),re(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),to("conv2dDerFilter",i,o);const d={x:a,dy:l},h={strides:s,pad:i,dataFormat:r,dimRoundingMode:o,filterShape:t};return Re.runKernel(by,d,h)}const UT=$e({conv2DBackpropFilter_:Rhe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VT(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return ke(n,h1(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function WT(n,e){let t=e;const s=Wi(n.shape,e.shape);return s.length>0&&(t=Sn(t,s)),De(t,n.shape)}function GT(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Wd(n);if(e==="elu")return iw(n);if(e==="relu6")return Y5(n);if(e==="prelu")return $T(n,t);if(e==="leakyrelu")return RT(n,s);if(e==="sigmoid")return Xp(n);throw new Error(`Unknown fused activation ${e}.`)}const HT=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mhe({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",HT(Re.state.gradientDepth,l)===!1){re(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=Id(n,e,t,s,i,r,o);return a!=null&&(k=Mt(k,a)),GT(k,l,c,u)}const d=ge(n,"x","conv2d","float32"),h=ge(e,"filter","conv2d","float32");let p=d,g=!1;d.rank===3&&(g=!0,p=De(d,[1,d.shape[0],d.shape[1],d.shape[2]])),re(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),re(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),to("fused conv2d",s,o);const y=i==="NHWC"?p.shape[3]:p.shape[1];re(h.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${h.shape[2]}.`),re(er(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`);const x=Js(p.shape,h.shape,t,r,s,o);let v;a!=null&&(v=ge(a,"bias","fused conv2d"),[v]=bi(v,d),i==="NHWC"?Mn(x.outShape,v.shape):(re(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),re(v.shape.length===0||v.shape[0]===x.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let b;if(c!=null){const k=c.shape;if(re(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)re(k[0]===1||k[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${x.outChannels}).`);else if(k.length===3)try{Mn(k,x.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(L)}b=ge(c,"prelu weights","fused conv2d")}const S=(k,R)=>{re(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[L,I,T,M]=R,j=VT(k,T,l);re(Ed(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const W=_T(I.shape,j,L,t,s),z=UT(I,j,L.shape,t,s),X=[W,z];if(M!=null){const B=WT(M,j);X.push(B)}return X},C={x:p,filter:h,bias:v,preluActivationWeights:b},E={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?Nf((R,L,I)=>{let T=Re.runKernel(Lg,C,E);return I([L,R,T]),g&&(T=De(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:S}})(p,h):Nf((R,L,I,T)=>{let M=Re.runKernel(Lg,C,E);return T([L,R,M,I]),g&&(M=De(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:S}})(p,h,v)}const Nhe=$e({fusedConv2d_:Mhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Phe(n,e,t,s,i,r=[1,1],o){let a=n;n.rank===3&&(a=De(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=De(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:s,pad:i,dimRoundingMode:o,dilations:r,filterShape:t};return Re.runKernel(ky,c,u)}const Dhe=$e({depthwiseConv2dNativeBackpropFilter_:Phe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lhe(n,e,t,s,i,r=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=De(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:s,pad:i,dimRoundingMode:o,dilations:r,inputShape:n},d=Re.runKernel(Ay,c,u);return l?De(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const $he=$e({depthwiseConv2dNativeBackpropInput_:Lhe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fhe({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(HT(Re.state.gradientDepth,r)===!1){let M=Ts(n,e,t,s);return i!=null&&(M=Mt(M,i)),GT(M,r,o,a)}let l=ge(n,"a","fused matMul"),c=ge(e,"b","fused matMul");[l,c]=bi(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?c.shape[c.rank-1]:c.shape[c.rank-2],h=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],g=l.shape.slice(0,-2),y=c.shape.slice(0,-2),x=Le(g),v=Le(y);re(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const S=Mn(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([h,p]),C=t?De(l,[x,u,h]):De(l,[x,h,u]),E=s?De(c,[v,p,d]):De(c,[v,d,p]);let k;i!=null&&(k=ge(i,"bias","fused matMul"),[k]=bi(k,l),Mn(S,k.shape));let R;o!=null&&(R=ge(o,"prelu weights","fused matMul"));const L=(M,j)=>{const[W,z,X,B]=j,J=VT(De(M,X.shape),X,r);let K,ee;if(!t&&!s?(K=Ts(J,z,!1,!0),ee=Ts(W,J,!0,!1)):!t&&s?(K=Ts(J,z,!1,!1),ee=Ts(J,W,!0,!1)):t&&!s?(K=Ts(z,J,!1,!0),ee=Ts(W,J,!1,!1)):(K=Ts(z,J,!0,!0),ee=Ts(J,W,!0,!0)),i!=null){const ne=WT(B,J);return[K,ee,ne]}else return[K,ee]},I={a:C,b:E,bias:k,preluActivationWeights:R},T={transposeA:t,transposeB:s,activation:r,leakyreluAlpha:a};return i==null?Nf((j,W,z)=>{const X=Re.runKernel(Dg,I,T);return z([j,W,X]),{value:De(X,S),gradFunc:L}})(C,E):Nf((j,W,z,X)=>{const B=Re.runKernel(Dg,I,T);return X([j,W,B,z]),{value:De(B,S),gradFunc:L}})(C,E,k)}const XP=$e({fusedMatMul_:Fhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ohe(n,e,t,s,i="bilinear",r=0){const o=ge(n,"image","cropAndResize"),a=ge(e,"boxes","cropAndResize","float32"),l=ge(t,"boxInd","cropAndResize","int32"),c=a.shape[0];re(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),re(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),re(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),re(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),re(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),re(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:o,boxes:a,boxInd:l},d={method:i,extrapolationValue:r,cropSize:s};return Re.runKernel(Ey,u,d)}const zhe=$e({cropAndResize_:Ohe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bhe(n){const e=ge(n,"image","flipLeftRight","float32");re(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Re.runKernel(Dy,t,{})}const Uhe=$e({flipLeftRight_:Bhe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vhe(n){const e=ge(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];re(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),re(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,ka(e,i)}const Whe=$e({grayscaleToRGB_:Vhe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ghe(n){const e=ge(n,"image","RGBToGrayscale"),t=e.rank-1,s=e.shape[t];re(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),re(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const i=e.dtype,r=Jt(e,"float32"),o=go([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Ym("ij,j->i",r,o);break;case 3:a=Ym("ijk,k->ij",r,o);break;case 4:a=Ym("ijkl,l->ijk",r,o);break;case 5:a=Ym("ijklm,m->ijkl",r,o);break;case 6:a=Ym("ijklmn,n->ijklm",r,o);break;default:throw new Error("Not a valid tensor rank.")}return a=jr(a,-1),Jt(a,i)}const Hhe=$e({rgbToGrayscale_:Ghe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jhe(n,e,t=0,s=.5){const i=ge(n,"image","rotateWithOffset","float32");re(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},o={radians:e,fillValue:t,center:s};return Re.runKernel(Yy,r,o)}const Xhe=$e({rotateWithOffset_:jhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(n,e,t,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const o=n.shape[0];return t=Math.min(t,o),re(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),re(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),re(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),re(e.rank===1,()=>"scores must be a 1D tensor"),re(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),re(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qhe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=ge(n,"boxes","nonMaxSuppression","float32"),o=ge(e,"scores","nonMaxSuppression","float32"),a=Kp(r,o,t,s,i);t=a.maxOutputSize,s=a.iouThreshold,i=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:i};return Re.runKernel(By,{boxes:r,scores:o},l)}const Khe=$e({nonMaxSuppression_:qhe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yhe(n,e,t){const s=Zhe(n,e,t),i=s<0?-(s+1):s;n.splice(i,0,e)}function Zhe(n,e,t){return Jhe(n,e,t||Qhe)}function Qhe(n,e){return n>e?1:n<e?-1:0}function Jhe(n,e,t){let s=0,i=n.length,r=0,o=!1;for(;s<i;){r=s+(i-s>>>1);const a=t(e,n[r]);a>0?s=r+1:(i=r,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n,e,t,s,i){return XT(n,e,t,s,i,0)}function jT(n,e,t,s,i,r){return XT(n,e,t,s,i,0,!1,r,!0)}function lw(n,e,t,s,i,r){return XT(n,e,t,s,i,r,!0)}function XT(n,e,t,s,i,r,o=!1,a=!1,l=!1){const c=[];for(let x=0;x<e.length;x++)e[x]>i&&c.push({score:e[x],boxIndex:x,suppressBeginIndex:0});c.sort(qP);const u=r>0?-.5/r:0,d=[],h=[];for(;d.length<t&&c.length>0;){const x=c.pop(),{score:v,boxIndex:b,suppressBeginIndex:S}=x;if(v<i)break;let C=!1;for(let E=d.length-1;E>=S;--E){const k=efe(n,b,d[E]);if(k>=s){C=!0;break}if(x.score=x.score*tfe(s,u,k),x.score<=i)break}x.suppressBeginIndex=d.length,C||(x.score===v?(d.push(b),h.push(x.score)):x.score>i&&Yhe(c,x,qP))}const p=d.length,g=t-p;a&&g>0&&(d.push(...new Array(g).fill(0)),h.push(...new Array(g).fill(0)));const y={selectedIndices:d};return o&&(y.selectedScores=h),l&&(y.validOutputs=p),y}function efe(n,e,t){const s=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),r=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),h=Math.max(i[1],i[3]),p=(a-r)*(l-o),g=(d-c)*(h-u);if(p<=0||g<=0)return 0;const y=Math.max(r,c),x=Math.max(o,u),v=Math.min(a,d),b=Math.min(l,h),S=Math.max(v-y,0)*Math.max(b-x,0);return S/(p+g-S)}function tfe(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function qP(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nfe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=ge(n,"boxes","nonMaxSuppressionAsync"),o=ge(e,"scores","nonMaxSuppressionAsync"),a=Kp(r,o,t,s,i);t=a.maxOutputSize,s=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([r.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:d}=aw(c,u,t,s,i);return r!==n&&r.dispose(),o!==e&&o.dispose(),go(d,"int32")}const sfe=nfe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ife(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=ge(n,"boxes","nonMaxSuppression"),a=ge(e,"scores","nonMaxSuppression"),l=Kp(o,a,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},d=Re.runKernel(Uy,c,u);return{selectedIndices:d[0],selectedScores:d[1]}}const rfe=$e({nonMaxSuppressionWithScore_:ife});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ofe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const o=ge(n,"boxes","nonMaxSuppressionAsync"),a=ge(e,"scores","nonMaxSuppressionAsync"),l=Kp(o,a,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],d=c[1],{selectedIndices:h,selectedScores:p}=lw(u,d,t,s,i,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:go(h,"int32"),selectedScores:go(p)}}const afe=ofe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lfe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=ge(n,"boxes","nonMaxSuppression"),a=ge(e,"scores","nonMaxSuppression"),l=Kp(o,a,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,h={boxes:o,scores:a},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:r},g=Re.runKernel(aT,h,p);return{selectedIndices:g[0],validOutputs:g[1]}}const cfe=$e({nonMaxSuppressionPadded_:lfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ufe(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const o=ge(n,"boxes","nonMaxSuppressionAsync"),a=ge(e,"scores","nonMaxSuppressionAsync"),l=Kp(o,a,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:y}=jT(h,p,c,u,d,r);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:go(g,"int32"),validOutputs:Is(y,"int32")}}const dfe=ufe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hfe(n,e,t=!1,s=!1){const i=ge(n,"images","resizeBilinear");re(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),re(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),re(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=De(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=Re.runKernel(Q0,a,l);return o?De(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const c6=$e({resizeBilinear_:hfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ffe(n,e,t=!1,s=!1){const i=ge(n,"images","resizeNearestNeighbor");re(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),re(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),re(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),re(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,o=!1;i.rank===3&&(o=!0,r=De(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=Re.runKernel(Z0,a,l);return o?De(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const u6=$e({resizeNearestNeighbor_:ffe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pfe(n,e="binary",t=!1,s=.5){const i=ge(n,"image","threshold"),r=.2989,o=.587,a=.114,l=i.shape[0]*i.shape[1];let c=ke(go([s]),255),u,d,h,p;if(re(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),re(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),re(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),re(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,d,h]=Po(i,[1,1,1],-1);const x=ke(u,r),v=ke(d,o),b=ke(h,a);p=Mt(Mt(x,v),b)}else p=n;if(e==="otsu"){const x=dce(Jt(Z5(p),"int32"),E5([]),256);c=mfe(x,l)}const g=t?qp(p,c):Oo(p,c);return Jt(ke(g,255),"int32")}function mfe(n,e){let t=go([-1]),s=go([0]),i=go([0]),r,o,a,l,c,u;for(let d=0;d<n.size-1;d++){r=Xs(n,0,d+1),o=Xs(n,d+1),c=Cn(Sn(r),e),u=Cn(Sn(o),e);const h=Sn(ke(r,Bg(0,r.size)));a=Cn(h,Sn(r));const p=sw(o.shape,r.size),g=Mt(Bg(0,o.size),p),y=ke(o,g);l=Cn(Sn(y),Sn(o));const x=Pn(a,l),v=Pn(a,l),b=ke(c,u);i=ke(ke(b,x),v);const S=Oo(i,s);s=Lr(S,i,s),t=Lr(S,go([d]),t)}return t}const gfe=$e({threshold_:pfe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xfe(n,e,t="nearest",s="constant",i=0,r){const o=ge(n,"image","transform","float32"),a=ge(e,"transforms","transform","float32");re(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),re(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),re(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:s,fillValue:i,outputShape:r};return Re.runKernel(Ky,l,c)}const vfe=$e({transform_:xfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yfe(n,e,t){const s=ge(n,"a","bandPart");re(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,o]=s.shape.slice(-2);let a,l;typeof e=="number"?(re(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),re(e<=r,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${r}).`),a=ge(e<0?r:e,"numLower","bandPart")):(re(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Lr(w2(e,0),r,zg(e,r))),typeof t=="number"?(re(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),re(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=ge(t<0?o:t,"numUpper","bandPart")):(re(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Lr(w2(t,0),o,zg(t,o)));const c=De(Bg(0,r,1,"int32"),[-1,1]),u=Bg(0,o,1,"int32"),d=Pn(c,u),h=fc(qp(d,a),Vd(d,wi(l))),p=Oi([r,o],s.dtype);return De(pc(Rd(De(s,[-1,r,o])).map(g=>Lr(h,g,p))),i)}const wfe=$e({bandPart_:yfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bfe(n){let e;if(Array.isArray(n)){e=!1,re(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)re(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else e=!0,n=Po(n,n.shape[0],0).map(i=>d1(i,[0]));re(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let i=0;i<n.length;++i)t.push(Re.tidy(()=>{let r=s[i];if(i>0)for(let o=0;o<i;++o){const a=ke(Sn(ke(t[o],r)),t[o]);r=Pn(r,a)}return Cn(r,rw(r,"euclidean"))}));return e?pc(t,0):t}const Sfe=$e({gramSchmidt_:bfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(n,e=!1){if(re(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return KP(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=Rd(De(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(l=>{const[c,u]=KP(l,e);i.push(c),r.push(u)});const o=De(pc(i,0),n.shape),a=De(pc(r,0),n.shape);return[o,a]}}function KP(n,e=!1){return Re.tidy(()=>{re(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let i=W5(t),r=pd(n);const o=KS([[1]],[1,1]);let a=pd(o);const l=t>=s?s:t;for(let c=0;c<l;++c){const u=r,d=a,h=i;[a,r,i]=Re.tidy(()=>{const p=Xs(r,[c,c],[t-c,1]),g=rw(p),y=Xs(r,[c,c],[1,1]),x=Lr(Oo(y,0),KS([[-1]]),KS([[1]])),v=Pn(y,ke(x,g)),b=Cn(p,v);b.shape[0]===1?a=pd(o):a=Yr([o,Xs(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const S=wi(Cn(Ts(x,v),g)),C=Xs(r,[c,0],[t-c,s]),E=ke(S,a),k=gs(a);if(c===0)r=Pn(C,Ts(E,Ts(k,C)));else{const I=Pn(C,Ts(E,Ts(k,C)));r=Yr([Xs(r,[0,0],[c,s]),I],0)}const R=gs(E),L=Xs(i,[0,c],[t,i.shape[1]-c]);if(c===0)i=Pn(L,Ts(Ts(L,a),R));else{const I=Pn(L,Ts(Ts(L,a),R));i=Yr([Xs(i,[0,0],[t,c]),I],1)}return[a,r,i]}),os([u,d,h])}return!e&&t>s&&(i=Xs(i,[0,0],[t,s]),r=Xs(r,[0,0],[s,s])),[i,r]})}const _fe=$e({qr_:Cfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rc={flipLeftRight:Uhe,grayscaleToRGB:Whe,resizeNearestNeighbor:u6,resizeBilinear:c6,rgbToGrayscale:Hhe,rotateWithOffset:Xhe,cropAndResize:zhe,nonMaxSuppression:Khe,nonMaxSuppressionAsync:sfe,nonMaxSuppressionWithScore:rfe,nonMaxSuppressionWithScoreAsync:afe,nonMaxSuppressionPadded:cfe,nonMaxSuppressionPaddedAsync:dfe,threshold:gfe,transform:vfe},Efe={bandPart:wfe,gramSchmidt:Sfe,qr:_fe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tfe=new Map,Ife=new Map;class Yp{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class sa{constructor(){this.classNameMap={}}static getMap(){return sa.instance==null&&(sa.instance=new sa),sa.instance}static register(e){sa.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function yt(n,e,t){re(n.className!=null,()=>"Class being registered does not have the static className property defined."),re(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),re(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const s=t,i=e+">"+s;return sa.register(n),Tfe.set(i,n),Ife.set(n,i),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yu extends Yp{minimize(e,t=!1,s){const{value:i,grads:r}=this.computeGradients(e,s);if(s!=null){const o=s.map(a=>({name:a.name,tensor:r[a.name]}));this.applyGradients(o)}else this.applyGradients(r);return os(r),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Nue(e,t)}dispose(){this.iterations_!=null&&os(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Is(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(yu,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d6 extends yu{static get className(){return"Adadelta"}constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Re.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Re.registeredVariables[s],o=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accum_grad`,variable:je(()=>xs(r).variable(o))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${s}/accum_var`,variable:je(()=>xs(r).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const l=this.accumulatedGrads[i].variable,c=this.accumulatedUpdates[i].variable;je(()=>{const u=Mt(ke(l,this.rho),ke(Qs(a),1-this.rho)),d=ke(Cn(wr(Mt(c,this.epsilon)),wr(Mt(l,this.epsilon))),a),h=Mt(ke(c,this.rho),ke(Qs(d),1-this.rho));l.assign(u),c.assign(h);const p=Mt(ke(d,-this.learningRate),r);r.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(os(this.accumulatedGrads.map(e=>e.variable)),os(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h6 extends yu{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Re.registeredVariables[s];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${s}/accumulator`,variable:je(()=>sw(r.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[i].tensor:e[s];if(o==null)return;const a=this.accumulatedGrads[i].variable;je(()=>{const l=Mt(a,Qs(o));a.assign(l);const c=Mt(ke(Cn(o,wr(Mt(l,Re.backend.epsilon()))),-this.learningRate),r);r.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&os(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f6 extends yu{static get className(){return"Adam"}constructor(e,t,s,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],je(()=>{this.accBeta1=Is(t).variable(),this.accBeta2=Is(s).variable()}),i==null&&(this.epsilon=Re.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);je(()=>{const s=Pn(1,this.accBeta1),i=Pn(1,this.accBeta2);t.forEach((r,o)=>{const a=Re.registeredVariables[r],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:je(()=>xs(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${r}/v`,variable:je(()=>xs(a).variable(l))});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,h=Mt(ke(u,this.beta1),ke(c,1-this.beta1)),p=Mt(ke(d,this.beta2),ke(Qs(c),1-this.beta2)),g=Cn(h,s),y=Cn(p,i);u.assign(h),d.assign(p);const x=Mt(ke(Cn(g,Mt(wr(y),this.epsilon)),-this.learningRate),a);a.assign(x)}),this.accBeta1.assign(ke(this.accBeta1,this.beta1)),this.accBeta2.assign(ke(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&os(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&os(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),je(()=>{this.accBeta1.assign(kd(this.beta1,this.iterations_+1)),this.accBeta2.assign(kd(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p6 extends yu{static get className(){return"Adamax"}constructor(e,t,s,i=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],je(()=>{this.iteration=Is(0).variable(),this.accBeta1=Is(t).variable()}),i==null&&(this.epsilon=Re.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);je(()=>{const s=Pn(1,this.accBeta1),i=Cn(-this.learningRate,Mt(ke(this.iteration,this.decay),1));t.forEach((r,o)=>{const a=Re.registeredVariables[r],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${r}/m`,variable:xs(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${r}/v`,variable:xs(a).variable(l)});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,h=Mt(ke(u,this.beta1),ke(c,1-this.beta1)),p=ke(d,this.beta2),g=Nr(c),y=xu(p,g);u.assign(h),d.assign(y);const x=Mt(ke(Cn(i,s),Cn(h,Mt(y,this.epsilon))),a);a.assign(x)}),this.iteration.assign(Mt(this.iteration,1)),this.accBeta1.assign(ke(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&os(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&os(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qT extends yu{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Array.isArray(e)?e[i].tensor:e[s];if(r==null)return;const o=Re.registeredVariables[s];je(()=>{const a=Mt(ke(this.c,r),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=xl(Is(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m6 extends qT{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Is(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Re.registeredVariables[s];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${s}/momentum`,variable:je(()=>xs(r).variable(!1))});const o=this.accumulations[i].variable,a=Array.isArray(e)?e[i].tensor:e[s];a!=null&&je(()=>{let l;const c=Mt(ke(this.m,o),a);this.useNesterov?l=Mt(ke(this.c,Mt(a,ke(c,this.m))),r):l=Mt(ke(this.c,c),r),o.assign(c),r.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&os(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g6 extends yu{static get className(){return"RMSProp"}constructor(e,t=.9,s=0,i=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=Re.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,i)=>{const r=Re.registeredVariables[s],o=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${s}/rms`,variable:je(()=>xs(r).variable(o))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${s}/momentum`,variable:je(()=>xs(r).variable(o))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${s}/mg`,variable:je(()=>xs(r).variable(o))});const a=Array.isArray(e)?e[i].tensor:e[s];if(a==null)return;const l=this.accumulatedMeanSquares[i].variable,c=this.accumulatedMoments[i].variable;je(()=>{const u=Mt(ke(l,this.decay),ke(Qs(a),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[i].variable,h=Mt(ke(d,this.decay),ke(a,1-this.decay)),p=Cn(ke(a,this.learningRate),wr(Pn(u,Mt(Qs(h),this.epsilon)))),g=Mt(ke(c,this.momentum),p);l.assign(u),d.assign(h),c.assign(g);const y=Pn(r,g);r.assign(y)}else{const d=Mt(ke(l,this.decay),ke(Qs(a),1-this.decay)),h=Mt(ke(c,this.momentum),Cn(ke(a,this.learningRate),wr(Mt(d,this.epsilon))));l.assign(d),c.assign(h);const p=Pn(r,h);r.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&os(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&os(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&os(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kfe=[d6,h6,f6,p6,m6,g6,qT];function Afe(){for(const n of kfe)yt(n)}function cw(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Le(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,r=i[i.length-1];let o=1;for(let d=0;d<i.length-1;++d)o*=i[d];const a=n.shape,l=i.slice();l.pop();let c=1;for(let d=r;d<t;++d)c*=a[d],l.push(a[d]);const u=[...gn(n.shape).map(d=>d/c),1].slice(0,r);return[l,o,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_=-2,Rfe=-1;function uw(n,e,t){const s=n.shape.length;re(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),re(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)re(e[i]+t[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function Mfe(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function dw(n,e,t){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((e[i]-n[i])/t[i]);return s}function x6(n,e,t,s){const i=[...n];for(let r=i.length;r<s.length;r++)i.push(1);for(let r=0;r<t;r++)r===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function v6(n,e,t){return t<=n?t:t-(e-1)}function y6(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function Nfe(n,e,t,s,i,r,o,a,l){const c=n.length;let u=new Array(c),d=new Array(c),h=new Array(c);if(e.length&&t>0){const p=e[0],g=t+1;u=w6(o,p,g,s,n),d=b6(a,p,g,i,n),h=x6(r,p,g,n)}else for(let p=0;p<c;p++)u[p]=C6(o,s,r,n,p,l),d[p]=_6(a,i,r,n,p,l),h[p]=S6(r,p,l);return{begin:u,end:d,strides:h}}function w6(n,e,t,s,i){const r=[...i],o=y6(t,e);for(let a=0;a<r.length;a++)if(o.indexOf(a)>-1)r[a]=0;else{const l=v6(e,t,a);let c=s[l];n&1<<l&&(c=0),r[a]=c}return r}function b6(n,e,t,s,i){const r=[...i],o=y6(t,e);for(let a=0;a<r.length;a++)if(o.indexOf(a)>-1)r[a]=Number.MAX_SAFE_INTEGER;else{const l=v6(e,t,a);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),r[a]=c}for(let a=0;a<r.length;a++){const l=i[a];r[a]<0&&(r[a]+=l),r[a]=Sd(0,r[a],i[a])}return r}function S6(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function C6(n,e,t,s,i,r){let o=e[i];const a=t[i]||1;(n&1<<i||r&1<<i||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),o=Sd(0,o,l-1),o}function _6(n,e,t,s,i,r){let o=e[i];const a=t[i]||1;(n&1<<i||r&1<<i||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[i];return o<0&&(o+=l),a>0?o=Sd(0,o,l):o=Sd(-1,o,l-1),o}function KT(n,e,t){let s=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){s=i;break}for(let i=s+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function YT(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function f1(n,e,t){let s;const i=n.shape.length;typeof e=="number"?s=[e,...new Array(i-1).fill(0)]:e.length<i?s=e.concat(new Array(i-e.length).fill(0)):s=e.slice(),s.forEach(o=>{re(o!==-1,()=>"slice() does not support negative begin indexing.")});let r;return t==null?r=new Array(i).fill(-1):typeof t=="number"?r=[t,...new Array(i-1).fill(-1)]:t.length<i?r=t.concat(new Array(i-t.length).fill(-1)):r=t,r=r.map((o,a)=>o>=0?o:(re(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,r]}function hw(n,e,t,s,i,r,o,a,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:r,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let S=0;S<d.dims;S++)u&&(1<<S&a)!==0&&d.numAddAxisAfterEllipsis++,1<<S&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Pfe(d,h);let p=!0,g=!0,y=!0;const x=[],v=[];for(let S=0;S<n.length;++S){if(h.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const C=!!(h.shrinkAxisMask&1<<S),E=n[S];if(E===-1){x.push(C?1:-1);continue}const k=[h.beginMask&1<<S,h.endMask&1<<S],R=[h.strides[S]>0?0:-1,h.strides[S]>0?E:E-1];if(C&&h.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&h.strides[S]===1;const L=!!(h.beginMask&1<<S&&h.endMask&1<<S);if(h.beginValid&&h.endValid){if(C){const j=h.begin[S]<0?E+h.begin[S]:h.begin[S];if(h.begin[S]=j,h.end[S]=h.begin[S]+1,j<0||j>=E)throw Error(`slice index ${h.begin[S]} of dimension ${S} out of bounds.`)}else h.begin[S]=YP(h.begin[S],0,h.strides[S],E,k,R),h.end[S]=YP(h.end[S],1,h.strides[S],E,k,R);const M=h.strides[S]===1&&h.begin[S]===0&&h.end[S]===E;p=p&&M,g=g&&(S===0&&h.strides[S]===1||M)}else p=p&&h.strides[S]===1&&L,g=g&&(S===0&&h.strides[S]===1||L);let I,T=!1;if(h.beginValid&&h.endValid?(I=h.end[S]-h.begin[S],T=!0):C?(I=1,T=!0):L&&E>=0&&(h.strides[S]<0?I=-E:I=E,T=!0),T){let M;I===0||I<0!=h.strides[S]<0?M=0:M=Math.trunc(I/h.strides[S])+(I%h.strides[S]!==0?1:0),x.push(M)}else x.push(-1)}for(let S=0;S<h.finalShapeGatherIndices.length;++S){const C=h.finalShapeGatherIndices[S];C>=0?v.push(x[C]):C===m_&&v.push(1)}return{finalShapeSparse:v.filter((S,C)=>h.finalShapeGatherIndices[C]!==m_),finalShape:v,isIdentity:p,sliceDim0:g,isSimpleSlice:y,begin:h.begin,end:h.end,strides:h.strides}}function Pfe(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(m_),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(Rfe),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function YP(n,e,t,s,i,r){if(i[e])return t>0?r[e]:r[e+1&1];{const o=n<0?s+n:n;return o<r[0]?r[0]:o>r[1]?r[1]:o}}const Dfe=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:uw,computeFlatOffset:YT,computeOutShape:dw,getNormalizedAxes:Nfe,isSliceContinous:KT,maskToAxes:Mfe,parseSliceParams:f1,sliceInfo:hw,startForAxis:C6,startIndicesWithElidedDims:w6,stopForAxis:_6,stopIndicesWithElidedDims:b6,stridesForAxis:S6,stridesWithElidedDims:x6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lfe{static sgd(e){return new qT(e)}static momentum(e,t,s=!1){return new m6(e,t,s)}static rmsprop(e,t=.9,s=0,i=null,r=!1){return new g6(e,t,s,i,r)}static adam(e=.001,t=.9,s=.999,i=null){return new f6(e,t,s,i)}static adadelta(e=.001,t=.95,s=null){return new d6(e,t,s)}static adamax(e=.002,t=.9,s=.999,i=null,r=0){return new p6(e,t,s,i,r)}static adagrad(e,t=.1){return new h6(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gh=Lfe;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $fe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function E6(){return new Promise(n=>$fe(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(n,e){const t=n[0].length;n.forEach((i,r)=>{re(i.length===t,()=>`Error in concat${t}D: rank of tensors[${r}] must be the same as the rank of the rest (${t})`)}),re(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((i,r)=>{for(let o=0;o<t;o++)re(o===e||i[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function Zr(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ta;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Ta||(Ta={}));function T6(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let i=1;i<t.length;++i){const r=t[i],o=s[s.length-t.length+i],a=s[o];if(r>=0)if(a>=0){if(a!==r)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${r} but shape[${i+n}] = ${a}`)}else s[o]=r}return s}function I6(n){const e={FIRST_DIM_SIZE:Ta.FIRST_DIM_SIZE,VALUE_ROWIDS:Ta.VALUE_ROWIDS,ROW_LENGTHS:Ta.ROW_LENGTHS,ROW_SPLITS:Ta.ROW_SPLITS,ROW_LIMITS:Ta.ROW_LIMITS,ROW_STARTS:Ta.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function k6(n){return n.length===0?0:n[0]===Ta.FIRST_DIM_SIZE?n.length-1:n.length}function A6(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(t,s-1);++i){const r=n[i],o=e[i+1];if(r>=0&&o>=0&&r!==1&&r!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${r} but ragged tensor input.flatValues.shape[${i-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZT=30;function pw(n){return n<=ZT?n:e_(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(n,e,t){const s=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[s,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gd(n,e,t,s=!0){let i=[];if(s)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const r=e.length;for(let o=0;o<r;++o)i=i.concat([n[o+1]/e[o],e[o]]);i=i.concat(n.slice(r+1))}return i}function Hd(n,e,t=!0){const s=[];if(t){s.push(e);for(let i=e+1;i<n;++i)i<=2*e?(s.push(i),s.push(i-(e+1))):s.push(i)}else{const i=[],r=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?r.push(o):i.push(o);s.push(...i),s.push(0),s.push(...r)}return s}function jd(n,e,t,s=!0){const i=[];s?i.push(n[0]/t):i.push(n[0]*t);for(let r=1;r<n.length;++r)r<=e.length?s?i.push(e[r-1]*n[r]):i.push(n[r]/e[r-1]):i.push(n[r]);return i}function gw(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function xw(n,e,t){const s=n.slice(0,1);for(let i=0;i<t;++i)s.push(n[i+1]-e[i][0]-e[i][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p1=1.7580993408473768,m1=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vw=.3275911,yw=.254829592,ww=-.284496736,bw=1.421413741,Sw=-1.453152027,Cw=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fa(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function R6(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function M6(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function N6(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function QT(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function P6(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function D6(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const r=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(r),s[i]=Math.sin(r)}return{real:t,imag:s}}function L6(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),i=Math.cos(s),r=Math.sin(s);return{real:i,imag:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YS="->",Ffe=/->/g,ZP=",",QP="...";function _w(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(Ffe,"").length)/YS.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${YS}").`);const[s,i]=n.split(YS);re(s.indexOf(QP)===-1,()=>`The ellipsis notation ("${QP}") is not supported yet.`);const r=s.split(ZP),o=r.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<i.length;++h){const p=i[h];if(!r.some(g=>g.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let h=0;h<s.length;++h){const p=s[h];a.indexOf(p)===-1&&p!==ZP&&a.push(p)}const l=new Array(r.length);for(let h=0;h<o;++h){if(new Set(r[h].split("")).size!==r[h].length)throw new Error(`Found duplicate axes in input component ${r[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<r[h].length;++p)l[h].push(a.indexOf(r[h][p]))}const c=a.length,u=i.length,d=[];for(let h=u;h<c;++h)d.push(h);return{allDims:a,summedDims:d,idDims:l}}function Ew(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const s=[];for(let i=0;i<n;++i)t[i]===-1&&s.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:s}}function Tw(n,e,t){const s=new Array(n);for(let i=0;i<t.length;++i){const r=t[i].shape;for(let o=0;o<e[i].length;++o)s[e[i][o]]===void 0?s[e[i][o]]=r[o]:re(s[e[i][o]]===r[o],()=>`Expected dimension ${s[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(r)}, but got dimension ${r[o]}`)}}function Iw(n,e){const t=n,s=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let o=0;o<i;++o)s.push([]);const r=[];for(let o=0;o<t.length;++o){const a=t[o],l=Ofe(e,a);for(const c of l)r.indexOf(c)===-1&&(s[o].push(c),r.push(c))}return{path:t,steps:s}}function kw(n){return n.every((e,t)=>e===t)}function Ofe(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Aw(n,e,t=0){let s=[];if(typeof e=="number")re(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);re(i<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(r!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[r]=n.shape[t]-o}re(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $6(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function F6(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function O6(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z6(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function B6(n,e){return`size ${n} must be non-negative, not ${e}`}function U6(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function V6(n,e){const t=Le(n),s=Le(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function W6(n,e){const t=Le(n),s=Le(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(){return"segment ids must be >= 0"}function G6(){return"segment ids are not increasing"}function H6(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function j6(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X6(n,e){let t=!1,s;for(n<=ZT?(s=n,t=!0):s=e_(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=e_(n,s+1);return s}function JT(n,e,t){const s=[],i=n.length;for(let r=0;r<i;r++)r!==e?s.push(n[r]):s.push(t);return s}function Rw(n,e,t,s){const i=e.shape.length,r=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>r)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let d=0;d<s;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let d=0;d<s;++d)a.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<t;d++)a.push(n.shape[d]),c*=n.shape[d];for(let d=s;d<i;d++)a.push(e.shape[d]);for(let d=t+1;d<r;d++)a.push(n.shape[d]),u*=n.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const zfe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:Rw,computeOutShape:JT,segOpComputeOptimalWindowSize:X6},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oa(n){try{return n.map(e=>$a(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function q6(n){return n.map(e=>ac(e))}const Bfe=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:yw,ERF_A2:ww,ERF_A3:bw,ERF_A4:Sw,ERF_A5:Cw,ERF_P:vw,PARALLELIZE_THRESHOLD:ZT,get RowPartitionType(){return Ta},SELU_SCALE:m1,SELU_SCALEALPHA:p1,applyActivation:GT,assertAndGetBroadcastShape:Mn,assertAxesAreInnerMostDims:Ai,assertParamsConsistent:fw,assignToTypedArray:P6,axesAreInnerMostDims:IT,calculateShapes:Pl,checkEinsumDimSizes:Tw,checkPadOnDimRoundingMode:to,combineLocations:U5,combineRaggedTensorToTensorShapes:T6,complexWithEvenIndex:M6,complexWithOddIndex:N6,computeConv2DInfo:Js,computeConv3DInfo:Wa,computeDefaultPad:bT,computeDilation2DInfo:gu,computeOptimalWindowSize:pw,computeOutAndReduceShapes:Ci,computeOutShape:Zr,computePool2DInfo:br,computePool3DInfo:Fo,convertConv2DDataFormat:bo,decodeEinsumEquation:_w,eitherStridesOrDilationsAreOne:er,expandShapeToKeepDim:Si,exponent:L6,exponents:D6,fromStringArrayToUint8:q6,fromUint8ToStringArray:Oa,getAxesPermutation:Os,getBroadcastDims:ou,getComplexWithIndex:QT,getEinsumComputePath:Iw,getEinsumPermutation:Ew,getFusedBiasGradient:WT,getFusedDyActivation:VT,getImageCenter:mw,getInnerMostAxes:Ys,getPermuted:Hd,getRaggedRank:k6,getReductionAxes:Wi,getReshaped:Gd,getReshapedPermuted:jd,getRowPartitionTypesHelper:I6,getSliceBeginCoords:gw,getSliceSize:xw,getSparseFillEmptyRowsIndicesDenseShapeMismatch:$6,getSparseFillEmptyRowsNegativeIndexErrorMessage:F6,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:O6,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:U6,getSparseReshapeInputOutputMismatchErrorMessage:W6,getSparseReshapeInputOutputMultipleErrorMessage:V6,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:z6,getSparseReshapeNegativeOutputDimErrorMessage:B6,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:j6,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:g_,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:G6,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:H6,getUndoAxesPermutation:Nl,isIdentityPermutation:kw,log:wae,mergeRealAndImagArrays:Fa,prepareAndValidate:cw,prepareSplitSize:Aw,segment_util:zfe,shouldFuse:HT,slice_util:Dfe,splitRealAndImagArrays:R6,stridesOrDilationsArePositive:Td,tupleValuesAreOne:Ed,upcastType:Ji,validateDefaultValueShape:A6,validateInput:xhe,validateUpdateShape:r6,warn:Ro},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Afe();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K6={kernelName:c0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,h1(Jt(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ufe={kernelName:Zf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Qs(Jt(t,"float32")),i=wr(Pn(Is(1),s));return wi(Cn(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vfe={kernelName:Qf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=wr(Pn(Qs(Jt(t,"float32")),1));return Cn(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wfe={kernelName:Bd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{let a=n;const l=Wi(t.shape,i);return l.length>0&&(a=Sn(a,l)),De(a,t.shape)},b:()=>{let a=n;const l=Wi(s.shape,i);return l.length>0&&(a=Sn(a,l)),De(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gfe={kernelName:py,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,i)=>{t[i]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hfe={kernelName:u0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>xs(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jfe={kernelName:d0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>xs(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xfe={kernelName:Jf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,wr(Pn(Is(1),Qs(Jt(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qfe={kernelName:ep,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=wr(Mt(Is(1),Qs(Jt(t,"float32"))));return Cn(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kfe={kernelName:sp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{const a=Mt(Qs(t),Qs(s));let l=ke(n,Cn(s,a));const c=Wi(t.shape,i);return c.length>0&&(l=Sn(l,c)),De(l,t.shape)},b:()=>{const a=Mt(Qs(t),Qs(s));let l=wi(ke(n,Cn(t,a)));const c=Wi(s.shape,i);return c.length>0&&(l=Sn(l,c)),De(l,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yfe={kernelName:tp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,Mt(Qs(Jt(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zfe={kernelName:np,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,Pn(Is(1),Qs(Jt(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qfe(n,e,t,s,i,r){const o=ge(n,"dy","avgPool3dGrad"),a=ge(e,"input","avgPool3dGrad");let l=o,c=a,u=!1;a.rank===4&&(u=!0,l=De(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),c=De(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),re(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),re(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),to("avgPool3dGrad",i,r);const d={dy:l,input:c},h={filterSize:t,strides:s,pad:i,dimRoundingMode:r},p=Re.runKernel(vy,d,h);return u?De(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Jfe=$e({avgPool3dGrad_:Qfe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const epe={kernelName:f0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:o,dimRoundingMode:a}=t;return{x:()=>Jfe(n,s,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tpe(n,e,t,s,i){const r=ge(n,"dy","avgPoolGrad"),o=ge(e,"input","avgPoolGrad");re(o.rank===r.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${r.rank})`);let a=o,l=r,c=!1;o.rank===3&&(c=!0,a=De(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=De(r,[1,r.shape[0],r.shape[1],r.shape[2]])),re(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),re(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const u={dy:l,input:a},d={filterSize:t,strides:s,pad:i},h=Re.runKernel(xy,u,d);return c?De(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const npe=$e({avgPoolGrad_:tpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const spe={kernelName:h0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:o}=t;return{x:()=>npe(n,s,i,r,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ipe={kernelName:p0,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,i]=e,{transposeA:r,transposeB:o}=t;return!r&&!o?{a:()=>Ts(n,i,!1,!0),b:()=>Ts(s,n,!0,!1)}:!r&&o?{a:()=>Ts(n,i,!1,!1),b:()=>Ts(n,s,!0,!1)}:r&&!o?{a:()=>Ts(i,n,!1,!0),b:()=>Ts(s,n,!1,!1)}:{a:()=>Ts(i,n,!0,!0),b:()=>Ts(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rpe={kernelName:m0,gradFunc:(n,e,t)=>{const{blockShape:s,crops:i}=t;return{x:()=>LT(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ope={kernelName:vae,gradFunc:(n,e,t)=>{const s=t,i=s.inputShape,r=s.shape,o=Array.from(r);for(let l=i.length-1;l>=0;l--)if(i[l]===r[l])o[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>Sn(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ape={kernelName:ip,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lpe={kernelName:rp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cpe={kernelName:op,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:i,clipValueMax:r}=t;return{x:()=>Lr(fc(Vd(s,i),qp(s,r)),n,xs(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const upe={kernelName:g0,inputsToSave:["x"],gradFunc:K6.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dpe={kernelName:x0,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(l=>l.shape),{axis:i}=t,r=Hn(i,e[0].shape)[0],o=s.map(l=>l[r]);return Po(n,o,r).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hpe={kernelName:v0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{dilations:r,strides:o,pad:a,dataFormat:l}=t;return re(Ed(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>_T(s.shape,n,i,o,a,l),filter:()=>UT(s,n,i.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fpe={kernelName:y0,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{strides:r,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>Id(n,i,r,o,a,1,l),filter:()=>UT(n,s,i.shape,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ppe(n,e,t,s,i){let r=n;n.rank===4&&(r=De(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=De(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),re(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),re(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),re(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),re(r.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${t[3]}.`),re(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:r,dy:o},l={strides:s,pad:i,filterShape:t};return Re.runKernel(Sy,a,l)}const mpe=$e({conv3DBackpropFilter_:ppe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gpe={kernelName:w0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r}=t;re(Ed(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,a]=e;return{x:()=>F5(o.shape,n,a,i,r),filter:()=>mpe(o,n,a.shape,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xpe={kernelName:ap,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(wi(t6(Jt(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vpe={kernelName:lp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n6(Jt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ype={kernelName:b0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i,exclusive:r,reverse:o}=t;return{x:()=>{const a=Os([i],s.rank);let l=z5(n,i,r,!o);return a!=null&&(l=gs(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wpe={kernelName:S0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r,dimRoundingMode:o}=t,a=s??[1,1];re(Ed(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,c]=e;return re(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),re(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),re(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),re(er(i,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${a}'.`),to("depthwiseConv2d",r,o),{x:()=>$he(l.shape,n,c,i,r,a,o),filter:()=>Dhe(l,n,c.shape,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bpe={kernelName:C0,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,r={x:s,filter:i,dy:n},o={x:s,filter:i,dy:n};return{x:()=>Re.runKernel(m2,r,t),filter:()=>Re.runKernel(g2,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Spe={kernelName:up,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>Re.runKernel(My,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cpe={kernelName:dp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=ke(_l(wi(Qs(t))),2/Math.sqrt(Math.PI));return{x:()=>ke(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _pe={kernelName:hp,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Epe={kernelName:E0,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>De(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tpe={kernelName:fp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,_l(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ipe={kernelName:pp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kpe={kernelName:mp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{const a=Cn(n,Jt(s,"float32")),l=Wi(t.shape,i);return l.length>0?De(Sn(a,l),t.shape):a},b:()=>{let a=ke(n,Jt(t,"float32"));const l=Wi(s.shape,i);l.length>0&&(a=De(Sn(a,l),s.shape));const c=Qs(s);return wi(Cn(a,Jt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ape={kernelName:T0,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[i,r,o,a]=e,l=a??Is(1),c=Wi(r.shape,i.shape),u=[];if(r.rank===1){for(let C=0;C<i.shape.length-1;++C)u.push(i.shape[C]);u.push(1)}const d=Pn(i,r),h=ke(n,l),p=Q5(Mt(o,Is(s))),g=ke(ke(ke(p,p),p),Is(-.5));return{x:()=>r.rank===1?De(ke(ke(n,ka(De(p,[1,1,1,r.shape[0]]),u)),l),i.shape):De(ke(ke(n,p),l),i.shape),mean:()=>{let C=ke(ke(p,Is(-1)),h);return r.rank===1&&(C=Sn(C,c)),De(C,r.shape)},variance:()=>{let C=ke(ke(g,d),h);return r.rank===1&&(C=Sn(C,c)),De(C,r.shape)},scale:()=>{const C=ke(d,p);let E=ke(n,C);return r.rank===1&&(E=Sn(E,c)),De(E,r.shape)},offset:()=>{let C=n;return r.rank===1&&(C=Sn(C,c)),De(C,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rpe={kernelName:I0,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,i]=e,{axis:r,batchDims:o}=t,a=Hn(r,s.shape)[0],l=(c,u,d)=>()=>{const h=c.shape,p=u.size,g=h.slice(0,a),y=g.length,x=h.slice(r,h.length).slice(1),v=x.length,b=JP(0,y),S=JP(y+1,y+1+v),C=eD([g,[p],x]),E=De(d,C),k=De(u,[p]),R=eD([[y],b,S]),L=gs(E,R);let I=a6(L,k,c.shape[a]);const T=Nl(R);return I=gs(I,T),I};if(o===1){const c=s.shape[0],u=s.split(c,0);return{x:()=>pc(u.map((p,g)=>l(p,i.slice(g,1),n.slice(g,1))())).reshape(s.shape),indices:()=>i}}else return{x:l(s,i,n),indices:()=>i}}};function JP(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function eD(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mpe={kernelName:gp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>xs(t),b:()=>xs(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Npe={kernelName:xp,gradFunc:n=>({x:()=>Jt(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ppe={kernelName:vp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dpe={kernelName:yp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lpe={kernelName:wp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $pe={kernelName:A0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:i}=t,r=Oo(s,0);return{x:()=>Lr(r,n,ke(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fpe={kernelName:Sp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,Mt(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ope={kernelName:bp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,Jt(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zpe={kernelName:yae,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;return{logits:()=>{const o=_l(s);return Pn(n,ke(Sn(n,i,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bpe(n,e,t,s=5,i=1,r=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:s,bias:i,alpha:r,beta:o};return Re.runKernel(Fy,a,l)}const Upe=$e({localResponseNormalizationBackprop_:Bpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpe={kernelName:L0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{depthRadius:r,bias:o,alpha:a,beta:l}=t;return{x:()=>Upe(s,i,n,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6(n,e,t,s){return e.rank<t.rank&&(e=De(e,Si(e.shape,s))),n.rank<t.rank&&(n=De(n,Si(n.shape,s))),{x:()=>ke(n,Jt(Cl(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tD={kernelName:$0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:i}=s,r=e[0],o=e[1],a=Hn(i,r.shape),l=Y6(n,o,r,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wpe={kernelName:Cp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ke(n,Jt(Vd(t,s),"float32")),b:()=>ke(n,Jt(w2(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gpe(n,e,t,s,i,r,o){const a=ge(n,"dy","maxPool3dGrad"),l=ge(e,"input","maxPool3dGrad"),c=ge(t,"output","maxPool3dGrad");let u=a,d=l,h=c,p=!1;l.rank===4&&(p=!0,u=De(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),d=De(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=De(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),re(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),re(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),re(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),to("maxPool3dGrad",r,o);const g={dy:u,input:d,output:h},y={filterSize:s,strides:i,pad:r,dimRoundingMode:o},x=Re.runKernel(zy,g,y);return p?De(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const Hpe=$e({maxPool3dGrad_:Gpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jpe={kernelName:O0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>Hpe(n,s,i,r,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xpe(n,e,t,s,i,r,o){const a=ge(n,"dy","maxPoolGrad"),l=ge(e,"input","maxPoolGrad"),c=ge(t,"output","maxPoolGrad");re(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),re(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),re(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),to("maxPoolGrad",r,o);const u={dy:a,input:l,output:c},d={filterSize:s,strides:i,pad:r,dimRoundingMode:o};return Re.runKernel(Oy,u,d)}const qpe=$e({maxPoolGrad_:Xpe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kpe={kernelName:F0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:o,pad:a}=t;return{x:()=>qpe(n,s,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ype={kernelName:z0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t,r=Hn(i,s.shape),a=Ci(s.shape,r)[1],l=Le(a);return{x:()=>{const u=s.shape.slice();r.forEach(p=>{u[p]=1});const d=De(n,u);return Cn(ke(d,vu(s.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zpe={kernelName:B0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:i}=s,[r,o]=e,a=Hn(i,r.shape),l=Y6(n,o,r,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qpe={kernelName:_p,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>ke(n,Jt(qp(t,s),"float32")),b:()=>ke(n,Jt(Oo(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jpe={kernelName:U0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(o=>o[0]);return{x:()=>Xs(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eme={kernelName:Ep,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{const a=Wi(t.shape,i);return a.length>0?De(Sn(n,a),t.shape):n},b:()=>{const a=ke(n,wi(ow(Cn(t,s)))),l=Wi(s.shape,i);return l.length>0?De(Sn(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tme={kernelName:Tp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{const a=ke(n,Jt(s,"float32")),l=Wi(t.shape,i);return l.length>0?De(Sn(a,l),t.shape):a},b:()=>{const a=ke(n,Jt(t,"float32")),l=Wi(s.shape,i);return l.length>0?De(Sn(a,l),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nme={kernelName:V0,gradFunc:n=>({x:()=>wi(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sme={kernelName:H0,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>Oi(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ime={kernelName:G0,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rme={kernelName:j0,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return Rd(n,s).map(r=>()=>r)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nD={kernelName:X0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(o=>o[0]);return{x:()=>Xs(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ome={kernelName:Ip,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,i]=e,r=t,o=s,a=Mn(r.shape,o.shape);return{a:()=>{const u=Jt(o,"float32");let d=ke(n,ke(u,kd(r,Pn(u,Is(1)))));const h=Wi(r.shape,a);return h.length>0&&(d=Sn(d,h)),De(d,r.shape)},b:()=>{const u=Oo(r,0),d=Lr(u,El(r),xs(r));let h=ke(n,ke(i,d));const p=Wi(o.shape,a);return p.length>0&&(h=Sn(h,p)),De(h,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ame={kernelName:q0,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,i=Oo(t,0);return{x:()=>Lr(i,n,ke(n,s)),alpha:()=>{let r=Lr(i,xs(n),ke(n,t));const o=Wi(s.shape,n.shape);return o.length>0&&(r=Sn(r,o)),De(r,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lme(n,e,t){const s=n.shape.slice();s[t]=1;const i=De(e,s),r=f_(n,t,!0,!1),o=f_(n,t,!0,!0),a=ke(r,o);return ke(i,a)}function cme(n,e,t){const s=n.shape.length,i=s-t.length,r=Os(t,s);let o=n;r!=null&&(o=gs(n,r));const a=o.shape.slice(),c=a.splice(s-t.length,t.length).reduce((h,p)=>h*p,1);a.push(c);const u=o.reshape(a);let d=lme(u,e,i);if(d=d.reshape(o.shape),r!=null){const h=Nl(r);d=gs(d,h)}return d}const ume={kernelName:K0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;let r=[];return i==null?r=s.shape.map((o,a)=>a):typeof i=="number"?r=[i]:r=i,{x:()=>cme(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dme={kernelName:cp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{const a=Cn(n,Jt(s,"float32")),l=Wi(t.shape,i);return l.length>0?De(Sn(a,l),t.shape):a},b:()=>{let a=ke(n,Jt(t,"float32"));const l=Wi(s.shape,i);l.length>0&&(a=De(Sn(a,l),s.shape));const c=Qs(s);return wi(Cn(a,Jt(c,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hme={kernelName:kp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,wi(Qs(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fme={kernelName:Rp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=ke(qp(t,6),h1(t));return{x:()=>ke(n,Jt(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pme={kernelName:Ap,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,Jt(h1(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mme={kernelName:Y0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>De(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gme={kernelName:Q0,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>Re.runKernel(Hy,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xme={kernelName:Z0,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>Re.runKernel(Gy,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vme={kernelName:J0,gradFunc:(n,e,t)=>{const{dims:s}=t,i=Hn(s,n.shape);return{x:()=>Ad(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yme={kernelName:Mp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wme={kernelName:Np,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>wi(Cn(n,ke(kd(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bme={kernelName:e1,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Jt(xs(t),"float32"),t:()=>ke(n,Jt(t,n.dtype)),e:()=>ke(n,Jt(MT(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sme={kernelName:Pp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Oo(t,Is(0)),i=Is(p1),r=Is(m1),o=ke(n,r),a=ke(ke(n,i),_l(Jt(t,"float32")));return Lr(s,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cme={kernelName:Fp,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,ke(t,Pn(Is(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me={kernelName:$p,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eme={kernelName:Dp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(ET(Jt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tme={kernelName:Lp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(O5(Jt(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ime={kernelName:t1,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:i,size:r}=t,o=s.shape,[a,l]=f1(s,i,r),c=[];for(let u=0;u<n.rank;u++)c.push([a[u],o[u]-a[u]-l[u]]);return{x:()=>DT(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kme={kernelName:r1,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:i}=t,r=!0,o=ke(n,s);return{logits:()=>Pn(o,ke(Sn(o,[i],r),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ame={kernelName:Op,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,Xp(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sD={kernelName:s1,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:i}=t;return{x:()=>CT(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iD={kernelName:i1,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>Yr(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rme={kernelName:zp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,ke(wr(Jt(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mme={kernelName:jy,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(n,ke(Jt(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nme={kernelName:Bp,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Is(2);return{a:()=>ke(n,ke(i,Pn(t,s))),b:()=>ke(n,ke(i,Pn(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pme={kernelName:Hp,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dme={kernelName:Up,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Mn(t.shape,s.shape);return{a:()=>{let a=n;const l=Wi(t.shape,i);return l.length>0&&(a=Sn(a,l)),De(a,t.shape)},b:()=>{let a=n;const l=Wi(s.shape,i);return l.length>0&&(a=Sn(a,l)),De(wi(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lme={kernelName:n1,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,i=s.shape.slice(),{axis:r}=t;Hn(r,s.shape).forEach(c=>{i[c]=1});const a=De(n,i),l=ke(a,vu(s.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $me={kernelName:Vp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Cn(n,Qs(ET(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fme={kernelName:Wp,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>ke(Pn(Is(1),Qs(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ome={kernelName:Gp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:i}=t;return{x:()=>{let o=xs(s);if(s.rank===1)for(let a=0;a<i[0];++a)o=Mt(o,Xs(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)o=Mt(o,Xs(n,[a*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)o=Mt(o,Xs(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<i[0];++a)for(let l=0;l<i[1];++l)for(let c=0;c<i[2];++c)for(let u=0;u<i[3];++u)o=Mt(o,Xs(n,[a*s.shape[0],l*s.shape[1],c*s.shape[2],u*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zme={kernelName:fd,gradFunc:(n,e,t)=>{const s=t,{perm:i}=s,r=Nl(i);return{x:()=>gs(n,r)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bme={kernelName:o1,gradFunc:(n,e,t)=>{const s=t,{axis:i}=s;return{value:()=>pc(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ume={kernelName:a1,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Vme(n,t)}}};function Vme(n,e){const t=xu(e,xs(e)),s=kT(n,t);let i=Vd(e,Is(0,"int32"));const r=s.rank-i.rank;for(let a=0;a<r;++a)i=jr(i,a+1);i=fc(i,vu(s.shape,"bool"));const o=xs(s);return Lr(i,s,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wme={kernelName:l1,gradFunc:n=>({x:()=>xs(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gme=[K6,Ufe,Vfe,Wfe,Gfe,Hfe,jfe,Xfe,qfe,Kfe,Yfe,Zfe,epe,spe,ipe,rpe,ope,ape,lpe,cpe,upe,dpe,fpe,hpe,gpe,xpe,vpe,ype,wpe,bpe,dme,Spe,Cpe,_pe,Epe,Tpe,kpe,Ipe,Ape,Rpe,Mpe,Npe,Ppe,Dpe,Lpe,$pe,Fpe,Ope,zpe,Vpe,tD,tD,Wpe,jpe,Kpe,Ype,Zpe,Qpe,Jpe,eme,tme,nme,sme,ime,rme,nD,nD,ome,ame,ume,hme,fme,pme,mme,gme,xme,vme,yme,wme,bme,Sme,Cme,_me,Eme,Tme,Ime,kme,Ame,sD,sD,iD,iD,Rme,Nme,Mme,Pme,Dme,Lme,$me,Fme,Ome,zme,Bme,Ume,Wme];for(const n of Gme)bae(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.abs=function(){return this.throwIfDisposed(),Nr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.acos=function(){return this.throwIfDisposed(),_le(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.acosh=function(){return this.throwIfDisposed(),Tle(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.add=function(n){return this.throwIfDisposed(),Mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.all=function(n,e){return this.throwIfDisposed(),D5(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.any=function(n,e){return this.throwIfDisposed(),d_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.argMax=function(n){return this.throwIfDisposed(),$g(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.argMin=function(n){return this.throwIfDisposed(),Mle(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.asScalar=function(){return this.throwIfDisposed(),re(this.size===1,()=>"The array must have only 1 element."),De(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.asType=function(n){return this.throwIfDisposed(),Jt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.as1D=function(){return this.throwIfDisposed(),De(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.as2D=function(n,e){return this.throwIfDisposed(),De(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),De(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),De(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.as5D=function(n,e,t,s,i){return this.throwIfDisposed(),De(this,[n,e,t,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.asin=function(){return this.throwIfDisposed(),Ple(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.asinh=function(){return this.throwIfDisposed(),Lle(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.atan=function(){return this.throwIfDisposed(),Fle(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.atan2=function(n){return this.throwIfDisposed(),zle(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.atanh=function(){return this.throwIfDisposed(),Ule(this)};it().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),ST(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),CT(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.batchNorm=function(n,e,t,s,i){return this.throwIfDisposed(),nw(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Sg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.cast=function(n){return this.throwIfDisposed(),Jt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.ceil=function(){return this.throwIfDisposed(),pce(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),Lo(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Fi&&(n=[n]),Yr([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.conv1d=function(n,e,t,s,i,r){return this.throwIfDisposed(),L5(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.conv2dTranspose=function(n,e,t,s,i){return this.throwIfDisposed(),$5(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.conv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),Id(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.cos=function(){return this.throwIfDisposed(),ET(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.cosh=function(){return this.throwIfDisposed(),O5(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),f_(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),z5(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),zce(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.depthwiseConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),TT(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.dilation2d=function(n,e,t,s,i){return this.throwIfDisposed(),Vce(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.divNoNan=function(n){return this.throwIfDisposed(),Xce(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.div=function(n){return this.throwIfDisposed(),Cn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.dot=function(n){return this.throwIfDisposed(),Kce(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.elu=function(){return this.throwIfDisposed(),iw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.equal=function(n){return this.throwIfDisposed(),Cl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.erf=function(){return this.throwIfDisposed(),B5(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),aue(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.exp=function(){return this.throwIfDisposed(),_l(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.expandDims=function(n){return this.throwIfDisposed(),jr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.expm1=function(){return this.throwIfDisposed(),due(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.fft=function(){return this.throwIfDisposed(),i6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.flatten=function(){return this.throwIfDisposed(),De(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.floor=function(){return this.throwIfDisposed(),ow(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.floorDiv=function(n){return this.throwIfDisposed(),P5(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.gather=function(n,e,t){return this.throwIfDisposed(),kT(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Vd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.greater=function(n){return this.throwIfDisposed(),Oo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.ifft=function(){return this.throwIfDisposed(),p_(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.irfft=function(){return this.throwIfDisposed(),ihe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.isFinite=function(){return this.throwIfDisposed(),wue(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.isInf=function(){return this.throwIfDisposed(),Sue(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.isNaN=function(){return this.throwIfDisposed(),_ue(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.leakyRelu=function(n){return this.throwIfDisposed(),RT(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.lessEqual=function(n){return this.throwIfDisposed(),qp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.less=function(n){return this.throwIfDisposed(),w2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),Aue(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logSigmoid=function(){return this.throwIfDisposed(),$ue(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logSoftmax=function(n){return this.throwIfDisposed(),H5(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),j5(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.log=function(){return this.throwIfDisposed(),El(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.log1p=function(){return this.throwIfDisposed(),G5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logicalAnd=function(n){return this.throwIfDisposed(),fc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logicalNot=function(){return this.throwIfDisposed(),MT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logicalOr=function(n){return this.throwIfDisposed(),X5(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.logicalXor=function(n){return this.throwIfDisposed(),Gue(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Ts(this,n,e,t)};it().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),NT(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.max=function(n,e){return this.throwIfDisposed(),Na(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.maximum=function(n){return this.throwIfDisposed(),xu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.mean=function(n,e){return this.throwIfDisposed(),ki(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.min=function(n,e){return this.throwIfDisposed(),y2(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.minimum=function(n){return this.throwIfDisposed(),zg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),Que(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.mod=function(n){return this.throwIfDisposed(),ede(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.mul=function(n){return this.throwIfDisposed(),ke(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.neg=function(){return this.throwIfDisposed(),wi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.norm=function(n,e,t){return this.throwIfDisposed(),rw(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.notEqual=function(n){return this.throwIfDisposed(),b2(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),q5(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.onesLike=function(){return this.throwIfDisposed(),aa(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.pad=function(n,e){return this.throwIfDisposed(),DT(this,n,e)};it().prototype.pool=function(n,e,t,s,i,r){return this.throwIfDisposed(),ude(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.pow=function(n){return this.throwIfDisposed(),kd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.prelu=function(n){return this.throwIfDisposed(),$T(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.prod=function(n,e){return this.throwIfDisposed(),fde(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.reciprocal=function(){return this.throwIfDisposed(),Ode(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.relu=function(){return this.throwIfDisposed(),Wd(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.relu6=function(){return this.throwIfDisposed(),Y5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.reshapeAs=function(n){return this.throwIfDisposed(),De(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.reshape=function(n){return this.throwIfDisposed(),De(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),c6(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),u6(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.reverse=function(n){return this.throwIfDisposed(),Ad(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.rfft=function(){return this.throwIfDisposed(),ahe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.round=function(){return this.throwIfDisposed(),Z5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.rsqrt=function(){return this.throwIfDisposed(),Q5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.selu=function(){return this.throwIfDisposed(),J5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.separableConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),e6(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sigmoid=function(){return this.throwIfDisposed(),Xp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sign=function(){return this.throwIfDisposed(),Xde(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sin=function(){return this.throwIfDisposed(),t6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sinh=function(){return this.throwIfDisposed(),n6(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.slice=function(n,e){return this.throwIfDisposed(),Xs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.softmax=function(n){return this.throwIfDisposed(),BT(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.softplus=function(){return this.throwIfDisposed(),c1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),LT(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.split=function(n,e){return this.throwIfDisposed(),Po(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sqrt=function(){return this.throwIfDisposed(),wr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.square=function(){return this.throwIfDisposed(),Qs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.squaredDifference=function(n){return this.throwIfDisposed(),che(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.squeeze=function(n){return this.throwIfDisposed(),d1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Fi?[this,n]:[this,...n];return pc(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.step=function(n){return this.throwIfDisposed(),h1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.stridedSlice=function(n,e,t,s,i,r,o,a){return this.throwIfDisposed(),phe(this,n,e,t,s,i,r,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sub=function(n){return this.throwIfDisposed(),Pn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.sum=function(n,e){return this.throwIfDisposed(),Sn(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.tan=function(){return this.throwIfDisposed(),ghe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.tanh=function(){return this.throwIfDisposed(),tw(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.tile=function(n){return this.throwIfDisposed(),ka(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.toBool=function(){return this.throwIfDisposed(),Jt(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.toFloat=function(){return this.throwIfDisposed(),Jt(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.toInt=function(){return this.throwIfDisposed(),Jt(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.topk=function(n,e){return this.throwIfDisposed(),yhe(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.transpose=function(n){return this.throwIfDisposed(),gs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.unique=function(n){return this.throwIfDisposed(),She(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),a6(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.unstack=function(n){return this.throwIfDisposed(),Rd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.where=function(n,e){return this.throwIfDisposed(),Lr(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */it().prototype.zerosLike=function(){return this.throwIfDisposed(),xs(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class il extends Error{constructor(e){super(e),Object.setPrototypeOf(this,il.prototype)}}class ia extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ia.prototype)}}class Te extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Te.prototype)}}class ts extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ts.prototype)}}class eI extends Error{constructor(e){super(e),Object.setPrototypeOf(this,eI.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Z6{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Md(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function rl(n,e){if(!n)throw new eI(e)}function rD(n,e){let t=0;for(const s of n)s===e&&t++;return t}function Xr(n){return n.length===1?n[0]:n}function Ns(n){return Array.isArray(n)?n:[n]}function tc(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function td(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Ko={};function tI(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function x_(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>x_(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:x_(s))}}}function g1(n,e={},t={},s="object",i=!1){if(typeof n=="string"){const r=n;let o;if(r in t)o=t[r];else if(r in Ko)o=Ko[r];else if(o=e[r],o==null)throw new Te(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const r=n;if(r.className==null||r.config==null)throw new Te(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const o=r.className;let a,l;if(o in t?[a,l]=t[o]:o in Ko?[a,l]=Ko.className:o in e&&([a,l]=e[o]),a==null)throw new Te(`Unknown ${s}: ${o}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const p of Object.keys(Ko))c[p]=Ko[p];for(const p of Object.keys(t))c[p]=t[p];const u=r.config;u.customObjects=c;const d=Object.assign({},Ko);for(const p of Object.keys(t))Ko[p]=t[p];x_(r.config);const h=l(a,r.config,t,i);return Ko=Object.assign({},d),h}else{const c=Object.assign({},Ko);for(const d of Object.keys(t))Ko[d]=t[d];const u=new a(r.config);return Ko=Object.assign({},c),u}}}function Hme(n,e){return n<e?-1:n>e?1:0}function fv(n,e){return-1*Hme(n,e)}function nu(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function jme(n){if(n==null)throw new Te(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Xd(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new Te(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function nI(n,e,t=0,s=1/0){return rl(t>=0),rl(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(i=>typeof i===e)}function Ki(n,e){Array.isArray(n)?(re(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Ki(t,`element ${s+1} of ${e}`))):re(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Q6(n)}.`)}function Q6(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Q6(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function Xme(n,e,t){let s=t!=null?t():Gr(),i;return(...o)=>{const a=t!=null?t():Gr();return a-s<e||(s=a,i=n(...o)),i}}function J6(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let qme=0;function ez(){return qme++}const pv={};function Mw(n=""){return n in pv||(pv[n]=0),pv[n]+=1,n+pv[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Kme=["channelsFirst","channelsLast"],Yme=["nearest","bilinear"],Zme=["valid","same","causal"],Qme=["max","avg"],Jme=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Hh=new Map;function _i(n){Xd(Kme,"DataFormat",n)}function ege(n){Xd(Yme,"InterpolationFormat",n)}function zo(n){Xd(Zme,"PaddingMode",n)}function tz(n){Xd(Qme,"PoolMode",n)}const Cg=[],oD="/";function md(n,e){Cg.push(n);try{const t=e();return Cg.pop(),t}catch(t){throw Cg.pop(),t}}function tge(){return Cg.length===0?"":Cg.join(oD)+oD}function nz(n){if(!iz(n))throw new Error("Not a valid tensor name: '"+n+"'");return tge()+n}function sz(n){if(!iz(n))throw new Error("Not a valid tensor name: '"+n+"'");Hh.has(n)||Hh.set(n,0);const e=Hh.get(n);if(Hh.set(n,Hh.get(n)+1),e>0){const t=`${n}_${e}`;return Hh.set(t,1),t}else return n}const nge=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function iz(n){return!!n.match(nge)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sge(n){return n===parseInt(n.toString(),10)}function su(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let i=e;i<t;++i)s*=n[i];return s}function Pf(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function au(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function za(n,e){if(e<n)throw new Te(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ZS;function zi(){return ZS==null&&(ZS=qae().epsilon()),ZS}function Ba(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vl(n,e){return Jt(n,e)}function x1(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),De(n,t)}function ige(n,e){return je(()=>{if(n.shape.length!==2)throw new Te(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=x1(n,1);return v_(t,[1,e,1])})}function rge(n){const e=[su(n.shape)];return De(n,e)}function oge(n){if(n.rank<=1)throw new Te(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],su(n.shape,1)];return De(n,e)}function gd(n,e,t){return je(()=>{switch(n.rank){case 1:return OT(n,e,t);case 2:return s6(n,[e,0],[t,n.shape[1]]);case 3:return zT(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return C2(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Xs(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Xs(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Te(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function QS(n,e,t){return je(()=>{switch(n.rank){case 1:return OT(n,e,t);case 2:return s6(n,[0,e],[n.shape[0],t]);case 3:return zT(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return C2(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new Te(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function mv(n,e,t,s){return je(()=>{switch(n.rank){case 1:return OT(n,e,t);case 2:switch(s){case 1:return gd(n,e,t);case 2:return QS(n,e,t);default:throw new Te(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return gd(n,e,t);case 2:return zT(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return QS(n,e,t);default:throw new Te(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return gd(n,e,t);case 2:return C2(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return C2(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return QS(n,e,t);default:throw new Te(`The axis is not within the rank of the tensor ${s}`)}default:throw new Te(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function sI(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Yr(n,e)}function aD(n,e){switch(n.rank){case 1:return xce([n,e]);case 2:return yce([n,e],0);case 3:return bce([n,e],0);case 4:return Cce([n,e],0);default:throw new Te(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function v_(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new Te(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return ka(n,e)}function Nw(n,e=0,t=1,s,i){return Dde(n,e,t,s,i)}function yl(n,e,t,s){if(n.rank<2||e.rank<2)throw new ts(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],r=e.shape.slice(-2)[0];if(i!==r)throw new ts(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return XP({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?y_(n.rank,s,Ba()):null,activation:t});{const i=n.shape.slice(),r=i.pop();n=De(n,[-1,r]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),c=[...o,a],u=Array.from({length:e.rank},(g,y)=>y===0?e.rank-2:y<=e.rank-2?y-1:y);e=De(gs(e,u),[l,-1]);const d=[...i,...c];return De(XP({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?y_(n.rank,s,Ba()):null,activation:t}),d)}}function rz(n,e,t){return je(()=>(Array.isArray(e)?e=go(e,"int32"):e=Jt(e,"int32"),kT(n,e,t)))}function v1(n){return ke(n,n)}function y_(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new Te(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?De(e,[1,s[0],1,1,1]):De(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?De(e,[1,1,1,1,s[0]]):De(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?De(e,[1,s[0],1,1]):De(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?De(e,[1,1,1,s[0]]):De(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?De(e,[1,s[0],1]):De(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?De(e,[1,1,s[0]]):De(e,[1].concat(s))}else if(n<3)return e;throw new Te(`Unsupported input rank by biasAdd: ${e.rank}`)}function Ga(n,e,t){return je(()=>(t==null&&(t=Ba()),_i(t),Mt(n,y_(n.rank,e,t))))}function age(n,e=1){if(e!==1)throw new ts(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return iw(n)}function lge(n){return je(()=>Cn(n,Mt(Nr(n),1)))}function oz(n,e,t,s){return je(()=>Ahe(n,e,t,s))}function cge(n){return je(()=>{const e=Mt(.5,ke(.2,n));return Lo(e,0,1)})}function y1(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const uge=["fanIn","fanOut","fanAvg"],dge=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hge(n){Xd(uge,"FanMode",n)}function fge(n){Xd(dge,"Distribution",n)}class la extends Yp{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class az extends la{apply(e,t){return Oi(e,t)}}az.className="Zeros";yt(az);class iI extends la{apply(e,t){return vu(e,t)}}iI.className="Ones";yt(iI);class lz extends la{constructor(e){if(super(),typeof e!="object")throw new Te(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Te(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return je(()=>ke(Is(this.value),vu(e,t)))}getConfig(){return{value:this.value}}}lz.className="Constant";yt(lz);class cz extends la{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return u1(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}cz.className="RandomUniform";yt(cz);class uz extends la{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ts(`randomNormal does not support dType ${t}.`);return Nw(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}uz.className="RandomNormal";yt(uz);class dz extends la{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ts(`truncatedNormal does not support dType ${t}.`);return o6(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dz.className="TruncatedNormal";yt(dz);class hz extends la{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return je(()=>{if(e.length!==2||e[0]!==e[1])throw new Te("Identity matrix initializer can only be used for 2D square matrices.");return ke(this.gain,W5(e[0]))})}getConfig(){return{gain:this.gain}}}hz.className="Identity";yt(hz);function pge(n,e="channelsLast"){let t,s;if(_i(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=su(n,2);t=n[1]*i,s=n[0]*i}else if(e==="channelsLast"){const i=su(n,0,n.length-2);t=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=su(n);t=Math.sqrt(i),s=Math.sqrt(i)}return[t,s]}class vo extends la{constructor(e){if(super(),e.scale<0)throw new Te(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,hge(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,fge(this.distribution),this.seed=e.seed}apply(e,t){const s=pge(e),i=s[0],r=s[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,i):this.mode==="fanOut"?o/=Math.max(1,r):o/=Math.max(1,(i+r)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ts(`${this.getClassName()} does not support dType ${t}.`);return o6(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return u1(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}vo.className="VarianceScaling";yt(vo);class rI extends vo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return vo.className}}rI.className="GlorotUniform";yt(rI);class oI extends vo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return vo.className}}oI.className="GlorotNormal";yt(oI);class aI extends vo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return vo.className}}aI.className="HeNormal";yt(aI);class lI extends vo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return vo.className}}lI.className="HeUniform";yt(lI);class cI extends vo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return vo.className}}cI.className="LeCunNormal";yt(cI);class uI extends vo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return vo.className}}uI.className="LeCunUniform";yt(uI);class fz extends la{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return je(()=>{if(e.length<2)throw new ts("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const s=Le(e.slice(0,-1)),i=e[e.length-1],r=s*i;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const o=[Math.max(i,s),Math.min(i,s)],a=Nw(o,0,1,t,this.seed),l=Efe.qr(a,!1);let c=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(i,s)*Math.min(i,s)],[Math.min(i,s)+1]);return c=ke(c,d.sign()),s<i&&(c=c.transpose()),ke(Is(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}fz.className="Orthogonal";yt(fz);const lD={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function cD(n,e={}){return g1(n,sa.getMap().classNameMap,e,"initializer")}function li(n){return tI(n)}function ii(n){if(typeof n=="string"){const e=n in lD?lD[n]:n;if(e==="GlorotNormal")return new oI;if(e==="GlorotUniform")return new rI;if(e==="HeNormal")return new aI;if(e==="HeUniform")return new lI;if(e==="LeCunNormal")return new cI;if(e==="LeCunUniform")return new uI;{const t={};return t.className=e,t.config={},cD(t)}}else return n instanceof la?n:cD(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function w_(n){return Array.isArray(n)&&Array.isArray(n[0])}function _2(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function On(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new Te(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function bs(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new Te(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function E2(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,i)=>s*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const uD="Variable";class mge{constructor(e,t="float32",s=uD,i=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=ez(),s=s??uD,this.originalName=nz(s),this.name=sz(this.originalName),this.trainable_=i,this.constraint=r,this.val=Ehe(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),gge(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function gge(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function b_(n){return n.map(e=>e.read())}function dI(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Bi{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Tl{constructor(e,t,s,i,r,o,a){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=i,this.callArgs=r,this.outputTensorIndex=a,this.id=ez(),o!=null&&(this.originalName=nz(o),this.name=sz(this.originalName)),this.rank=t.length}}let xge=0;class Pw{constructor(e,t){this.callArgs=t,this.id=xge++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let vge=0;class rs extends Yp{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=vge++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=tc(s)+"_"+Mw(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),s=[r].concat(e.inputShape)}this.batchInputShape=s;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new ia(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Te(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Xr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Xr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new il(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new il(`Layer ${this.name} is not connected, no input to return.`);return Xr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new il(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new il(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Xr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ns(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=Ns(this.inputSpec);if(t.length!==s.length)throw new Te(`Layer ${this.name} expects ${s.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let i=0;i<t.length;i++){const r=t[i],o=s[i];if(o==null)continue;const a=r.rank;if(o.ndim!=null&&a!==o.ndim)throw new Te(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new Te(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new Te(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&r.dtype!==o.dtype)throw new Te(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${r.dtype}.`);if(o.axes){const l=r.shape;for(const c in o.axes){const u=Number(c),d=o.axes[c],h=u>=0?l[u]:l[l.length+u];if(d!=null&&[d,null].indexOf(h)===-1)throw new Te(`Input ${i} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${d} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const c=o.shape[l],u=r.shape[l];if(c!=null&&u!=null&&c!==u)throw new Te(`Input ${i} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Ns(e),i=bge(e),r=Sge(e);if(i===r)throw new Te("Arguments to apply() must be all SymbolicTensors or all Tensors");return md(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Ns(e))o.push(a.shape);this.build(Xr(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Ns(o),l=[];for(let c of a)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(o=Xr(l),this.activityRegularizer!=null)throw new ts("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=yge(e),a=this.computeOutputShape(o);let l;const c=wge(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,d)=>new Tl(c,u,this,Ns(e),t,this.name,d)):l=new Tl(c,a,this,Ns(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new ts("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&e[i]!=null&&e[i]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new il(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new il(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ia(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return E2(this.weights)}build(e){this.built=!0}getWeights(e=!1){return b_(e?this.trainableWeights:this.weights)}setWeights(e){je(()=>{const t=this.weights;if(t.length!==e.length)throw new Te(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],i=b_(t);for(let r=0;r<i.length;++r){const o=i[r],a=t[r],l=e[r];if(!ds(o.shape,l.shape))throw new Te(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([a,l])}dI(s)})}addWeight(e,t,s,i,r,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new Te(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():ii("zeros"));const c=i.apply(t,s),u=new mge(c,s,e,o,a);return c.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),o==null&&(o=!0),o?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ns(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,s){if(!this.supportsMasking)return;const i=this.computeMask(e,s),r=Ns(t),o=Ns(i);if(r.length!==o.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let a=0;a<r.length;a++)r[a].kerasMask=o[a]}addInboundNode(e,t,s,i,r,o,a=null){const l=Ns(e);t=Ns(t),s=Ns(s),i=Ns(i),r=_2(r),o=_2(o);const c=[],u=[],d=[];for(const h of l)c.push(h.sourceLayer),u.push(h.nodeIndex),d.push(h.tensorIndex);new Pw({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:d,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:i,inputShapes:r,outputShapes:o},a);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function yge(n){n=Ns(n);const e=[];for(const t of n)e.push(t.shape);return Xr(e)}function wge(n){return"float32"}function pz(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let r=0;r<s.inboundLayers.length;r++){const o=s.inputTensors[r],a=s.inboundLayers[r],l=s.nodeIndices[r],c=pz(o,a,l);for(const u of c)i.indexOf(u)===-1&&i.push(u)}return i}}}function bge(n){let e=!0;for(const t of Ns(n))if(!(t instanceof Tl)){e=!1;break}return e}function Sge(n){let e=!0;for(const t of Ns(n))if(t instanceof Tl){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class w1 extends rs{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Mw("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Te("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Te("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Te("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const i=new Tl(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new Pw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Te(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}w1.className="InputLayer";yt(w1);function Cge(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new Te("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new w1({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _ge(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Jt(e,n.dtype)}catch{throw new Te(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Yc{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Yc)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=_ge(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new Te(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Tl){if(this.id2Value[e.id]==null)throw new Te(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Te(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Tl){if(this.id2Value[e.id]==null)throw new Te(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Te(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&os(this.id2Mask)}}const T2=new Z6,I2=new Z6;function Ege(n){T2!=null&&T2.setMaxEntries(n),I2!=null&&I2.setMaxEntries(n)}function rg(n,e,t,s){const i=t==null?!1:t.training,r=Array.isArray(n),o=r?n:[n],a=o.map(g=>g.name),l=[],c=e.names();for(const g of a)c.indexOf(g)!==-1?l.push(e.getValue(g)):l.push(null);const u=a.join(",")+"|"+e.names().sort().join(",");let d=T2.get(u),h;if(d==null){const g=Tge(o,e);d=g.sorted,h=g.recipientCounts,T2.put(u,d),I2.put(u,h)}h={},i||Object.assign(h,I2.get(u));const p=new Yc(e);for(let g=0;g<d.length;++g){const y=d[g],x=y.sourceLayer;if(x instanceof w1)continue;const v=[],b=[],S=[];let C=!1;for(const I of y.inputs){const T=p.getValue(I),M=p.getMask(I);v.push(T),b.push(M),M!=null&&(C=!0),i||(h[I.name]--,h[I.name]===0&&!e.hasKey(I)&&a.indexOf(I.name)===-1&&!T.isDisposed&&I.sourceLayer.stateful!==!0&&S.push(T))}C&&(t=t||{},t.mask=b[0]);const E=Ns(x.apply(v,t));let k=null;x.supportsMasking&&(k=x.computeMask(v,b));const R=kge(y),L=Array.isArray(R)?R:[R];for(let I=0;I<L.length;++I){p.hasKey(L[I])||p.add(L[I],E[I],Array.isArray(k)?k[0]:k);const T=a.indexOf(L[I].name);T!==-1&&(l[T]=E[I])}i||os(S)}return p.disposeMasks(),r?l:l[0]}function Tge(n,e){re(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const i=dD(n[0],e);t=i.sorted,s=i.recipientMap}else{const i=new Set;for(const r of n){const{sorted:o,recipientMap:a}=dD(r,e);for(const l of o)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in a)s[l]==null&&(s[l]=new Set),a[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:Ige(s)}}function Ige(n){const e={};for(const t in n)e[t]=n[t].size;return e}function dD(n,e){const t=new Set,s=[],i={};for(const a of e.names())t.add(a);const r=[],o=[];for(r.push(n);r.length>0;){const a=r[r.length-1];if(t.has(a.name)){r.pop();continue}const l=o[o.length-1]===r.length-1;if(a.inputs.length===0||l)r.pop(),s.push(a),t.add(a.name),l&&o.pop();else{o.push(r.length-1);for(const c of a.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(a.name),!t.has(c.name)&&r.push(c)}}return{sorted:s,recipientMap:i}}function kge(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Age=ze();Age.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Ege);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hI(n,e){return je(()=>wr(Sn(ke(n,n),e,!0)))}class b1 extends Yp{getConfig(){return{}}}class mz extends b1{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return je(()=>{const t=hI(e,this.axis),s=Lo(t,0,this.maxValue);return ke(e,Cn(s,Mt(zi(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}mz.className="MaxNorm";yt(mz);class gz extends b1{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return je(()=>Cn(e,Mt(zi(),hI(e,this.axis))))}getConfig(){return{axis:this.axis}}}gz.className="UnitNorm";yt(gz);class xz extends b1{apply(e){return Wd(e)}}xz.className="NonNeg";yt(xz);class vz extends b1{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return je(()=>{const t=hI(e,this.axis),s=Mt(ke(this.rate,Lo(t,this.minValue,this.maxValue)),ke(1-this.rate,t));return ke(e,Cn(s,Mt(zi(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}vz.className="MinMaxNorm";yt(vz);const hD={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ui(n){return tI(n)}function fD(n,e={}){return g1(n,sa.getMap().classNameMap,e,"constraint")}function Vi(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in hD?hD[n]:n,config:{}};return fD(t)}else return n instanceof b1?n:fD(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Wu(n){if(n==null)return;const e=[],t=[],s=[];for(const i in n){const r=n[i];if(typeof r!="number"){const o=r;e.push(o.data()),t.push(i),s.push(o)}}if(e.length>0){const i=await Promise.all(e);for(let r=0;r<i.length;++r)n[t[r]]=i[r][0];os(s)}}function yz(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var pD;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(pD||(pD={}));const Rge=125;class Ug{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Mge{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Nge extends Ug{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const i in t){const r=t[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*s;else{let o;i in this.totals?o=this.totals[i]:this.totals[i]=0;const a=je(()=>Mt(this.totals[i],ke(r,s)));this.totals[i]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:je(()=>{const i=ke(Cn(1,this.seen),this.totals[s]);t[s]=i,this.totals[s].dispose(),xl(t[s])}))}}class Pge extends Ug{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const r in this.history){const o=this.history[r];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(r),s.push(a)}}const i=await Promise.all(e);for(let r=0;r<i.length;++r)this.history[t[r]][s[r]].dispose(),this.history[t[r]][s[r]]=i[r][0]}}class Dge extends Ug{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||E6,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Rge),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");QC(this.yieldEvery)&&(this.maybeWait=Xme(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const i=[];this.yield!=null&&(await Wu(s),i.push(this.yield(e,t,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Wu(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await Wu(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Wu(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await Wu(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):QC(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await Wu(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Wu(e),await this.trainEnd(e))}}function wz(n,e){return n==null&&(n={}),n instanceof Ug?[n]:Array.isArray(n)&&n[0]instanceof Ug?n:Ns(n).map(s=>new Dge(s,e))}class Jo{constructor(){}static registerCallbackConstructor(e,t){re(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Jo.checkForDuplicate(t),Jo.constructors[e]==null&&(Jo.constructors[e]=[]),Jo.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Jo.constructors)Jo.constructors[+t].forEach(i=>{if(i===e)throw new Te("Duplicate callback constructor.")})}static clear(){Jo.constructors={}}static createCallbacks(e){const t=[];for(const s in Jo.constructors){const i=+s;e>=i&&t.push(...Jo.constructors[i])}return t.map(s=>new s)}}Jo.constructors={};function bz(n,e,t,s,i,r,o,a,l){const c=new Pge,u=[new Nge,...Jo.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const d=new Mge(u);return d.setParams({epochs:t,initialEpoch:s,samples:i,steps:r,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:d,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lc(n,e={},t=!1){return g1(n,sa.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function k2(n,e){return je(()=>{n.dtype!=="float32"&&(n=Jt(n,"float32"));const t=Sn(v1(n),e,!0),s=sw(t.shape,zi()),i=wr(xu(t,s));return Cn(n,i)})}function Dw(n,e){return je(()=>ki(v1(Pn(e,n)),-1))}function fI(n,e){return je(()=>ki(Nr(Pn(e,n)),-1))}function pI(n,e){return je(()=>{const t=Pn(n,e),s=Lo(Nr(n),zi(),Number.MAX_VALUE),i=Nr(Cn(t,s));return ke(100,ki(i,-1))})}function Lge(n,e){return je(()=>{const t=Lo(e,zi(),Number.MAX_VALUE),s=El(Mt(1,t)),i=Lo(n,zi(),Number.MAX_VALUE),r=El(Mt(1,i));return ki(v1(Pn(s,r)),-1)})}function $ge(n,e){return je(()=>{const t=xu(0,Pn(1,ke(n,e)));return ki(v1(t),-1)})}function Fge(n,e){return je(()=>{const t=xu(0,Pn(1,ke(n,e)));return ki(t,-1)})}function Oge(n,e){return je(()=>{const t=Sn(ke(n,e),-1),s=Na(ke(Pn(1,n),e),-1);return xu(0,Mt(1,Pn(s,t)))})}function zge(n,e){return je(()=>{const t=Math.log(2),s=Pn(e,n),i=Pn(Mt(s,c1(ke(-2,s))),t);return ki(i,-1)})}function Vg(n,e,t=!1){return je(()=>{if(t)e=BT(e);else{const s=Sn(e,e.shape.length-1,!0);e=Cn(e,s)}return e=Lo(e,zi(),1-zi()),wi(Sn(ke(Jt(n,"float32"),El(e)),e.shape.length-1))})}function A2(n,e,t=!1){return je(()=>{const s=Jt(ow(rge(n)),"int32");e=Lo(e,zi(),1-zi());const i=e.shape,r=De(q5(s,i[i.length-1]),i);return Vg(r,e,t)})}function Bge(n,e){if(!ds(n.shape,e.shape))throw new Te(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return je(()=>{const t=Wd(e),s=wi(Nr(e));return Mt(Pn(t,ke(e,n)),G5(_l(s)))})}function Lw(n,e){return je(()=>{let t;return t=Lo(e,zi(),1-zi()),t=El(Cn(t,Pn(1,t))),ki(Bge(n,t),-1)})}function Uge(n,e){return je(()=>{const t=Lo(n,zi(),1),s=Lo(e,zi(),1);return Sn(ke(n,El(Cn(t,s))),-1)})}function Vge(n,e){return je(()=>{const t=El(Mt(zi(),e));return ki(Pn(e,ke(n,t)),-1)})}function Sz(n,e){return je(()=>{const t=k2(n,-1),s=k2(e,-1),i=ke(t,s);return wi(Sn(i,-1))})}const R2={meanSquaredError:Dw,meanAbsoluteError:fI,meanAbsolutePercentageError:pI,meanSquaredLogarithmicError:Lge,squaredHinge:$ge,hinge:Fge,categoricalHinge:Oge,logcosh:zge,categoricalCrossentropy:Vg,sparseCategoricalCrossentropy:A2,binaryCrossentropy:Lw,kullbackLeiblerDivergence:Uge,poisson:Vge,cosineProximity:Sz};function JS(n){if(typeof n=="string"){if(n in R2)return R2[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Te(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cz(n,e){return je(()=>{const t=ke(.5,aa(e)),s=vl(Oo(e,t),n.dtype);return ki(Cl(n,s),-1)})}function _z(n,e){return je(()=>vl(Cl($g(n,-1),$g(e,-1)),"float32"))}function Wge(n,e){return je(()=>Jt(Sn(fc(Cl(n,1),Cl(e,1))),"float32"))}function Gge(n,e){return je(()=>Jt(Sn(fc(Cl(n,0),Cl(e,1))),"float32"))}function Hge(n,e){return je(()=>{const t=Wge(n,e),s=Gge(n,e),i=Mt(t,s);return Jt(Lr(Oo(i,0),Cn(t,i),0),"float32")})}function jge(n,e){return Lw(n,e)}function Xge(n,e){return n.rank===e.rank&&(n=d1(n,[n.rank-1])),e=$g(e,-1),e.dtype!==n.dtype&&(e=Jt(e,n.dtype)),Jt(Cl(n,e),"float32")}const qge=Dw,Kge=Dw,Yge=fI,Zge=fI,Qge=pI,Jge=pI,Ez=Vg,e0e=Sz,Tz=A2,M2={binaryAccuracy:Cz,categoricalAccuracy:_z,precision:Hge,categoricalCrossentropy:Ez,sparseCategoricalCrossentropy:Tz,mse:qge,MSE:Kge,mae:Yge,MAE:Zge,mape:Qge,MAPE:Jge,cosine:e0e};function t0e(n){if(typeof n=="string"&&n in M2)return M2[n];if(typeof n!="string"&&n!=null)return n;throw new Te(`Unknown metric ${n}`)}function gv(n){if(rl(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(R2))if(R2[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(M2))if(M2[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function n0e(n){const e={Adagrad:()=>Gh.adagrad(.01),Adadelta:()=>Gh.adadelta(1,.95,zi()),Adam:()=>Gh.adam(.001,.9,.999,zi()),Adamax:()=>Gh.adamax(.002,.9,.999,zi(),0),RMSProp:()=>Gh.rmsprop(.001,.9,0,zi()),SGD:()=>Gh.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new Te(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const mD=1*1024*1024;function gD(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!S_(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>mD&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${mD}.`)}}function S_(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!S_(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!S_(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function s0e(n,e,t,s=console.log){const i=r0e(n),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let o;if(!i){r.push("Receives inputs"),o=[];for(const u in n.nodesByDepth)o.push(...n.nodesByDepth[u])}s("_".repeat(e)),N2(r,t,s),s("=".repeat(e));const a=n.layers;for(let u=0;u<a.length;++u)i?o0e(a[u],t,s):a0e(a[u],t,o,s),s((u===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=i0e(n),c=E2(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function i0e(n){let e;return n.collectedTrainableWeights!=null?e=E2(n.collectedTrainableWeights):e=E2(n.trainableWeights),e}function r0e(n){let e=!0;const t=[],s=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}s.push(...i)}if(e)for(const i of n.layers){let r=!1;for(const o of i.inboundNodes)if(s.indexOf(o)!==-1)if(r){e=!1;break}else r=!0;if(!e)break}return e}function N2(n,e,t=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,e[i]),s+=" ".repeat(e[i]-s.length);t(s)}function o0e(n,e,t){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const r=n.name,o=n.getClassName(),a=[`${r} (${o})`,i,s,n.countParams().toString()];N2(a,e,t)}function a0e(n,e,t,s){let i,r;try{r=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const o=[];for(const d of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){const p=d.inboundLayers[h].name,g=d.nodeIndices[h],y=d.tensorIndices[h];o.push(`${p}[${g}][${y}]`)}const a=n.name,l=n.getClassName(),c=o.length===0?"":o[0],u=[`${a} (${l})`,r,i,n.countParams().toString(),c];N2(u,e,s);for(let d=1;d<o.length;++d)N2(["","","","",o[d]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Iz(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function C_(n,e){if(n===null)return null;if(typeof n=="string")return td(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];Iz(e,i,r)?t.push(r):t.push(C_(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")t[s]=i;else{const r=td(s);t[r]=C_(i,r)}}return t}}function __(n,e){if(n==null)return null;if(typeof n=="string")return tc(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];Iz(e,i,r)?t.push(r):t.push(__(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s],r=tc(s);(s==="name"||s==="className")&&typeof i=="string"?t[r]=i:t[r]=__(i,s)}return t}}/** @license See the LICENSE file. */const kz="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const l0e=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class Ca extends rs{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=Mw(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],nu(this.inputs).length!==this.inputs.length)throw new Te(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);nu(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const S=b.sourceLayer,C=b.nodeIndex,E=b.tensorIndex;this.outputLayers.push(S),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(E)}for(const b of this.inputs){const S=b.sourceLayer,C=b.nodeIndex,E=b.tensorIndex;rl(C===0,"input layer has >1 nodes"),rl(E===0,"input layer has >1 tensors"),this.inputLayers.push(S),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(E)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const S=this.inputLayers[b];if(!(S instanceof w1))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${S.getClassName()}.`);this.inputNames.push(S.name),this.feedInputShapes.push(S.batchInputShape),this.feedInputNames.push(S.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},s={},i={},r={},o={},a=[],l=(b,S,C,E,k,R)=>{(E==null||k==null||R==null)&&(E=b.sourceLayer,k=b.nodeIndex,R=b.tensorIndex);const L=E.inboundNodes[k];if(C.indexOf(L)!==-1)throw new ia(`The tensor ${b.name} at layer "${E.name}" is part of a cycle.`);if(S.indexOf(L)!==-1)return;this.containerNodes.add(Ca.nodeKey(E,k)),E.id in o||(o[E.id]=Object.keys(o).length),C.indexOf(L)===-1&&C.push(L);const I=L.inboundLayers.length;for(let T=0;T<I;T++){const M=L.inputTensors[T],j=L.inboundLayers[T],W=L.nodeIndices[T],z=L.tensorIndices[T];l(M,S,C,j,W,z)}for(S.push(L);C.indexOf(L)>=0;)C.splice(C.indexOf(L),1);a.push(L)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const d=a.slice().reverse();for(const b of d){s[b.id]=b,b.id in t||(t[b.id]=0);let S=t[b.id];const C=i[b.outboundLayer.id]==null?0:i[b.outboundLayer.id];S=Math.max(S,C),i[b.outboundLayer.id]=S,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=S;for(let E=0;E<b.inboundLayers.length;E++){const k=b.inboundLayers[E],R=b.nodeIndices[E],L=k.inboundNodes[R],I=t[L.id]==null?0:t[L.id];t[L.id]=Math.max(S+1,I),s[L.id]=L}}const h={};for(const b in t){const S=t[b];S in h||(h[S]=[]),h[S].push(s[b])}const p={};for(const b in i){const S=i[b];S in p||(p[S]=[]),p[S].push(r[b])}let g=Object.keys(p).map(b=>parseInt(b,10)).sort(fv);this.layers=[];for(const b of g){const S=p[b];S.sort((C,E)=>{const k=o[C.id],R=o[E.id];return k<R?-1:k>R?1:0});for(const C of S)C instanceof Ca&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=p,g=Object.keys(h).map(b=>parseInt(b,10)).sort(fv);const y=this.inputs.slice(),x=[];for(const b of g)for(const S of h[b]){const C=S.outboundLayer;if(C!=null){for(const E of S.inputTensors)if(y.indexOf(E)===-1)throw new ia(`Graph disconnected: cannot obtain value for tensor ${E} at layer "${C.name}". The following previous layers were accessed without issue: ${x}`);for(const E of S.outputTensors)y.push(E);x.push(C.name)}}this.nodesByDepth=h;const v=this.layers.map(b=>b.name);for(const b of v){const S=v.filter(C=>C===b).length;if(S!==1)throw new ia(`The name "${b}" is used ${S} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new Pw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Te("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let i=0;const r=l0e(e);r&&this.parseWeights(e);for(const a of this.layers)for(const[l,c]of a.weights.entries()){const u=r?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(s[u]!=null)throw new Te(`Duplicate weight name: ${u}`);s[u]=c,i++}const o=[];for(const a in e){let l=a;if(s[a]==null){const c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(s[l]!=null)o.push([s[l],e[a]]);else if(t)throw new Te(`Provided weight data has no target variable: ${a}`);delete s[l]}if(t){const a=[];for(const l in s)a.push(l);if(a.length>0)throw new Te(`${a.length} of ${i} weights are not set: ${a}`)}dI(o)}parseWeights(e){for(const t in Object.keys(e)){const s=t.split("/"),i=["vars","layer_checkpoint_dependencies"],r=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!i.includes(o)).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${kz}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=__(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return je(()=>{e=Ns(e);const s=new Yc;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],e[i]);return rg(this.outputs,s,t)})}computeMask(e,t){return je(()=>{e=Ns(e);let s;return t==null?s=Md(null,e.length):s=Ns(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=_2(e);if(t.length!==this.inputLayers.length)throw new Te(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],c=t[a],u=l.name+"_0_0";s[u]=c}const i=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(fv);if(i.length>1)for(const a of i){const l=this.nodesByDepth[a];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(u.id)!==-1)continue;const d=[];for(let y=0;y<c.inboundLayers.length;y++){const x=c.inboundLayers[y],v=c.nodeIndices[y],b=c.tensorIndices[y],S=`${x.name}_${v}_${b}`,C=s[S];d.push(C)}const h=u.computeOutputShape(Xr(d)),p=_2(h),g=u.inboundNodes.indexOf(c);for(let y=0;y<p.length;y++){const x=`${u.name}_${g}_${y}`;s[x]=p[y]}}}const r=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],d=`${l.name}_${c}_${u}`;o.push(d)}for(let a=0;a<o.length;a++){const l=o[a];rl(l in s),r.push(s[l])}return Xr(r)}runInternalGraph(e,t){t==null&&(t=Md(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],d=t[l];s[c.id]=[u,d]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(fv);for(const l of i){const c=this.nodesByDepth[l];for(const u of c){const d=u.outboundLayer,h=u.inputTensors,p=u.outputTensors,g=new Array;for(const y of h)y.id in s&&g.push(s[y.id]);if(g.length===h.length){let y={},x,v,b,S;if(u.callArgs!=null&&(y=u.callArgs),g.length===1){const[C,E]=g[0];y.mask==null&&(y.mask=E),b=Ns(d.call(C,y)),S=Ns(d.computeMask(C,E)),x=[C],v=[E]}else x=g.map(C=>C[0]),v=g.map(C=>C[1]),y.mask==null&&(y.mask=v),b=Ns(d.call(x,y)),S=Ns(d.computeMask(x,v));if(d.activityRegularizer)throw new ts("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<p.length;++C){const E=p[C],k=b[C],R=S[C];s[E.id]=[k,R]}}}}const r=[],o=[],a=[];for(const l of this.outputs){rl(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=s[l.id];a.push(c.shape),r.push(c),o.push(u)}return[r,o,a]}buildNodeConversionMap(e){const t={};let s;for(const i of this.layers){s=i instanceof Ca?1:0;for(let r=0;r<i.inboundNodes.length;r++){const o=Ca.nodeKey(i,r);this.containerNodes.has(o)&&(t[o]=s,s+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new Te("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new Te(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Te(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return je(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const i=Ca.nodeKey(t,s);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),c=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],p=Ca.nodeKey(o,d);let g={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),g=h.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(h.inboundLayers.length>0){const y=[];for(let x=0;x<h.inboundLayers.length;x++){const v=h.inboundLayers[x],b=h.nodeIndices[x],S=h.tensorIndices[x],C=Ca.nodeKey(v,b);let E=t[C];E==null&&(E=0),y.push([v.name,E,S,g])}c.push(y)}}}const u={};u.name=o.name,u.className=a,u.config=l,u.inboundNodes=c,s.push(u)}e.layers=s;const i=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],c=Ca.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const d=this.inputLayersTensorIndices[o];i.push([a.name,u,d])}e.inputLayers=i;const r=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],c=Ca.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const d=this.outputLayersTensorIndices[o];r.push([a.name,u,d])}return e.outputLayers=r,e}static fromConfig(e,t,s={},i=!1){const r={},o={};function a(x,v){x.name in o?o[x.name].push(v):o[x.name]=[v]}function l(x,v){const b=[];let S;for(const C of v){const E=C[0],k=C[1],R=C[2];if(S=C[3]==null?{}:C[3],!(E in r)){a(x,v);return}const L=r[E];if(L.inboundNodes.length<=k){a(x,v);return}const I=L.inboundNodes[k];b.push(I.outputTensors[R])}b.length>0&&x.apply(Xr(b),S)}function c(x){const v=x.name,b=lc(x,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(i),r[v]=b,x.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new Te(`Corrupted configuration, expected array for nodeData: ${C}`);a(b,C)})}const u=t.name,d=t.layers;for(const x of d)c(x);for(;!jme(o);)for(const x of d){const v=r[x.name];if(v.name in o){const b=o[v.name];delete o[v.name];for(const S of b)l(v,S)}}const h=[],p=[],g=t.inputLayers;for(const x of g){const v=x[0],b=x[1],S=x[2];rl(v in r);const E=r[v].inboundNodes[b].outputTensors;h.push(E[S])}const y=t.outputLayers;for(const x of y){const v=x[0],b=x[1],S=x[2];rl(v in r);const E=r[v].inboundNodes[b].outputTensors;p.push(E[S])}return new e({inputs:h,outputs:p,name:u})}get stateful(){if(this._stateful)throw new Te("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){je(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function c0e(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(r=>{r in n?i.push(n[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function Az(n,e){return c0e(n,e,"classWeight")}async function Rz(n,e,t,s){if(t!=null){const i=je(()=>{if(n.shape.length===1)return pd(n);if(n.shape.length===2){if(n.shape[1]>1)return $g(n,1);if(n.shape[1]===1)return De(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());os(i);const o=[];return r.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),go(o,"float32")}else return null}function u0e(n,e){return ke(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const d0e=32;function Mz(n,e){let t,s;const i=e;t=i.xs,s=i.ys,re(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=xD("input",n.inputNames,t),o=xD("output",n.outputNames,s),a=r[0].shape[0];re(r.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),re(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<r.length;l++)re(r[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${r[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)re(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:r,ys:o}}function xD(n,e,t){if(t instanceof Fi)return[t];if(Array.isArray(t))return re(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const i of e){if(t[i]==null)throw new Te(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(t[i])}return s}}function h0e(n){if(n.length===3)throw new ts("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function f0e(n,e,t){const s=t.batchesPerEpoch!=null;if(re(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),re(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),re(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),re(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),re(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let r,o;if(i)if(vD(t.validationData))re(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const x=h0e(t.validationData);r=x.xs,o=x.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(x=>"val_"+x)):c=l.slice();const u=wz(t.callbacks,t.yieldEvery),d=t.verbose==null?1:t.verbose,{callbackList:h,history:p}=bz(u,d,t.epochs,null,null,p0e(e,t),null,i,c);h.setModel(n),n.history=p,await h.onTrainBegin(),n.stopTraining_=!1;let g=t.initialEpoch==null?0:t.initialEpoch,y=await e.iterator();for(;g<t.epochs;){const x={};await h.onEpochBegin(g);let v=0,b=0;for(s||(y=await e.iterator());!s||v<t.batchesPerEpoch;){const S=await y.next();if(s&&S.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(S.value!=null){const{xs:C,ys:E}=Mz(n,S.value),k={};k.batch=b,k.size=C[0].shape[0],await h.onBatchBegin(b,k);const R=[];if(t.classWeight!=null){const T=Az(t.classWeight,n.outputNames);for(let M=0;M<T.length;++M)R.push(await Rz(E[M],null,T[M]))}const L=C.concat(E).concat(R),I=a(L);os(L);for(let T=0;T<l.length;++T){const M=l[T],j=I[T];k[M]=j,xl(j)}await h.onBatchEnd(b,k),yz(k),b++,v++}if(s?v>=t.batchesPerEpoch:S.done){if(i){let C;vD(t.validationData)?C=Ns(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):C=Ns(n.evaluate(r,o,{batchSize:t.validationBatchSize==null?d0e:t.validationBatchSize,verbose:0}));for(let E=0;E<n.metricsNames.length;++E)x[`val_${n.metricsNames[E]}`]=C[E]}break}if(n.stopTraining_)break}if(await h.onEpochEnd(g,x),g++,n.stopTraining_)break}return await h.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function p0e(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function vD(n){return typeof n.iterator=="function"}function m0e(n){return typeof n.next=="function"}async function g0e(n,e,t){t=t||{};const s=t.batches!=null,i=n.testFunction;let r=[];if(t.verbose>0)throw new ts("Verbose mode is not implemented yet.");re(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=m0e(e)?e:await e.iterator();let a=0,l=0;for(;!s||l<t.batches;){const c=await o.next();if(r=je(()=>{if(c.value){const{xs:u,ys:d}=Mz(n,c.value),h=u.concat(d),p=je(()=>i(h));if(os(h),l===0)for(let y=0;y<p.length;++y)r.push(Is(0));const g=h[0].shape[0];for(let y=0;y<p.length;++y){const x=p[y],v=r[y];r[y]=je(()=>Mt(r[y],ke(g,x))),l>0&&os(v)}os(p),a+=g,++l}return r}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<r.length;++c){const u=r[c];r[c]=Cn(r[c],a),os(u)}return Xr(r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eC(n){re(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Zm(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>gd(s,e,t-e)):gd(n,e,t-e)}function E_(n,e){return je(()=>n==null?null:Array.isArray(n)?n.map(t=>E_(t,e)):rz(n,e.dtype==="int32"?e:Jt(e,"int32")))}function tC(n,e){const t=[];let s=0,i=null;for(;s<n;)i=s+e,i>=n&&(i=n),t.push([s,i]),s=i;return t}function Nz(n){const e=[];n instanceof Fi&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(x1(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function ba(n,e){if(n==null)return;const t=[];if(e instanceof Fi)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const r=e[i];t.push(r.id)}const s=[];if(n instanceof Fi)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const r=n[i];t.indexOf(r.id)===-1&&s.push(r)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function x0e(n){return n instanceof Fi}function T_(n){return Array.isArray(n)}function yD(n){return!x0e(n)&&!T_(n)}function wD(n,e,t,s=!0,i=""){if(e==null||e.length===0){if(n!=null){let o=!1;if(T_(n)&&n.length>0)o=!0;else if(yD(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new Te(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let r;if(yD(n)){n=n,r=[];for(const o of e){if(n[o]==null)throw new Te(`No data provided for "${o}". Need data for each key in: ${e}`);r.push(n[o])}}else if(T_(n)){if(n=n,n.length!==e.length)throw new Te(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);r=n}else{if(n=n,e.length>1)throw new Te(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);r=[n]}if(r=Nz(r),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=r[o];if(a.shape.length!==t[o].length)throw new Te(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u>=0&&c!==u)throw new Te(`${i} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${i} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return r}function v0e(n,e,t){const s=nu(n.map(r=>r.shape[0]));s.sort();const i=nu(e.map(r=>r.shape[0]));if(i.sort(),s.length>1)throw new Te(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(r=>r.shape))}`);if(i.length>1)throw new Te(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(r=>r.shape))}`);if(s.length>0&&i.length>0&&!ds(s,i))throw new Te(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function y0e(n,e,t){const s=[Dw,Lw,Vg];for(let i=0;i<n.length;++i){const r=n[i],o=e[i],a=t[i];if(o!=null){if(o===Vg&&r.shape[r.shape.length-1]===1)throw new Te(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(o)!==-1){const l=r.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){const d=l[u],h=c[u];if(h!=null&&d!==h)throw new Te(`A target Tensor with shape ${r.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function bD(n,e,t,s=!0,i=""){let r;if(Array.isArray(n)){if(n.length!==e.length)throw new Te(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);r=n}else{if(e.length>1)throw new Te(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);r=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=r[o];if(a.shape.length!==t[o].length)throw new Te(`Error when checking ${i}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!s)continue;const c=a.shape[l],u=t[o][l];if(u!=null&&u!==c)throw new Te(`Error when checking ${i}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function w0e(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const i of e){let r=t.hasOwnProperty(i)?t[i]:[];Array.isArray(r)||(r=[r]),s.push(r)}return s}}const b0e="layers-model";class df extends Ca{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new Te("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");s0e(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=n0e(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof yu))throw new Te("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new Te(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(JS(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Te(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>JS(a))}else{const o=JS(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],md("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const i=w0e(e.metrics,this.outputNames),r=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};md("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(s.indexOf(o)!==-1)continue;const a=i[o];(c=>{const u="";let d,h,p;for(const g of c){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){const x=this.internalOutputShapes[o];x[x.length-1]===1||this.lossFunctions[o]===Lw?["accuracy","acc"].indexOf(g)!==-1?h=Cz:["crossentropy","ce"].indexOf(g)!==-1&&(h=jge):this.lossFunctions[o]===A2?["accuracy","acc"].indexOf(g)!==-1?h=Xge:["crossentropy","ce"].indexOf(g)!==-1&&(h=Tz):["accuracy","acc"].indexOf(g)!==-1?h=_z:["crossentropy","ce"].indexOf(g)!==-1&&(h=Ez);let v;["accuracy","acc"].indexOf(g)!==-1?v="acc":["crossentropy","ce"].indexOf(g)!==-1&&(v="ce"),p=h,d=u+v}else p=t0e(g),d=u+gv(g);let y;md(d,()=>{y=p}),r(o,d,y)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const i=s.batchSize==null?32:s.batchSize;eC(i);const o=this.standardizeUserDataXY(e,t,!0,i);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,a,i,s.verbose,s.steps);return Xr(c)}finally{ba(o[0],e),ba(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),g0e(this,e,t)}checkNumSamples(e,t,s,i="steps"){let r;if(s!=null){if(r=null,t!=null)throw new Te(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new Te(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Te("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),i=s?t:[t],r=this.retrieveSymbolicTensors(i),o=new Yc;if(e instanceof Fi&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Te(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new Te(`No value is provided for the model's input ${l.name}`);o.add(l,c)}const a=rg(r,o);return s?a:a[0]}retrieveSymbolicTensors(e){const t=Md(null,e.length);let s=e.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],o=r.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=r[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw t.forEach((r,o)=>{r==null&&i.push(e[o])}),new Te(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,s=!1){return je(()=>{const i=this.checkNumSamples(e);if(s)throw new ts("Verbose predictLoop() is not implemented yet.");const r=tC(i,t),o=this.outputs.map(a=>[]);for(let a=0;a<r.length;++a)je(()=>{const c=r[a][0],u=r[a][1],d=Zm(e,c,u),h=[];if(Array.isArray(d))for(let g=0;g<d.length;++g)h.push({key:this.inputs[g],value:d[g]});else h.push({key:this.inputs[0],value:d});const p=new Yc(h);return rg(this.outputs,p)}).forEach((c,u)=>o[u].push(c));return Xr(o.map(a=>Yr(a,0)))})}predict(e,t={}){const s=Nz(e);bD(s,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return eC(i),this.predictLoop(s,i)}finally{ba(s,e)}}predictOnBatch(e){bD(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,i){if(this.optimizer_==null)throw new ia("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===A2?r.push(a.slice(0,a.length-1).concat([1])):r.push(a)}if(e=wD(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=wD(t,this.feedOutputNames,r,!1,"target"),v0e(e,t),y0e(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new Te(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,i,r=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,r,o);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const u=Az(i,this.outputNames);c=[];for(let d=0;d<u.length;++d)c.push(await Rz(l[d],null,u[d]))}return[a,l,c]}testLoop(e,t,s,i=0,r){return je(()=>{const o=this.checkNumSamples(t,s,r,"steps"),a=[];if(i>0)throw new ts("Verbose mode is not implemented yet.");if(r!=null)throw new ts("steps mode in testLoop() is not implemented yet");{const l=tC(o,s),c=go(za(0,o));for(let u=0;u<l.length;++u){const d=l[u][0],h=l[u][1],p=gd(c,d,h-d),g=E_(t,p),y=e(g);if(u===0)for(let x=0;x<y.length;++x)a.push(Is(0));for(let x=0;x<y.length;++x){const v=y[x];a[x]=Mt(a[x],ke(h-d,v))}}for(let u=0;u<a.length;++u)a[u]=Cn(a[u],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const i=e[s];let r=i;if(rD(e,i)>1){const o=rD(e.slice(0,s),i);r+=`_${o}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const d=[];for(let y=0;y<this.inputs.length;++y)d.push({key:this.inputs[y],value:s[y]});const h=new Yc(d),p=rg(this.outputs,h,{training:!0});let g;for(let y=0;y<this.lossFunctions.length;++y){const x=this.lossFunctions[y];let v=x(i[y],p[y]);r[y]!=null&&(v=u0e(v,r[y]));const b=ki(v);t.push(b),y===0?g=v:g=Mt(g,v)}for(let y=0;y<this.metricsTensors.length;++y){let x;if(this.outputs.length>1&&y<this.outputs.length)x=t[y];else{const v=this.metricsTensors[y][0],b=this.metricsTensors[y][1];x=ki(v(i[b],p[b]))}xl(x),o.push(x)}return g=ki(g),this.calculateLosses().forEach(y=>{g=Mt(g,y)}),g},l=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>je(()=>{const t=[];let s;const i=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let c=0;c<this.inputs.length;++c)o.push({key:this.inputs[c],value:i[c]});const a=new Yc(o),l=rg(this.outputs,a);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],d=ki(u(r[c],l[c]));c===0?s=d:s=Mt(s,d),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],d=this.metricsTensors[c][1],h=ki(u(r[d],l[d]));t.push(h)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,o,a,l,c,u,d,h;try{const p=s.batchSize==null?32:s.batchSize;eC(p);const y=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,!1,p);i=y[0],r=y[1],h=y[2];let x=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(x=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new ts("validationData including sample weights is not supported yet."):new Te(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const T=await this.standardizeUserData(l,c,null,null,!0,p);u=T[0],d=T[1],v=u.concat(d)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){x=!0;const I=Math.floor(i[0].shape[0]*(1-s.validationSplit)),T=i[0].shape[0];u=Zm(i,I,T),o=i,i=Zm(i,0,I),d=Zm(r,I,T),a=r,r=Zm(r,0,I),v=u.concat(d)}else s.validationSteps!=null&&(x=!0);const b=i.concat(r).concat(h);this.checkTrainableWeightsConsistency();const S=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let E,k;x?(this.makeTestFunction(),E=this.testFunction,k=C.slice().concat(C.map(I=>"val_"+I))):(E=null,v=[],k=C.slice());const R=wz(s.callbacks,s.yieldEvery);return await this.fitLoop(S,b,C,p,s.epochs,s.verbose,R,E,v,s.shuffle,k,s.initialEpoch,null,null)}finally{this.isTraining=!1,ba(i,e),ba(r,t),ba(o,e),ba(a,t),ba(u,l),ba(d,c),h!=null&&os(h)}}async fitLoop(e,t,s,i,r,o,a,l,c,u,d,h,p,g){i==null&&(i=32),r==null&&(r=1),u==null&&(u=!0),h==null&&(h=0);let y=!1;if(l!=null&&c!=null&&(y=!0),g!=null&&(y=!0,p==null))throw new Te("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const x=this.checkNumSamples(t,i,p,"steps_per_epoch");let v;x!=null&&(v=za(0,x)),o==null&&(o=1);const{callbackList:b,history:S}=bz(a,o,r,h,x,p,i,y,d);b.setModel(this),this.history=S,await b.onTrainBegin(),this.stopTraining_=!1;for(let C=h;C<r;++C){await b.onEpochBegin(C);const E={};if(p!=null)throw new ts("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new ts("batch shuffling is not implemneted yet");u&&aae(v);const k=go(v),R=tC(x,i);for(let L=0;L<R.length;++L){const I={};if(await b.onBatchBegin(L,I),je(()=>{const T=R[L][0],M=R[L][1],j=gd(k,T,M-T);I.batch=L,I.size=M-T;const W=E_(t,j),z=e(W);for(let X=0;X<s.length;++X){const B=s[X],J=z[X];I[B]=J,xl(J)}if(L===R.length-1&&y){const X=this.testLoop(l,c,i);for(let B=0;B<s.length;++B){const J=s[B],K=X[B];xl(K),E["val_"+J]=K}}}),await b.onBatchEnd(L,I),yz(I),this.stopTraining_)break}k.dispose()}if(await b.onEpochEnd(C,E),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return f0e(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),i=s[0],r=s[1],a=this.makeTrainFunction()(i.concat(r)),l=[];for(const c of a){const u=await c.data();l.push(u[0])}return os(a),ba(s[0],e),ba(s[1],t),Xr(l)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,i=s?this.trainableWeights:this.weights,r=this.getWeights(s);for(let o=0;o<i.length;++o)s&&!i[o].trainable||t.push({name:i[o].originalName,tensor:r[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=PP().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-PP().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=tc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>tc(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const i of t)if(typeof s[i]=="string")e[i]=tc(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[tc(gv(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>tc(gv(e)));{const e={};for(const t in this.metrics)e[t]=tc(gv(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=C_(e.optimizer_config),s=lc(t);let i;if(typeof e.loss=="string")i=td(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(o=>td(o));else if(e.loss!=null){i={};for(const o in e.loss)i[o]=td(e.loss[o])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(o=>td(o));else if(e.metrics!=null){r={};for(const o in e.metrics)r[o]=td(e.metrics[o])}this.compile({loss:i,metrics:r,optimizer:s})}async save(e,t){if(typeof e=="string"){const c=Jae(e);if(c.length===0)throw new Te(`Cannot find any save handlers for URL '${e}'`);if(c.length>1)throw new Te(`Found more than one (${c.length}) save handlers for URL '${e}'`);e=c[0]}if(e.save==null)throw new Te("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await LP(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:b0e,generatedBy:`TensorFlow.js tfjs-layers v${kz}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const c="optimizer",{data:u,specs:d}=await LP(await this.optimizer.getWeights(),c);s.specs.push(...d),s.data=Qae([s.data,u])}return this.userDefinedMetadata!=null&&(gD(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){gD(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}df.className="Model";yt(df);class Pz extends df{}Pz.className="Functional";yt(Pz);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wg extends df{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Mw("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new Te(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Wg||e instanceof df;let s;if(t){if(s=e,s.outputs.length!==1)throw new Te("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new Te("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Te("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=Cge({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new Te(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Te("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=pz(this.outputs[0])}this.inboundNodes=[],new Pw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Md(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(bs(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new df({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new ia("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new ia("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new ia("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new ia("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},i=!1){let r,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Te("Legacy serialization format not supported yet.");r=t}else re(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof Wg))throw new ts(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of r){const u=lc(l,void 0,i);i&&u.setFastWeightInitDuringBuild(!0),a.add(u)}return a}set stopTraining(e){if(this.model==null)throw new Te("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Te("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}}Wg.className="Sequential";yt(Wg);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Sr=class extends Yp{getConfig(){return{}}};class Dz extends Sr{apply(e,t=1){return age(e,t)}}Dz.className="elu";yt(Dz);class Lz extends Sr{apply(e){return J5(e)}}Lz.className="selu";yt(Lz);class $z extends Sr{apply(e){return Wd(e)}}$z.className="relu";yt($z);class Fz extends Sr{apply(e){return je(()=>zg(6,Wd(e)))}}Fz.className="relu6";yt(Fz);class Oz extends Sr{apply(e){return e}}Oz.className="linear";yt(Oz);class zz extends Sr{apply(e){return Xp(e)}}zz.className="sigmoid";yt(zz);class Bz extends Sr{apply(e){return cge(e)}}Bz.className="hardSigmoid";yt(Bz);class Uz extends Sr{apply(e){return c1(e)}}Uz.className="softplus";yt(Uz);class Vz extends Sr{apply(e){return lge(e)}}Vz.className="softsign";yt(Vz);class Wz extends Sr{apply(e){return tw(e)}}Wz.className="tanh";yt(Wz);let mI=class extends Sr{apply(e,t=-1){return BT(e,t)}};mI.className="softmax";yt(mI);class Gz extends Sr{apply(e,t=-1){return H5(e,t)}}Gz.className="logSoftmax";yt(Gz);class Hz extends Sr{apply(e){return je(()=>je(()=>{const t=Math.sqrt(2),s=ke(.5,Mt(1,B5(Cn(e,t))));return ke(e,s)}))}}Hz.className="gelu";yt(Hz);class jz extends Sr{apply(e){return je(()=>ke(.5,ke(e,Mt(1,tw(ke(wr(Cn(2,Math.PI)),Mt(e,ke(.044715,kd(e,3)))))))))}}jz.className="gelu_new";yt(jz);class Xz extends Sr{apply(e){return je(()=>ke(e,tw(c1(e))))}}Xz.className="mish";yt(Xz);class qz extends Sr{apply(e,t=1){return je(()=>ke(Xp(ke(e,t)),e))}}qz.className="swish";yt(qz);function lu(n){return n.getClassName()}function nC(n,e={}){return g1(n,sa.getMap().classNameMap,e,"activation")}function cu(n){if(n==null){const e={};return e.className="linear",e.config={},nC(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},nC(e)}else return n instanceof Sr?n:nC(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function S0e(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class Kz extends Yp{}class Yz extends Kz{constructor(e){super(),S0e(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return je(()=>{let t=Oi([1]);return this.hasL1&&(t=Mt(t,Sn(ke(this.l1,Nr(e))))),this.hasL2&&(t=Mt(t,Sn(ke(this.l2,v1(e))))),De(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}Yz.className="L1L2";yt(Yz);const SD={l1l2:"L1L2"};function Vs(n){return tI(n)}function CD(n,e={}){return g1(n,sa.getMap().classNameMap,e,"regularizer")}function ri(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in SD?SD[n]:n,config:{}};return CD(t)}else return n instanceof Kz?n:CD(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Zz extends rs{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=On(e);let s=Wd(e);return this.maxValue!=null&&(s=Lo(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Zz.className="ReLU";yt(Zz);class Qz extends rs{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=On(e);return RT(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Qz.className="LeakyReLU";yt(Qz);class Jz extends rs{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ii(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ri(e.alphaRegularizer),this.alphaConstraint=Vi(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Te(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=bs(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new Bi({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=On(e),$T(e,this.alpha.read())}getConfig(){const e={alphaInitializer:li(this.alphaInitializer),alphaRegularizer:Vs(this.alphaRegularizer),alphaConstraint:Ui(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Jz.className="PReLU";yt(Jz);let eB=class extends rs{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new ts(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=On(e);return iw(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};eB.className="ELU";yt(eB);class tB extends rs{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=On(e);return ke(s,Jt(Oo(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}tB.className="ThresholdedReLU";yt(tB);class nB extends rs{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new mI().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return je(()=>{let s=On(e);const i=t.mask;if(i!=null){const r=ke(Pn(vu(s.shape),Jt(i,s.dtype)),Is(-1e9));s=Mt(s,r)}return this.axis instanceof Array?this.axis.length>1?_l(Pn(s,j5(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}nB.className="Softmax";yt(nB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hf(n,e,t){if(typeof n=="number")return Md(n,e);if(n.length!==e)throw new Te(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const i=n[s];if(!sge(i))throw new Te(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Pa(n,e,t,s,i=1){if(n==null)return n;const r=e+(e-1)*(i-1);let o;return t==="same"?o=n:o=n-r+1,Math.floor((o+s-1)/s)}function ol(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+au([t-e,0]);else if(s==="same")n=n*e;else throw new Te(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gI(n,e){return je(()=>(_i(e),e==="channelsFirst"?gs(n,[0,2,3,1]):n))}function sB(n,e){return je(()=>(_i(e),e==="channelsFirst"?gs(n,[0,2,3,4,1]):n))}function C0e(n,e,t,s=1,i="valid",r,o=1){return je(()=>{if(r==null&&(r=Ba()),_i(r),n.shape.length!==3)throw new Te(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new Te(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new Te(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(r==="channelsFirst"&&(n=gs(n,[0,2,1])),i==="causal")throw new ts("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=L5(n,e,s,i==="same"?"same":"valid","NWC",o);return t!=null&&(a=Ga(a,t)),a})}function _D(n,e,t,s=[1,1],i="valid",r,o,a=null){return je(()=>{if(r==null&&(r=Ba()),_i(r),n.rank!==3&&n.rank!==4)throw new Te(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Te(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=gI(n,r);if(i==="causal")throw new ts("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Nhe({x:l,filter:e,strides:s,pad:i==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),r==="channelsFirst"&&(l=gs(l,[0,3,1,2])),l})}function _0e(n,e,t,s=[1,1,1],i="valid",r,o){return je(()=>{if(r==null&&(r=Ba()),_i(r),n.rank!==4&&n.rank!==5)throw new Te(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Te(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=sB(n,r);if(i==="causal")throw new ts("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Ace(a,e,s,i==="same"?"same":"valid","NDHWC",o),t!=null&&(a=Ga(a,t)),r==="channelsFirst"&&(a=gs(a,[0,4,1,2,3])),a})}class $w extends rs{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$w.verifyArgs(t),this.rank=e,Ki(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ts(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=hf(t.kernelSize,e,"kernelSize"),this.strides=hf(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,zo(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,_i(this.dataFormat),this.activation=cu(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=ii(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Vi(t.biasConstraint),this.biasRegularizer=ri(t.biasRegularizer),this.activityRegularizer=ri(t.activityRegularizer),this.dilationRate=hf(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Te(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Te(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Te(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(rl("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!nI(e.kernelSize,"number",1,3))throw new Te(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:lu(this.activation),useBias:this.useBias,biasInitializer:li(this.biasInitializer),biasRegularizer:Vs(this.biasRegularizer),activityRegularizer:Vs(this.activityRegularizer),biasConstraint:Ui(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Zp extends $w{constructor(e,t){super(e,t),this.kernel=null,Zp.verifyArgs(t),this.filters=t.filters,Ki(this.filters,"filters"),this.kernelInitializer=ii(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Vi(t.kernelConstraint),this.kernelRegularizer=ri(t.kernelRegularizer)}build(e){e=bs(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Te(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return je(()=>{e=On(e);let s;const i=this.bias==null?null:this.bias.read(),r=J6(this.activation.getClassName());if(r!=null&&this.rank===2)s=_D(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)s=C0e(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=_D(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=_0e(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ts("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=bs(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<s.length;++r){const o=Pa(s[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);t.push(o)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:li(this.kernelInitializer),kernelRegularizer:Vs(this.kernelRegularizer),kernelConstraint:Ui(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Te(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class S1 extends Zp{constructor(e){super(2,e),S1.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!nI(e.kernelSize,"number",1,2))throw new Te(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}S1.className="Conv2D";yt(S1);class C1 extends Zp{constructor(e){super(3,e),C1.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Te(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}C1.className="Conv3D";yt(C1);class iB extends S1{constructor(e){if(super(e),this.inputSpec=[new Bi({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Te(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=bs(e),e.length!==4)throw new Te("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Te("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Bi({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return je(()=>{let s=On(e);if(s.shape.length!==4)throw new Te(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=i[o],c=i[a],u=this.kernelSize[0],d=this.kernelSize[1],h=this.strides[0],p=this.strides[1],g=ol(l,h,u,this.padding),y=ol(c,p,d,this.padding),x=[r,g,y,this.filters];this.dataFormat!=="channelsLast"&&(s=gs(s,[0,2,3,1]));let v=$5(s,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=gs(v,[0,3,1,2])),this.bias!=null&&(v=Ga(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=bs(e);const t=e.slice();let s,i,r;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3):(s=3,i=1,r=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[i]=ol(t[i],l,o,this.padding),t[r]=ol(t[r],c,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}iB.className="Conv2DTranspose";yt(iB);class rB extends C1{constructor(e){if(super(e),this.inputSpec=[new Bi({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Te(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=bs(e),e.length!==5)throw new Te("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Te("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Bi({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return je(()=>{let s=On(e);if(s.shape.length!==5)throw new Te(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const c=i[l],u=i[o],d=i[a],h=this.kernelSize[0],p=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[0],x=this.strides[1],v=this.strides[2],b=ol(c,y,h,this.padding),S=ol(u,x,p,this.padding),C=ol(d,v,g,this.padding),E=[r,b,S,C,this.filters];this.dataFormat!=="channelsLast"&&(s=gs(s,[0,2,3,4,1]));let k=Nce(s,this.kernel.read(),E,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=gs(k,[0,4,1,2,3])),this.bias!==null&&(k=Ga(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(e){e=bs(e);const t=e.slice();let s,i,r,o;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3,o=4):(s=4,i=1,r=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],d=this.strides[1],h=this.strides[2];return t[s]=this.filters,t[i]=ol(t[i],u,a,this.padding),t[r]=ol(t[r],d,l,this.padding),t[o]=ol(t[o],h,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}rB.className="Conv3DTranspose";yt(rB);class oB extends Zp{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Te("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Te("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Te(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=ii(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ri(t.depthwiseRegularizer),this.depthwiseConstraint=Vi(t.depthwiseConstraint),this.pointwiseInitializer=ii(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ri(t.pointwiseRegularizer),this.pointwiseConstraint=Vi(t.pointwiseConstraint)}build(e){if(e=bs(e),e.length<this.rank+2)throw new Te(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Te(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],i=this.kernelSize.concat([s,this.depthMultiplier]),r=[];for(let a=0;a<this.rank;++a)r.push(1);r.push(s*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Bi({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return je(()=>{e=On(e);let s;if(this.rank===1)throw new ts("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=gs(e,[0,2,3,1])),s=e6(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Ga(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=gs(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=li(this.depthwiseInitializer),e.pointwiseInitializer=li(this.pointwiseInitializer),e.depthwiseRegularizer=Vs(this.depthwiseRegularizer),e.pointwiseRegularizer=Vs(this.pointwiseRegularizer),e.depthwiseConstraint=Ui(this.depthwiseConstraint),e.pointwiseConstraint=Ui(this.pointwiseConstraint),e}}oB.className="SeparableConv";class aB extends oB{constructor(e){super(2,e)}}aB.className="SeparableConv2D";yt(aB);class Fw extends Zp{constructor(e){super(1,e),Fw.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!nI(e.kernelSize,"number",1,1))throw new Te(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Fw.className="Conv1D";yt(Fw);class lB extends rs{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return je(()=>{if(e=On(e),this.dataFormat==="channelsLast"){const s=mv(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return mv(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=mv(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return mv(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}lB.className="Cropping2D";yt(lB);class cB extends rs{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_i(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,ege(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return je(()=>{let s=On(e);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=gs(s,[0,2,3,1]);const r=this.size[0]*i[2],o=this.size[1]*i[3],a=this.interpolation==="nearest"?rc.resizeNearestNeighbor(s,[r,o]):rc.resizeBilinear(s,[r,o]);return gs(a,[0,3,1,2])}else{const r=this.size[0]*i[1],o=this.size[1]*i[2];return this.interpolation==="nearest"?rc.resizeNearestNeighbor(s,[r,o]):rc.resizeBilinear(s,[r,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}cB.className="UpSampling2D";yt(cB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function E0e(n,e,t=[1,1],s="valid",i,r){return je(()=>{i==null&&(i=Ba()),_i(i);let o=gI(n,i);if(n.rank!==4)throw new Te(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new Te(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=TT(o,e,t,s==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(o=gs(o,[0,3,1,2])),o})}class uB extends $w{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=ii(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Vi(e.depthwiseConstraint),this.depthwiseRegularizer=ri(e.depthwiseRegularizer)}build(e){if(e=bs(e),e.length<4)throw new Te(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Te(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return je(()=>{e=On(e);let s=E0e(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Ga(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=bs(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Pa(t,this.kernelSize[0],this.padding,this.strides[0]),o=Pa(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,r,o]:[e[0],r,o,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=li(this.depthwiseInitializer),e.depthwiseRegularizer=Vs(this.depthwiseRegularizer),e.depthwiseConstraint=Ui(this.depthwiseRegularizer),e}}uB.className="DepthwiseConv2D";yt(uB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function dB(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new Te("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function hB(n,e,t,s=!1,i,r,o=!1,a=!1){return je(()=>{const l=e.shape.length;if(l<3)throw new Te(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(za(2,l));e=gs(e,c),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=Jt(Jt(i,"bool"),"float32"),i.rank===l-1&&(i=jr(i,-1)),i=gs(i,c)),s&&(e=Ad(e,0),i!=null&&(i=Ad(i,0)));const u=[];let d,h=t;const p=e.shape[0],g=Rd(e);let y;i!=null&&(y=Rd(i));for(let v=0;v<p;++v){const b=g[v],S=je(()=>n(b,h));if(i==null)d=S[0],h=S[1];else{const C=je(()=>{const E=y[v],k=Pn(aa(E),E),R=Mt(ke(S[0],E),ke(h[0],k)),L=h.map((I,T)=>Mt(ke(S[1][T],E),ke(I,k)));return{output:R,newStates:L}});d=C.output,h=C.newStates}a&&u.push(d)}let x;return a&&(x=pc(u,1)),[d,x,h]})}class wu extends rs{constructor(e){super(e);let t;if(e.cell==null)throw new Te("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new yI({cells:e.cell}):t=e.cell,t.stateSize==null)throw new Te("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Bi({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return za(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){w_(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let i;if(this.returnSequences?i=[e[0],e[1],s]:i=[e[0],s],this.returnState){const r=[];for(const o of t)r.push([e[0],o]);return[i].concat(r)}else return i}computeMask(e,t){return je(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(r=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new ts("Constants support is not implemented in RNN yet.");w_(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Bi({shape:[t,null,...s]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!ds(this.stateSpec.map(o=>o.shape[o.shape.length-1]),r))throw new Te(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(o=>new Bi({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){je(()=>{if(!this.stateful)throw new il("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new Te("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Oi([s,i])):this.states_=[Oi([s,this.cell.stateSize])];else if(e==null)os(this.states_),this.keptStates!=null&&(os(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Oi([s,i])):this.states_[0]=Oi([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Te(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):os(this.states_);for(let i=0;i<this.states_.length;++i){const r=e[i],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,a=[s,o];if(!ds(r.shape,a))throw new Te(`State ${i} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>xl(i.clone()))})}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=dB(e,s,i,this.numConstants);e=r.inputs,s=r.initialState,i=r.constants;let o=[],a=[];if(s!=null){t.initialState=s,o=o.concat(s),this.stateSpec=[];for(const c of s)this.stateSpec.push(new Bi({shape:c.shape}));a=a.concat(this.stateSpec)}if(i!=null&&(t.constants=i,o=o.concat(i),this.numConstants=i.length),o[0]instanceof Tl){const c=[e].concat(o),u=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=u;const h=super.apply(c,t);return this.inputSpec=d,h}else return super.apply(e,t)}call(e,t){return je(()=>{const s=t==null?null:t.mask,i=t==null?null:t.training;let r=t==null?null:t.initialState;e=On(e),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==o)throw new Te(`RNN Layer has ${o} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:i},c=hB((g,y)=>{const x=this.cell.call([g].concat(y),a);return[x[0],x.slice(1)]},e,r,this.goBackwards,s,null,this.unroll,this.returnSequences),u=c[0],d=c[1],h=c[2];this.stateful&&this.resetStates(h,i);const p=this.returnSequences?d:u;return this.returnState?[p].concat(h):p})}getInitialState(e){return je(()=>{let t=Oi(e.shape);return t=Sn(t,[1,2]),t=x1(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?v_(t,[1,s]):t):this.cell.stateSize>1?[v_(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===wu.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const i=t.cell,r=lc(i,s);return new e(Object.assign(t,{cell:r}))}}wu.className="RNN";yt(wu);class Ow extends rs{}class xI extends Ow{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ki(this.units,"units"),this.activation=cu(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ii(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ii(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ii(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ri(e.kernelRegularizer),this.recurrentRegularizer=ri(e.recurrentRegularizer),this.biasRegularizer=ri(e.biasRegularizer),this.kernelConstraint=Vi(e.kernelConstraint),this.recurrentConstraint=Vi(e.recurrentConstraint),this.biasConstraint=Vi(e.biasConstraint),this.dropout=Pf([1,au([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Pf([1,au([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=bs(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return je(()=>{if(e=e,e.length!==2)throw new Te(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uu({ones:()=>aa(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uu({ones:()=>aa(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?r=yl(ke(e,o),this.kernel.read()):r=yl(e,this.kernel.read()),this.bias!=null&&(r=Ga(r,this.bias.read())),a!=null&&(s=ke(s,a));let l=Mt(r,yl(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:lu(this.activation),useBias:this.useBias,kernelInitializer:li(this.kernelInitializer),recurrentInitializer:li(this.recurrentInitializer),biasInitializer:li(this.biasInitializer),kernelRegularizer:Vs(this.kernelRegularizer),recurrentRegularizer:Vs(this.recurrentRegularizer),biasRegularizer:Vs(this.biasRegularizer),activityRegularizer:Vs(this.activityRegularizer),kernelConstraint:Ui(this.kernelConstraint),recurrentConstraint:Ui(this.recurrentConstraint),biasConstraint:Ui(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}xI.className="SimpleRNNCell";yt(xI);class fB extends wu{constructor(e){e.cell=new xI(e),super(e)}call(e,t){return je(()=>{this.cell.dropoutMask!=null&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return new e(t)}}fB.className="SimpleRNN";yt(fB);class vI extends Ow{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Te("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ki(this.units,"units"),this.activation=cu(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cu(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ii(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ii(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ii(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ri(e.kernelRegularizer),this.recurrentRegularizer=ri(e.recurrentRegularizer),this.biasRegularizer=ri(e.biasRegularizer),this.kernelConstraint=Vi(e.kernelConstraint),this.recurrentConstraint=Vi(e.recurrentConstraint),this.biasConstraint=Vi(e.biasConstraint),this.dropout=Pf([1,au([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Pf([1,au([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=bs(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return je(()=>{if(e=e,e.length!==2)throw new Te(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uu({ones:()=>aa(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uu({ones:()=>aa(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,c;0<this.dropout&&this.dropout<1&&(e=ke(e,r[0]));let u=yl(e,this.kernel.read());this.useBias&&(u=Ga(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=ke(i,o[0]));const d=this.recurrentKernel.read(),[h,p]=Po(d,[2*this.units,this.units],d.rank-1),g=yl(i,h),[y,x,v]=Po(u,3,u.rank-1),[b,S]=Po(g,2,g.rank-1);a=this.recurrentActivation.apply(Mt(y,b)),l=this.recurrentActivation.apply(Mt(x,S));const C=yl(ke(l,i),p);c=this.activation.apply(Mt(v,C));const E=Mt(ke(a,i),ke(Mt(1,wi(a)),c));return[E,E]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:lu(this.activation),recurrentActivation:lu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:li(this.kernelInitializer),recurrentInitializer:li(this.recurrentInitializer),biasInitializer:li(this.biasInitializer),kernelRegularizer:Vs(this.kernelRegularizer),recurrentRegularizer:Vs(this.recurrentRegularizer),biasRegularizer:Vs(this.biasRegularizer),activityRegularizer:Vs(this.activityRegularizer),kernelConstraint:Ui(this.kernelConstraint),recurrentConstraint:Ui(this.recurrentConstraint),biasConstraint:Ui(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}vI.className="GRUCell";yt(vI);class pB extends wu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new vI(e),super(e)}call(e,t){return je(()=>{this.cell.dropoutMask!=null&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}pB.className="GRU";yt(pB);class zw extends Ow{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ki(this.units,"units"),this.activation=cu(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=cu(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=ii(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ii(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ii(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ri(e.kernelRegularizer),this.recurrentRegularizer=ri(e.recurrentRegularizer),this.biasRegularizer=ri(e.biasRegularizer),this.kernelConstraint=Vi(e.kernelConstraint),this.recurrentConstraint=Vi(e.recurrentConstraint),this.biasConstraint=Vi(e.biasConstraint),this.dropout=Pf([1,au([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Pf([1,au([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=bs(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,o=this.units;i=new(t=class extends la{apply(l,c){const u=r.apply([o]),d=new iI().apply([o]),h=r.apply([o*2]);return aD(aD(u,d),h)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return je(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Te(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uu({ones:()=>aa(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uu({ones:()=>aa(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,c,u,d;0<this.dropout&&this.dropout<1&&(e=ke(e,o[0]));let h=yl(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=ke(i,a[0])),h=Mt(h,yl(i,this.recurrentKernel.read())),this.useBias&&(h=Ga(h,this.bias.read()));const[p,g,y,x]=Po(h,4,h.rank-1);l=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(g),u=Mt(ke(c,r),ke(l,this.activation.apply(y))),d=this.recurrentActivation.apply(x);const v=ke(d,this.activation.apply(u));return[v,v,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:lu(this.activation),recurrentActivation:lu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:li(this.kernelInitializer),recurrentInitializer:li(this.recurrentInitializer),biasInitializer:li(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Vs(this.kernelRegularizer),recurrentRegularizer:Vs(this.recurrentRegularizer),biasRegularizer:Vs(this.biasRegularizer),activityRegularizer:Vs(this.activityRegularizer),kernelConstraint:Ui(this.kernelConstraint),recurrentConstraint:Ui(this.recurrentConstraint),biasConstraint:Ui(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}zw.className="LSTMCell";yt(zw);class mB extends wu{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new zw(e),super(e)}call(e,t){return je(()=>{this.cell.dropoutMask!=null&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}mB.className="LSTM";yt(mB);class yI extends Ow{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return je(()=>{e=e;let s=e.slice(1);const i=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?i.push(s.splice(0,a.stateSize.length)):i.push(s.splice(0,1));i.reverse();const r=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];s=i[a],a===0?o=[e[0]].concat(s):o=[o[0]].concat(s),o=l.call(o,t),r.push(o.slice(1))}s=[];for(const a of r.slice().reverse())s.push(...a);return[o[0]].concat(s)})}build(e){w_(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,i)=>{md(`RNNCell_${i}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,s={}){const i=[];for(const r of t.cells)i.push(lc(r,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return b_(e)}setWeights(e){const t=[];for(const s of this.cells){const i=s.weights.length,r=e.splice(i);for(let o=0;o<s.weights.length;++o)t.push([s.weights[o],r[o]])}dI(t)}}yI.className="StackedRNNCells";yt(yI);function uu(n){const{ones:e,rate:t,training:s=!1,count:i=1,dropoutFunc:r}=n,o=()=>r!=null?r(e(),t):oz(e(),t),a=()=>y1(o,e,s);return!i||i<=1?xl(a().clone()):Array(i).fill(void 0).map(a).map(c=>xl(c.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var T0e=function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(t[s[i]]=n[s[i]]);return t};class gB extends wu{constructor(e){if(e.unroll)throw new ts("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ts("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Bi({ndim:5})]}call(e,t){return je(()=>{if(this.cell.dropoutMask!=null&&(os(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(os(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Te("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return je(()=>{const{stateSize:t}=this.cell,s=e.shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)],o=Oi(r);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){je(()=>{if(!this.stateful)throw new il("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)];if(s[0]==null)throw new Te("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Oi(r)):this.states_=[Oi(r)];else if(e==null)os(this.states_),this.keptStates!=null&&(os(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Oi(r)):this.states_[0]=Oi(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Te(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):os(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],c=r;if(!ds(l.shape,c))throw new Te(`State ${a} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>xl(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:i,padding:r,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],d=Pa(c,i[0],r,o[0],a[0]),h=Pa(u,i[1],r,o[1],a[1]);return[...e.slice(0,2),...l?[s,d,h]:[d,h,s]]}}gB.className="ConvRNN2D";class wI extends zw{constructor(e){const{filters:t,kernelSize:s,strides:i,padding:r,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Ki(this.filters,"filters"),this.kernelSize=hf(s,2,"kernelSize"),this.kernelSize.forEach(l=>Ki(l,"kernelSize")),this.strides=hf(i||1,2,"strides"),this.strides.forEach(l=>Ki(l,"strides")),this.padding=r||"valid",zo(this.padding),this.dataFormat=o||"channelsLast",_i(this.dataFormat),this.dilationRate=hf(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>Ki(l,"dilationRate"))}build(e){var t;e=bs(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new Te(`The channel dimension of the input should be defined. Found ${e[s]}`);const i=e[s],r=4,o=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends la{apply(h,p){const g=c.apply([u]),y=vu([u]),x=c.apply([u*2]);return sI([g,y,x])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return je(()=>{if(e.length!==3)throw new Te(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,i=e[0],r=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=uu({ones:()=>aa(i),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(ne,V,Z)=>!V||!V[Z]?ne:ke(V[Z],ne);let u=c(i,l,0),d=c(i,l,1),h=c(i,l,2),p=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=uu({ones:()=>aa(r),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let y=c(r,g,0),x=c(r,g,1),v=c(r,g,2),b=c(r,g,3);const S=3,[C,E,k,R]=Po(this.kernel.read(),a,S),[L,I,T,M]=this.useBias?Po(this.bias.read(),a):[null,null,null,null];u=this.inputConv(u,C,L,this.padding),d=this.inputConv(d,E,I,this.padding),h=this.inputConv(h,k,T,this.padding),p=this.inputConv(p,R,M,this.padding);const[j,W,z,X]=Po(this.recurrentKernel.read(),a,S);y=this.recurrentConv(y,j),x=this.recurrentConv(x,W),v=this.recurrentConv(v,z),b=this.recurrentConv(b,X);const B=this.recurrentActivation.apply(Mt(u,y)),J=this.recurrentActivation.apply(Mt(d,x)),K=Mt(ke(J,o),ke(B,this.activation.apply(Mt(h,v)))),ee=ke(this.recurrentActivation.apply(Mt(p,b)),this.activation.apply(K));return[ee,ee,K]})}getConfig(){const e=super.getConfig(),{units:t}=e,s=T0e(e,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(e,t,s,i){const r=Id(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Ga(r,s,this.dataFormat):r}recurrentConv(e,t){return Id(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}wI.className="ConvLSTM2DCell";yt(wI);class xB extends gB{constructor(e){const t=new wI(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}xB.className="ConvLSTM2D";yt(xB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bI extends rs{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return s}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,r=this.getNoiseShape(s);return y1(()=>oz(s,this.rate,r,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}bI.className="Dropout";yt(bI);class vB extends bI{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}vB.className="SpatialDropout1D";yt(vB);class yB extends rs{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Ki(this.units,"units"),this.activation=cu(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=ii(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ii(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Vi(e.kernelConstraint),this.biasConstraint=Vi(e.biasConstraint),this.kernelRegularizer=ri(e.kernelRegularizer),this.biasRegularizer=ri(e.biasRegularizer),this.activityRegularizer=ri(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=bs(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=bs(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e),i=J6(this.activation.getClassName());let r;return i!=null?r=yl(s,this.kernel.read(),i,this.bias?this.bias.read():null):(r=yl(s,this.kernel.read()),this.bias!=null&&(r=Ga(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:lu(this.activation),useBias:this.useBias,kernelInitializer:li(this.kernelInitializer),biasInitializer:li(this.biasInitializer),kernelRegularizer:Vs(this.kernelRegularizer),biasRegularizer:Vs(this.biasRegularizer),activityRegularizer:Vs(this.activityRegularizer),kernelConstraint:Ui(this.kernelConstraint),biasConstraint:Ui(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}yB.className="Dense";yt(yB);class wB extends rs{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=bs(e);for(const t of e.slice(1))if(t==null)throw new Te(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],su(e,1)]}call(e,t){return je(()=>{this.invokeCallHook(e,t);let s=On(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let r=2;r<s.rank;++r)i.push(r);i.push(1),s=gs(s,i)}return oge(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}wB.className="Flatten";yt(wB);class bB extends rs{constructor(e){super(e),this.supportsMasking=!0,this.activation=cu(e.activation)}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e);return this.activation.apply(s)})}getConfig(){const e={activation:lu(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}bB.className="Activation";yt(bB);class SB extends rs{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return je(()=>(e=On(e),ige(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}SB.className="RepeatVector";yt(SB);class CB extends rs{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",i=t.slice();let r=1,o=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(o===null)o=l;else throw new Te("Can only specifiy one unknown dimension.");else r*=c}const a=su(e);if(o!==null){if(r===0||a%r!==0)throw new Te(s);i[o]=a/r}else if(a!==r)throw new Te(s);return i}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e),i=s.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return De(s,r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}CB.className="Reshape";yt(CB);class _B extends rs{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=za(1,e.dims.length+1);if(!ds(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Bi({ndim:this.dims.length+1})]}computeOutputShape(e){e=bs(e);const t=e.slice();return this.dims.forEach((s,i)=>{t[i+1]=e[s]}),t}call(e,t){return gs(On(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}_B.className="Permute";yt(_B);class EB extends rs{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=On(e);return d_(b2(s,this.maskValue),-1)}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e),o=d_(b2(s,this.maskValue),-1,!0);return ke(s,Jt(o,s.dtype))})}}EB.className="Masking";yt(EB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class TB extends rs{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ns(e.inputLength))}this.inputDim=e.inputDim,Ki(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ki(this.outputDim,"outputDim"),this.embeddingsInitializer=ii(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ri(e.embeddingsRegularizer),this.activityRegularizer=ri(e.activityRegularizer),this.embeddingsConstraint=Vi(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return je(()=>this.maskZero?(e=On(e),b2(e,xs(e))):null)}computeOutputShape(e){if(e=bs(e),this.inputLength==null)return[...e,this.outputDim];const t=Ns(this.inputLength);if(t.length!==e.length-1)throw new Te(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<t.length;++i){const r=t[i],o=e[i+1];if(r!=null&&o!=null&&r!==o)throw new Te(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[s]=o),s++}}return[e[0],...t,this.outputDim]}call(e,t){return je(()=>{this.invokeCallHook(e,t);let s=On(e);s.dtype!=="int32"&&(s=vl(s,"int32"));const i=rz(this.embeddings.read(),De(s,[s.size]));return De(i,bs(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:li(this.embeddingsInitializer),embeddingsRegularizer:Vs(this.embeddingsRegularizer),activityRegularizer:Vs(this.activityRegularizer),embeddingsConstraint:Ui(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}TB.className="Embedding";yt(TB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class qd extends rs{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ts}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const r=e[e.length-t.length+i],o=t[i];if(r==null||o==null||r<0||o<0)s.push(null);else if(r===1)s.push(o);else if(o===1)s.push(r);else{if(r!==o)throw new Te("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(r)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[bs(e)]),e=e,e.length<2)throw new Te(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=nu(t),t.length>1)throw new Te(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const i=e.map(r=>r.length);e.indexOf(null)===-1&&nu(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return je(()=>{if(e=e,this.reshapeRequired){const s=[],i=e.map(r=>r.rank);if(i.indexOf(null)===-1){const r=au(i);for(let o of e){const a=o.rank;for(let l=0;l<r-a;++l)o=x1(o,1);s.push(o)}return this.mergeFunction(s)}else{let r=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,d=u[0],h=u.slice(1).concat([d]);let p=De(l,[d].concat(su(u.slice(1))));p=gs(p,[1,0]),p=De(p,h),s.push(p),r=!0}else if(c>1){const u=za(1,c).concat([0]);s.push(gs(l,u)),r=!0}else s.push(l)}let o=this.mergeFunction(s);const a=o.rank;if(r){if(a==null){const l=o.shape,c=l.length,u=l[c-1],d=[u].concat(l.slice(0,l.length-1));o=De(gs(De(o,[-1,u]),[1,0]),d)}else if(a>1){const l=[a-1].concat(za(0,a-1));o=gs(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const r=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let s=[];for(const i of e)i!=null&&i[0]!==null&&s.push(i[0]);return s=nu(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return je(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Te("`mask` should be an Array");if(!Array.isArray(e))throw new Te("`inputs` should be an Array");if(t.length!==e.length)throw new Te(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:jr(i,0));let s=t[0];for(let i=1;i<t.length-1;++i)s=fc(s,t[i]);return s})}}class IB extends qd{constructor(e){super(e)}mergeFunction(e){return je(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Mt(t,e[s]);return t})}}IB.className="Add";yt(IB);class kB extends qd{constructor(e){super(e)}mergeFunction(e){return je(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=ke(t,e[s]);return t})}}kB.className="Multiply";yt(kB);class AB extends qd{constructor(e){super(e)}mergeFunction(e){return je(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=Mt(t,e[s]);return ke(1/e.length,t)})}}AB.className="Average";yt(AB);class RB extends qd{constructor(e){super(e)}mergeFunction(e){return je(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=xu(t,e[s]);return t})}}RB.className="Maximum";yt(RB);class MB extends qd{constructor(e){super(e)}mergeFunction(e){return je(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=zg(t,e[s]);return t})}}MB.className="Minimum";yt(MB);class NB extends qd{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Te("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const s=[];for(let i=0;i<e.length;++i){const r=e[i].slice();r.splice(this.axis,1);let o=!1;for(const a of s)if(ds(a,r)){o=!0;break}o||s.push(r)}if(s.length>1)throw new Te("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return je(()=>sI(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Te("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const r of t.slice(1)){if(s[i]==null||r[i]==null){s[i]=null;break}s[i]+=r[i]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Te("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Te("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Te(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return je(()=>{let s=!0;if(t.forEach(o=>{if(o!=null){s=!1;return}}),s)return null;const i=[];for(let o=0;o<e.length;++o)t[o]==null?i.push(Jt(aa(e[o]),"bool")):t[o].rank<e[o].rank?i.push(jr(t[o],-1)):i.push(t[o]);const r=Yr(i,this.axis);return D5(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}NB.className="Concatenate";yt(NB);function Qm(n,e){for(;n<0;)n+=e;return n}function I0e(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new ts("batchDot is not implemented for tensors of 4D or higher rank yet");if(re(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),re(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new ts("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=e.shape.length;t==null&&(t=[s-1,i-2]);const r=t;return je(()=>{let o;if(s>i){o=s-i;const l=[];for(let c=0;c<o;++c)l.push(1);e=De(e,e.shape.concat(l))}else if(i>s){o=i-s;const l=[];for(let c=0;c<o;++c)l.push(1);n=De(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)r[0]===r[1]?a=Sn(ke(n,e),r[0]):a=Sn(ke(gs(n,[1,0]),e),r[1]);else{const l=r[0]!==n.shape.length-1,c=r[1]===e.shape.length-1;a=Ts(n,e,l,c)}if(o>0){let l;s>i?l=s+i-3:l=s-1;const c=[];for(let u=l;u<l+o;++u)c.push(u);a=d1(a,c)}return a.shape.length===1&&(a=jr(a,1)),a})}class PB extends qd{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){re(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new ts("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);if(t[i[0]]!==s[i[1]])throw new Te(`Dimension incompatibility: ${t[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Te(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,o)=>Qm(r,e[o].shape.length)):i=[Qm(this.axes,t.shape.length),Qm(this.axes,s.shape.length)],this.normalize&&(t=k2(t,i[0]),s=k2(s,i[1])),I0e(t,s,i)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[Qm(this.axes,e.length),Qm(this.axes,t.length)],s}computeOutputShape(e){re(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new ts("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);t.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=t.concat(s);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}PB.className="Dot";yt(PB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class DB extends rs{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e);return y1(()=>Mt(Nw(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}}DB.className="GaussianNoise";yt(DB);class LB extends rs{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return je(()=>{this.invokeCallHook(e,t);const s=On(e);return this.rate>0&&this.rate<1?y1(()=>{const r=Math.sqrt(this.rate/(1-this.rate));return ke(s,Nw(s.shape,1,r))},()=>s,t.training||!1):s})}}LB.className="GaussianDropout";yt(LB);class $B extends rs{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||On(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return je(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return y1(()=>{const r=On(e),a=-1.6732632423543772*1.0507009873554805;let l=Vd(u1(s),this.rate);l=vl(l,"float32");const c=((1-this.rate)*(1+this.rate*a**2))**-.5,u=-c*a*this.rate,d=Mt(ke(r,l),ke(Mt(l,-1),a));return Mt(ke(d,c),u)},()=>On(e),t.training||!1)}return e})}}$B.className="AlphaDropout";yt($B);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gg(n,e,t,s,i,r=.001){let o;if(n.rank===2)o=rce(n,e,t,s,i,r);else if(n.rank===3)o=ace(n,e,t,s,i,r);else if(n.rank===4)o=cce(n,e,t,s,i,r);else throw new ts(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function k0e(n,e,t,s,i=.001){return je(()=>{const r=PT(n,s),o=r.mean,a=r.variance;return[Gg(n,o,a,t,e,i),o,a]})}function A0e(n,e,t,s,i=.001){return je(()=>{const r=PT(n,s),o=r.mean,a=r.variance,l=[];for(const g of za(0,n.rank))s.indexOf(g)!==-1?l.push(1):l.push(n.shape[g]);const c=De(o,l),u=De(a,l),d=e==null?null:De(e,l),h=t==null?null:De(t,l);return[Gg(n,c,u,h,d,i),o,a]})}function R0e(n,e,t,s,i=.001){return ds(s.slice().sort(),za(0,n.rank-1))?k0e(n,e,t,s,i):A0e(n,e,t,s,i)}class FB extends rs{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ii(e.betaInitializer||"zeros"),this.gammaInitializer=ii(e.gammaInitializer||"ones"),this.movingMeanInitializer=ii(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ii(e.movingVarianceInitializer||"ones"),this.betaConstraint=Vi(e.betaConstraint),this.gammaConstraint=Vi(e.gammaConstraint),this.betaRegularizer=ri(e.betaRegularizer),this.gammaRegularizer=ri(e.gammaRegularizer)}build(e){e=bs(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new Te(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Bi({ndim:e.length,axes:{[t]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return je(()=>{const s=t.training==null?!1:t.training,i=On(e),r=i.shape,o=r.length,a=za(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const c=Md(1,o);c[l]=r[l];const u=a.slice();u.sort();const d=!ds(u,za(0,o).slice(0,o-1)),h=()=>{if(d){const b=De(this.movingMean.read(),c),S=De(this.movingVariance.read(),c),C=this.center?De(this.beta.read(),c):null,E=this.scale?De(this.gamma.read(),c):null;return Gg(i,b,S,C,E,this.epsilon)}else return Gg(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return h();const[p,g,y]=R0e(i,this.gamma.read(),this.beta.read(),a,this.epsilon),x=(b,S,C)=>{je(()=>{const E=1-C,k=b.read(),R=ke(Pn(k,S),E);b.write(Pn(k,R))})};return(()=>{x(this.movingMean,g,this.momentum),x(this.movingVariance,y,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:li(this.betaInitializer),gammaInitializer:li(this.gammaInitializer),movingMeanInitializer:li(this.movingMeanInitializer),movingVarianceInitializer:li(this.movingVarianceInitializer),betaRegularizer:Vs(this.betaRegularizer),gammaRegularizer:Vs(this.gammaRegularizer),betaConstraint:Ui(this.betaConstraint),gammaConstraint:Ui(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}FB.className="BatchNormalization";yt(FB);class OB extends rs{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=ii(e.betaInitializer||"zeros"),this.gammaInitializer=ii(e.gammaInitializer||"ones"),this.betaRegularizer=ri(e.betaRegularizer),this.gammaRegularizer=ri(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=bs(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==nu(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(r=>e[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const s=On(e),i=s.shape,r=i.length;return je(()=>{let{mean:a,variance:l}=PT(s,this.axis,!0);const c=Md(1,r);for(const y of this.axis)c[y]=i[y];const u=y=>y!=null&&y.shape.length!==r?De(y,c):y;let d=this.scale?u(this.gamma.read()):null,h=this.center?u(this.beta.read()):null;const p=[],g=[];for(let y=0;y<r;++y)this.axis.indexOf(y)!==-1?(p.push(i[y]),g.push(1)):(p.push(1),g.push(i[y]));return a=ka(a,p),l=ka(l,p),d!=null&&(d=ka(d,g)),h!=null&&(h=ka(h,g)),Gg(s,a,l,h,d,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:li(this.betaInitializer),gammaInitializer:li(this.gammaInitializer),betaRegularizer:Vs(this.betaRegularizer),gammaRegularizer:Vs(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}OB.className="LayerNormalization";yt(OB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function M0e(n,e,t){return je(()=>{if(n.rank!==4)throw new Te(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Te("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Ba()),t!=="channelsLast"&&t!=="channelsFirst")throw new Te(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],DT(n,s)})}class zB extends rs{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ba():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Te(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Te(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Te(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new Bi({ndim:4})]}computeOutputShape(e){e=bs(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return je(()=>M0e(On(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}zB.className="ZeroPadding2D";yt(zB);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Bw(n,e,t,s,i,r){return je(()=>{_i(i),tz(r),zo(s),t==null&&(t=[1,1]),s==null&&(s="valid"),i==null&&(i=Ba()),r==null&&(r="max"),n=gI(n,i);let o;const a=s==="same"?"same":"valid";return r==="max"?o=NT(n,e,t,a):o=ST(n,e,t,a),i==="channelsFirst"&&(o=gs(o,[0,3,1,2])),o})}function BB(n,e,t,s,i,r){return je(()=>{_i(i),tz(r),zo(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),i==null&&(i=Ba()),r==null&&(r="max"),n=sB(n,i);let o;const a=s==="same"?"same":"valid";return r==="max"?o=Xue(n,e,t,a):o=Kle(n,e,t,a),i==="channelsFirst"&&(o=gs(o,[0,4,1,2,3])),o})}class UB extends rs{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Te(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Ki(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Te(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Ki(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,zo(this.padding),this.inputSpec=[new Bi({ndim:3})]}computeOutputShape(e){e=bs(e);const t=Pa(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return je(()=>{this.invokeCallHook(e,t),e=x1(On(e),2);const s=this.poolingFunction(On(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return d1(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class VB extends UB{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return _i(r),zo(i),Bw(e,t,s,i,r,"max")}}VB.className="MaxPooling1D";yt(VB);class WB extends UB{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return _i(r),zo(i),Bw(e,t,s,i,r,"avg")}}WB.className="AveragePooling1D";yt(WB);class GB extends rs{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Te(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Ki(this.poolSize,"poolSize"),Ki(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_i(this.dataFormat),zo(this.padding),this.inputSpec=[new Bi({ndim:4})]}computeOutputShape(e){e=bs(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Pa(t,this.poolSize[0],this.padding,this.strides[0]),s=Pa(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return je(()=>(this.invokeCallHook(e,t),this.poolingFunction(On(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class HB extends GB{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return _i(r),zo(i),Bw(e,t,s,i,r,"max")}}HB.className="MaxPooling2D";yt(HB);class jB extends GB{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return _i(r),zo(i),Bw(e,t,s,i,r,"avg")}}jB.className="AveragePooling2D";yt(jB);class XB extends rs{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Te(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Ki(this.poolSize,"poolSize"),Ki(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_i(this.dataFormat),zo(this.padding),this.inputSpec=[new Bi({ndim:5})]}computeOutputShape(e){e=bs(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Pa(t,this.poolSize[0],this.padding,this.strides[0]),s=Pa(s,this.poolSize[1],this.padding,this.strides[1]),i=Pa(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,i]:[e[0],t,s,i,e[4]]}call(e,t){return je(()=>(this.invokeCallHook(e,t),this.poolingFunction(On(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class qB extends XB{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return _i(r),zo(i),BB(e,t,s,i,r,"max")}}qB.className="MaxPooling3D";yt(qB);class KB extends XB{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return _i(r),zo(i),BB(e,t,s,i,r,"avg")}}KB.className="AveragePooling3D";yt(KB);class YB extends rs{constructor(e){super(e),this.inputSpec=[new Bi({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ts}}class ZB extends YB{constructor(e){super(e||{})}call(e,t){return je(()=>{const s=On(e);return ki(s,1)})}}ZB.className="GlobalAveragePooling1D";yt(ZB);class QB extends YB{constructor(e){super(e||{})}call(e,t){return je(()=>{const s=On(e);return Na(s,1)})}}QB.className="GlobalMaxPooling1D";yt(QB);class JB extends rs{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,_i(this.dataFormat),this.inputSpec=[new Bi({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ts}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class eU extends JB{call(e,t){return je(()=>{const s=On(e);return this.dataFormat==="channelsLast"?ki(s,[1,2]):ki(s,[2,3])})}}eU.className="GlobalAveragePooling2D";yt(eU);class tU extends JB{call(e,t){return je(()=>{const s=On(e);return this.dataFormat==="channelsLast"?Na(s,[1,2]):Na(s,[2,3])})}}tU.className="GlobalMaxPooling2D";yt(tU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class nU extends rs{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const i=t.layer,r=lc(i,s);delete t.layer;const o={layer:r};return Object.assign(o,t),new e(o)}}class sU extends nU{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=bs(e),e.length<3)throw new Te(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=bs(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),i=e[1];return[s[0],i].concat(s.slice(1))}call(e,t){return je(()=>(e=On(e),hB((o,a)=>[On(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}sU.className="TimeDistributed";yt(sU);function N0e(n){Xd(Jme,"BidirectionalMergeMode",n)}const P0e="concat";class iU extends nU{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=lc(s),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=lc(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?P0e:e.mergeMode,N0e(this.mergeMode),e.weights)throw new ts("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,i,r;return this.returnState&&(r=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[s].concat(r).concat(r.slice()):Xr(i)}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=dB(e,s,i,this.numConstants);if(e=r.inputs,s=r.initialState,i=r.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&i==null)return super.apply(e,t);const o=[],a=[];if(s!=null){const c=s.length;if(c%2>0)throw new Te("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,o.push(...s);const u=s.map(d=>new Bi({shape:d.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),a.push(...u)}if(i!=null)throw new ts("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof Tl;for(const c of o)if(c instanceof Tl!==l)throw new Te("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(o),u=this.inputSpec.concat(a),d=this.inputSpec;this.inputSpec=u;const h=super.apply(c,t);return this.inputSpec=d,h}else return super.apply(e,t)}call(e,t){return je(()=>{const s=t.initialState;let i,r;if(s==null)i=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let o;this.returnState&&(Array.isArray(i)&&(o=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=Ad(r,1));let a;return this.mergeMode==="concat"?a=sI([i,r]):this.mergeMode==="sum"?a=Mt(i,r):this.mergeMode==="ave"?a=ke(.5,Mt(i,r)):this.mergeMode==="mul"?a=ke(i,r):this.mergeMode==null&&(a=[i,r]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){md(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),md(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const r=this.forwardLayer.states.map(o=>null);return Array.isArray(s)?s.concat(r).concat(r):[s].concat(r).concat(r)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=lc(t.layer);if(delete t.layer,t.numConstants!=null)throw new ts("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=s,new e(i)}}iU.className="Bidirectional";yt(iU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class rU extends rs{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return je(()=>(e=On(e),e.dtype!=="float32"&&(e=vl(e,"float32")),Mt(ke(e,this.scale),this.offset)))}}rU.className="Rescaling";yt(rU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:D0e,cropAndResize:L0e}=rc;class oU extends rs{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,i,r,o,a,l){return je(()=>{let c,u=!1;const d=t/o,h=s/a,p=(i+t)/o,g=(r+s)/a,y=[d,h,p,g],x=[];e.rank===3?(u=!0,c=pc([e])):c=e;for(let E=0;E<c.shape[0];E++)x.push(y);const v=E5(x,[x.length,4]),b=Bg(0,x.length,1,"int32"),C=L0e(c,v,b,[i,r],"nearest");return vl(u?On(Rd(C)):C,l)})}upsize(e,t,s,i){return je(()=>{const r=D0e(e,[t,s]);return vl(r,i)})}call(e,t){return je(()=>{const s=On(e),i=s.dtype,r=s.shape,o=r[r.length-3],a=r[r.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let c=0;return a!==this.width&&(c=Math.floor((a-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,o,a,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=bs(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}oU.className="CenterCrop";yt(oU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $0e(n,e,t,s){let i=On(n);if(i.dtype!=="int32"&&(i=vl(i,"int32")),e==="int")return i;const r=i.shape;if(i.rank===0&&(i=jr(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=jr(i,-1)),i.rank>2)throw new Te(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${r} which would result in output rank ${i.rank}.`);const o=["multiHot","oneHot"].includes(e),a=i;let l;if(typeof s<"u"&&e==="count"?l=OP(a,s,t,o):l=OP(a,[],t,o),e!=="tfIdf")return l;if(s)return ke(l,s);throw new Te("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class aU extends rs{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=bs(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return je(()=>{e=On(e),e.dtype!=="int32"&&(e=vl(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new Te(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=On(t.countWeights)}const i=Na(e),r=y2(e),o=Oo(this.numTokens,i).bufferSync().get(0),a=Vd(r,0).bufferSync().get(0);if(!(o&&a))throw new Te(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return $0e(e,this.outputMode,this.numTokens,s)})}}aU.className="CategoryEncoding";yt(aU);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const F0e=["bilinear","nearest"],ED=new Set(F0e);class lU extends rs{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(ED.has(e.interpolation))this.interpolation=e.interpolation;else throw new Te(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=bs(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return je(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return rc.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return rc.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ED]} are supported`)})}}lU.className="Resizing";yt(lU);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cU{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}cU.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class uU extends rs{constructor(e){super(e),this.randomGenerator=new cU(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}uU.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const O0e=["bilinear","nearest"],TD=new Set(O0e);class dU extends uU{constructor(e){super(e);const{factor:t,interpolation:s="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Te(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Te(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Te(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(TD.has(s))this.interpolation=s;else throw new Te(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=bs(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return je(()=>{const s=On(e);this.imgHeight=s.shape[s.shape.length-3];const i=s.shape[s.shape.length-2];this.widthFactor=u1([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*i;r=Math.round(r);const o=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return rc.resizeBilinear(e,o);case"nearest":return rc.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...TD]} are supported`)}})}}dU.className="RandomWidth";yt(dU);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e=ze();z0e.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ID;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ID||(ID={}));var kD;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(kD||(kD={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var AD;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(AD||(AD={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function un(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&re(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B0e=l6;class Uw extends hy{nextDataId(){return Uw.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new XE(this,Ao())}write(e,t,s){this.firstUse&&(this.firstUse=!1,ze().get("IS_NODE")&&Ro(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&Kf(s[0])){const r=s.map(o=>ac(o));i=this.write(r,e,t)}else i=this.write(s,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,i,r){this.data.set(e,{values:t,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const i=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return Fa(i,r)}return Lv(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>$a(i));return Yn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Yn(e.shape,e.dtype,t)}makeOutput(e,t,s){return Ao().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Gr();return e(),{kernelMs:Gr()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){un([e],"where");const t=this.readSync(e.dataId);return B0e(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Uw.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hU(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const U0e=n=>{const{x:e}=n.inputs,t=n.backend;un(e,"abs");let s=new Float32Array(Le(e.shape));const i=t.data.get(e.dataId).values;return s=hU(i),t.makeOutput(s,e.shape,e.dtype)},V0e={kernelName:c0,backendName:"cpu",kernelFunc:U0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ei(n){return(e,t,s,i,r)=>{const o=Mn(e,t),a=o.length,l=gn(o),c=Le(o),u=Qi(r,c),d=e.length,h=t.length,p=gn(e),g=gn(t),y=ou(e,o),x=ou(t,o);if(y.length+x.length===0)for(let v=0;v<u.length;++v)u[v]=n(s[v%s.length],i[v%i.length]);else for(let v=0;v<u.length;++v){const b=Yf(v,a,l),S=b.slice(-d);y.forEach(R=>S[R]=0);const C=gl(S,d,p),E=b.slice(-h);x.forEach(R=>E[R]=0);const k=gl(E,h,g);u[v]=n(s[C],i[k])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mo(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,a=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",r),imag:t.makeTensorInfo(i.shape,"float32",o)},a}const W0e={kernelName:wy,backendName:"cpu",kernelFunc:mo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2(n,e,t="float32"){if(t==="complex64"){const i=P2(n,e,"float32"),r=P2(n,e,"float32");return mo({inputs:{real:i,imag:r},backend:n})}const s=dr(Le(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Il(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const G0e={kernelName:xp,backendName:"cpu",kernelFunc:Il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nd(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.real,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const H0e={kernelName:Wy,backendName:"cpu",kernelFunc:Nd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fU(n,e,t,s){if(s==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(s==="bool"){const i=Ud([0],t),[r,o]=Ei((a,l)=>a!==l?1:0)(e,[],n,i,"bool");return[o,"bool",r]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function du(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return Il({inputs:{x:i},backend:t});const u=P2(t,i.shape,i.dtype),d=du({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),h=mo({inputs:{real:d,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),h}if(i.dtype==="complex64"){const u=Nd({inputs:{input:i},backend:t}),d=du({inputs:{x:u},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(u),d}if(!YE(i.dtype,r)){const u=Il({inputs:{x:i},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:r}}const o=t.data.get(i.dataId).values,[a,l,c]=fU(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}const j0e={kernelName:ip,backendName:"cpu",kernelFunc:du};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gi(n,e,t,s){return t==null?({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;un([o,a],n);const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d=o.dtype==="string"?Oa(c):c,h=o.dtype==="string"?Oa(u):u,p=s||o.dtype,[g,y]=e(o.shape,a.shape,d,h,p);return l.makeTensorInfo(y,p,g)}:({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;if(o.dtype==="complex64"||a.dtype==="complex64"){const c=du({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),d=u.complexTensorInfos.real,h=u.complexTensorInfos.imag,p=l.data.get(d.dataId).values,g=l.data.get(h.dataId).values,y=du({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),x=l.data.get(y.dataId),v=x.complexTensorInfos.real,b=x.complexTensorInfos.imag,S=l.data.get(v.dataId).values,C=l.data.get(b.dataId).values,[E,k,R]=t(o.shape,a.shape,p,g,S,C),L=l.makeTensorInfo(R,"float32",E),I=l.makeTensorInfo(R,"float32",k),T=mo({inputs:{real:L,imag:I},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(L),l.disposeIntermediateTensorInfo(I),T}else{const c=l.data.get(o.dataId).values,u=l.data.get(a.dataId).values,d=s||o.dtype,[h,p]=e(o.shape,a.shape,c,u,d);return l.makeTensorInfo(p,d,h)}}}function SI(n){return(e,t,s,i,r,o)=>{const a=Mn(e,t),l=Le(a),c=a.length,u=gn(a),d=Qi("float32",l),h=Qi("float32",l),p=ou(e,a),g=ou(t,a),y=Fa(s,i),x=Fa(r,o),v=e.length,b=gn(e),S=t.length,C=gn(t);if(p.length+g.length===0)for(let E=0;E<d.length;E++){const k=E%y.length,R=E%x.length,L=n(y[k*2],y[k*2+1],x[R*2],x[R*2+1]);d[E]=L.real,h[E]=L.imag}else for(let E=0;E<d.length;E++){const k=Yf(E,c,u),R=k.slice(-v);p.forEach(j=>R[j]=0);const L=gl(R,v,b),I=k.slice(-S);g.forEach(j=>I[j]=0);const T=gl(I,S,C),M=n(y[L*2],y[L*2+1],x[T*2],x[T*2+1]);d[E]=M.real,h[E]=M.imag}return[d,h,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pU=Ei((n,e)=>n+e),X0e=SI((n,e,t,s)=>({real:n+t,imag:e+s})),Df=Gi(Bd,pU,X0e),q0e={kernelName:Bd,backendName:"cpu",kernelFunc:Df};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(n,e,t,s,i){const r=Le(s),o=dr(i,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?o[l]+=e[a]:o[l]+=1)}return o}function mU(n,e,t,s=!1){const i=n.shape[0],r=n.shape[1],o=Yn([i,t],e.dtype);for(let a=0;a<i;a++)for(let l=0;l<r;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gU=Ei((n,e)=>n&e),K0e=Gi(eT,gU),Y0e={kernelName:eT,backendName:"cpu",kernelFunc:K0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dl(n){return(e,t,s)=>{const i=fi(t,e.length);for(let r=0;r<e.length;++r)i[r]=n(e[r],s);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ds(n,e,t){const s=Dl(e);return bu(n,s,t)}function bu(n,e,t){return({inputs:s,attrs:i,backend:r})=>{const{x:o}=s;un(o,n);const a=r,l=a.data.get(o.dataId).values;let c;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=Oa(l)}else c=l;const u=t||o.dtype,d=e(c,u,i);return a.makeTensorInfo(o.shape,u,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xU=Dl(n=>Math.ceil(n)),Z0e=bu(rp,xU),Q0e={kernelName:rp,backendName:"cpu",kernelFunc:Z0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n,e,t,s){const i=fi(t,Le(e));if(s&&t!=="string"){let r=0;n.forEach(o=>{const a=Le(o.shape);i.set(o.vals,r),r+=a})}else{let r=0;n.forEach(o=>{const a=t==="string"?Oa(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+r;for(let d=0;d<o.shape[1];++d)i[u+d]=a[l++]}r+=o.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yU=Ei((n,e)=>n===e?1:0),wU=Gi(_0,yU,null,"bool"),J0e={kernelName:_0,backendName:"cpu",kernelFunc:wU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bU=Dl(n=>Math.exp(n)),SU=bu(hp,bU,"float32"),e1e={kernelName:hp,backendName:"cpu",kernelFunc:SU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CU=Dl(n=>Math.expm1(n)),t1e=bu(fp,CU),n1e={kernelName:fp,backendName:"cpu",kernelFunc:t1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _U=Dl(n=>Math.floor(n)),s1e=bu(pp,_U),i1e={kernelName:pp,backendName:"cpu",kernelFunc:s1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EU=Ei((n,e)=>Math.floor(n/e)),r1e=Gi(mp,EU,null,"int32"),o1e={kernelName:mp,backendName:"cpu",kernelFunc:r1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TU(n,e,t,s,i,r,o,a,l){const c=Yn([s,r],t);for(let u=0;u<s;u++){const d=[];let h=0;for(let p=0;p<i;p++){const g=n[u*i+p];h+=g*o[p],d.push(g)}if(h<0||h>=l/r)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let p=0;p<r;p++)c.values[u*r+p]=e.get(...e.indexToLoc(h*r+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IU(n,e,t){const s=Yn(t,n.dtype);for(let i=0;i<s.size;++i){const o=s.indexToLoc(i).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);0<=u&&u<n.values.length&&(s.values[i]=n.values[u])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kU=Ei((n,e)=>n>e?1:0),a1e=Gi(k0,kU,null,"bool"),l1e={kernelName:k0,backendName:"cpu",kernelFunc:a1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AU=Ei((n,e)=>n>=e?1:0),c1e=Gi(gp,AU,null,"bool"),u1e={kernelName:gp,backendName:"cpu",kernelFunc:c1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RU=Ei((n,e)=>n<e?1:0),d1e=Gi(R0,RU,null,"bool"),h1e={kernelName:R0,backendName:"cpu",kernelFunc:d1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MU=Ei((n,e)=>n<=e?1:0),f1e=Gi(M0,MU,null,"bool"),p1e={kernelName:M0,backendName:"cpu",kernelFunc:f1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NU(n,e,t){const s=(e-n)/(t-1),i=dr(t,"float32");i[0]=n;for(let r=1;r<i.length;r++)i[r]=i[r-1]+s;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PU=Dl(n=>Math.log(n)),m1e=bu(bp,PU),g1e={kernelName:bp,backendName:"cpu",kernelFunc:m1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(n,e,t,s){const i=Qi(s,Le(t));for(let r=0;r<i.length;++r){const o=r*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}i[r]=a}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LU=Ei((n,e)=>Math.max(n,e)),x1e=Gi(Cp,LU),v1e={kernelName:Cp,backendName:"cpu",kernelFunc:x1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $U=Ei((n,e)=>Math.min(n,e)),y1e=Gi(_p,$U),w1e={kernelName:_p,backendName:"cpu",kernelFunc:y1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _I=Ei((n,e)=>n*e),b1e=SI((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Vw=Gi(Tp,_I,b1e),S1e={kernelName:Tp,backendName:"cpu",kernelFunc:Vw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(n,e,t){const s=mu(-1,t);return _I([],e,s,n,t)}function C1e(n){const{inputs:e,backend:t}=n,{x:s}=e;un(s,"neg");const i=t.data.get(s.dataId).values,[r,o]=FU(i,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,r)}const _1e={kernelName:V0,backendName:"cpu",kernelFunc:C1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OU=Ei((n,e)=>n!==e?1:0),E1e=Gi(W0,OU,null,"bool"),T1e={kernelName:W0,backendName:"cpu",kernelFunc:E1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EI(n,e,t,s,i){const r=e.length,o=Le(e),a=gn(e),l=gn(i),c=Qi(t,Le(i));for(let u=0;u<o;++u){const d=Yf(u,r,a),h=new Array(d.length);for(let g=0;g<h.length;g++)h[g]=d[s[g]];const p=gl(h,r,l);c[p]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(n){const{inputs:e,attrs:t,backend:s}=n,{x:i}=e,{perm:r}=t;un(i,"transpose");const o=i.shape.length,a=new Array(o);for(let d=0;d<a.length;d++)a[d]=i.shape[r[d]];const l=s.data.get(i.dataId).values,c=EI(l,i.shape,i.dtype,r,a);return{dataId:s.write(c,a,i.dtype),shape:a,dtype:i.dtype}}const I1e={kernelName:fd,backendName:"cpu",kernelFunc:eo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zU(n,e,t,s){const[i,r]=Ci(n,s),o=Ji(e,"int32"),a=dr(Le(i),o),l=Le(r);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let h=0;h<l;++h)d*=t[u+h];a[c]=d}return{outVals:a,outShape:i,outDtype:o}}function k1e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;un(i,"prod");const a=i.shape.length,l=Hn(r,i.shape),c=Os(l,a);let u=l,d=i;const h=[];c!=null&&(d=eo({inputs:{x:i},backend:t,attrs:{perm:c}}),h.push(d),u=Ys(u.length,a));const p=t.data.get(d.dataId).values,{outVals:g,outShape:y,outDtype:x}=zU(d.shape,d.dtype,p,u);let v=y;return o&&(v=Si(y,l)),h.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(v,x,g)}const A1e={kernelName:K0,backendName:"cpu",kernelFunc:k1e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1e(n,e,t){n.forEach((s,i)=>{if(s<0||s>=t){const r=Yf(i,e.length,gn(e)).join(",");throw new Error(`indices[${r}] = ${s} is not in [0, ${t})`)}})}function M1e(n,e){for(let t=0;t<n.length;++t){const s=n[t],i=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<s.length;++r)if(s[r-1]>s[r])throw new Error("Ragged splits must be sorted in ascending order")}}function N1e(n,e,t,s){const i=[];let r=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);M1e(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let d=1;d<l+1;++d)a[c].push(d*u)}for(let c=0;c<n.length;++c){let u=n[c],d=n[c]+1;for(let h=0;h<t.length;++h){const p=t[h],g=h+e.length-1;if(g>=0){const y=a[g],x=y[y.length-1]-p[u];for(let v=u;v<d;++v)a[g].push(p[v+1]+x)}u=p[u],d=p[d]}d!==u&&(i.push([u,d]),r+=d-u)}return{outSplits:a,valueSlices:i,numValues:r}}function P1e(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,i=fi("int32",s);e.push(i),n[t].forEach((r,o)=>i[o]=r)}return e}function RD(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function D1e(n,e,t,s,i,r){const o=RD(e,2)[1],a=RD(r,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let d=0;d<s;++d)i[l*a+d]=n[u*o+d];++l}}function L1e(n,e,t,s,i){const r=e.slice();r[0]=i;const o=fi(t,Le(r)),a=n.length,l=a===0?0:a/e[0];return D1e(n,e,s,l,o,r),[o,r]}function BU(n,e,t,s,i,r,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(R1e(r,o,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:u,valueSlices:d,numValues:h}=N1e(r,o,n,c),p=P1e(u),g=L1e(t,s,i,d,h);return[p,g[0],g[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MD=2147483647;function UU(n,e,t,s,i,r,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=i.length===0,c=o.length===0,u=[];a||u.push(e[0]),l||u.push(i[0]),c||u.push(o[0]);for(let x=1;x<u.length;++x)if(u[x]!==u[x-1])throw new Error("starts, limits, and deltas must have the same shape");const d=u.length===0?1:u[0],h=fi("int32",d+1);h[0]=0;for(let x=0;x<d;++x){const v=a?n[0]:n[x],b=l?s[0]:s[x],S=c?r[0]:r[x];if(S===0)throw new Error("Requires delta != 0");let C;if(S>0&&b<v||S<0&&b>v)C=0;else if(C=Math.ceil(Math.abs((b-v)/S)),C>MD)throw new Error(`Requires ((limit - start) / delta) <= ${MD}`);h[x+1]=h[x]+C}const p=h[d],g=fi(t,p);let y=0;for(let x=0;x<d;++x){const v=h[x+1]-h[x];let b=a?n[0]:n[x];const S=c?r[0]:r[x];for(let C=0;C<v;++C)g[y++]=b,b+=S}return[h,g]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yo=Ta;class D2{constructor(e,t,s,i,r,o,a,l,c,u){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=i,this.valuesDType=r,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=I6(u),this.raggedRank=k6(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Yo.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Yo.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Yo.VALUE_ROWIDS:return D2.getMaxWidthValueRowID(t);case Yo.ROW_SPLITS:return D2.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Yo[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let i=0;i<t-1;++i){const r=e[i+1]-e[i];r>s&&(s=r)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,i=e[0],r=0;for(let o=1;o<t;++o){const a=e[o];a!==i&&(i=a,r=Math.max(o-s,r),s=o)}return Math.max(t-s,r)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return PD(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;A6(s,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=T6(this.raggedRank,i,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,s){const i=Math.min(e,s),r=[];let o=0;for(let a=0;a<i;++a,o+=t)r.push(o);for(let a=i;a<e;++a)r.push(-1);return re(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,s,i){const r=e.length,o=[];for(let a=0;a<r-1;++a){const l=e[a+1]-e[a];let c=Math.min(i,l),u=t[a];u===-1&&(c=0);for(let d=0;d<c;++d)o.push(u),u+=s;for(let d=0;d<l-c;++d)o.push(-1)}if(r>0&&o.length!==e[r-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,s,i){const r=e.length,o=[];if(r===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];o.push(c);for(let u=1;u<r;++u){const d=e[u];if(d===l)c>=0&&(++a,a<i?c+=s:c=-1);else{if(a=0,l=d,d>=t.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${t.length}`);c=t[d]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,s,i){const r=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case Yo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,s,i);case Yo.ROW_SPLITS:if(r.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(r,t,s,i);default:throw new Error(`Unsupported partition type: ${Yo[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case Yo.FIRST_DIM_SIZE:return e[0];case Yo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Yo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Yo[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),s=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*s[l+1];const r=PD(s,!1),o=fi(this.valuesDType,Le(r));if(i[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(t,i[0],s[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],s[c]);this.setOutput(this.raggedRank,l,o,r)}return[r,o]}setOutput(e,t,s,i){if(s.length===0)return;const r=this.values,o=s;let a=i.slice();a=a.slice(e+1);const l=Le(a),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const g=this.defaultValueShape;je(()=>{const y=De(u,g);u=Sg(y,a).dataSync()})}let d=0,h=0,p=0;for(let g=0;g<=c;++g){let y=g<c?t[g]:-1;if(y===p){++p;continue}if(h<p){const x=r.subarray(d*l),v=o.subarray(h*l),b=(p-h)*l;ND(v,x,b)}if(g>=c){const x=s.length;y=Math.floor(x/l)}if(y>p)if(this.defaultValue.length===1)o.subarray(p*l,y*l).fill(this.defaultValue[0]),p=y;else for(;y>p;){const x=o.slice(p*l);ND(x,u,l),++p}y<0?(d=g+1,h=p):(d=g,h=p,p=h+1)}}}function ND(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function PD(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function VU(n,e,t,s,i,r,o,a,l,c){return new D2(n,e,t,s,i,r,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(n,e,t,s){const i=n===e,r=n<e&&t<0,o=e<n&&t>1;if(i||r||o)return dr(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=dr(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GU=Dl(n=>1/Math.sqrt(n)),$1e=bu(Np,GU),F1e={kernelName:Np,backendName:"cpu",kernelFunc:$1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ad(n,e,t,s,i,r,o,a,l,c){const u=[s/i,i],d=n.values,h=e.values;if(s===0)return Yn(t,e.dtype);const p=l instanceof ur?l:Yn(u,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let g=0;g<r;g++){const y=[];let x=0;for(let v=0;v<o;v++){const b=d[g*o+v];y.push(b),x+=b*a[v]}if(x<0||x>=s/i)throw new Error(`Invalid indices: ${y} does not index into ${t}`);for(let v=0;v<i;v++)c?p.values[x*i+v]+=h[g*i+v]:p.values[x*i+v]=e.rank===0?h[0]:h[g*i+v]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O1e=Dl(n=>1/(1+Math.exp(-n))),HU=Ds(Fp,n=>1/(1+Math.exp(-n))),z1e={kernelName:Fp,backendName:"cpu",kernelFunc:HU};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jU(n,e,t,s,i){const r=KT(s,e,t),o=Le(t),a=gn(s);if(r){const d=YT(e,a);return i==="string"?n.slice(d,d+o):n.subarray(d,d+o)}const l=i==="string"?Oa(n):n,c=Yn(s,i,l),u=Yn(t,i);for(let d=0;d<u.size;++d){const h=u.indexToLoc(d),p=h.map((g,y)=>g+e[y]);u.set(c.get(...p),...h)}return i==="string"?q6(u.values):u.values}function Pd(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s;un(i,"slice");const[a,l]=f1(i,r,o);uw(i,a,l);const c=t.data.get(i.dataId).values,u=jU(c,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,u)}const B1e={kernelName:t1,backendName:"cpu",kernelFunc:Pd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XU(n,e,t,s,i,r,o){const a=e[0],l=r[0],c=new Array(l),u=new Array(a),d=e[1];if(l===0){if(a!==0)throw new Error($6(a));const x=fi(t,0),v=fi(i,0);return[x,[0,d],v,c,u]}let h=!0,p=0;const g=new Array(l).fill(0);for(let x=0;x<a;++x){const v=n[x*d];if(v<0)throw new Error(F6(x,v));if(v>=l)throw new Error(O6(x,v,l));++g[v],h=h&&v>=p,p=v}let y=!0;for(let x=0;x<l;++x){const v=g[x]===0;c[x]=v,y=y&&!v,g[x]=Math.max(g[x],1),x>0&&(g[x]+=g[x-1])}if(y&&h){const x=n,v=s;for(let b=0;b<a;++b)u[b]=b;return[x,[a,d],v,c,u]}else{const x=g[l-1],v=fi(t,x*d),b=fi(i,x),S=new Array(l).fill(0);for(let C=0;C<a;++C){const E=n[C*d],k=S[E],R=(E===0?0:g[E-1])+k;S[E]++;for(let L=0;L<d;++L)v[R*d+L]=n[C*d+L];b[R]=s[C],u[C]=R}for(let C=0;C<l;++C)if(S[C]===0){const k=C===0?0:g[C-1];v[k*d+0]=C;for(let R=1;R<d;++R)v[k*d+R]=0;b[k]=o}return[v,[x,d],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(n,e,t,s,i){const r=Le(s),o=e[0],a=i.length,l=[];let c=1,u=-1;for(let x=0;x<a;++x){const v=i[x];if(v===-1){if(u!==-1)throw new Error(z6(u,x));u=x,l.push(1)}else{if(v<0)throw new Error(B6(x,v));c*=v,l.push(v)}}if(u!==-1){if(c<=0)throw new Error(U6());const x=Math.trunc(r/c);if(c*x!==r)throw new Error(V6(s,l));l[u]=x}if(Le(l)!==r)throw new Error(W6(s,l));const h=s.length,p=[];if(h>0){p[h-1]=1;for(let x=h-2;x>=0;--x)p[x]=p[x+1]*s[x+1]}const g=[];if(a>0){g[a-1]=1;for(let x=a-2;x>=0;--x)g[x]=g[x+1]*l[x+1]}const y=fi(t,o*a);for(let x=0;x<o;++x){let v=0;for(let b=0;b<h;++b)v+=n[x*h+b]*p[b];for(let b=0;b<a;++b)y[x*a+b]=Math.trunc(v/g[b]),v%=g[b]}return[y,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n,e,t,s,i,r=!1,o=0){const a=s.length,l=[e[0],n.length/e[0]],c=l[1],d=a>0?i[a-1]+1:0;if(d<0)throw new Error(g_());const h=e.slice();h[0]=d;const p=h.reduce((S,C)=>S*C,1),g=fi(t,p);if(a===0)return d>0&&g.fill(o),[g,h];if(d<=0)throw new Error(g_());let y=0,x=1,v=0,b=i[y];for(;;){let S=0;if(x<a){if(S=i[x],b===S){++x;continue}if(b>=S)throw new Error(G6())}if(b<0||b>=d)throw new Error(H6(b,d));b>v&&g.fill(o,v*c,b*c);for(let C=y;C<x;++C){const E=s[C];if(E<0||E>=l[0])throw new Error(j6(C,s[C],l[0]));for(let k=0;k<c;k++)g[b*c+k]+=n[E*c+k]}if(r)for(let C=0;C<c;C++)g[b*c+C]/=x-y;if(y=x,++x,v=b+1,b=S,x>a)break}return v<d&&g.fill(o,v*c,d*c),[g,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U1e=Dl(n=>Math.sqrt(n)),V1e=Ds(zp,n=>Math.sqrt(n)),W1e={kernelName:zp,backendName:"cpu",kernelFunc:V1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KU=Ei((n,e)=>{const t=n-e;return t*t}),G1e=Gi(Bp,KU),H1e={kernelName:Bp,backendName:"cpu",kernelFunc:G1e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YU=Dl((n,e)=>{const{pattern:t,replaceGlobal:s,rewrite:i}=e;return n.replace(new RegExp(t,s?"g":""),i)}),j1e=bu(pT,YU),X1e={kernelName:pT,backendName:"cpu",kernelFunc:j1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n,e,t,s){const i=Yn(n,e.dtype);for(let r=0;r<i.size;r++){const o=i.indexToLoc(r),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+s[l];i.set(e.get(...a),...o)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q1e{constructor(e,t,s,i,r,o){this.separator=ac(e),this.nGramWidths=t,this.leftPad=ac(s),this.rightPad=ac(i),this.padWidth=r,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,i,r,o){for(let a=0;a<r;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(r-(a+1))),d=o-(c+u),h=t+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let b=0;b<d;++b)p+=e[h+b].length;p+=u*this.rightPad.length;const g=c+u+d-1;p+=g*this.separator.length,s[i+a]=new Uint8Array(p);const y=s[i+a];let x=0;const v=b=>b.forEach(S=>y[x++]=S);for(let b=0;b<c;++b)v(this.leftPad),v(this.separator);for(let b=0;b<d-1;++b)v(e[h+b]),v(this.separator);if(d>0){v(e[h+d-1]);for(let b=0;b<u;++b)v(this.separator),v(this.rightPad)}else{for(let b=0;b<u-1;++b)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const s=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let u=t[c]>=l;if(u=u&&t[c]<=s,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const r=i-1,o=fi("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=r;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=r;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[r]);for(let l=0;l<r;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(d=>{const h=t[l+1]-t[l],p=this.getNumNGrams(h,d);this.createNGrams(e,c,a,u,p,d),u+=p}),this.preserveShort&&u===o[l]){const d=t[l+1]-t[l];if(d===0)continue;const h=d+2*this.padWidth;this.createNGrams(e,c,a,u,1,h)}}return[a,o]}}function QU(n,e,t,s,i,r,o,a){return new q1e(t,s,i,r,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1e(n,e,t,s){if(!n.length)return;if(e.length===0){for(let r=0;r<n.length;++r)s.push(n.subarray(r,r+1));return}if(e.length===1){const r=e[0];let o=n.indexOf(r);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(r)}(!t||n.length!==0)&&s.push(n);return}let i=0;for(let r=0;r<n.length+1;r++)if(r===n.length||e.indexOf(n[r])!==-1){const o=n.subarray(i,r);(!t||o.length!==0)&&s.push(o),i=r+1}}function JU(n,e,t){const s=n.length,i=[];let r=0,o=0;const a=new Array(s);for(let h=0;h<s;++h){const p=i.length;K1e(n[h],e,t,i);const g=i.length-p;a[h]=g,r+=g,o=Math.max(o,g)}const l=fi("int32",r*2),c=new Array(r),u=[s,o];let d=0;for(let h=0;h<s;++h)for(let p=0;p<a[h];++p)l[d*2]=h,l[d*2+1]=p,c[d]=i[d],++d;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(n,e){const t=fi("int32",n.length);for(let s=0;s<n.length;++s)t[s]=kae(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t8=Ei((n,e)=>n-e),Y1e=SI((n,e,t,s)=>({real:n-t,imag:e-s})),II=Gi(Up,t8,Y1e),Z1e={kernelName:Up,backendName:"cpu",kernelFunc:II};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n8(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const s=Yn(t,n.dtype);for(let i=0;i<s.values.length;++i){const r=s.indexToLoc(i),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=r[l]%n.shape[l];const a=n.locToIndex(o);s.values[i]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const og=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function s8(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),h=Math.max(t,Math.floor(e-l*u/a+d)),p=Math.min(s,Math.floor(e+(a-l)*u/a+d));s8(n,e,h,p)}const i=n[e];let r=t,o=s;for(Kh(n,t,e),og(n[s],i)>0&&Kh(n,t,s);r<o;){for(Kh(n,r,o),r++,o--;og(n[r],i)<0;)r=r+1;for(;og(n[o],i)>0;)o=o-1}og(n[t],i)===0?Kh(n,t,o):(o=o+1,Kh(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function i8(n,e,t,s,i){const r=e[e.length-1],[o,a]=[n.length/r,r],l=Qi(t,o*s),c=Qi("int32",o*s);for(let d=0;d<o;d++){const h=d*a,p=n.subarray(h,h+a);let g=new Array(p.length);p.forEach((b,S)=>g[S]={value:b,index:S}),s<g.length&&(s8(g,s),g=g.slice(0,s)),i&&g.sort(og);const y=d*s,x=l.subarray(y,y+s),v=c.subarray(y,y+s);for(let b=0;b<s;b++)x[b]=g[b].value,v[b]=g[b].index}const u=e.slice();return u[u.length-1]=s,[Yn(u,t,l),Yn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(n,e,t,s){const i=Hn(e,t)[0],r=[1,t[0],1];for(let g=0;g<i;g++)r[0]*=t[g];r[1]=t[i];for(let g=i+1;g<t.length;g++)r[2]*=t[g];const o=new Map,a=new Int32Array(t[i]),l=new ur(r,s,n),c=[],u=r[0]===1&&r[2]===1;for(let g=0;g<t[i];g++){let y;if(u)y=n[g].toString();else{const v=[];for(let b=0;b<r[0];b++)for(let S=0;S<r[2];S++)v.push(l.get(b,g,S));y=v.join(",")}const x=o.get(y);if(x!=null)a[g]=x;else{const v=o.size;o.set(y,v),a[g]=v,c.push(g)}}const d=r.slice();d[1]=o.size;const h=new ur(d,s);c.forEach((g,y)=>{for(let x=0;x<r[0];x++)for(let v=0;v<r[2];v++)h.set(l.get(x,g,v),x,y,v)});const p=t.slice();return p[i]=d[1],{outputValues:h.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o8=Object.freeze(Object.defineProperty({__proto__:null,addImpl:pU,bincountImpl:CI,bincountReduceImpl:mU,bitwiseAndImpl:gU,castImpl:fU,ceilImpl:xU,concatImpl:vU,equalImpl:yU,expImpl:bU,expm1Impl:CU,floorDivImpl:EU,floorImpl:_U,gatherNdImpl:TU,gatherV2Impl:IU,greaterEqualImpl:AU,greaterImpl:kU,lessEqualImpl:MU,lessImpl:RU,linSpaceImpl:NU,logImpl:PU,maxImpl:DU,maximumImpl:LU,minimumImpl:$U,multiplyImpl:_I,negImpl:FU,notEqualImpl:OU,prodImpl:zU,raggedGatherImpl:BU,raggedRangeImpl:UU,raggedTensorToTensorImpl:VU,rangeImpl:WU,rsqrtImpl:GU,scatterImpl:ad,sigmoidImpl:O1e,simpleAbsImpl:hU,sliceImpl:jU,sparseFillEmptyRowsImpl:XU,sparseReshapeImpl:qU,sparseSegmentReductionImpl:TI,sqrtImpl:U1e,squaredDifferenceImpl:KU,staticRegexReplaceImpl:YU,stridedSliceImpl:ZU,stringNGramsImpl:QU,stringSplitImpl:JU,stringToHashBucketFastImpl:e8,subImpl:t8,tileImpl:n8,topKImpl:i8,transposeImpl:EI,uniqueImpl:r8},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */yT("cpu",()=>new Uw,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a8=Ds(up,n=>n>=0?n:Math.exp(n)-1),Q1e={kernelName:up,backendName:"cpu",kernelFunc:a8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s;un([i],"leakyRelu");const o=Le(i.shape),a=t.data.get(i.dataId).values,l=Qi("float32",o);for(let c=0;c<a.length;c++)l[c]=a[c]<0?r*a[c]:a[c];return t.makeTensorInfo(i.shape,"float32",l)}const J1e={kernelName:A0,backendName:"cpu",kernelFunc:l8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const exe=Ei((n,e)=>n<0?e*n:n);function c8(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e;un([s,i],"prelu");const r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,[a,l]=exe(s.shape,i.shape,r,o,"float32");return t.makeTensorInfo(l,"float32",a)}const txe={kernelName:q0,backendName:"cpu",kernelFunc:c8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u8=Ds(Ap,n=>Math.max(0,n)),nxe={kernelName:Ap,backendName:"cpu",kernelFunc:u8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d8=Ds(Rp,n=>Math.min(Math.max(0,n),6)),sxe={kernelName:Rp,backendName:"cpu",kernelFunc:d8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L2(n,e,t,s,i){if(t==="linear")return Il({inputs:{x:e},backend:n});if(t==="relu")return u8({inputs:{x:e},backend:n});if(t==="elu")return a8({inputs:{x:e},backend:n});if(t==="relu6")return d8({inputs:{x:e},backend:n});if(t==="prelu")return c8({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return l8({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return HU({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ks(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,o=Le(i.shape),a=KE(r,o),l=Le(a);re(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;u.shape=a,d.shape=a}return{dataId:i.dataId,shape:a,dtype:i.dtype}}const ixe={kernelName:Y0,backendName:"cpu",kernelFunc:Ks};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;un([i,r],"matMul");const l=i.shape.length,c=r.shape.length,u=o?i.shape[l-2]:i.shape[l-1],d=a?r.shape[c-1]:r.shape[c-2],h=o?i.shape[l-1]:i.shape[l-2],p=a?r.shape[c-2]:r.shape[c-1],g=i.shape.slice(0,-2),y=r.shape.slice(0,-2),x=Le(g),v=Le(y),S=Mn(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([h,p]);re(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${o} and transposeB=${a} must match.`);const C=o?[x,u,h]:[x,h,u],E=a?[v,p,d]:[v,d,p],k=Ks({inputs:{x:i},backend:t,attrs:{shape:C}}),R=Ks({inputs:{x:r},backend:t,attrs:{shape:E}}),L=o?k.shape[1]:k.shape[2],I=o?k.shape[2]:k.shape[1],T=a?R.shape[1]:R.shape[2],M=Math.max(x,v),j=t.data.get(k.dataId).values,W=t.data.get(R.dataId).values,z=gn(k.shape),X=gn(R.shape),[B,J,K]=o?[z[0],1,z[1]]:[z[0],z[1],1],[ee,ne,V]=a?[1,X[1],X[0]]:[X[1],1,X[0]],Z=I*T,he=Yn([M,I,T],k.dtype),ve=he.values,be=t.blockSize;for(let Ie=0;Ie<M;Ie++){const Xe=Ie%x,Fe=Ie%v;for(let Pe=0;Pe<I;Pe+=be){const ct=Math.min(Pe+be,I);for(let at=0;at<T;at+=be){const Ee=Math.min(at+be,T);for(let nn=0;nn<L;nn+=be){const gt=Math.min(nn+be,L);for(let vt=Pe;vt<ct;vt++)for(let wt=at;wt<Ee;wt++){let Vt=0;for(let It=nn;It<gt;It++){const zt=j[Xe*B+vt*J+It*K],Gt=W[It*ee+wt*ne+Fe*V];Vt+=zt*Gt}ve[Ie*Z+(vt*T+wt)]+=Vt}}}}}return t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(S,he.dtype,he.values)}const rxe={kernelName:p0,backendName:"cpu",kernelFunc:h8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oxe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=s;let h,p,g;const y=[];h=h8({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:c},backend:t}),o&&(p=Df({inputs:{a:h,b:o},backend:t}),y.push(h),h=p),u&&(g=L2(t,h,u,a,d),y.push(h),h=g);for(const v of y)t.disposeIntermediateTensorInfo(v);return h}const axe={kernelName:Dg,backendName:"cpu",kernelFunc:oxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lxe=Ds(Zf,n=>Math.acos(n)),cxe={kernelName:Zf,backendName:"cpu",kernelFunc:lxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uxe=Ds(Qf,n=>Math.acosh(n)),dxe={kernelName:Qf,backendName:"cpu",kernelFunc:uxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hxe(n){const{inputs:e,backend:t}=n,s=e;un(e,"addN");const i=s.map(a=>t.data.get(a.dataId).values),r=Yn(s[0].shape,s[0].dtype),o=r.values;for(let a=0;a<s.length;a++){const l=i[a];for(let c=0;c<o.length;c++)o[c]+=l[c]}return t.makeTensorInfo(r.shape,r.dtype,r.values)}const fxe={kernelName:py,backendName:"cpu",kernelFunc:hxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;un(i,"all");const a=Hn(r,i.shape);let l=a;const c=Os(l,i.shape.length);let u=i;c!=null&&(u=eo({inputs:{x:i},backend:t,attrs:{perm:c}}),l=Ys(l.length,i.shape.length)),Ai("all",l,u.shape.length);const[d,h]=Ci(u.shape,l),p=Le(h),g=dr(Le(d),u.dtype),y=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const b=v*p;let S=y[b];for(let C=0;C<p;++C){const E=y[b+C];S=S&&E}g[v]=S}c!=null&&t.disposeIntermediateTensorInfo(u);const x=t.makeTensorInfo(d,u.dtype,g);if(o){const v=Si(d,a),b=Ks({inputs:{x},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(x),b}return x}const mxe={kernelName:my,backendName:"cpu",kernelFunc:pxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;un(i,"any");const a=Hn(r,i.shape);let l=a;const c=Os(l,i.shape.length);let u=i;c!=null&&(u=eo({inputs:{x:i},backend:t,attrs:{perm:c}}),l=Ys(l.length,i.shape.length)),Ai("any",l,u.shape.length);const[d,h]=Ci(u.shape,l),p=Le(h),g=dr(Le(d),u.dtype),y=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const b=v*p;let S=y[b];for(let C=0;C<p;++C){const E=y[b+C];S=S||E}g[v]=S}c!=null&&t.disposeIntermediateTensorInfo(u);const x=t.makeTensorInfo(d,u.dtype,g);if(o){const v=Si(d,a),b=Ks({inputs:{x},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(x),b}return x}const xxe={kernelName:gy,backendName:"cpu",kernelFunc:gxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;un(i,"argMax");let o=Hn(r,i.shape);const a=Os(o,i.shape.length);let l=i;const c=[];a!=null&&(l=eo({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Ys(o.length,l.shape.length)),o=[o[0]],Ai("argMax",o,l.shape.length);const[u,d]=Ci(l.shape,o),h=Le(u),p=dr(h,"int32"),g=Le(d),y=t.data.get(l.dataId).values;for(let x=0;x<p.length;++x){const v=x*g;let b=y[v],S=0;for(let C=0;C<g;++C){const E=y[v+C];E>b&&(b=E,S=C)}p[x]=S}return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(u,"int32",p)}const yxe={kernelName:u0,backendName:"cpu",kernelFunc:vxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;un(i,"argMin");let o=Hn(r,i.shape);const a=Os(o,i.shape.length);let l=i;const c=[];a!=null&&(l=eo({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Ys(o.length,l.shape.length)),o=[o[0]],Ai("argMin",o,l.shape.length);const[u,d]=Ci(l.shape,o),h=Le(u),p=dr(h,"int32"),g=Le(d),y=t.data.get(l.dataId).values;for(let x=0;x<p.length;++x){const v=x*g;let b=y[v],S=0;for(let C=0;C<g;++C){const E=y[v+C];E<b&&(b=E,S=C)}p[x]=S}return c.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(u,"int32",p)}const bxe={kernelName:d0,backendName:"cpu",kernelFunc:wxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sxe=Ds(Jf,n=>Math.asin(n)),Cxe={kernelName:Jf,backendName:"cpu",kernelFunc:Sxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _xe=Ds(ep,n=>Math.asinh(n)),Exe={kernelName:ep,backendName:"cpu",kernelFunc:_xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Txe=Ds(tp,n=>Math.atan(n)),Ixe={kernelName:tp,backendName:"cpu",kernelFunc:Txe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kxe=Ei((n,e)=>Math.atan2(n,e)),Axe=Gi(sp,kxe),Rxe={kernelName:sp,backendName:"cpu",kernelFunc:Axe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mxe=Ds(np,n=>Math.atanh(n)),Nxe={kernelName:np,backendName:"cpu",kernelFunc:Mxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kI(n,e,t,s,i,r){const o=i.strideHeight,a=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,d=i.effectiveFilterWidth,h=i.padInfo.top,p=i.padInfo.left,g=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=Yn(i.outShape,t),x=y.values,v=i.outShape[1]*i.outShape[2]*i.outShape[3],b=i.outShape[2]*i.outShape[3],S=i.outShape[3];for(let C=0;C<i.batchSize;++C){const E=C*v,k=C*s[0];for(let R=0;R<i.inChannels;++R)for(let L=0;L<i.outHeight;++L){const I=L*o-h,T=Math.max(0,I),M=Math.min(i.inHeight,u+I),j=E+L*b;for(let W=0;W<i.outWidth;++W){const z=W*a-p,X=Math.max(0,z),B=Math.min(i.inWidth,d+z);let J=g,K=0,ee=0;for(let V=T;V<M;V+=l){const Z=k+V*s[1];for(let he=X;he<B;he+=c){const ve=Z+he*s[2],be=n[ve+R];r==="max"&&be>J?J=be:r==="avg"&&(K+=be,ee++)}if(isNaN(J))break}const ne=j+W*S+R;x[ne]=r==="avg"?K/ee:J}}}return y}function f8(n,e,t,s,i=!1,r=!1){const o=Yn(s.outShape,"int32"),a=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,u=s.dilationWidth,d=s.effectiveFilterHeight,h=s.effectiveFilterWidth,p=s.padInfo.top,g=s.padInfo.left,y=Yn(e,t,n);for(let x=0;x<s.batchSize;++x)for(let v=0;v<s.inChannels;++v)for(let b=0;b<s.outHeight;++b){const S=b*a-p;let C=S;for(;C<0;)C+=c;const E=Math.min(s.inHeight,d+S);for(let k=0;k<s.outWidth;++k){const R=k*l-g;let L=R;for(;L<0;)L+=u;const I=Math.min(s.inWidth,h+R);let T=Number.NEGATIVE_INFINITY,M=-1;for(let j=C;j<E;j+=c){const W=j-S;for(let z=L;z<I;z+=u){const X=z-R,B=y.get(x,j,z,v);B>T&&(T=B,i?M=r?((x*s.inHeight+j)*s.inWidth+z)*s.inChannels+v:(j*s.inWidth+z)*s.inChannels+v:M=W*h+X)}}o.set(M,x,b,k,v)}}return o}function p8(n,e,t,s,i,r){const o=i.strideDepth,a=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,u=i.dilationHeight,d=i.dilationWidth,h=i.effectiveFilterDepth,p=i.effectiveFilterHeight,g=i.effectiveFilterWidth,y=i.padInfo.front,x=i.padInfo.top,v=i.padInfo.left,b=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=Yn(i.outShape,t),C=S.values,E=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],k=i.outShape[2]*i.outShape[3]*i.outShape[4],R=i.outShape[3]*i.outShape[4],L=i.outShape[4];for(let I=0;I<i.batchSize;++I){const T=I*E,M=I*s[0];for(let j=0;j<i.inChannels;++j)for(let W=0;W<i.outDepth;++W){const z=W*o-y;let X=z;for(;X<0;)X+=c;const B=Math.min(i.inDepth,h+z),J=T+W*k;for(let K=0;K<i.outHeight;++K){const ee=K*a-x;let ne=ee;for(;ne<0;)ne+=u;const V=Math.min(i.inHeight,p+ee),Z=J+K*R;for(let he=0;he<i.outWidth;++he){const ve=he*l-v;let be=ve;for(;be<0;)be+=d;const Ie=Math.min(i.inWidth,g+ve),Xe=Z+he*L;let Fe=b,Pe=0,ct=0;for(let Ee=X;Ee<B;Ee+=c){const nn=M+Ee*s[1];for(let gt=ne;gt<V;gt+=u){const vt=nn+gt*s[2];for(let wt=be;wt<Ie;wt+=d){const Vt=vt+wt*s[3],It=n[Vt+j];if(r==="max"&&It>Fe?Fe=It:r==="avg"&&(Pe+=It,ct++),isNaN(Fe))break}if(isNaN(Fe))break}if(isNaN(Fe))break}const at=Xe+j;C[at]=r==="avg"?Pe/Math.max(ct,1):Fe}}}}return S}function Pxe(n,e){const t=Yn(e.outShape,"int32"),s=e.strideDepth,i=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.front,p=e.padInfo.top,g=e.padInfo.left;for(let y=0;y<e.batchSize;++y)for(let x=0;x<e.inChannels;++x)for(let v=0;v<e.outDepth;++v){const b=v*s-h;let S=b;for(;S<0;)S+=o;const C=Math.min(e.inDepth,c+b);for(let E=0;E<e.outHeight;++E){const k=E*i-p;let R=k;for(;R<0;)R+=a;const L=Math.min(e.inHeight,u+k);for(let I=0;I<e.outWidth;++I){const T=I*r-g;let M=T;for(;M<0;)M+=l;const j=Math.min(e.inWidth,d+T);let W=Number.NEGATIVE_INFINITY,z=-1;for(let X=S;X<C;X+=o){const B=X-b;for(let J=R;J<L;J+=a){const K=J-k;for(let ee=M;ee<j;ee+=l){const ne=ee-T,V=n.get(y,X,J,ee,x);V>=W&&(W=V,z=B*u*d+K*u+ne)}}}t.set(z,y,v,E,I,x)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;un(i,"avgPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;re(er(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=br(i.shape,r,o,c,a,l);let d;if(u.filterWidth===1&&u.filterHeight===1&&ds(u.inShape,u.outShape))d=Il({inputs:{x:i},backend:t});else{const h=t.data.get(i.dataId).values,p=gn(i.shape),g=kI(h,i.shape,i.dtype,p,u,"avg");d=t.makeTensorInfo(u.outShape,i.dtype,g.values)}return d}const Lxe={kernelName:h0,backendName:"cpu",kernelFunc:Dxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;un(i,"avgPool3d");const u=Fo(i.shape,r,o,1,a,l,c),d=t.data.get(i.dataId).values,h=p8(d,i.shape,i.dtype,gn(i.shape),u,"avg");return t.makeTensorInfo(h.shape,"float32",h.values)}const Fxe={kernelName:f0,backendName:"cpu",kernelFunc:$xe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;un([i,r],"avgPool3DGrad");const u=Fo(r.shape,o,a,1,l,c),d=u.strideDepth,h=u.strideHeight,p=u.strideWidth,g=u.filterDepth,y=u.filterHeight,x=u.filterWidth,v=u.dilationDepth,b=u.dilationHeight,S=u.dilationWidth,C=u.effectiveFilterDepth,E=u.effectiveFilterHeight,k=u.effectiveFilterWidth,R=C-1-u.padInfo.front,L=k-1-u.padInfo.left,I=E-1-u.padInfo.top,T=Yn(r.shape,"float32"),M=1/(g*y*x),j=t.bufferSync(i);for(let W=0;W<u.batchSize;++W)for(let z=0;z<u.inChannels;++z)for(let X=0;X<u.inDepth;++X)for(let B=0;B<u.inHeight;++B)for(let J=0;J<u.inWidth;++J){const K=X-R,ee=B-I,ne=J-L;let V=0;for(let Z=0;Z<C;Z+=v){const he=(K+Z)/d;if(!(he<0||he>=u.outDepth||Math.floor(he)!==he))for(let ve=0;ve<E;ve+=b){const be=(ee+ve)/h;if(!(be<0||be>=u.outHeight||Math.floor(be)!==be))for(let Ie=0;Ie<k;Ie+=S){const Xe=(ne+Ie)/p;if(Xe<0||Xe>=u.outWidth||Math.floor(Xe)!==Xe)continue;const Fe=j.get(W,he,be,Xe,z);V+=Fe}}}T.set(V*M,W,X,B,J,z)}return t.makeTensorInfo(T.shape,T.dtype,T.values)}const zxe={kernelName:vy,backendName:"cpu",kernelFunc:Oxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;un([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=br(o.shape,a,l,1,c),d=u.strideHeight,h=u.strideWidth,p=u.filterHeight,g=u.filterWidth,y=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterHeight,b=u.effectiveFilterWidth,S=b-1-u.padInfo.left,C=v-1-u.padInfo.top,E=Yn(o.shape,"float32"),k=1/(p*g),R=t.data.get(i.dataId).values,L=Yn(i.shape,"float32",R);for(let I=0;I<u.batchSize;++I)for(let T=0;T<u.inChannels;++T)for(let M=0;M<u.inHeight;++M)for(let j=0;j<u.inWidth;++j){const W=M-C,z=j-S;let X=0;for(let B=0;B<v;B+=y){const J=(W+B)/d;if(!(J<0||J>=u.outHeight||Math.floor(J)!==J))for(let K=0;K<b;K+=x){const ee=(z+K)/h;if(ee<0||ee>=u.outWidth||Math.floor(ee)!==ee)continue;const ne=L.get(I,J,ee,T);X+=ne}}E.set(X*k,I,M,j,T)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Uxe={kernelName:xy,backendName:"cpu",kernelFunc:Bxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,scale:r,offset:o,mean:a,variance:l}=e;re(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),re(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),re(r==null||a.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),un([i,a,l,r,o],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const u=t.data.get(i.dataId).values,d=t.data.get(a.dataId).values,h=t.data.get(l.dataId).values,p=r?t.data.get(r.dataId).values:new Float32Array([1]),g=o?t.data.get(o.dataId).values:new Float32Array([0]),y=new Float32Array(u.length),x=g.length,v=p.length,b=h.length,S=d.length;let C=0,E=0,k=0,R=0;for(let L=0;L<u.length;++L)y[L]=g[C++]+(u[L]-d[E++])*p[k++]/Math.sqrt(h[R++]+c),C>=x&&(C=0),E>=S&&(E=0),k>=v&&(k=0),R>=b&&(R=0);return t.makeTensorInfo(i.shape,i.dtype,y)}const Wxe={kernelName:T0,backendName:"cpu",kernelFunc:Vxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;un([i],"batchToSpaceND");const a=r.reduce((v,b)=>v*b),l=Gd(i.shape,r,a),c=Hd(l.length,r.length),u=jd(i.shape,r,a),d=gw(o,r.length),h=xw(u,o,r.length),p=Ks({inputs:{x:i},backend:t,attrs:{shape:l}}),g=eo({inputs:{x:p},backend:t,attrs:{perm:c}}),y=Ks({inputs:{x:g},backend:t,attrs:{shape:u}}),x=Pd({inputs:{x:y},backend:t,attrs:{begin:d,size:h}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),x}const Hxe={kernelName:m0,backendName:"cpu",kernelFunc:Gxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jxe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=CI(a,l,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,c)}const Xxe={kernelName:yy,backendName:"cpu",kernelFunc:jxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qxe(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,a=Mn(Array.from(r),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Kxe={kernelName:tT,backendName:"cpu",kernelFunc:qxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yxe=Ds(op,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),Zxe={kernelName:op,backendName:"cpu",kernelFunc:Yxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qxe=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(Le(e.shape)),i=t.data.get(e.dataId),r=i.complexTensorInfos.real,o=i.complexTensorInfos.imag,a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values;for(let c=0;c<a.length;c++){const u=a[c],d=l[c];s[c]=Math.hypot(u,d)}return t.makeOutput(s,e.shape,"float32")},Jxe={kernelName:g0,backendName:"cpu",kernelFunc:Qxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lf(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.imag,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const eve={kernelName:$y,backendName:"cpu",kernelFunc:Lf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Hn(i,e[0].shape)[0],o=e.map(y=>y.shape);fw(o,r);let a=Zr(e.map(y=>y.shape),r);if(Le(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(y=>Le(y.shape)>0);if(l.length===1)return Il({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const y=l.map(C=>Nd({inputs:{input:C},backend:t})),x=l.map(C=>Lf({inputs:{input:C},backend:t})),v=$f({inputs:y,backend:t,attrs:{axis:r}}),b=$f({inputs:x,backend:t,attrs:{axis:r}}),S=mo({inputs:{real:v,imag:b},backend:t});return y.forEach(C=>t.disposeIntermediateTensorInfo(C)),x.forEach(C=>t.disposeIntermediateTensorInfo(C)),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(b),S}const c=l.map(y=>{const v=[-1,Le(y.shape.slice(r))];return Ks({inputs:{x:y},backend:t,attrs:{shape:v}})}),u=c.map(y=>({vals:t.data.get(y.dataId).values,shape:y.shape}));a=Zr(c.map(y=>y.shape),1);const d=c[0].shape[0]===1,h=vU(u,a,e[0].dtype,d),p=Zr(l.map(y=>y.shape),r),g=t.makeTensorInfo(p,e[0].dtype,h);return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}const tve={kernelName:x0,backendName:"cpu",kernelFunc:$f};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s;un([i,r],"conv2d");const d=bo(l),h=Js(i.shape,r.shape,o,c,a,u,!1,d),p=h.filterHeight,g=h.filterWidth,y=h.dilationHeight,x=h.dilationWidth,v=h.padInfo.left,b=h.padInfo.top,S=h.dataFormat==="channelsLast",C=new ur(h.outShape,i.dtype),E=gn(i.shape),k=gn(r.shape),R=E[0],L=S?E[1]:E[2],I=S?E[2]:1,T=S?1:E[1],M=C.strides[0],j=S?C.strides[1]:C.strides[2],W=S?C.strides[2]:1,z=S?1:C.strides[1],X=t.data.get(i.dataId).values,B=t.data.get(r.dataId).values,J=C.values;for(let K=0;K<h.batchSize;++K){const ee=K*R,ne=K*M;for(let V=0;V<h.outHeight;++V){const Z=ne+V*j,he=V*h.strideHeight-b;for(let ve=0;ve<p;++ve){const be=he+ve*y;if(be<0||be>=h.inHeight)continue;const Ie=ve*k[0],Xe=ee+be*L;for(let Fe=0;Fe<h.outWidth;++Fe){const Pe=Z+Fe*W,ct=Fe*h.strideWidth-v;for(let at=0;at<g;++at){const Ee=ct+at*x;if(Ee<0||Ee>=h.inWidth)continue;const nn=Ie+at*k[1],gt=Xe+Ee*I;let vt=nn;for(let wt=0;wt<h.inChannels;++wt){const Vt=X[gt+wt*T];for(let It=0;It<h.outChannels;++It)J[Pe+It*z]+=Vt*B[vt+It];vt+=h.outChannels}}}}}}return t.makeTensorInfo(C.shape,C.dtype,J)}const nve={kernelName:v0,backendName:"cpu",kernelFunc:m8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s;un([i,r],"conv2dBackpropFilter");const d=bo(l),h=Js(i.shape,u,o,1,a,c,!1,d),{strideHeight:p,strideWidth:g,filterHeight:y,filterWidth:x}=h,v=h.dataFormat==="channelsLast",b=new ur(h.filterShape,"float32"),S=h.padInfo.left,C=h.padInfo.top,E=t.data.get(i.dataId).values,k=t.data.get(r.dataId).values,R=new ur(i.shape,i.dtype,E),L=new ur(r.shape,r.dtype,k);for(let I=0;I<y;++I){const T=Math.max(0,Math.ceil((C-I)/p)),M=Math.min(h.outHeight,(h.inHeight+C-I)/p);for(let j=0;j<x;++j){const W=Math.max(0,Math.ceil((S-j)/g)),z=Math.min(h.outWidth,(h.inWidth+S-j)/g);for(let X=0;X<h.inChannels;++X)for(let B=0;B<h.outChannels;++B){let J=0;for(let K=0;K<h.batchSize;++K)for(let ee=T;ee<M;++ee){const ne=I+ee*p-C;for(let V=W;V<z;++V){const Z=j+V*g-S;v?J+=R.get(K,ne,Z,X)*L.get(K,ee,V,B):J+=R.get(K,X,ne,Z)*L.get(K,B,ee,V)}}b.set(J,I,j,X,B)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const ive={kernelName:by,backendName:"cpu",kernelFunc:sve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s;un([i,r],"conv2dBackpropInput");const d=gn(r.shape),h=gn(i.shape);let p=bo(c);const g=Js(o,r.shape,a,1,l,u,!1,p),y=new ur(g.inShape,"float32"),x=y.values,v=t.data.get(i.dataId).values,b=t.data.get(r.dataId).values,[S,C,E]=d,{batchSize:k,filterHeight:R,filterWidth:L,inChannels:I,inHeight:T,inWidth:M,outChannels:j,outHeight:W,outWidth:z,strideHeight:X,strideWidth:B}=g;p=g.dataFormat;const J=R-1-g.padInfo.top,K=L-1-g.padInfo.left,ee=p==="channelsLast",ne=y.strides[0],V=ee?y.strides[1]:y.strides[2],Z=ee?y.strides[2]:1,he=ee?1:y.strides[1],ve=h[0],be=ee?h[1]:h[2],Ie=ee?h[2]:1,Xe=ee?1:h[1];for(let Fe=0;Fe<k;++Fe)for(let Pe=0;Pe<I;++Pe)for(let ct=0;ct<T;++ct){const at=ct-J,Ee=Math.max(0,Math.ceil(at/X)),nn=Math.min(W,(R+at)/X);for(let gt=0;gt<M;++gt){const vt=gt-K,wt=Math.max(0,Math.ceil(vt/B)),Vt=Math.min(z,(L+vt)/B);let It=0;for(let Gt=Ee;Gt<nn;++Gt){const dn=Gt*X-at;for(let vn=wt;vn<Vt;++vn){const ce=vn*B-vt,Y=ve*Fe+be*Gt+Ie*vn,ye=S*(R-1-dn)+C*(L-1-ce)+E*Pe;for(let Qe=0;Qe<j;++Qe){const tt=v[Y+Xe*Qe],rt=b[ye+Qe];It+=tt*rt}}}const zt=ne*Fe+V*ct+Z*gt+he*Pe;x[zt]=It}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const ove={kernelName:y0,backendName:"cpu",kernelFunc:rve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s;un([i,r],"conv3d");const c=Wa(i.shape,r.shape,o,l,a),{filterDepth:u,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:g,dilationWidth:y,padInfo:x}=c,v=x.front,b=x.left,S=x.top,C=new ur(c.outShape,i.dtype),E=t.data.get(i.dataId).values,k=t.data.get(r.dataId).values,R=C.values,L=gn(i.shape),I=gn(r.shape);for(let T=0;T<c.batchSize;++T){const M=T*L[0],j=T*C.strides[0];for(let W=0;W<c.outDepth;++W){const z=j+W*C.strides[1],X=W*c.strideDepth-v;for(let B=0;B<u;++B){const J=X+B*p;if(J<0||J>=c.inDepth)continue;const K=B*I[0],ee=M+J*L[1];for(let ne=0;ne<c.outHeight;++ne){const V=z+ne*C.strides[2],Z=ne*c.strideHeight-S;for(let he=0;he<d;++he){const ve=Z+he*g;if(ve<0||ve>=c.inHeight)continue;const be=K+he*I[1],Ie=ee+ve*L[2];for(let Xe=0;Xe<c.outWidth;++Xe){const Fe=V+Xe*c.outChannels,Pe=Xe*c.strideWidth-b;for(let ct=0;ct<h;++ct){const at=Pe+ct*y;if(at<0||at>=c.inWidth)continue;const Ee=be+ct*I[2],nn=Ie+at*c.inChannels;let gt=Ee;for(let vt=0;vt<c.inChannels;++vt){const wt=E[nn+vt];for(let Vt=0;Vt<c.outChannels;++Vt)R[Fe+Vt]+=wt*k[gt+Vt];gt+=c.outChannels}}}}}}}}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const lve={kernelName:w0,backendName:"cpu",kernelFunc:ave};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s;un([i,r],"conv3dBackpropFilterV2");const c=gn(i.shape),u=gn(r.shape),d=Wa(i.shape,l,o,1,a),h=d.strideDepth,p=d.strideHeight,g=d.strideWidth,y=d.filterDepth,x=d.filterHeight,v=d.filterWidth,b=new ur(d.filterShape,"float32"),S=b.values,[C,E,k,R]=b.strides,L=t.data.get(r.dataId).values,[I,T,M,j]=u,W=t.data.get(i.dataId).values,[z,X,B,J]=c,K=d.padInfo.front,ee=d.padInfo.left,ne=d.padInfo.top;for(let V=0;V<y;++V){const Z=Math.max(0,Math.ceil((K-V)/h)),he=Math.min(d.outDepth,(d.inDepth+K-V)/h),ve=V*C;for(let be=0;be<x;++be){const Ie=Math.max(0,Math.ceil((ne-be)/p)),Xe=Math.min(d.outHeight,(d.inHeight+ne-be)/p),Fe=be*E+ve;for(let Pe=0;Pe<v;++Pe){const ct=Math.max(0,Math.ceil((ee-Pe)/g)),at=Math.min(d.outWidth,(d.inWidth+ee-Pe)/g),Ee=Pe*k+Fe;for(let nn=0;nn<d.inChannels;++nn){const gt=nn*R+Ee;for(let vt=0;vt<d.outChannels;++vt){let wt=0;for(let Vt=0;Vt<d.batchSize;++Vt){const It=Vt*z,zt=Vt*I;for(let Gt=Z;Gt<he;++Gt){const vn=(V+Gt*h-K)*X+It,ce=Gt*T+zt;for(let Y=Ie;Y<Xe;++Y){const Qe=(be+Y*p-ne)*B+vn,tt=Y*M+ce;for(let rt=ct;rt<at;++rt){const pt=(Pe+rt*g-ee)*J+Qe,At=rt*j+tt;wt+=W[pt+nn]*L[At+vt]}}}}S[gt+vt]=wt}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const uve={kernelName:Sy,backendName:"cpu",kernelFunc:cve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:o,strides:a,inputShape:l}=s;un([i],"conv3dBackpropInputV2");const c=gn(i.shape),u=gn(r.shape),d=Wa(l,r.shape,a,1,o),h=new ur(d.inShape,"float32"),p=h.values,[g,y,x,v]=h.strides,b=t.data.get(i.dataId).values,[S,C,E,k]=c,R=t.data.get(r.dataId).values,[L,I,T,M]=u,{batchSize:j,filterDepth:W,filterHeight:z,filterWidth:X,inChannels:B,inDepth:J,inHeight:K,inWidth:ee,outChannels:ne,outDepth:V,outHeight:Z,outWidth:he,strideDepth:ve,strideHeight:be,strideWidth:Ie}=d,Xe=W-1-d.padInfo.front,Fe=z-1-d.padInfo.top,Pe=X-1-d.padInfo.left;for(let ct=0;ct<j;++ct)for(let at=0;at<B;++at)for(let Ee=0;Ee<J;++Ee){const nn=Ee-Xe,gt=Math.max(0,Math.ceil(nn/ve)),vt=Math.min(V,(W+nn)/ve);for(let wt=0;wt<K;++wt){const Vt=wt-Fe,It=Math.max(0,Math.ceil(Vt/be)),zt=Math.min(Z,(z+Vt)/be);for(let Gt=0;Gt<ee;++Gt){const dn=Gt-Pe,vn=Math.max(0,Math.ceil(dn/Ie)),ce=Math.min(he,(X+dn)/Ie);let Y=0;for(let ye=gt;ye<vt;++ye){const Qe=ye*ve-nn;for(let tt=It;tt<zt;++tt){const rt=tt*be-Vt;for(let Pt=vn;Pt<ce;++Pt){const pt=Pt*Ie-dn,At=S*ct+C*ye+E*tt+k*Pt,xe=L*(W-1-Qe)+I*(z-1-rt)+T*(X-1-pt)+M*at;for(let xt=0;xt<ne;++xt){const Ye=b[At+xt],kt=R[xe+xt];Y+=Ye*kt}}}}p[g*ct+y*Ee+x*wt+v*Gt+at]=Y}}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}const hve={kernelName:Cy,backendName:"cpu",kernelFunc:dve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fve=Ds(ap,n=>Math.cos(n)),pve={kernelName:ap,backendName:"cpu",kernelFunc:fve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mve=Ds(lp,n=>Math.cosh(n)),gve={kernelName:lp,backendName:"cpu",kernelFunc:mve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xve(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,[u,d,h,p]=i.shape,g=r.shape[0],[y,x]=a,v=Yn([g,y,x,p],"float32"),b=t.data.get(r.dataId).values,S=t.data.get(o.dataId).values,C=t.data.get(i.dataId).values,E=gn(i.shape),k=gn(v.shape);for(let R=0;R<g;R++){const L=R*4,I=b[L],T=b[L+1],M=b[L+2],j=b[L+3],W=S[R];if(W>=u)continue;const z=y>1?(M-I)*(d-1)/(y-1):0,X=x>1?(j-T)*(h-1)/(x-1):0;for(let B=0;B<y;B++){const J=y>1?I*(d-1)+B*z:.5*(I+M)*(d-1);if(J<0||J>d-1){for(let K=0;K<x;K++)for(let ee=0;ee<p;ee++){const ne=ee+K*k[2]+B*k[1]+R*k[0];v.values[ne]=c}continue}if(l==="bilinear"){const K=Math.floor(J),ee=Math.ceil(J),ne=J-K;for(let V=0;V<x;V++){const Z=x>1?T*(h-1)+V*X:.5*(T+j)*(h-1);if(Z<0||Z>h-1){for(let Ie=0;Ie<p;Ie++){const Xe=Ie+V*k[2]+B*k[1]+R*k[0];v.values[Xe]=c}continue}const he=Math.floor(Z),ve=Math.ceil(Z),be=Z-he;for(let Ie=0;Ie<p;Ie++){let Xe=Ie+he*E[2]+K*E[1]+W*E[0];const Fe=C[Xe];Xe=Ie+ve*E[2]+K*E[1]+W*E[0];const Pe=C[Xe];Xe=Ie+he*E[2]+ee*E[1]+W*E[0];const ct=C[Xe];Xe=Ie+ve*E[2]+ee*E[1]+W*E[0];const at=C[Xe],Ee=Fe+(Pe-Fe)*be,nn=ct+(at-ct)*be;Xe=Ie+V*k[2]+B*k[1]+R*k[0],v.values[Xe]=Ee+(nn-Ee)*ne}}}else for(let K=0;K<x;++K){const ee=x>1?T*(h-1)+K*X:.5*(T+j)*(h-1);if(ee<0||ee>h-1){for(let Z=0;Z<p;Z++){const he=Z+K*k[2]+B*k[1]+R*k[0];v.values[he]=c}continue}const ne=Math.round(ee),V=Math.round(J);for(let Z=0;Z<p;Z++){const he=Z+ne*E[2]+V*E[1]+W*E[0],ve=Z+K*k[2]+B*k[1]+R*k[0];v.values[ve]=C[he]}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const vve={kernelName:Ey,backendName:"cpu",kernelFunc:xve};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;un(i,"cumprod");const l=Os([r],i.shape.length);let c=i;l!=null&&(c=eo({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=Ys(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=Ji(c.dtype,"int32"),h=ZE(Le(c.shape),d),p=t.data.get(c.dataId).values,g=c.shape[c.shape.length-1],y=a?(v,b)=>v+g-b-1:(v,b)=>v+b;for(let v=0;v<p.length;v+=g)for(let b=0;b<g;b++){const S=y(v,b);if(b===0)h[S]=o?1:p[S];else{const C=y(v,b-1);h[S]=o?p[C]*h[C]:p[S]*h[C]}}const x=t.makeTensorInfo(c.shape,d,h);if(l!=null){const v=Nl(l),b=eo({inputs:{x},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(c),b}return x}const wve={kernelName:_y,backendName:"cpu",kernelFunc:yve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;un(i,"cumsum");const l=Os([r],i.shape.length);let c=i;l!=null&&(c=eo({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=Ys(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const d=Ji(c.dtype,"int32"),h=dr(Le(c.shape),d),p=t.data.get(c.dataId).values,g=c.shape[c.shape.length-1],y=a?(v,b)=>v+g-b-1:(v,b)=>v+b;for(let v=0;v<p.length;v+=g)for(let b=0;b<g;b++){const S=y(v,b);if(b===0)h[S]=o?0:p[S];else{const C=y(v,b-1);h[S]=o?p[C]+h[C]:p[S]+h[C]}}const x=t.makeTensorInfo(c.shape,d,h);if(l!=null){const v=Nl(l),b=eo({inputs:{x},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(c),b}return x}const Sve={kernelName:b0,backendName:"cpu",kernelFunc:bve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s;if(i.shape.length===1){const l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=CI(l,c,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=mU(l,c,o,a);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const _ve={kernelName:Ty,backendName:"cpu",kernelFunc:Cve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s;re(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=i.shape[0],l=i.shape[1],c=i.shape[2],u=i.shape[3],d=l*r,h=c*r,p=u/(r*r),g=t.data.get(i.dataId).values,y=new Float32Array(a*d*h*p);let x=0;for(let v=0;v<a;++v)for(let b=0;b<d;++b){const S=Math.floor(b/r),C=b%r;for(let E=0;E<h;++E){const k=Math.floor(E/r),R=E%r,L=(C*r+R)*p;for(let I=0;I<p;++I){const M=I+L+u*(k+c*(S+l*v));y[x++]=g[M]}}}return t.makeTensorInfo([a,d,h,p],i.dtype,y)}const Tve={kernelName:Iy,backendName:"cpu",kernelFunc:Eve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;un([i,r],"depthwiseConv2DNative");const u=gn(i.shape),d=gn(r.shape);let h=l;h==null&&(h=[1,1]),re(er(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const p=Js(i.shape,r.shape,o,h,a,c,!0),{filterHeight:g,filterWidth:y,dilationHeight:x,dilationWidth:v,padInfo:b}=p,S=b.left,C=b.top,E=p.outChannels/p.inChannels,k=new ur(p.outShape,i.dtype),R=t.data.get(i.dataId).values,L=t.data.get(r.dataId).values,I=k.values;for(let T=0;T<p.batchSize;++T){const M=T*u[0],j=T*k.strides[0];for(let W=0;W<p.outHeight;++W){const z=j+W*k.strides[1],X=W*p.strideHeight-C;for(let B=0;B<g;++B){const J=X+B*x;if(J<0||J>=p.inHeight)continue;const K=B*d[0],ee=M+J*u[1];for(let ne=0;ne<p.outWidth;++ne){const V=z+ne*k.strides[2],Z=ne*p.strideWidth-S;for(let he=0;he<y;++he){const ve=Z+he*v;if(ve<0||ve>=p.inWidth)continue;const be=K+he*d[1],Ie=ee+ve*p.inChannels;let Xe=V,Fe=be;for(let Pe=0;Pe<p.inChannels;++Pe){const ct=R[Ie+Pe];for(let at=0;at<E;++at)I[Xe+at]+=ct*L[Fe+at];Xe+=E,Fe+=E}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const Ive={kernelName:S0,backendName:"cpu",kernelFunc:g8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s;un([i,r],"depthwiseConv2dNativeBackpropFilter");const d=Js(i.shape,u,o,a,l,c,!0),{strideHeight:h,strideWidth:p,filterHeight:g,filterWidth:y}=d,x=new ur(d.filterShape,"float32"),v=d.padInfo.left,b=d.padInfo.top,S=d.outChannels/d.inChannels,C=t.data.get(i.dataId).values,E=new ur(i.shape,i.dtype,C),k=t.data.get(r.dataId).values,R=new ur(r.shape,r.dtype,k);for(let L=0;L<g;++L){const I=Math.max(0,Math.ceil((b-L)/h)),T=Math.min(d.outHeight,(d.inHeight+b-L)/h);for(let M=0;M<y;++M){const j=Math.max(0,Math.ceil((v-M)/p)),W=Math.min(d.outWidth,(d.inWidth+v-M)/p);for(let z=0;z<d.outChannels;++z){const X=Math.trunc(z/S),B=z%S;let J=0;for(let K=0;K<d.batchSize;++K)for(let ee=I;ee<T;++ee){const ne=L+ee*h-b;for(let V=j;V<W;++V){const Z=M+V*p-v;J+=E.get(K,ne,Z,X)*R.get(K,ee,V,z)}}x.set(J,L,M,X,B)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const Ave={kernelName:ky,backendName:"cpu",kernelFunc:kve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s;un([i,r],"depthwiseConv2DNativeBackpropInput");const d=gn(i.shape),h=gn(r.shape),p=Js(u,r.shape,o,a,l,c,!0),g=new ur(p.inShape,"float32"),y=g.values,[x,v,b]=g.strides,S=t.data.get(i.dataId).values,[C,E,k]=d,R=t.data.get(r.dataId).values,[L,I,T]=h,{batchSize:M,filterHeight:j,filterWidth:W,inChannels:z,inHeight:X,inWidth:B,outChannels:J,outHeight:K,outWidth:ee,strideHeight:ne,strideWidth:V}=p,Z=j-1-p.padInfo.top,he=W-1-p.padInfo.left,ve=J/z;for(let be=0;be<M;++be)for(let Ie=0;Ie<z;++Ie)for(let Xe=0;Xe<X;++Xe){const Fe=Xe-Z,Pe=Math.max(0,Math.ceil(Fe/ne)),ct=Math.min(K,(j+Fe)/ne);for(let at=0;at<B;++at){const Ee=at-he,nn=Math.max(0,Math.ceil(Ee/V)),gt=Math.min(ee,(W+Ee)/V);let vt=0;for(let wt=Pe;wt<ct;++wt){const Vt=wt*ne-Fe;for(let It=nn;It<gt;++It){const zt=It*V-Ee,Gt=C*be+E*wt+k*It,dn=L*(j-1-Vt)+I*(W-1-zt)+T*Ie;for(let vn=0;vn<ve;++vn){const ce=Ie*ve+vn,Y=S[Gt+ce],ye=R[dn+vn];vt+=Y*ye}}}y[x*be+v*Xe+b*at+Ie]=vt}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const Mve={kernelName:Ay,backendName:"cpu",kernelFunc:Rve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nve(n){const{inputs:e,backend:t}=n,{x:s}=e,i=Le(s.shape),r=t.data.get(s.dataId).values,o=Yn([i,i],s.dtype),a=o.values;for(let c=0;c<r.length;c++)a[c*i+c]=r[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const Pve={kernelName:nT,backendName:"cpu",kernelFunc:Nve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dve={kernelName:C0,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i}=n,{strides:r,pad:o,dilations:a}=t,l=e,c=l.data.get(s.dataId).values,u=s.shape.length,d=l.data.get(i.dataId).values,h=i.shape.length,{batchSize:p,inHeight:g,inWidth:y,inChannels:x,outHeight:v,outWidth:b,padInfo:S,strideHeight:C,strideWidth:E,filterHeight:k,filterWidth:R,dilationHeight:L,dilationWidth:I,outShape:T}=gu(s.shape,i.shape,r,o,"NHWC",a),M=Le(T),j=T.length,W=fi(s.dtype,M);for(let X=0;X<p;++X)for(let B=0;B<v;++B){const J=B*C-S.top;for(let K=0;K<b;++K){const ee=K*E-S.left;for(let ne=0;ne<x;++ne){let V=Number.MIN_SAFE_INTEGER;for(let he=0;he<k;++he){const ve=J+he*L;if(ve>=0&&ve<g)for(let be=0;be<R;++be){const Ie=ee+be*I;if(Ie>=0&&Ie<y){const Xe=gl([X,ve,Ie,ne],u,gn(s.shape)),Fe=gl([he,be,ne],h,gn(i.shape)),Pe=c[Xe]+d[Fe];Pe>V&&(V=Pe)}}}const Z=gl([X,B,K,ne],j,gn(T));W[Z]=V}}}return{dataId:l.write(Ud(W,s.dtype),T,s.dtype),shape:T,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lve={kernelName:g2,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Ma(s.shape,c.data.get(s.dataId).values),d=Ma(i.shape,c.data.get(i.dataId).values),{batchSize:h,inHeight:p,inWidth:g,inChannels:y,outHeight:x,outWidth:v,padInfo:b,strideHeight:S,strideWidth:C,filterHeight:E,filterWidth:k,dilationHeight:R,dilationWidth:L,outShape:I}=gu(s.shape,i.shape,o,a,"NHWC",l);re(r.rank===I.length,()=>`Error in ${g2}, dy must have the same rank as output ${I.length}, but got ${r.rank}`);const T=Ma(I,c.data.get(r.dataId).values),M=ZO(i.shape,i.dtype);for(let W=0;W<h;++W)for(let z=0;z<x;++z){const X=z*S-b.top;for(let B=0;B<v;++B){const J=B*C-b.left;for(let K=0;K<y;++K){let ee=Number.MIN_SAFE_INTEGER,ne=0,V=0;for(let Z=0;Z<E;++Z){const he=X+Z*R;if(he>=0&&he<p)for(let ve=0;ve<k;++ve){const be=J+ve*L;if(be>=0&&be<g){const Ie=u[W][he][be][K]+d[Z][ve][K];Ie>ee&&(ee=Ie,ne=Z,V=ve)}}}M[ne][V][K]+=T[W][z][B][K]}}}return{dataId:c.write(Ud(M,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ve={kernelName:m2,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:o,pad:a,dilations:l}=t,c=e,u=Ma(s.shape,c.data.get(s.dataId).values),d=Ma(i.shape,c.data.get(i.dataId).values),{batchSize:h,inHeight:p,inWidth:g,inChannels:y,outHeight:x,outWidth:v,padInfo:b,strideHeight:S,strideWidth:C,filterHeight:E,filterWidth:k,dilationHeight:R,dilationWidth:L,outShape:I}=gu(s.shape,i.shape,o,a,"NHWC",l);re(r.rank===I.length,()=>`Error in ${m2}, dy must have the same rank as output ${I.length}, but got ${r.rank}`);const T=Ma(I,c.data.get(r.dataId).values),M=ZO(s.shape,s.dtype);for(let W=0;W<h;++W)for(let z=0;z<x;++z){const X=z*S-b.top;for(let B=0;B<v;++B){const J=B*C-b.left;for(let K=0;K<y;++K){let ee=Number.MIN_SAFE_INTEGER,ne=X<0?0:X,V=J<0?0:J;for(let Z=0;Z<E;++Z){const he=X+Z*R;if(he>=0&&he<p)for(let ve=0;ve<k;++ve){const be=J+ve*L;if(be>=0&&be<g){const Ie=u[W][he][be][K]+d[Z][ve][K];Ie>ee&&(ee=Ie,ne=he,V=be)}}}M[W][ne][V][K]+=T[W][z][B][K]}}}return{dataId:c.write(Ud(M,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fve(n){const{inputs:e,backend:t,attrs:s}=n,{image:i}=e,{canvas:r,options:o}=s,{contextOptions:a,imageOptions:l}=o||{},c=(l==null?void 0:l.alpha)||1,u=(a==null?void 0:a.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const d=r.getContext(u,(a==null?void 0:a.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${u} type.`);const[h,p]=i.shape.slice(0,2),g=i.shape.length===2?1:i.shape[2],y=t.data.get(i.dataId).values,x=i.dtype==="float32"?255:1,v=new Uint8ClampedArray(p*h*4);for(let S=0;S<h*p;++S){const C=[0,0,0,255*c];for(let k=0;k<g;k++){const R=y[S*g+k];if(i.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(i.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);g===1?(C[0]=R*x,C[1]=R*x,C[2]=R*x):C[k]=R*x}const E=S*4;v[E+0]=Math.round(C[0]),v[E+1]=Math.round(C[1]),v[E+2]=Math.round(C[2]),v[E+3]=Math.round(C[3])}r.width=p,r.height=h;const b=new ImageData(v,p,h);return d.putImageData(b,0,0),i}const Ove={kernelName:e5,backendName:"cpu",kernelFunc:Fve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;un(i,"sum");let a;i.dtype==="bool"?a=du({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):a=Il({inputs:{x:i},backend:t});const l=a.shape.length,c=Hn(r,a.shape),u=Os(c,l);let d=c,h=a;u!=null&&(h=eo({inputs:{x:a},backend:t,attrs:{perm:u}}),d=Ys(d.length,l)),Ai("sum",d,h.shape.length);const[p,g]=Ci(h.shape,d),y=Ji(h.dtype,"int32");let x=P2(t,p,y);const v=Le(g),b=t.data.get(x.dataId).values,S=t.data.get(h.dataId).values;for(let C=0;C<b.length;++C){const E=C*v;let k=0;for(let R=0;R<v;++R)k+=S[E+R];b[C]=k}if(o){const C=Si(x.shape,c),E=x;x=Ks({inputs:{x},backend:t,attrs:{shape:C}}),t.disposeIntermediateTensorInfo(E)}return t.disposeIntermediateTensorInfo(a),u!=null&&t.disposeIntermediateTensorInfo(h),x}const zve={kernelName:n1,backendName:"cpu",kernelFunc:_1};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=_w(i,r.length);Tw(o.length,l,r);const{path:c,steps:u}=Iw(a,l),d=u.length;let h=null,p=o.length;const g=[];for(let y=0;y<d;++y){for(const x of u[y]){const{permutationIndices:v,expandDims:b}=Ew(p,l[x]);let S;kw(v)?S=r[x]:(S=eo({inputs:{x:r[x]},backend:t,attrs:{perm:v}}),g.push(S));const C=S.shape.slice();for(let E=0;E<b.length;++E)C.splice(b[E],0,1);ds(S.shape,C)||(S=Ks({inputs:{x:S},backend:t,attrs:{shape:C}}),g.push(S)),h===null?h=S:(h=Vw({inputs:{a:S,b:h},backend:t}),g.push(h))}y<d-1&&(c[y]>=0&&(h=_1({inputs:{x:h},backend:t,attrs:{axis:c[y]-(o.length-p),keepDims:!1}}),g.push(h)),p--)}for(const y of g)y!==h&&t.disposeIntermediateTensorInfo(y);return h}const Uve={kernelName:Ry,backendName:"cpu",kernelFunc:Bve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(n){const{inputs:e,backend:t}=n,{dy:s,y:i}=e;un([s,i],"eluGrad");const r=new Float32Array(Le(i.shape)),o=t.data.get(i.dataId).values,a=t.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const c=o[l];c>=0?r[l]=a[l]:r[l]=a[l]*(c+1)}return t.makeTensorInfo(i.shape,"float32",r)}const Wve={kernelName:My,backendName:"cpu",kernelFunc:Vve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gve=vw,Hve=yw,jve=ww,Xve=bw,qve=Sw,Kve=Cw,Yve=Ds(dp,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+Gve*t);return e*(1-((((Kve*s+qve)*s+Xve)*s+jve)*s+Hve)*s*Math.exp(-t*t))}),Zve={kernelName:dp,backendName:"cpu",kernelFunc:Yve};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2(n){const{inputs:e,backend:t,attrs:s}=n,{input:i}=e,{dim:r}=s,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(re(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Ks({inputs:{x:i},backend:t,attrs:{shape:a}})}const Qve={kernelName:E0,backendName:"cpu",kernelFunc:$2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jve=Ei((n,e)=>n/e),AI=Gi(cp,Jve),I_={kernelName:cp,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8(n,e,t){const s=n.shape,i=s[0],r=s[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,c=[i,r],u=Le(c),d=Qi("float32",u),h=Qi("float32",u);for(let x=0;x<i;x++){const v=Pd({inputs:{x:a},backend:t,attrs:{begin:[x,0],size:[1,r]}}),b=Pd({inputs:{x:l},backend:t,attrs:{begin:[x,0],size:[1,r]}}),S=mo({inputs:{real:v,imag:b},backend:t}),{real:C,imag:E}=e2e(S,e,t),k=Fa(C,E);for(let R=0;R<r;R++){const L=QT(k,R);d[x*r+R]=L.real,h[x*r+R]=L.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(S)}const p=t.makeTensorInfo(c,"float32",d),g=t.makeTensorInfo(c,"float32",h),y=mo({inputs:{real:p,imag:g},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),y}function e2e(n,e,t){const s=Le(n.shape),i=t.data.get(n.dataId),r=t.data.get(i.complexTensorInfos.real.dataId).values,o=t.data.get(i.complexTensorInfos.imag.dataId).values;if(t2e(s)){const a=k_(r,o,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",a.real),u=t.makeTensorInfo(l,"float32",a.imag),d=t.makeTensorInfo([],"float32",mu(s,"float32")),h=Il({inputs:{x:d},backend:t}),p=I_.kernelFunc({inputs:{a:c,b:d},backend:t}),g=I_.kernelFunc({inputs:{a:u,b:h},backend:t}),y=t.data.get(p.dataId).values,x=t.data.get(g.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),{real:y,imag:x}}return a}else{const a=Fa(r,o),l=n2e(a,s,e);return R6(l)}}function t2e(n){return(n&n-1)===0}function k_(n,e,t,s,i){if(t===1)return{real:n,imag:e};const r=Fa(n,e),o=t/2,a=M6(r),l=a.real,c=a.imag,u=[l.length],d=i.makeTensorInfo(u,"float32",l),h=i.makeTensorInfo(u,"float32",c),p=mo({inputs:{real:d,imag:h},backend:i}),g=N6(r),y=g.real,x=g.imag,v=[y.length],b=i.makeTensorInfo(v,"float32",y),S=i.makeTensorInfo(v,"float32",x),C=mo({inputs:{real:b,imag:S},backend:i}),E=k_(l,c,o,s,i),k=E.real,R=E.imag,L=[k.length],I=i.makeTensorInfo(L,"float32",k),T=i.makeTensorInfo(L,"float32",R),M=mo({inputs:{real:I,imag:T},backend:i}),j=k_(y,x,o,s,i),W=j.real,z=j.imag,X=[W.length],B=i.makeTensorInfo(X,"float32",W),J=i.makeTensorInfo(X,"float32",z),K=mo({inputs:{real:B,imag:J},backend:i}),ee=D6(t,s),ne=[ee.real.length],V=i.makeTensorInfo(ne,"float32",ee.real),Z=i.makeTensorInfo(ne,"float32",ee.imag),he=mo({inputs:{real:V,imag:Z},backend:i}),ve=Vw({inputs:{a:he,b:K},backend:i}),be=Df({inputs:{a:M,b:ve},backend:i}),Ie=II({inputs:{a:M,b:ve},backend:i}),Xe=Nd({inputs:{input:be},backend:i}),Fe=Nd({inputs:{input:Ie},backend:i}),Pe=Lf({inputs:{input:be},backend:i}),ct=Lf({inputs:{input:Ie},backend:i}),at=$f({inputs:[Xe,Fe],backend:i,attrs:{axis:0}}),Ee=$f({inputs:[Pe,ct],backend:i,attrs:{axis:0}}),nn=i.data.get(at.dataId).values,gt=i.data.get(Ee.dataId).values;return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(I),i.disposeIntermediateTensorInfo(T),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(J),i.disposeIntermediateTensorInfo(K),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo(Z),i.disposeIntermediateTensorInfo(he),i.disposeIntermediateTensorInfo(ve),i.disposeIntermediateTensorInfo(be),i.disposeIntermediateTensorInfo(Ie),i.disposeIntermediateTensorInfo(Xe),i.disposeIntermediateTensorInfo(Pe),i.disposeIntermediateTensorInfo(Fe),i.disposeIntermediateTensorInfo(ct),i.disposeIntermediateTensorInfo(at),i.disposeIntermediateTensorInfo(Ee),{real:nn,imag:gt}}function n2e(n,e,t){const s=new Float32Array(e*2);for(let i=0;i<e;i++){let r=0,o=0;for(let a=0;a<e;a++){const l=L6(i*a,e,t),c=QT(n,a);r+=c.real*l.real-c.imag*l.imag,o+=c.real*l.imag+c.imag*l.real}t&&(r/=e,o/=e),P6(s,r,o,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2e(n){const{inputs:e,backend:t}=n,{input:s}=e,i=Le(s.shape),r=s.shape[s.shape.length-1],o=i/r,a=Ks({inputs:{x:s},backend:t,attrs:{shape:[o,r]}}),l=x8(a,!1,t),c=Ks({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const i2e={kernelName:Ny,backendName:"cpu",kernelFunc:s2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n){const{backend:e,attrs:t}=n,{shape:s,value:i,dtype:r}=t,o=r||zd(i),a=fi(o,Le(s));return o2e(a,i,o),e.makeTensorInfo(s,o,a)}const r2e={kernelName:Py,backendName:"cpu",kernelFunc:RI};function o2e(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2e={kernelName:Dy,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,i=t,r=Qi(s.dtype,Le(s.shape)),[o,a,l,c]=s.shape,u=i.data.get(s.dataId).values;for(let h=0;h<o;h++){const p=h*l*a*c;for(let g=0;g<a;g++){const y=g*(l*c);for(let x=0;x<l;x++){const v=x*c;for(let b=0;b<c;b++){const S=Math.round(l-x-1),C=p+y+v+b;let E=u[C];if(S>=0&&S<l){const k=S*c,R=p+y+k+b;E=u[R]}r[C]=E}}}}return{dataId:i.write(r,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:g}=s;let y=m8({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const x=y;if(u==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const v=Ks({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});y=Df({inputs:{a:y,b:v},backend:t}),t.disposeIntermediateTensorInfo(v)}else y=Df({inputs:{a:y,b:o},backend:t});t.disposeIntermediateTensorInfo(x)}if(p){const x=y;if(u==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const v=Ks({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});y=L2(t,y,p,v,g),t.disposeIntermediateTensorInfo(v)}else y=L2(t,y,p,a,g);t.disposeIntermediateTensorInfo(x)}return y}const c2e={kernelName:Lg,backendName:"cpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:g}=s;let y=g8({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h}});if(o){const x=y;y=Df({inputs:{a:y,b:o},backend:t}),t.disposeIntermediateTensorInfo(x)}if(p){const x=y;y=L2(t,y,p,a,g),t.disposeIntermediateTensorInfo(x)}return y}const d2e={kernelName:xT,backendName:"cpu",kernelFunc:u2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2e(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=Le(s.shape),o=i.shape,a=o[o.length-1],[l,c,u,d]=cw(s,i);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const h=t.data.get(i.dataId).values,p=t.bufferSync(s),g=TU(h,p,s.dtype,c,a,u,d,s.shape,r);return t.makeTensorInfo(l,s.dtype,g.values)}const f2e={kernelName:sT,backendName:"cpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s;un([i,r],"gatherV2");const l=Hn(o,i.shape)[0],c=t.data.get(r.dataId).values,u=i.shape[l];for(let C=0;C<c.length;++C){const E=c[C];re(E<=u-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${u-1}]`)}let d=a;a==null&&(d=0);const h=Le(r.shape),p=Rw(i,r,l,d),g=Ks({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),y=Ks({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,h/p.batchSize]}}),x=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],v=t.bufferSync(y),b=t.bufferSync(g),S=IU(b,v,x);return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),t.makeTensorInfo(p.outputShape,S.dtype,S.values)}const m2e={kernelName:I0,backendName:"cpu",kernelFunc:p2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2e(n){const{inputs:e,backend:t}=n,{input:s}=e,i=Le(s.shape),r=s.shape[s.shape.length-1],o=i/r,a=Ks({inputs:{x:s},backend:t,attrs:{shape:[o,r]}}),l=x8(a,!0,t),c=Ks({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const x2e={kernelName:Ly,backendName:"cpu",kernelFunc:g2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2e=Ds(vp,n=>Number.isFinite(n)?1:0,"bool"),y2e={kernelName:vp,backendName:"cpu",kernelFunc:v2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2e=Ds(yp,n=>Math.abs(n)===1/0?1:0,"bool"),b2e={kernelName:yp,backendName:"cpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S2e=Ds(wp,n=>Number.isNaN(n)?1:0,"bool"),C2e={kernelName:wp,backendName:"cpu",kernelFunc:S2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2e(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=NU(s,i,r);return e.makeTensorInfo([o.length],"float32",o)}const E2e={kernelName:iT,backendName:"cpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T2e=Ds(Sp,n=>Math.log1p(n)),I2e={kernelName:Sp,backendName:"cpu",kernelFunc:T2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k2e=Ei((n,e)=>n&&e),A2e=Gi(N0,k2e,null,"bool"),R2e={kernelName:N0,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M2e=Ds(P0,n=>n?0:1,"bool"),N2e={kernelName:P0,backendName:"cpu",kernelFunc:M2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P2e=Ei((n,e)=>n||e),D2e=Gi(D0,P2e,null,"bool"),L2e={kernelName:D0,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s;un(i,"LRN");const c=i.shape[3],u=c-1,d=t.data.get(i.dataId).values,h=Le(i.shape),p=new Float32Array(h);function g(y){const x=y%c;let v=y-x+Math.max(0,x-r);const b=y-x+Math.min(x+r,u);let S=0;for(;v<=b;v++){const C=d[v];S+=C*C}return S}for(let y=0;y<h;y++){const x=g(y),v=d[y]*Math.pow(o+a*x,-l);p[y]=v}return t.makeTensorInfo(i.shape,i.dtype,p)}const F2e={kernelName:L0,backendName:"cpu",kernelFunc:$2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s;un(o,"LRNGrad");const d=Le(o.shape),h=o.shape[3],p=t.data.get(o.dataId).values,g=t.data.get(i.dataId).values,y=t.data.get(r.dataId).values,x=new Float32Array(d),v=d;for(let b=0;b<v;b++){const S=b%h,C=b-S+Math.max(0,S-a),E=b-S+Math.min(h,S+a+1);let k=0;for(let R=C;R<E;R++)k+=Math.pow(g[R],2);k=c*k+l;for(let R=C;R<E;R++){let L=-2*c*u*g[R]*y[b]/k;b===R&&(L+=Math.pow(k,-u)),L*=p[b],x[R]+=L}}return t.makeTensorInfo(o.shape,i.dtype,x)}const z2e={kernelName:Fy,backendName:"cpu",kernelFunc:O2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s,a=t;let l=i.shape;const c=l.length,u=Hn(r,l);let d=u;const h=Os(d,c);let p=a.data.get(i.dataId).values;if(h!=null){const C=new Array(c);for(let E=0;E<C.length;E++)C[E]=l[h[E]];p=EI(p,l,i.dtype,h,C),d=Ys(d.length,c),l=C}un(i,"max"),Ai("max",d,c);const[g,y]=Ci(l,d),x=Le(y),v=DU(p,x,g,i.dtype),b=a.write(v,g,i.dtype);let S=g;return o&&(S=Si(g,u)),{dataId:b,shape:S,dtype:i.dtype}}const B2e={kernelName:$0,backendName:"cpu",kernelFunc:v8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;un(i,"maxPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;re(er(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=br(i.shape,r,o,c,a,l);let d;if(u.filterWidth===1&&u.filterHeight===1&&ds(u.inShape,u.outShape))d=Il({inputs:{x:i},backend:t});else{const h=t.data.get(i.dataId).values,p=gn(i.shape),g=kI(h,i.shape,i.dtype,p,u,"max");d=t.makeTensorInfo(u.outShape,i.dtype,g.values)}return d}const V2e={kernelName:F0,backendName:"cpu",kernelFunc:U2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s;un(i,"maxPool3d");const u=Fo(i.shape,r,o,1,a,l,c),d=t.data.get(i.dataId).values,h=p8(d,i.shape,i.dtype,gn(i.shape),u,"max");return t.makeTensorInfo(h.shape,"float32",h.values)}const G2e={kernelName:O0,backendName:"cpu",kernelFunc:W2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:c}=s;un([i,r],"maxPool3DGrad");const u=Fo(r.shape,o,a,1,l,c),d=t.bufferSync(r),h=Pxe(d,u),p=u.strideDepth,g=u.strideHeight,y=u.strideWidth,x=u.dilationDepth,v=u.dilationHeight,b=u.dilationWidth,S=u.effectiveFilterDepth,C=u.effectiveFilterHeight,E=u.effectiveFilterWidth,k=S-1-u.padInfo.front,R=E-1-u.padInfo.left,L=C-1-u.padInfo.top,I=Yn(r.shape,"float32"),T=t.bufferSync(i);for(let M=0;M<u.batchSize;++M)for(let j=0;j<u.inChannels;++j)for(let W=0;W<u.inDepth;++W)for(let z=0;z<u.inHeight;++z)for(let X=0;X<u.inWidth;++X){const B=W-k,J=z-L,K=X-R;let ee=0;for(let ne=0;ne<S;ne+=x){const V=(B+ne)/p;if(!(V<0||V>=u.outDepth||Math.floor(V)!==V))for(let Z=0;Z<C;Z+=v){const he=(J+Z)/g;if(!(he<0||he>=u.outHeight||Math.floor(he)!==he))for(let ve=0;ve<E;ve+=b){const be=(K+ve)/y;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;const Ie=S*C*E-1-h.get(M,V,he,be,j),Xe=ne*C*E+Z*E+ve,Fe=Ie===Xe?1:0;if(Fe===0)continue;const Pe=T.get(M,V,he,be,j);ee+=Pe*Fe}}}I.set(ee,M,W,z,X,j)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const j2e={kernelName:zy,backendName:"cpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;un([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=s,h=br(a.shape,l,c,1,u,d),p=t.data.get(a.dataId).values,g=Yn(h.outShape,a.dtype,f8(p,a.shape,a.dtype,h).values),y=h.strideHeight,x=h.strideWidth,v=h.dilationHeight,b=h.dilationWidth,S=h.effectiveFilterHeight,C=h.effectiveFilterWidth,E=C-1-h.padInfo.left,k=S-1-h.padInfo.top,R=Yn(a.shape,"float32"),L=t.data.get(i.dataId).values,I=Yn(i.shape,"float32",L);for(let T=0;T<h.batchSize;++T)for(let M=0;M<h.inChannels;++M)for(let j=0;j<h.inHeight;++j)for(let W=0;W<h.inWidth;++W){const z=j-k,X=W-E;let B=0;for(let J=0;J<S;J+=v){const K=(z+J)/y;if(!(K<0||K>=h.outHeight||Math.floor(K)!==K))for(let ee=0;ee<C;ee+=b){const ne=(X+ee)/x;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const V=S*C-1-g.get(T,K,ne,M),Z=J*C+ee,he=V===Z?1:0;if(he===0)continue;const ve=I.get(T,K,ne,M);B+=ve*he}}R.set(B,T,j,W,M)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const q2e={kernelName:Oy,backendName:"cpu",kernelFunc:X2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K2e(n,e,t,s,i){const r=gn(e),o=kI(n,e,t,r,i,"max"),a=f8(n,e,t,i,!0,s);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y2e={kernelName:rT,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=e,l=t;un(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,u=br(s.shape,i,r,[1,1],o),[d,h]=K2e(c,s.shape,s.dtype,a,u),p=l.write(d,u.outShape,s.dtype),g=l.write(h,u.outShape,s.dtype);return[{dataId:p,shape:u.outShape,dtype:s.dtype},{dataId:g,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=Hn(r,i.shape),c=Ci(i.shape,a)[1],u=Le(c),d=[],h=t.makeTensorInfo([],"float32",new Float32Array([u]));d.push(h);const p=du({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});d.push(p);const g=AI({inputs:{a:p,b:h},backend:t});d.push(g);const y=_1({inputs:{x:g},backend:t,attrs:{axis:r,keepDims:o}});return d.forEach(x=>t.disposeIntermediateTensorInfo(x)),y}const Q2e={kernelName:z0,backendName:"cpu",kernelFunc:Z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;un(i,"min");const a=Hn(r,i.shape);let l=a;const c=Os(l,i.shape.length);let u=i;c!=null&&(u=eo({inputs:{x:i},backend:t,attrs:{perm:c}}),l=Ys(l.length,i.shape.length)),Ai("min",l,u.shape.length);const[d,h]=Ci(u.shape,l),p=Le(h),g=dr(Le(d),u.dtype),y=t.data.get(u.dataId).values;for(let v=0;v<g.length;++v){const b=v*p;let S=y[b];for(let C=0;C<p;++C){const E=y[b+C];(Number.isNaN(E)||E<S)&&(S=E)}g[v]=S}c!=null&&t.disposeIntermediateTensorInfo(u);const x=t.makeTensorInfo(d,u.dtype,g);if(o){const v=Si(d,a),b=Ks({inputs:{x},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(x),b}return x}const eye={kernelName:B0,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tye(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,mode:o}=s;un(i,"mirrorPad");const a=r.map((S,C)=>S[0]+i.shape[C]+S[1]),l=r.map(S=>S[0]),c=r.map((S,C)=>S[0]+i.shape[C]),u=o==="reflect"?0:1,d=t.data.get(i.dataId).values,h=i.shape.length,p=gn(i.shape),g=Le(a),y=a.length,x=gn(a),v=Qi(i.dtype,g);for(let S=0;S<g;S++){let C=Yf(S,y,x);for(let k=0;k<y;k++)C[k]<l[k]?C[k]=l[k]*2-C[k]-u:C[k]>=c[k]&&(C[k]=(c[k]-1)*2-C[k]+u);C=C.map((k,R)=>k-l[R]);const E=gl(C,h,p);v[S]=d[E]}return{dataId:t.write(v,a,i.dtype),shape:a,dtype:i.dtype}}const nye={kernelName:U0,backendName:"cpu",kernelFunc:tye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sye=Ei((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),iye=Gi(Ep,sye),rye={kernelName:Ep,backendName:"cpu",kernelFunc:iye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y8(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=i.shape.length;let a=r;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=Hn([a],i.shape),c=v8({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=Si(c.shape,l),d=Ks({inputs:{x:c},backend:t,attrs:{shape:u}}),h=II({inputs:{a:i,b:d},backend:t}),p=SU({inputs:{x:h},backend:t}),g=_1({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),y=Ks({inputs:{x:g},backend:t,attrs:{shape:u}}),x=AI({inputs:{a:p,b:y},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),x}const oye={kernelName:r1,backendName:"cpu",kernelFunc:y8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aye(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s;un(i,"multinomial");const l=a?i:y8({inputs:{logits:i},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],d=t.data.get(l.dataId).values,h=[c,r],p=dr(Le(h),"int32");for(let g=0;g<c;++g){const y=g*u,x=new Float32Array(u-1);x[0]=d[y];for(let S=1;S<x.length;++S)x[S]=x[S-1]+d[y+S];const v=FT.alea(o.toString()),b=g*r;for(let S=0;S<r;++S){const C=v();p[b+S]=x.length;for(let E=0;E<x.length;E++)if(C<x[E]){p[b+S]=E;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(h,"int32",p)}const lye={kernelName:oT,backendName:"cpu",kernelFunc:aye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cye=aw;function uye(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s;un(i,"NonMaxSuppression");const c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,{selectedIndices:d}=cye(c,u,o,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const dye={kernelName:By,backendName:"cpu",kernelFunc:uye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hye=jT;function fye(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;un(i,"NonMaxSuppressionPadded");const u=t.data.get(i.dataId).values,d=t.data.get(r.dataId).values,{selectedIndices:h,validOutputs:p}=hye(u,d,o,a,l,c);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const pye={kernelName:aT,backendName:"cpu",kernelFunc:fye};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mye=lw;function gye(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;un(i,"NonMaxSuppressionWithScore");const u=t.data.get(i.dataId).values,d=t.data.get(r.dataId).values,h=o,p=a,g=l,y=c,{selectedIndices:x,selectedScores:v}=mye(u,d,h,p,g,y);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const xye={kernelName:Uy,backendName:"cpu",kernelFunc:gye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vye(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s;un(i,"oneHot");const c=Le(i.shape),u=new Float32Array(c*o);u.fill(l);const d=t.data.get(i.dataId).values;for(let h=0;h<c;++h)d[h]>=0&&d[h]<o&&(u[h*o+d[h]]=a);return t.makeTensorInfo([...i.shape,o],r,u)}const yye={kernelName:H0,backendName:"cpu",kernelFunc:vye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Nd({inputs:{input:s},backend:t}),r=F2({inputs:{x:i},backend:t}),o=Lf({inputs:{input:s},backend:t}),a=F2({inputs:{x:o},backend:t}),l=mo({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return RI({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const wye={kernelName:l1,backendName:"cpu",kernelFunc:F2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w8(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Nd({inputs:{input:s},backend:t}),r=w8({inputs:{x:i},backend:t}),o=Lf({inputs:{input:s},backend:t}),a=F2({inputs:{x:o},backend:t}),l=mo({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return RI({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const bye={kernelName:G0,backendName:"cpu",kernelFunc:w8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b8(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return $2({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{fy(r,u.shape,"All tensors passed to stack must have matching shapes"),re(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const d=$2({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(d),d}),c=$f({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const Sye={kernelName:j0,backendName:"cpu",kernelFunc:b8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cye(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;un(i,"pad");const a=r.map((b,S)=>b[0]+i.shape[S]+b[1]),l=r.map(b=>b[0]),c=t.data.get(i.dataId).values,u=Le(i.shape),d=i.shape.length,h=gn(i.shape),p=Le(a),g=a.length,y=gn(a),x=Qi(i.dtype,p);o!==0&&x.fill(o);for(let b=0;b<u;b++){const C=Yf(b,d,h).map((k,R)=>k+l[R]),E=gl(C,g,y);x[E]=c[b]}return{dataId:t.write(x,a,i.dtype),shape:a,dtype:i.dtype}}const S8={kernelName:X0,backendName:"cpu",kernelFunc:Cye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ye=Ei((n,e)=>Math.pow(n,e)),Eye=Gi(Ip,_ye),Tye={kernelName:Ip,backendName:"cpu",kernelFunc:Eye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iye(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=e,{outputRaggedRank:a}=s,l=i.map(v=>t.data.get(v.dataId).values),c=i.map(v=>v.shape),u=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,[h,p,g]=BU(l,c,u,r.shape,r.dtype,d,o.shape),y=h.map(v=>t.makeTensorInfo([v.length],"int32",v)),x=t.makeTensorInfo(g,r.dtype,p);return y.concat([x])}const kye={kernelName:t5,backendName:"cpu",kernelFunc:Iye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aye(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=UU(o,s.shape,s.dtype,a,i.shape,l,r.shape),d=t.makeTensorInfo([c.length],"int32",c),h=t.makeTensorInfo([u.length],s.dtype,u);return[d,h]}const Rye={kernelName:n5,backendName:"cpu",kernelFunc:Aye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mye(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,h=a.map(x=>t.data.get(x.dataId).values),p=a.map(x=>x.shape),[g,y]=VU(c,i.shape,u,r.shape,r.dtype,d,o.shape,h,p,l);return t.makeTensorInfo(g,r.dtype,y)}const Nye={kernelName:s5,backendName:"cpu",kernelFunc:Mye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pye(n){const{backend:e,attrs:t}=n,{start:s,stop:i,dtype:r,step:o}=t,a=WU(s,i,o,r);return e.makeTensorInfo([a.length],r,a)}const Dye={kernelName:Vy,backendName:"cpu",kernelFunc:Pye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lye=Ds(kp,n=>1/n),$ye={kernelName:kp,backendName:"cpu",kernelFunc:Lye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s;un(i,"resizeBilinear");const l=gn(i.shape),[c,u]=a,[d,h,p,g]=i.shape,y=t.data.get(i.dataId).values,x=new Float32Array(Le([d,c,u,g])),v=[r&&c>1?h-1:h,r&&u>1?p-1:p],b=[r&&c>1?c-1:c,r&&u>1?u-1:u];let S=0;const C=v[0]/b[0],E=v[1]/b[1];for(let k=0;k<d;k++)for(let R=0;R<c;R++){let L;o?L=C*(R+.5)-.5:L=C*R;const I=Math.max(0,Math.floor(L)),T=L-I,M=Math.min(h-1,Math.ceil(L)),j=k*l[0]+I*l[1],W=k*l[0]+M*l[1];for(let z=0;z<u;z++){let X;o?X=E*(z+.5)-.5:X=E*z;const B=Math.max(0,Math.floor(X)),J=X-B,K=Math.min(p-1,Math.ceil(X)),ee=j+B*l[2],ne=W+B*l[2],V=j+K*l[2],Z=W+K*l[2];for(let he=0;he<g;he++){const ve=y[ee+he],be=y[ne+he],Ie=y[V+he],Xe=y[Z+he],Fe=ve+(Ie-ve)*J,Pe=be+(Xe-be)*J,ct=Fe+(Pe-Fe)*T;x[S++]=ct}}}return t.makeTensorInfo([d,c,u,g],"float32",x)}const Oye={kernelName:Q0,backendName:"cpu",kernelFunc:Fye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s;un([r,i],"resizeBilinearGrad");const a=gn(i.shape),[l,c,u,d]=i.shape,[,h,p]=r.shape,g=new Float32Array(l*c*u*d),y=[o&&h>1?c-1:c,o&&p>1?u-1:u],x=[o&&h>1?h-1:h,o&&p>1?p-1:p],v=y[0]/x[0],b=y[1]/x[1],S=t.data.get(r.dataId).values;let C=0;for(let E=0;E<l;E++){const k=E*a[0];for(let R=0;R<h;R++){const L=R*v,I=Math.floor(L),T=Math.min(Math.ceil(L),c-1),M=k+I*a[1],j=k+T*a[1],W=L-I,z=1-W;for(let X=0;X<p;X++){const B=X*b,J=Math.floor(B),K=Math.min(Math.ceil(B),u-1),ee=B-J,ne=1-ee,V=M+J*a[2],Z=M+K*a[2],he=j+J*a[2],ve=j+K*a[2],be=z*ne,Ie=z*ee,Xe=W*ne,Fe=W*ee;for(let Pe=0;Pe<d;Pe++){const ct=S[C++];g[V+Pe]+=ct*be,g[Z+Pe]+=ct*Ie,g[he+Pe]+=ct*Xe,g[ve+Pe]+=ct*Fe}}}}return t.makeTensorInfo([l,u,c,d],"float32",g)}const Bye={kernelName:Hy,backendName:"cpu",kernelFunc:zye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uye(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s;un(i,"resizeNearestNeighbor");const l=gn(i.shape),[c,u]=a,[d,h,p,g]=i.shape,y=t.data.get(i.dataId).values,x=new Float32Array(d*c*u*g),v=[r&&c>1?h-1:h,r&&u>1?p-1:p],b=[r&&c>1?c-1:c,r&&u>1?u-1:u],S=v[0]/b[0],C=v[1]/b[1];let E=0;for(let k=0;k<d;k++){const R=k*l[0];for(let L=0;L<c;L++){const I=o?S*(L+.5):S*L;let T=Math.min(h-1,r?Math.round(I):Math.floor(I));o&&(T=Math.max(0,T));const M=R+T*l[1];for(let j=0;j<u;j++){const W=o?C*(j+.5):C*j;let z=Math.min(p-1,r?Math.round(W):Math.floor(W));o&&(z=Math.max(0,z));const X=M+z*l[2];for(let B=0;B<g;B++){const J=y[X+B];x[E++]=J}}}}return t.makeTensorInfo([d,c,u,g],i.dtype,x)}const Vye={kernelName:Z0,backendName:"cpu",kernelFunc:Uye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wye(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s;un([r,i],"resizeNearestNeighborGrad");const a=gn(i.shape),l=gn(r.shape),[c,u,d,h]=i.shape,[,p,g]=r.shape,y=new Float32Array(c*u*d*h),x=t.data.get(r.dataId).values,v=[o&&p>1?u-1:u,o&&g>1?d-1:d],b=[o&&p>1?p-1:p,o&&g>1?g-1:g],S=v[0]/b[0],C=v[1]/b[1],E=1/S,k=1/C,R=Math.ceil(E)*2+2,L=Math.ceil(k)*2+2;for(let I=0;I<c;I++){const T=I*a[0];for(let M=0;M<u;M++){const j=T+M*a[1],W=Math.floor(M*E),z=Math.floor(W-R/2);for(let X=0;X<d;X++){const B=j+X*a[2],J=Math.floor(X*k),K=Math.floor(J-L/2);for(let ee=0;ee<h;ee++){let ne=0;for(let V=0;V<R;V++){const Z=V+z;if(Z<0||Z>=p)continue;const he=T+Z*l[1],ve=Z*S,be=Math.min(u-1,o?Math.round(ve):Math.floor(ve));if(M===be)for(let Ie=0;Ie<L;Ie++){const Xe=Ie+K;if(Xe<0||Xe>=g)continue;const Fe=he+Xe*l[2],Pe=Xe*C,ct=Math.min(d-1,o?Math.round(Pe):Math.floor(Pe));X===ct&&(ne+=x[Fe+ee])}}y[B+ee]=ne}}}}return t.makeTensorInfo(i.shape,i.dtype,y)}const Gye={kernelName:Gy,backendName:"cpu",kernelFunc:Wye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hye(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s;un(i,"reverse");const o=i.shape.length,a=Hn(r,i.shape);if(o===0)return Il({inputs:{x:i},backend:t});const l=new ur(i.shape,i.dtype),c=t.bufferSync(i);for(let u=0;u<l.size;u++){const d=l.indexToLoc(u),h=d.slice();a.forEach(p=>h[p]=i.shape[p]-1-h[p]),l.set(c.get(...h),...d)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const jye={kernelName:J0,backendName:"cpu",kernelFunc:Hye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xye={kernelName:Yy,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=Qi(s.dtype,Le(s.shape)),[c,u,d,h]=s.shape,[p,g]=mw(o,u,d),y=255,x=Math.sin(i),v=Math.cos(i),b=a.data.get(s.dataId).values;for(let C=0;C<c;C++){const E=C*d*u*h;for(let k=0;k<u;k++){const R=k*(d*h);for(let L=0;L<d;L++){const I=L*h;for(let T=0;T<h;T++){const M=[c,k,L,T],j=M[2],W=M[1];let z=(j-p)*v-(W-g)*x,X=(j-p)*x+(W-g)*v;z=Math.round(z+p),X=Math.round(X+g);let B=r;if(typeof r!="number"&&(T===3?B=y:B=r[T]),z>=0&&z<d&&X>=0&&X<u){const K=X*(d*h),ee=z*h,ne=E+K+ee+T;B=b[ne]}const J=E+R+I+T;l[J]=B}}}}return{dataId:a.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qye=Ds(Mp,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),Kye={kernelName:Mp,backendName:"cpu",kernelFunc:qye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yye(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Pl(r,i,o),h=!0,p=t.bufferSync(i),g=t.bufferSync(r),y=ad(p,g,o,d,c,l,a,u,0,h);return t.makeTensorInfo(o,y.dtype,y.values)}const Zye={kernelName:lT,backendName:"cpu",kernelFunc:Yye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<e?t=i+1:s=i;return s}function Jye(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<=e?t=i+1:s=i;return s}function ewe(n,e,t,s,i,r){const o=fi("int32",t*i);for(let a=0;a<t;++a){const l=n.slice(a*s,(a+1)*s),c=a*i;for(let u=0;u<i;++u)o[c+u]=r==="left"?Qye(l,e[u+c]):Jye(l,e[u+c])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function twe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=ewe(a,l,i.shape[0],i.shape[1],r.shape[1],o);return t.makeTensorInfo(r.shape,"int32",c)}const nwe={kernelName:uT,backendName:"cpu",kernelFunc:twe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function swe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e;un([s,i,r],"select");const o=s.shape.length,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=Ji(i.dtype,r.dtype),d=dr(Le(i.shape),u);let h=0;const p=o===0||o>1||i.shape.length===1?1:Le(i.shape.slice(1));for(let g=0;g<a.length;g++)for(let y=0;y<p;y++)a[g]===1?d[h++]=l[g]:d[h++]=c[g];return t.makeTensorInfo(i.shape,u,d)}const iwe={kernelName:e1,backendName:"cpu",kernelFunc:swe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rwe=p1,owe=m1,awe=Ds(Pp,n=>n>=0?owe*n:rwe*(Math.exp(n)-1)),lwe={kernelName:Pp,backendName:"cpu",kernelFunc:awe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cwe=Ds($p,n=>n<0?-1:n>0?1:0),uwe={kernelName:$p,backendName:"cpu",kernelFunc:cwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dwe=Ds(Dp,n=>Math.sin(n)),hwe={kernelName:Dp,backendName:"cpu",kernelFunc:dwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fwe=Ds(Lp,n=>Math.sinh(n)),pwe={kernelName:Lp,backendName:"cpu",kernelFunc:fwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mwe=11920928955078125e-23,DD=Math.log(mwe)+2,gwe=Ds(Op,n=>{const e=n>-DD,t=n<DD,s=Math.exp(n);let i;return t?i=s:e?i=n:i=Math.log(1+s),i}),xwe={kernelName:Op,backendName:"cpu",kernelFunc:gwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;un([i],"spaceToBatchND");const a=Le(r),l=[[0,0]];l.push(...o);for(let k=1+r.length;k<i.shape.length;++k)l.push([0,0]);const c=S8.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),u=Gd(c.shape,r,a,!1),d=Hd(u.length,r.length,!1),h=jd(c.shape,r,a,!1),y=Ks({inputs:{x:c},backend:t,attrs:{shape:u}}),b=eo({inputs:{x:y},backend:t,attrs:{perm:d}}),E=Ks({inputs:{x:b},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),E}const ywe={kernelName:s1,backendName:"cpu",kernelFunc:vwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wwe(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values[0],[d,h,p,g,y]=XU(a,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(h,s.dtype,d),t.makeTensorInfo([h[0]],i.dtype,p),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(x=>Number(x)))),t.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}const bwe={kernelName:i5,backendName:"cpu",kernelFunc:wwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Swe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(t.data.get(i.dataId).values),a=t.data.get(s.dataId).values,l=Array.from(t.data.get(r.dataId).values),[c,u,d]=qU(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([d.length],r.dtype,new Int32Array(d))]}const Cwe={kernelName:r5,backendName:"cpu",kernelFunc:Swe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=TI(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const Ewe={kernelName:dT,backendName:"cpu",kernelFunc:_we};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Twe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=TI(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const Iwe={kernelName:hT,backendName:"cpu",kernelFunc:Twe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kwe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Pl(r,i,a),p=!1,g=t.bufferSync(i);let y;switch(r.dtype){case"bool":{const x=t.bufferSync(r),v=!!t.data.get(o.dataId).values[0];y=ad(g,x,a,h,u,c,l,d,v,p);break}case"float32":{const x=t.bufferSync(r),v=t.data.get(o.dataId).values[0];y=ad(g,x,a,h,u,c,l,d,v,p);break}case"int32":{const x=t.bufferSync(r),v=t.data.get(o.dataId).values[0];y=ad(g,x,a,h,u,c,l,d,v,p);break}case"string":{const x=t.bufferSync(r),v=$a(t.data.get(o.dataId).values[0]);y=ad(g,x,a,h,u,c,l,d,v,p);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return t.makeTensorInfo(a,y.dtype,y.values)}const Awe={kernelName:fT,backendName:"cpu",kernelFunc:kwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Hn(o,i.shape)[0],l=Aw(i,r,a),c=new Array(i.shape.length).fill(0),u=i.shape.slice();return l.map(d=>{const h=[...u];h[a]=d;const p=Pd({inputs:{x:i},backend:t,attrs:{begin:c,size:h}});return c[a]+=d,p})}const Mwe={kernelName:i1,backendName:"cpu",kernelFunc:Rwe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nwe={kernelName:jy,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;un(t,"square");const i=s.data.get(t.dataId).values,r=new Float32Array(i.length);for(let a=0;a<i.length;++a){const l=i[a];r[a]=l*l}return{dataId:s.write(r,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pwe=Ds(Hp,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),Dwe={kernelName:Hp,backendName:"cpu",kernelFunc:Pwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=s;un(i,"stridedSlice");const{finalShapeSparse:p,finalShape:g,isIdentity:y,sliceDim0:x,isSimpleSlice:v,begin:b,end:S,strides:C}=hw(i.shape,r,o,a,l,c,u,d,h);let E;if(y)E=Ks({inputs:{x:i},backend:t,attrs:{shape:g}});else if(x||v){re(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const k=dw(b,S,C),R=Pd({inputs:{x:i},backend:t,attrs:{begin:b,size:k}});E=Ks({inputs:{x:R},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(R)}else{const k=t.bufferSync(i),R=ZU(p,k,C,b);E=t.makeTensorInfo(g,R.dtype,R.values)}return E}const $we={kernelName:Xy,backendName:"cpu",kernelFunc:Lwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fwe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:d}=e,h=t.data.get(u.dataId).values,p=t.data.get(d.dataId).values,[g,y]=QU(h,p,i,r,o,a,l,c);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(d.shape,"int32",y)]}const Owe={kernelName:mT,backendName:"cpu",kernelFunc:Fwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values[0],[c,u,d]=JU(a,l,i),h=u.length;return[t.makeTensorInfo([h,2],"int32",c),t.makeTensorInfo([h],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const Bwe={kernelName:o5,backendName:"cpu",kernelFunc:zwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uwe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(r.dataId).values,a=e8(o,i);return t.makeTensorInfo(r.shape,"int32",a)}const Vwe={kernelName:a5,backendName:"cpu",kernelFunc:Uwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wwe=Ds(Vp,n=>Math.tan(n)),Gwe={kernelName:Vp,backendName:"cpu",kernelFunc:Wwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hwe=Ds(Wp,n=>Math.tanh(n)),jwe={kernelName:Wp,backendName:"cpu",kernelFunc:Hwe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xwe(n){const{inputs:e,backend:t}=n,{tensor:s,indices:i,updates:r}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=Pl(r,i,s.shape),d=!1,h=t.bufferSync(i),p=t.bufferSync(r),g=t.bufferSync(s),y=ad(h,p,s.shape,u,l,a,o,c,g,d);return t.makeTensorInfo(s.shape,y.dtype,y.values)}const qwe={kernelName:cT,backendName:"cpu",kernelFunc:Xwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;un(i,"tile");const o=n8(t.bufferSync(i),r);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const Ywe={kernelName:Gp,backendName:"cpu",kernelFunc:Kwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zwe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s;un(i,"topk");const a=t.data.get(i.dataId).values,[l,c]=i8(a,i.shape,i.dtype,r,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const Qwe={kernelName:qy,backendName:"cpu",kernelFunc:Zwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jwe(n){const{inputs:e,attrs:t,backend:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=t,[u,d,h,p]=i.shape,[g,y]=c??[d,h],x=[u,g,y,p],v=gn(i.shape),b=v[0],S=v[1],C=v[2],E=gn(x),k=E[0],R=E[1],L=E[2],I=Qi(i.dtype,Le(x));I.fill(l);const T=s.data.get(i.dataId).values,M=s.data.get(r.dataId).values;for(let W=0;W<u;++W){const z=r.shape[0]===1?M:M.subarray(W*8,W*8+8);for(let X=0;X<g;++X)for(let B=0;B<y;++B)for(let J=0;J<p;++J){let K;const ee=z[6]*B+z[7]*X+1;if(ee===0)continue;const ne=(z[0]*B+z[1]*X+z[2])/ee,V=(z[3]*B+z[4]*X+z[5])/ee,Z=LD(ne,h,a),he=LD(V,d,a);switch(o){case"nearest":K=rbe(T,d,h,b,S,C,W,he,Z,J,l);break;case"bilinear":K=obe(T,d,h,b,S,C,W,he,Z,J,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ve=W*k+X*R+B*L+J;I[ve]=K}return s.makeTensorInfo(x,i.dtype,I)}return{dataId:s.write(I,x,i.dtype),shape:i.shape,dtype:i.dtype}}const ebe={kernelName:Ky,backendName:"cpu",kernelFunc:Jwe};function LD(n,e,t){switch(t){case"reflect":return tbe(n,e);case"wrap":return nbe(n,e);case"nearest":return ibe(n,e);case"constant":default:return sbe(n)}}function tbe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Sd(0,t,e-1)}function nbe(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Sd(0,t,e-1)}function sbe(n,e){return n}function ibe(n,e){return Sd(0,n,e-1)}function ag(n,e,t,s,i,r,o,a,l,c,u){const d=o*s+a*i+l*r+c;return 0<=a&&a<e&&0<=l&&l<t?n[d]:u}function rbe(n,e,t,s,i,r,o,a,l,c,u){const d=Math.round(a),h=Math.round(l);return ag(n,e,t,s,i,r,o,d,h,c,u)}function obe(n,e,t,s,i,r,o,a,l,c,u){const d=Math.floor(a),h=Math.floor(l),p=d+1,g=h+1,y=(g-l)*ag(n,e,t,s,i,r,o,d,h,c,u)+(l-h)*ag(n,e,t,s,i,r,o,d,g,c,u),x=(g-l)*ag(n,e,t,s,i,r,o,p,h,c,u)+(l-h)*ag(n,e,t,s,i,r,o,p,g,c,u);return(p-a)*y+(a-d)*x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;un(r,"unique");const o=s.data.get(r.dataId).values,{outputValues:a,outputShape:l,indices:c}=r8(o,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const lbe={kernelName:gT,backendName:"cpu",kernelFunc:abe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i.shape.length,a=i.shape[r],l=new Array(o-1);let c=0;for(let p=0;p<o;p++)p!==r&&(l[c++]=i.shape[p]);const u=new Array(o).fill(0),d=i.shape.slice();d[r]=1;const h=new Array(a);for(let p=0;p<h.length;p++){u[r]=p;const g=Pd({inputs:{x:i},backend:t,attrs:{begin:u,size:d}});h[p]=Ks({inputs:{x:g},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(g)}return h}const ube={kernelName:o1,backendName:"cpu",kernelFunc:cbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s;un(i,"unsortedSegmentSum");const a=i.shape.length,l=r.shape.length,c=[],u=[],d=a-l;let h=r;for(let g=0;g<d;++g){const y=$2({inputs:{input:h},backend:t,attrs:{dim:g+1}});h=y,u.push(y)}for(let g=0;g<o;++g){const y=mu(g,"int32"),x=t.makeTensorInfo([],"int32",y),v=wU({inputs:{a:x,b:h},backend:t}),b=du({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),S=Vw({inputs:{a:b,b:i},backend:t}),C=_1({inputs:{x:S},backend:t,attrs:{axis:0,keepDims:!1}});c.push(C),u.push(x),u.push(v),u.push(b),u.push(S),u.push(C)}const p=b8({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const hbe={kernelName:a1,backendName:"cpu",kernelFunc:dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fbe=[axe,V0e,cxe,dxe,q0e,fxe,mxe,xxe,yxe,bxe,Cxe,Exe,Ixe,Rxe,Nxe,Lxe,Fxe,zxe,Uxe,rxe,Wxe,Hxe,Xxe,Y0e,Kxe,j0e,Q0e,Zxe,W0e,Jxe,tve,nve,ive,ove,lve,uve,hve,pve,gve,vve,wve,Sve,_ve,Tve,Ive,Ave,Mve,Pve,Dve,Lve,$ve,Ove,Uve,Q1e,Wve,J0e,Zve,e1e,Qve,n1e,i2e,r2e,a2e,i1e,o1e,c2e,d2e,f2e,m2e,l1e,u1e,G0e,x2e,eve,y2e,b2e,C2e,J1e,h1e,p1e,E2e,g1e,I2e,R2e,N2e,L2e,F2e,z2e,B2e,v1e,V2e,G2e,j2e,q2e,Y2e,Q2e,eye,w1e,nye,rye,lye,S1e,_1e,dye,pye,xye,T1e,yye,bye,Sye,S8,Tye,txe,A1e,kye,Rye,Nye,Dye,H0e,I_,$ye,nxe,sxe,ixe,Oye,Bye,Vye,Gye,jye,Xye,Kye,F1e,Zye,nwe,iwe,lwe,z1e,uwe,hwe,pwe,B1e,oye,xwe,ywe,bwe,Cwe,Ewe,Iwe,Awe,Mwe,W1e,Nwe,H1e,X1e,Dwe,$we,Owe,Bwe,Vwe,Z1e,zve,Gwe,jwe,qwe,Ywe,Qwe,ebe,I1e,lbe,ube,hbe,wye];for(const n of fbe)vT(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nd={},xv={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function pbe(n,e){nd[n]=e}function Ua(n,e){if(!(n in nd)||e!=null){const s=gbe(n,e);if(s!==null)nd[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=nd[n];return t==null||t.isContextLost()?(delete nd[n],Ua(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),nd[n])}function mbe(n){if(!ze().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function gbe(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??mbe(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete nd[n]},!1),ze().getBool("SOFTWARE_WEBGL_ENABLED")&&(xv.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",xv)||t.getContext("experimental-webgl",xv):t.getContext("webgl2",xv)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Hg;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Hg||(Hg={}));var No;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(No||(No={}));var lr;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(lr||(lr={}));function E1(n,e){return[e,n]}function xbe(n,e){return n*e}function vv(n){const e=Le(n),t=Math.ceil(e/4);return ZC(t)}function Qp(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function vbe(n,e){const[t,s]=Qp(n,e);return t*s*4}function MI(n,e){const t=n;let s,i,r,o,a,l,c,u,d,h;return ze().getNumber("WEBGL_VERSION")===2?(s=t.R32F,i=t.R16F,r=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,d=t.HALF_FLOAT,h=t.FLOAT,l=t.RGBA8):(s=n.RGBA,i=n.RGBA,r=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,d=e!=null?e.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(n,e){const t=e();return ze().getBool("DEBUG")&&ybe(n),t}function ybe(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Cbe(n,e))}const wbe=596e-10,bbe=65504;function Sbe(n){return!!(ze().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||wbe<Math.abs(n)&&Math.abs(n)<bbe)}function Cbe(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function yv(n,e){return xc(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function _be(n,e){const t=xc(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Qt(n,()=>n.shaderSource(t,e)),Qt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Ebe(n,e){const t=xc(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Qt(n,()=>n.shaderSource(t,e)),Qt(n,()=>n.compileShader(t)),ze().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw C8(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const Tbe=/ERROR: [0-9]+:([0-9]+):/g;function C8(n,e){const t=Tbe.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],i=n.split(`
`),r=i.length.toString().length+2,o=i.map((d,h)=>cf((h+1).toString(),r)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),u=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${cf(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function Ibe(n){return xc(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function kbe(n,e){if(Qt(n,()=>n.linkProgram(e)),!ze().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function sC(n,e){if(Qt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Abe(n,e){const t=xc(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Qt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Qt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Rbe(n,e){const t=xc(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Qt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Qt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Mbe(n){return xc(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Nbe(n,e){const t=ze().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function Pbe(n){return xc(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function $D(n,e,t,s,i,r,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Qt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Qt(n,()=>n.vertexAttribPointer(a,i,n.FLOAT,!1,r,o)),Qt(n,()=>n.enableVertexAttribArray(a)),!0)}function Dbe(n,e,t){zbe(n,t),Qt(n,()=>n.activeTexture(n.TEXTURE0+t)),Qt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Lbe(n,e,t){return xc(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function $be(n,e,t){return n.getUniformLocation(e,t)}function Fbe(n,e,t,s){Qt(n,()=>Dbe(n,e,s)),Qt(n,()=>n.uniform1i(t,s))}function iC(n,e,t){Qt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Qt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function FD(n,e){Qt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Qt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function wv(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Obe(n,e))}function Obe(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function xc(n,e,t){const s=Qt(n,()=>e());if(s==null)throw new Error(t);return s}function zbe(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function Ff(n,e=2){return Le(n.slice(0,n.length-e))}function Of(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function bv(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[Ff(n),...Of(n)]),e}function Bbe(n,e=!1){let t=ze().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ze().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ze().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((a,l)=>l>=n.length-2?qE(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=pu(n).newShape);let i=Le(n),r=null;n.length<=1&&i<=t?r=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?r=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?r=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?r=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?r=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(r=[n[0],n[1]*n[2]*n[3]]);const o=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(e?2:1)&&Math.min(...r)>0;if(r==null||o)if(e){const a=Ff(n);let l=2,c=2;n.length&&([l,c]=Of(n)),i=a*(l/2)*(c/2),r=ZC(i).map(u=>u*2)}else r=ZC(i);return r}function Sv(n){return n%2===0}function O2(n,e){if(n=n.slice(-2),e=e.slice(-2),ds(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],s=e[e.length-1];if(t===s||Sv(t)&&Sv(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Sv(n[0])&&Sv(e[0])}let rC,oC;function Ube(n){if(rC==null){const e=Ua(n);rC=e.getParameter(e.MAX_TEXTURE_SIZE)}return rC}function Vbe(n){if(oC==null){const e=Ua(n);oC=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,oC)}function Wbe(n){if(n===0)return 0;let e;const t=Ua(n);return ra(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:ra(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function ra(n,e){return n.getExtension(e)!=null}function OD(n){try{if(Ua(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Gbe(n){if(n===0)return!1;const e=Ua(n);if(n===1){if(!ra(e,"OES_texture_float"))return!1}else if(!ra(e,"EXT_color_buffer_float"))return!1;return A_(e)}function Hbe(n){if(n===0)return!1;const e=Ua(n);if(n===1){if(!ra(e,"OES_texture_float")||!ra(e,"WEBGL_color_buffer_float"))return!1}else{if(ra(e,"EXT_color_buffer_float"))return A_(e);const s="EXT_color_buffer_half_float";if(ra(e,s)){const i=e.getExtension(s);return jbe(e,i)}return!1}return A_(e)}function A_(n){const e=MI(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(r),o}function jbe(n,e){const t=MI(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function Xbe(n){return n!==2?!1:Ua(n).fenceSync!=null}function T1(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&re(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mn=ze();mn.registerFlag("HAS_WEBGL",()=>mn.getNumber("WEBGL_VERSION")>0);mn.registerFlag("WEBGL_VERSION",()=>OD(2)?2:OD(1)?1:0);mn.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);mn.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>mn.get("WEBGL_VERSION")===2);mn.registerFlag("WEBGL_CPU_FORWARD",()=>!0);mn.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);mn.registerFlag("WEBGL_PACK",()=>mn.getBool("HAS_WEBGL"));mn.registerFlag("WEBGL_PACK_NORMALIZATION",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_CLIP",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_REDUCE",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_LAZILY_UNPACK",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_CONV_IM2COL",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>mn.getBool("WEBGL_PACK"));mn.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Ube(mn.getNumber("WEBGL_VERSION")));mn.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Vbe(mn.getNumber("WEBGL_VERSION")));mn.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=mn.getNumber("WEBGL_VERSION");return n===0?0:Wbe(n)});mn.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>mn.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!b5());mn.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Gbe(mn.getNumber("WEBGL_VERSION")));mn.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>mn.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:mn.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));mn.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Hbe(mn.getNumber("WEBGL_VERSION")));mn.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Xbe(mn.getNumber("WEBGL_VERSION")));mn.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>mn.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);mn.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});mn.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>b5()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});mn.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);mn.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);mn.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);mn.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);mn.registerFlag("WEBGL_EXP_CONV",()=>!1);mn.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>mn.getBool("IS_TEST"));mn.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);mn.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);mn.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);mn.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fr(){let n,e,t,s,i,r,o,a,l,c;return ze().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",i="texture",r="outputColor",o="out vec4 outputColor;",a=ze().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",i="texture2D",r="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:i,output:r,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kd(n,e,t="index"){const s=gn(e);return s.map((i,r)=>{const o=`int ${n[r]} = ${t} / ${i}`,a=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * ${i}`:`index -= ${n[r]} * ${i}`;return`${o}; ${a};`}).join("")}function Ww(n,e,t="index"){const s=gn(e);return s.map((i,r)=>{const o=`int ${n[r]} = ${t} / outShapeStrides[${r}]`,a=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * outShapeStrides[${r}]`:`index -= ${n[r]} * outShapeStrides[${r}]`;return`${o}; ${a};`}).join("")}function qbe(n,e){const t=n.length,s=n.map(r=>`${e}[${r}]`),i=new Array(t-1);i[t-2]=s[t-1];for(let r=t-3;r>=0;--r)i[r]=`(${i[r+1]} * ${s[r+1]})`;return i}function Kbe(n,e,t="index"){const s=n.map((r,o)=>o),i=qbe(s,e);return i.map((r,o)=>{const a=`int ${n[o]} = ${t} / ${i[o]}`,l=o===i.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${i[o]}`:`index -= ${n[o]} * ${i[o]}`;return`${a}; ${l};`}).join("")}function NI(n){const e=gn(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function PI(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const _8=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:E8}=Bfe;function Ybe(n,e,t){const s=[];if(n.forEach(p=>{const g=Le(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${g>1?`[${g}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:y}=DI(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(y.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const i=s.join(`
`),r=n.map(p=>Zbe(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Fr(),l=e3e(a);let c,u,d=s3e(a);return e.isPacked?(c=Qbe(e.logicalShape,o,t.enableShapeUniforms),u=n3e(a)):(c=Jbe(e.logicalShape,o,t.enableShapeUniforms),u=t3e(a)),t.packedInputs&&(d+=a3e),[d,l,u,i,c,r,t.userCode].join(`
`)}function Jp(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return y3e(n,e);case 1:return b3e(n,e);case 2:return C3e(n,e);case 3:return E3e(n,e);case 4:return I3e(n,e);case 5:return k3e(n);case 6:return A3e(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function T8(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return v3e(n);case 1:return w3e(n,e);case 2:return S3e(n,e);case 3:return _3e(n,e);default:return T3e(n,e)}}function Zbe(n,e,t=!1,s){let i="";t?i+=T8(n,s):i+=Jp(n,s);const r=n.shapeInfo.logicalShape,o=e.logicalShape;return r.length<=o.length&&(t?i+=R3e(n,e):i+=M3e(n,e)),i}function Qbe(n,e,t){switch(n.length){case 0:return I8();case 1:return l3e(n,e,t);case 2:return g3e(n,e,t);case 3:return u3e(n,e,t);default:return h3e(n,e,t)}}function Jbe(n,e,t){switch(n.length){case 0:return I8();case 1:return c3e(n,e,t);case 2:return x3e(n,e,t);case 3:return d3e(n,e,t);case 4:return f3e(n,e,t);case 5:return p3e(n,e);case 6:return m3e(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function e3e(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function t3e(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function n3e(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function s3e(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${i3e}
    ${r3e}
    ${o3e}
  `}const i3e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,r3e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,o3e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,a3e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function I8(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function l3e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function c3e(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function u3e(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),r=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function d3e(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ww(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=Kd(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function h3e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),r=i*Math.ceil(n[n.length-2]/2);let o=r,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function f3e(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ww(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Kd(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function p3e(n,e){const t=Kd(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function m3e(n,e){const t=Kd(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function g3e(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(ds(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function x3e(n,e,t){return ds(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Yd(n){return`offset${n}`}function v3e(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Fr();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function y3e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[i,r]=n.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Yd(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function w3e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,r=Fr();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${r.texture2D}(${t}, uv);
    }
  `}function b3e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${em(n)}
      }
    `;const i=n.shapeInfo.texShape,r=i[0],o=i[1];if(o===1&&r===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Yd(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${r}.0);
        return sampleTexture(${t}, uv);
      }
    `:r===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function S3e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=r[0],a=r[1],l=Fr();if(r!=null&&ds(t,r))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function C3e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape;if(r!=null&&ds(t,r)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const h=r[0],p=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=pu(t),l=o;if(l.length<t.length){const h=tm(n,l),p=["row","col"];return`
      ${Jp(h,e)}
      float ${i}(int row, int col) {
        return ${i}(${nm(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${em(n)}
      }
    `;const c=r[0],u=r[1],d=Yd(s);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`}function _3e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){const h=t.slice(1),p=[1,2],g=tm(n,h),y=["b","row","col"];return`
        ${T8(g,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${nm(y,p)});
        }
      `}const a=Fr();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),d=u*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${u}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function E3e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=pu(t),c=a;if(c.length<t.length){const y=tm(n,c),x=["row","col","depth"];return`
        ${Jp(y,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${nm(x,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${o}, 1)));
        ${em(n)}
      }
    `;const u=n.shapeInfo.texShape,d=u[0],h=u[1],p=n.shapeInfo.flatOffset;if(h===r&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(h===o&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const g=Yd(s);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${o} + depth + ${g};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${s}, uv);
      }
  `}function T3e(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=Fr();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const r=n.shapeInfo.logicalShape,o=r.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(r[o-1]/2);let h=d*Math.ceil(r[o-2]/2),p="int b, int row, int col",g=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let y=2;y<o-1;y++)p=`int b${y}, `+p,h*=r[o-y-1],g=`b${y} * ${h} + `+g;return`
    vec4 ${s}(${p}) {
      int index = ${g};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${i.texture2D}(${t}, uv);
    }
  `}function I3e(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[3],o=t[2]*r,a=t[1]*o,{newShape:l,keptDims:c}=pu(t);if(l.length<t.length){const b=tm(n,l),S=["row","col","depth","depth2"];return`
      ${Jp(b,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${nm(S,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${r}, 1)));
        ${em(n)}
      }
    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1],g=`int stride2 = ${s}Shape[3];`,y=`int stride1 = ${s}Shape[2] * stride2;`,x=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${g}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===r&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=Yd(s);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${y}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function k3e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],r=e[3]*i,o=e[2]*r,a=e[1]*o,{newShape:l,keptDims:c}=pu(e);if(l.length<e.length){const y=tm(n,l),x=["row","col","depth","depth2","depth3"];return`
      ${Jp(y)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${nm(x,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${r}, ${i})) +
          depth3;
        ${em(n)}
      }
    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1];if(p===a&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===i&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Yd(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${r} +
          depth2 * ${i} + depth3 + ${g};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function A3e(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:r}=pu(e);if(i.length<e.length){const x=tm(n,i),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${Jp(x)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${nm(v,r)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${em(n)}
      }
    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],g=h[1];if(g===u&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===o&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const y=Yd(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${y};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function em(n){const e=n.name,t=Le(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function R3e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=E8(n.shapeInfo.logicalShape,e.logicalShape),l=Fs(o),c=o-r;let u;const d=["x","y","z","w","u","v"];r===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${d[b+c]} = 0;`).join(`
`);let h="";o<2&&r>0?h="coords":h=n.shapeInfo.logicalShape.map((b,S)=>`coords.${d[S+c]}`).join(", ");let p="return outputValue;";const y=Le(n.shapeInfo.logicalShape)===1,v=Le(e.logicalShape)===1;if(r===1&&!y&&!v)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(y&&!v)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=r-2,S=r-1;a.indexOf(b)>-1&&a.indexOf(S)>-1?p="return vec4(outputValue.x);":a.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(S)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${h});
      ${p}
    }
  `}function M3e(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&ds(o,r))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Fs(l),u=E8(n.shapeInfo.logicalShape,e.logicalShape),d=l-a;let h;const p=["x","y","z","w","u","v"];a===0?h="":l<2&&u.length>=1?h="coords = 0;":h=u.map(y=>`coords.${p[y+d]} = 0;`).join(`
`);let g="";return l<2&&a>0?g="coords":g=n.shapeInfo.logicalShape.map((y,x)=>`coords.${p[x+d]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${h}
      return get${s}(${g});
    }
  `}function Fs(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function DI(n,e,t){const{newShape:s,keptDims:i}=pu(e),r=e.length,o=n&&r===3&&e[0]===1,a=o?e.slice(1):s,l=!n&&r>1&&!ds(e,t)&&s.length<r||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:i}}function tm(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function nm(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3e(n,e,t,s){const i=t.map((u,d)=>{const h={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(h.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:h}}),r=i.map(u=>u.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=Ybe(i,o,e),l=Ebe(n.gl,a),c=n.createProgram(l);return ze().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:r,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:r,outShapeInfo:o},k8(n,e,c)))}function k8(n,e,t){const s=[],i=[];let r,o,a,l=null,c=null;c=n.getUniformLocation(t,"NAN",!1),ze().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const d of e.variableNames){const h={name:d,uniform:n.getUniformLocation(t,d,u),offset:n.getUniformLocation(t,`offset${d}`,u)};e.enableShapeUniforms&&(h.shape=n.getUniformLocation(t,`${d}Shape`,u),h.texShape=n.getUniformLocation(t,`${d}TexShape`,u)),s.push(h)}if(e.enableShapeUniforms&&(r=n.getUniformLocation(t,"outShape",u),a=n.getUniformLocation(t,"outShapeStrides",u),o=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const d of e.customUniforms)i.push(n.getUniformLocation(t,d.name,u));return{variablesLocations:s,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:r,outShapeStridesLocation:a,outTexShapeLocation:o}}function zD(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const i=t.logicalShape,r=e[s],o=r.shape;if(!ds(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(t.isUniform&&r.isUniform)return;const a=t.texShape,l=r.isUniform?null:r.texData.texShape;if(!ds(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function P3e(n,e,t,s,i){e.program.enableShapeUniforms||(zD(e.inShapeInfos,t),zD([e.outShapeInfo],[s]));const r=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(r.texture,o[0],o[1]):n.setOutputMatrixTexture(r.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ze().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:u,offset:d,shape:h,texShape:p}=e.variablesLocations[l];if(h){const{uniformShape:g}=DI(e.program.packedInputs,c.shape,c.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(h,new Int32Array(g));break;case 2:n.gl.uniform2iv(h,new Int32Array(g));break;case 3:n.gl.uniform3iv(h,new Int32Array(g));break;case 4:n.gl.uniform4iv(h,new Int32Array(g));break}}if(p&&n.gl.uniform2i(p,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(Le(c.shape)<2)n.gl.uniform1f(u,c.uniformValues[0]);else{let g=c.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(u,g)}continue}c.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,u,l)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=gn(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],u=e.customUniformLocations[l],d=i[l];if(c.type==="float")n.gl.uniform1fv(u,d);else if(c.type==="vec2")n.gl.uniform2fv(u,d);else if(c.type==="vec3")n.gl.uniform3fv(u,d);else if(c.type==="vec4")n.gl.uniform4fv(u,d);else if(c.type==="int")n.gl.uniform1iv(u,d);else if(c.type==="ivec2")n.gl.uniform2iv(u,d);else if(c.type==="ivec3")n.gl.uniform3iv(u,d);else if(c.type==="ivec4")n.gl.uniform4iv(u,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}n.executeProgram()}function D3e(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=DI(n.packedInputs,o.shape,l);let h="",p="",g="";if(u.length===1&&n.packedInputs){const E=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${E[0]>1}_${E[1]>1}`}else if(u.length===2&&!n.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const E=gn(u);g=`${E[0]===l[1]}_${E[E.length-1]===l[1]}`}const y=o.shape.length,x=u.length===2&&ds(o.shape,l),v=Le(o.shape)===1,b=ou(o.shape,t.shape),S=!n.packedInputs&&y===t.shape.length&&ds(l,t.texData.texShape),C=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${y}_${S}_${c?d:""}_${u.length}_${v}_${b}_${x}_${h}_${p}_${g}_${C}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const i=n.userCode;let r=n.constructor.name;return r+="_"+s+"_"+i+`${ze().getNumber("WEBGL_VERSION")}`,r}function Cr(n){return ze().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L3e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Hg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Fr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ww(["r","c","d"],e):Kd(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $3e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Hg.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Fr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ww(["r","c","d"],e):Kd(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F3e{constructor(e){this.variableNames=["A"],this.outTexUsage=No.DOWNLOAD;const t=Fr();this.outputShape=e,this.userCode=`
      ${_8}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O3e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=No.DOWNLOAD;const t=Fr();this.outputShape=e,this.userCode=`
      ${_8}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z3e={R:0,G:1,B:2,A:3};class BD{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=Fr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let o="";for(let a=0;a<s.length;a++){const l=s[a];o+=`
          if(offset == ${a}) {
            result = values[${z3e[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?PI():NI(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${o}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B3e{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Fr();this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let i="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;i+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?PI():NI(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3e(n){const e=Fr(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return _be(n,t)}function V3e(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Abe(n,e)}function W3e(n){const e=new Uint16Array([0,1,2,2,1,3]);return Rbe(n,e)}function I1(n,e,t,s,i,r){Nbe(e,t);const o=Mbe(n),a=n.TEXTURE_2D;return Qt(n,()=>n.bindTexture(a,o)),Qt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Qt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Qt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Qt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ze().getNumber("WEBGL_VERSION")===1?Qt(n,()=>n.texImage2D(a,0,s,e,t,0,i,r,null)):Qt(n,()=>n.texStorage2D(a,1,s,e,t)),Qt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function A8(n){return n.internalFormatFloat}function G3e(n,e,t,s){const[i,r]=E1(e,t);return I1(n,i,r,A8(s),s.textureFormatFloat,n.FLOAT)}function R8(n){return n.internalFormatHalfFloat}function H3e(n,e,t,s){const[i,r]=E1(e,t);return I1(n,i,r,R8(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function M8(n){return n.downloadTextureFormat}function j3e(n,e,t,s){const[i,r]=E1(e,t);return I1(n,i,r,M8(s),n.RGBA,n.UNSIGNED_BYTE)}function N8(n){return n.internalFormatPackedFloat}function X3e(n,e,t,s){const[i,r]=Qp(e,t);return I1(n,i,r,N8(s),n.RGBA,n.FLOAT)}function P8(n){return n.internalFormatPackedHalfFloat}function q3e(n,e,t,s){const[i,r]=Qp(e,t);return I1(n,i,r,P8(s),n.RGBA,s.textureTypeHalfFloat)}function K3e(n,e,t){return Qt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),$D(n,e,"clipSpacePos",t,3,20,0)&&$D(n,e,"uv",t,2,20,12)}function Y3e(n,e,t,s,i,r){Qt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;i instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,l=r.internalFormatPackedFloat),o.set(i),ze().getNumber("WEBGL_VERSION")===2?Qt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):Qt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,o)),Qt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Z3e(n,e,t){Qt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ze().getNumber("WEBGL_VERSION")===2?Qt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Qt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ze().getNumber("WEBGL_VERSION")===2?Qt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Qt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Qt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Q3e(n,e,t,s){const i=n.createBuffer();Qt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const a=4*4*e*t;return Qt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Qt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Qt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function J3e(n,e,t){const s=n,i=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function eSe(n,e,t,s){const[i,r]=E1(e,t),o=4,a=new Uint8Array(xbe(e*t,o));return Qt(n,()=>n.readPixels(0,0,i,r,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function tSe(n,e,t,s,i,r,o,a){const l=n,c=new Float32Array(vbe(r,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function nSe(n,e,t){const s=new Float32Array(e*t*4);return Qt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aC{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ze().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,pbe(t,e)):this.gl=Ua(t),e=this.gl,ze().getNumber("WEBGL_VERSION")===2){const r=e;this.createVertexArray=()=>Qt(r,()=>r.createVertexArray()),this.bindVertexArray=o=>Qt(r,()=>r.bindVertexArray(o)),this.deleteVertexArray=o=>Qt(r,()=>r.deleteVertexArray(o)),this.getVertexArray=()=>Qt(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){const r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Qt(e,()=>r.createVertexArrayOES()),this.bindVertexArray=o=>Qt(e,()=>r.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Qt(e,()=>r.deleteVertexArrayOES(o)),this.getVertexArray=()=>Qt(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ze().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=yv(this.gl,r),ra(this.gl,o))this.textureHalfFloatExtension=yv(this.gl,o);else if(ze().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ra(this.gl,i))this.colorBufferHalfFloatExtension=yv(this.gl,i);else if(ze().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ra(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(ra(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=V3e(this.gl),this.indexBuffer=W3e(this.gl),this.framebuffer=Pbe(this.gl),this.textureConfig=MI(this.gl,this.textureHalfFloatExtension)}get debug(){return ze().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Qt(e,()=>e.finish()),Qt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Qt(e,()=>e.deleteFramebuffer(this.framebuffer)),Qt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Qt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Qt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),G3e(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),H3e(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),j3e(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Z3e(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,i){this.throwIfDisposed(),Y3e(this.gl,e,t,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),q3e(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),X3e(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(FD(this.gl,this.framebuffer),this.outputTexture=null),Qt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>eSe(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,i,r,o){return tSe(this.gl,e,t,s,i,r,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return J3e(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const i=Q3e(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ze().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=i.clientWaitSync(r,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},t=r}else ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>nSe(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=U3e(t));const s=Ibe(t);Qt(t,()=>t.attachShader(s,this.vertexShader)),Qt(t,()=>t.attachShader(s,e)),kbe(t,s);const i=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&sC(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Qt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),K3e(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Qt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&sC(this.gl,this.program),Qt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?Lbe(this.gl,e,t):$be(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Qt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),Fbe(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[i,r]=Qp(t,s);this.setOutputMatrixTextureDriver(e,i,r)}setOutputMatrixWriteRegion(e,t,s,i){this.setOutputMatrixWriteRegionDriver(s,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&sC(this.gl,this.program),wv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Qt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Qt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=yv(this.gl,ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,r),r}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await SP(()=>this.disposed||this.isQueryAvailable(e,ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=sSe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ze().platform&&(s=ze().platform.setTimeoutCustom.bind(ze().platform)),SP(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),iC(this.gl,e,this.framebuffer),this.debug&&wv(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(iC(this.gl,this.outputTexture,this.framebuffer),this.debug&&wv(this.gl)):FD(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const i=this.gl;iC(i,e,this.framebuffer),this.debug&&wv(i),this.outputTexture=e,Qt(i,()=>i.viewport(0,0,t,s)),Qt(i,()=>i.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,i){this.throwIfDisposed(),Qt(this.gl,()=>this.gl.scissor(e,t,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function sSe(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:iSe,bincountImpl:D8,bincountReduceImpl:rSe,bitwiseAndImpl:oSe,castImpl:aSe,ceilImpl:lSe,concatImpl:cSe,equalImpl:uSe,expImpl:dSe,expm1Impl:hSe,floorImpl:fSe,gatherNdImpl:pSe,gatherV2Impl:mSe,greaterImpl:gSe,greaterEqualImpl:xSe,lessImpl:vSe,lessEqualImpl:ySe,linSpaceImpl:wSe,logImpl:bSe,maxImpl:SSe,maximumImpl:CSe,minimumImpl:_Se,multiplyImpl:ESe,negImpl:TSe,notEqualImpl:ISe,prodImpl:kSe,raggedGatherImpl:ASe,raggedRangeImpl:RSe,raggedTensorToTensorImpl:MSe,rangeImpl:NSe,rsqrtImpl:PSe,scatterImpl:DSe,sigmoidImpl:LSe,simpleAbsImpl:L8,sliceImpl:$Se,sparseFillEmptyRowsImpl:FSe,sparseReshapeImpl:OSe,sparseSegmentReductionImpl:$8,sqrtImpl:zSe,staticRegexReplaceImpl:BSe,stridedSliceImpl:USe,stringNGramsImpl:VSe,stringSplitImpl:WSe,stringToHashBucketFastImpl:GSe,subImpl:HSe,tileImpl:jSe,topKImpl:XSe,transposeImpl:LI,uniqueImpl:qSe}=o8;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F8(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function Dr(n,e){return e===1?[n]:F8(n,e)}function KSe(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YSe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Cr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=Dr("rc",this.rank),s=Fs(this.rank),i=this.getOutOfBoundsCondition(t),r=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let r=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)r=`${e[e.length-1-o]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O8{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);let s="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),s+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${ZSe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?PI():NI(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function ZSe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?Kbe(["r","c","d"],"inputShape"):Kd(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let QSe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const i=VD(t,s),r=WD(e,i,s);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const o=UD(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[r].pop();return this.usedTextures[r].push(l),l}let a;return i===lr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===lr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===lr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===lr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===lr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,i){if(this.freeTextures==null)return;const r=VD(s,i),o=WD(t,r,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=UD(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=ze().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c&&c.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function JSe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function UD(n,e,t,s,i){const r=eCe(e,s);let o;if(i){const[l,c]=Qp(n[0],n[1]);o=l*c}else{const[l,c]=E1(n[0],n[1]);o=l*c}const a=JSe(t,r);return o*a}function eCe(n,e){switch(n){case lr.PACKED_2X2_FLOAT32:return N8(e);case lr.PACKED_2X2_FLOAT16:return P8(e);case lr.UNPACKED_FLOAT32:return A8(e);case lr.UNPACKED_FLOAT16:return R8(e);case lr.PACKED_4X1_UNSIGNED_BYTE:return M8(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function tCe(n){return ze().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?lr.PACKED_2X2_FLOAT32:lr.UNPACKED_FLOAT32:n?lr.PACKED_2X2_FLOAT16:lr.UNPACKED_FLOAT16}function VD(n,e){if(n===No.UPLOAD)return lr.PACKED_2X2_FLOAT32;if(n===No.RENDER||n==null)return tCe(e);if(n===No.DOWNLOAD||n===No.PIXELS)return lr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function WD(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ul=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const ca="if (isnan(x)) return x;",nCe="return x;",GD="return abs(x);",sCe="return (x >= 0.0) ? x : (exp(x) - 1.0);",iCe=ca+`
  return (x < 0.0) ? 0.0 : x;
`,rCe=ca+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,jc="return x;",oCe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aCe="return x;",lCe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,cCe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uCe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dCe="return 1.0 / (1.0 + exp(-1.0 * x));";class Zc{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hCe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);const t=e.length,s=Dr("rc",t),i=Fs(t),r=KSe(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCe=l6,pCe=1e-7,mCe=1e-4,Cv={};function gCe(n){return n in Cv||(Cv[n]={}),Cv[n]}const xCe=ze().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),vCe=600;function yCe(){return ze().global.screen==null?1024:ze().global.screen.height*ze().global.screen.width*window.devicePixelRatio*vCe/1024/1024}class Gw extends hy{nextDataId(){return Gw.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ze().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof aC)t=e;else{const s=Ua(ze().getNumber("WEBGL_VERSION"),e);t=new aC(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Ua(ze().getNumber("WEBGL_VERSION"));t=new aC(s),this.binaryCache=gCe(ze().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new QSe(this.gpgpu),this.numMBBeforeWarning=yCe(),this.texData=new XE(this,Ao())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,i,r,o){const a=this.makeTensorInfo(t,s),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,r]},l.texShape=[i,r];const c=bv(t),u=new BD(c,!1,o),d=this.runWebGLProgram(u,[a],s,[[i,r]]);return d.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),d.dataId}write(e,t,s){if((ze().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ze().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:s,values:e,usage:No.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,i,r){if(ze().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:t,usage:No.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:r,slice:o,shape:a,isPacked:l}=t;if(o!=null){let h;l?h=new Zc(a,jc):h=new ul(a,jc);const p=this.runWebGLProgram(h,[{dataId:e,shape:a,dtype:i}],i),g=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return s;const c=this.activeTimers!=null;let u;c&&(u=Gr());let d;if(i==="complex64"){const h=this.readSync(r.real.dataId),p=this.readSync(r.imag.dataId);d=Fa(h,p)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Gr()-u),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const g=this.pendingRead.get(e);return new Promise(y=>g.push(y))}const t=this.texData.get(e),{values:s,shape:i,slice:r,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(r!=null){let g;l?g=new Zc(i,jc):g=new ul(i,jc);const y=this.runWebGLProgram(g,[{dataId:e,shape:i,dtype:o}],o),x=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(ze().getBool("DEBUG")&&!ze().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ze().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&ze().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const g=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(g.texture.texture,...vv(i))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const g=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),y=g[0],x=g[1];d=Fa(y,x)}else if(c==null)d=this.getValuesFromTexture(e);else{const g=Le(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,g)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const g=this.gpgpu.gl;Qt(g,()=>g.deleteBuffer(c))}const h=this.convertAndCacheOnCPU(e,d),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(g=>g(h)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ao().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e,t={}){const s=this.texData.get(e),{values:i,shape:r,slice:o,dtype:a,isPacked:l,texture:c}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new Zc(r,jc):p=new ul(r,jc);const g=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:a}],a),y=this.readToGPU(g,t);return this.disposeIntermediateTensorInfo(g),y}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),d=Ao().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>$a(i));return Yn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Yn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!Sbe(s))throw ze().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:i}=this.texData.get(e),r=Le(t);if(ze().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(e),p=this.texData.get(h.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...vv(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(h),g}const o=ze().getBool("WEBGL_PACK")&&i===!0,a=o?bv(t):t,l=o?new O3e(a):new F3e(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),u=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const r=hc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=hc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);a.kernelMs=qO(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gr(),endMs:null}}endTimer(e){return ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Gr(),e)}async getQueryTime(e){if(ze().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:i,usage:r,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,i,r,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=xCe){return ze().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Le(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Ro("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return fCe(e.shape,t)}packedUnaryOp(e,t,s){const i=new Zc(e.shape,t),r=this.compileAndRun(i,[e],s);return Ao().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=L8(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(ze().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,GD,e.dtype);const t=new ul(e.shape,GD),s=this.compileAndRun(t,[e]);return Ao().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&Kf(s[0])){const r=s.map(o=>ac(o));i=this.write(r,e,t)}else i=this.write(s,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,s){return Ao().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new hCe(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new YSe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const s=[Ff(e.shape),...Of(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},r=[Ff(t),...Of(t)],o=new O8(r,s),a=!0,l=[s],c=this.runWebGLProgram(o,[i],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:i,shape:r,dtype:o}=s;if(t!=null){const h=Le(r),p=t[0]*t[1]*4;re(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=bv(r);let l;i?l=new $3e(a):l=new L3e(a);const c=!0,u=[t??vv(a)],d=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,t);return{dtype:o,shape:r,dataId:d.dataId}}runWebGLProgram(e,t,s,i,r=!1,o){const a=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Hg.DENSE){const v=o??vv(e.outputShape);l.texShape=v.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Le(a.shape)===0)return l.values=Qi(a.dtype,0),a;const c=[],u=t.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(v.dataId);if(b.texture==null){if(!e.packedInputs&&Le(v.shape)<=ze().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!b.isPacked!=!!e.packedInputs)v=b.isPacked?this.unpackTensor(v):this.packTensor(v),c.push(v),b=this.texData.get(v.dataId);else if(b.isPacked&&!O2(b.shape,v.shape)){const S=v,C=v.shape;v.shape=b.shape,v=this.packedReshape(v,C),c.push(v),b=this.texData.get(v.dataId),S.shape=C}return{shape:v.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},h=D3e(e,u,d),p=this.getAndSaveBinary(h,()=>N3e(this.gpgpu,e,u,d)),g=this.activeTimers!=null;let y;g&&(y=this.startTimer()),ze().get("ENGINE_COMPILE_ONLY")||P3e(this.gpgpu,p,u,d,i),c.forEach(v=>this.disposeIntermediateTensorInfo(v)),g&&(y=this.endTimer(y),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(y)}));const x=ze().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){const v=Gr();v-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!ze().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const v=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),v}return a}compileAndRun(e,t,s,i,r=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,i,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ze().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=je(()=>{if(!ze().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ze().getBool("DEBUG");ze().set("DEBUG",!1);const t=this.abs(Is(1e-8)).dataSync()[0];if(ze().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?pCe:mCe}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:i,values:r,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Gr());let d=t.texShape;if(d==null&&(d=Bbe(s,l),t.texShape=d),r!=null){const h=bv(s);let p,g=d[1],y=d[0];const x=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!x)&&([g,y]=Qp(d[0],d[1])),l?p=new B3e(h,x):p=new BD(h,x);const v=x?[y,g]:d,b=this.makeTensorInfo(v,i),S=this.texData.get(b.dataId);x?S.usage=No.PIXELS:S.usage=No.UPLOAD,S.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),g,y,r);const C=[[y,g]],k=this.runWebGLProgram(p,[b],i,C,!0),R=this.texData.get(k.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,ze().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=Gr()-u)}else{const h=this.acquireTexture(d,a,i,l);t.texture=h}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:i}=s;return t!=null&&(s.values=wCe(t,i)),s.values}acquireTexture(e,t,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*p2(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(r){throw r}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await E6(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(C8(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:s,infLoc:i,nanLoc:r,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=k8(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=r,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:i,height:r,width:o,channels:a}=e,l=Ao().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,s,r,o,a);return Ao().makeTensorFromDataId(c,t,s,l)}}Gw.nextDataId=0;function wCe(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */S5()&&yT("webgl",()=>new Gw,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $I=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let Dd=class{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Mn(t,s),this.enableShapeUniforms=Cr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zd=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class sm{constructor(e,t,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Mn(t,s);const r=this.outputShape.length;this.enableShapeUniforms=Cr(r);let o="";if(i)if(r===0||Le(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Fs(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=Dr("coords",r);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${l[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yo(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const bCe={kernelName:xp,backendName:"webgl",kernelFunc:yo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Su(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(r.dataId),a=yo({inputs:{x:s},backend:t}),l=yo({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},r}const SCe={kernelName:wy,backendName:"webgl",kernelFunc:Su};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z8="return (a < 0.) ? b * a : a;",B8=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function CCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s,o=t.makeTensorInfo([],"float32",mu(r,"float32")),a=ze().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sm(B8,i.shape,o.shape):new Dd(z8,i.shape,o.shape),l=t.runWebGLProgram(a,[i,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const _Ce={kernelName:A0,backendName:"webgl",kernelFunc:CCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U8="return (a < 0.) ? b * a : a;",V8=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ECe(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,r=ze().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sm(V8,s.shape,i.shape):new Dd(U8,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],"float32")}const TCe={kernelName:q0,backendName:"webgl",kernelFunc:ECe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const im="if (isnan(x)) return x;";function vs({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:i,backend:r})=>{const{x:o}=i,a=r,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const d=a.texData.get(o.dataId),h=t(d.values,l);return a.makeTensorInfo(o.shape,l,h)}const c=ze().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Zc(o.shape,e):u=new ul(o.shape,n),a.runWebGLProgram(u,[o],l)}}function hr({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:r}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(s&&l.dtype==="complex64"){const g=u.texData.get(l.dataId),y=u.texData.get(c.dataId),[x,v]=[[g.complexTensorInfos.real,y.complexTensorInfos.real],[g.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(S=>{const[C,E]=S,k={dataId:C.dataId,dtype:C.dtype,shape:l.shape},R={dataId:E.dataId,dtype:E.dtype,shape:c.shape},L=new Dd(n,l.shape,c.shape);return u.runWebGLProgram(L,[k,R],Ji(C.dtype,E.dtype))}),b=Su({inputs:{real:x,imag:v},backend:u});return u.disposeIntermediateTensorInfo(x),u.disposeIntermediateTensorInfo(v),b}const d=r||Ji(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&i!=null){const g=u.texData.get(l.dataId).values,y=u.texData.get(c.dataId).values,x=l.dtype==="string"?Oa(g):g,v=l.dtype==="string"?Oa(y):y,[b,S]=i(l.shape,c.shape,x,v,d),C=u.makeTensorInfo(S,d),E=u.texData.get(C.dataId);return E.values=b,C}const h=ze().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return h?p=new sm(e,l.shape,c.shape,t):p=new Dd(n,l.shape,c.shape),u.runWebGLProgram(p,[l,c],d)}}function jg(n,e=!1){if(n==="linear")return e?aCe:nCe;if(n==="relu")return e?cCe:iCe;if(n==="elu")return e?lCe:sCe;if(n==="relu6")return e?uCe:rCe;if(n==="prelu")return e?V8:U8;if(n==="leakyrelu")return e?B8:z8;if(n==="sigmoid")return e?dCe:oCe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let W8=class{constructor(e,t,s,i=!1,r=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Cr(this.outputShape.length);const u=i?e[1]:e[2],d=Math.ceil(u/2),h=i?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",g=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",v="";a&&(l?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:x=`vec4 activation(vec4 x) {
          ${a}
        }`,v="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let S="rc.x",C="rc.x";e[0]<t[0]?S=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(C=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${x}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${S};
        int batchB = ${C};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${y[0]});
          result += (${g[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${v}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let jD=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Mn(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XD="return a * b;";function FI(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,r=Ji(s.dtype,i.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(i.dataId),c=new jD(HD.REAL,s.shape,i.shape),u=new jD(HD.IMAG,s.shape,i.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],h=t.runWebGLProgram(c,d,"float32"),p=t.runWebGLProgram(u,d,"float32"),g=Su({inputs:{real:h,imag:p},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),g}if(t.shouldExecuteOnCPU([s,i])){const a=t.texData.get(s.dataId),l=t.texData.get(i.dataId),[c,u]=ESe(s.shape,i.shape,a.values,l.values,r),d=t.makeTensorInfo(u,r),h=t.texData.get(d.dataId);return h.values=c,d}let o;return ze().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new sm(XD,s.shape,i.shape):o=new Dd(XD,s.shape,i.shape),t.runWebGLProgram(o,[s,i],r)}const ICe={kernelName:Tp,backendName:"webgl",kernelFunc:FI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kCe(n,e,t){const s=[Ff(n.shape),...Of(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},r=[Ff(e),...Of(e)],o=new O8(r,s),a=!0,l=[s],c=t.runWebGLProgram(o,[i],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,o=t,a=Le(i.shape),l=KE(r,a),c=Le(l);re(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(i.dataId);return u.isPacked&&!O2(i.shape,l)&&!(u.texture!==null&&O2(u.shape,l))?kCe(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const ACe={kernelName:Y0,backendName:"webgl",kernelFunc:Xt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qD{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=e;this.outputShape=[i,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const d=1/t;c=`sumValue += dot(values * ${Af(d)?d.toPrecision(2):d}, ones);`}let u="";r%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RCe=class{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:o}=e;this.outputShape=[i,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(s/4)*4,d=s%4;let h=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let g="";r%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${c});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MCe(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=pw(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Qd(n,e,t,s){const i=MCe(n.shape);let r=n;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:l,outSize:c}=i[o];let u,d;t==="mean"?u=o===0?new qD({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new qD({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new RCe({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),d=r,r=s.runWebGLProgram(u,[r],e),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let NCe=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const i=Fs(this.rank),r=PCe(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function PCe(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let i=0;i<n.length;i++)s[n[i]]=t[i];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DCe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let u=0;u<s.length;u++)s[u]=e[t[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Fs(this.rank),r=F8("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=r[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${r[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e,t){const s=ze().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DCe(n.shape,e):new NCe(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LCe(n,e,t,s){const i=e,r=n.shape.length,o=Hn(i,n.shape);let a=o;const l=Os(a,r),c=l!=null;let u=n;c&&(u=Hw(n,l,s),a=Ys(a.length,r)),Ai("sum",a,r);const[d,h]=Ci(u.shape,a);let p=d;t&&(p=Si(d,o));const g=Le(h),x=Le(n.shape)/g,v=Xt({inputs:{x:u},attrs:{shape:[x,g]},backend:s}),b=Qy(n.dtype),S=Qd(v,b,"sum",s),C=Xt({inputs:{x:S},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(S),c&&s.disposeIntermediateTensorInfo(u),C}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return LCe(i,r,o,t)}const $Ce={kernelName:n1,backendName:"webgl",kernelFunc:jw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $r(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:r}=s,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[r[u]];let c;if(o.shouldExecuteOnCPU([i])){const d=o.texData.get(i.dataId).values,h=LI(d,i.shape,i.dtype,r,l);c=o.makeTensorInfo(l,i.dtype);const p=o.texData.get(c.dataId);p.values=h}else c=Hw(i,r,o);return c}const FCe={kernelName:fd,backendName:"webgl",kernelFunc:$r};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G8=1e3;function z2({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,d=t?n.shape[c-2]:n.shape[c-1],h=s?e.shape[u-1]:e.shape[u-2],p=t?n.shape[c-1]:n.shape[c-2],g=s?e.shape[u-2]:e.shape[u-1],y=n.shape.slice(0,-2),x=e.shape.slice(0,-2),v=Le(y),b=Le(x),C=Mn(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,g]);re(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[v,d,p]:[v,p,d],k=s?[b,g,h]:[b,h,g],R=Xt({inputs:{x:n},backend:i,attrs:{shape:E}}),L=Xt({inputs:{x:e},backend:i,attrs:{shape:k}}),I=[R,L],T=Math.max(v,b),M=t?R.shape[1]:R.shape[2],j=r!=null,W=o!=null,z=l==="leakyrelu",X=l!=null?jg(l,!0):null,B=j||W||z||X!=null;let J;if((p===1||g===1)&&M>G8&&B===!1){let ee=R,ne=L;t&&(ee=$r({inputs:{x:R},backend:i,attrs:{perm:[0,2,1]}}),I.push(ee)),s&&(ne=$r({inputs:{x:L},backend:i,attrs:{perm:[0,2,1]}}),I.push(ne));const V=g!==1,Z=g===1;let he=ee;V&&(he=Xt({inputs:{x:ee},backend:i,attrs:{shape:[T,M,1]}}),I.push(he));const ve=g===1?2:1;let be=ne;Z&&(be=Xt({inputs:{x:ne},backend:i,attrs:{shape:[T,1,M]}}),I.push(be));const Ie=FI({inputs:{a:he,b:be},backend:i});J=jw({inputs:{x:Ie},backend:i,attrs:{axis:ve,keepDims:!0}}),I.push(Ie)}else{const ee=Ji(n.dtype,e.dtype),ne=new W8(E,k,[T,p,g],t,s,j,X,W,z),V=[R,L];if(r!=null&&V.push(r),W&&V.push(o),z){const Z=i.makeTensorInfo([],"float32",mu(a,"float32"));V.push(Z),I.push(Z)}J=i.runWebGLProgram(ne,V,ee)}const K=Xt({inputs:{x:J},backend:i,attrs:{shape:C}});I.push(J);for(const ee of I)i.disposeIntermediateTensorInfo(ee);return K}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OCe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=s;return z2({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}const zCe={kernelName:Dg,backendName:"webgl",kernelFunc:OCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KD="return abs(x);";function BCe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const r=t.texData.get(s.dataId),o=L8(r.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let i;return ze().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Zc(s.shape,KD):i=new ul(s.shape,KD),t.runWebGLProgram(i,[s],s.dtype)}const UCe={kernelName:c0,backendName:"webgl",kernelFunc:BCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VCe=ca+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,WCe=vs({opSnippet:VCe}),GCe={kernelName:Zf,backendName:"webgl",kernelFunc:WCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HCe=ca+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,jCe=vs({opSnippet:HCe}),XCe={kernelName:Qf,backendName:"webgl",kernelFunc:jCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD="return a + b;",qCe=hr({opSnippet:YD,packedOpSnippet:YD,supportsComplex:!0,cpuKernelImpl:iSe}),KCe={kernelName:Bd,backendName:"webgl",kernelFunc:qCe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YCe{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZCe=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,o)=>`T${o}`);const s=[];this.variableNames.forEach(r=>{s.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hv(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return yo({inputs:{x:s[0]},backend:t});if(s.length>ze().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=Hv({inputs:s.slice(0,l),backend:t}),u=Hv({inputs:s.slice(l),backend:t});return Hv({inputs:[c,u],backend:t})}const i=s.map(l=>l.dtype).reduce((l,c)=>Ji(l,c)),r=s.map(l=>l.shape),a=ze().getBool("WEBGL_PACK")?new ZCe(s[0].shape,r):new YCe(s[0].shape,r);return t.runWebGLProgram(a,s,i)}const QCe={kernelName:py,backendName:"webgl",kernelFunc:Hv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JCe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Hn(r,i.shape);let c=l;const u=Os(c,a);let d=i;u!=null&&(d=$r({inputs:{x:i},backend:t,attrs:{perm:u}}),c=Ys(c.length,a)),Ai("all",c,a);const[h,p]=Ci(d.shape,c),g=Le(p),y=Xt({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),x=Qd(y,y.dtype,"all",t);let v;if(o){const b=Si(h,l);v=Xt({inputs:{x},backend:t,attrs:{shape:b}})}else v=Xt({inputs:{x},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),u!=null&&t.disposeIntermediateTensorInfo(d),v}const e_e={kernelName:my,backendName:"webgl",kernelFunc:JCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Hn(r,i.shape);let c=l;const u=Os(c,a);let d=i;u!=null&&(d=$r({inputs:{x:i},backend:t,attrs:{perm:u}}),c=Ys(c.length,a)),Ai("any",c,a);const[h,p]=Ci(d.shape,c),g=Le(p),y=Xt({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),x=Qd(y,y.dtype,"any",t);let v;if(o){const b=Si(h,l);v=Xt({inputs:{x},backend:t,attrs:{shape:b}})}else v=Xt({inputs:{x},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),u!=null&&t.disposeIntermediateTensorInfo(d),v}const n_e={kernelName:gy,backendName:"webgl",kernelFunc:t_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let s_e=class{constructor(e,t,s){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[r,o];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i_e{constructor(e,t,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,re(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const r=e[e.length-1],o=Math.ceil(r/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Fs(l),u=Dr("coords",l);let d,h;if(o===1){h=l+1;const L=Fs(h);d=`
        ${L} sourceLocR = ${L}(${u.join()}, 0);
        ++${u[l-1]};
        ${L} sourceLocG = ${L}(${u.join()}, 0);
        ++${u[l-2]};
        ${L} sourceLocA = ${L}(${u.join()}, 0);
        --${u[l-1]};
        ${L} sourceLocB = ${L}(${u.join()}, 0);
        --${u[l-2]};`}else h=l,d=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),g="."+p[h-1],y=p.map(L=>"int "+L),x=Dr("sourceLocR",h-1).concat("inIdx.r"),v=Dr("sourceLocG",h-1).concat("inIdx.g"),b=Dr("sourceLocB",h-1).concat("inIdx.b"),S=Dr("sourceLocA",h-1).concat("inIdx.a"),C=s==="max"?"greaterThan":"lessThan",E=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${S.join()})));`,k=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,R=i?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(n,e,t,s=null){let i=e.shape[0],r=e.shape[1];s!=null&&(i=s.shape[0],r=s.shape[1]);const o=pw(r),a={windowSize:o,inSize:r,batchSize:i,outSize:Math.ceil(r/o)},l=new s_e(a,t,s==null),c=[e];s!=null&&c.push(s);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const d=H8(n,e,t,u);return n.disposeIntermediateTensorInfo(u),d}function j8(n,e,t,s=null){const i=s!=null?s.shape:e.shape,r=i[i.length-1],o=pw(r),a=new i_e(i,o,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=j8(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function X8(n,e,t,s){const i=[t];if(Ai("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,e.shape.length),!ze().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const r=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),r.push(l));const[c,u]=Ci(l.shape,i),d=Le(u),h=Xt({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});r.push(h);const p=H8(n,h,s);r.push(p);const g=Xt({inputs:{x:p},backend:n,attrs:{shape:c}});return r.forEach(y=>n.disposeIntermediateTensorInfo(y)),g}return j8(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Hn(r,i.shape);const a=Os(o,i.shape.length);let l=i;const c=[];a!=null&&(l=$r({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Ys(o.length,l.shape.length)),Ai("argMax",[o[0]],l.shape.length);const u=X8(t,l,o[0],"max");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),u}const o_e={kernelName:u0,backendName:"webgl",kernelFunc:r_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Hn(r,i.shape);const a=Os(o,i.shape.length);let l=i;const c=[];a!=null&&(l=$r({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Ys(o.length,l.shape.length)),Ai("argMin",[o[0]],l.shape.length);const u=X8(t,l,o[0],"min");return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),u}const l_e={kernelName:d0,backendName:"webgl",kernelFunc:a_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c_e=ca+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,u_e=vs({opSnippet:c_e}),d_e={kernelName:Jf,backendName:"webgl",kernelFunc:u_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h_e=ca+"return log(x + sqrt(x * x + 1.0));",f_e=vs({opSnippet:h_e}),p_e={kernelName:ep,backendName:"webgl",kernelFunc:f_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_e=ca+`
  return atan(x);
`,g_e=vs({opSnippet:m_e}),x_e={kernelName:tp,backendName:"webgl",kernelFunc:g_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v_e=$I+`
  return atan(a, b);
`,y_e=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Zd+`
  return result;
`,w_e=hr({opSnippet:v_e,packedOpSnippet:y_e}),b_e={kernelName:sp,backendName:"webgl",kernelFunc:w_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S_e=ca+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,C_e=vs({opSnippet:S_e}),__e={kernelName:np,backendName:"webgl",kernelFunc:C_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Xg=class{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const y=t==="avg",x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(y||(b="-1.0 / 1e-20"),s){const L=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${L} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?x:v:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(C="avgValue / max(count, 1.0)");const E=Math.floor(o/4)*4,k=o%4,R=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${g});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${E};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${C});
      }
    `}},OI=class{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,p=e.effectiveFilterDepth,g=e.effectiveFilterHeight,y=e.effectiveFilterWidth,x=e.padInfo.front,v=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const S=t==="avg";let C="0.0";if(S||(C="-1.0 / 1e-20"),s){const T=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${x}, ${v}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${T} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / max(count, 1.0)");const R=Math.floor(o/4)*4,L=o%4,I=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${x}, ${v}, ${b});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${I}
            }

            int xC = xCCorner + ${R};
            if (${L===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${L===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${L===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${I}
            }
          }
        }
        setOutput(${k});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;T1(i,"avgPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;re(er(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=br(i.shape,r,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&ds(u.inShape,u.outShape))return yo({inputs:{x:i},backend:t});const d=new Xg(u,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const T_e={kernelName:h0,backendName:"webgl",kernelFunc:E_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,u=[1,1,1],d=Fo(i.shape,r,o,u,a,l,c),h=new OI(d,"avg",!1);return t.runWebGLProgram(h,[i],"float32")}const k_e={kernelName:f0,backendName:"webgl",kernelFunc:I_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let A_e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,d=c-1-e.padInfo.left,h=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${d});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},R_e=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=d-1-e.padInfo.front,y=h-1-e.padInfo.top,x=p-1-e.padInfo.left,v=1/(t*s*i);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${y}, ${x});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,d=[1,1,1],h=Fo(o.shape,a,l,d,c,u),p=new R_e(h);return t.runWebGLProgram(p,[i],o.dtype)}const N_e={kernelName:vy,backendName:"webgl",kernelFunc:M_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;T1([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=br(o.shape,a,l,1,c),d=new A_e(u);return t.runWebGLProgram(d,[i],o.dtype)}const D_e={kernelName:xy,backendName:"webgl",kernelFunc:P_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_e(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;return z2({a:i,b:r,transposeA:o,transposeB:a,backend:t})}const $_e={kernelName:p0,backendName:"webgl",kernelFunc:L_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let F_e=class{constructor(e,t,s,i,r,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Mn(e,t),Mn(e,s);let a="0.0";i!=null&&(Mn(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";r!=null&&(Mn(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O_e{constructor(e,t,s,i,r,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Mn(e,t),Mn(e,s);let a="vec4(0.0)";i!=null&&(Mn(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";r!=null&&(Mn(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_e=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:i,variance:r,offset:o,scale:a}=n;re(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),re(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),re(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,i,r];let u=null;o!=null&&(u=o.shape,c.push(o));let d=null;a!=null&&(d=a.shape,c.push(a));const h=ze().getBool("WEBGL_PACK_NORMALIZATION")?new O_e(s.shape,i.shape,r.shape,u,d,l):new F_e(s.shape,i.shape,r.shape,u,d,l);return e.runWebGLProgram(h,c,c[0].dtype)},B_e={kernelName:T0,backendName:"webgl",kernelFunc:z_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U_e=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Fs(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=V_e(this.rank);let i;const r=e.map((o,a)=>`sourceLoc.${R_[a]} = start[${a}] + coords.${R_[a]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}};const R_=["x","y","z","w","u","v"];function V_e(n){if(n===1)return"sourceLoc";if(n<=6)return R_.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W_e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Fs(this.rank),s=Dr("coords",this.rank),i=Dr("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${r})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,d)=>`start[${d}]`).join()});`:e.map((u,d)=>`${i[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_e(n,e,t,s){const i=s.texData.get(n.dataId),r=s.makeTensorInfo(t,n.dtype),o=s.texData.get(r.dataId);Object.assign(o,i),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=YT(e,gn(n.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),r}function rm(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s,[a,l]=f1(i,r,o);if(uw(i,a,l),Le(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const d=t.texData.get(i.dataId),h=$Se(d.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,h)}const{isPacked:c}=t.texData.get(i.dataId),u=KT(i.shape,a,l);if(c||!u){const d=ze().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new W_e(l):new U_e(l),h=[a];return t.runWebGLProgram(d,[i],i.dtype,h)}return t.uploadToGPU(i.dataId),G_e(i,a,l,t)}const H_e={kernelName:t1,backendName:"webgl",kernelFunc:rm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j_e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;re(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=r.reduce((b,S)=>b*S),l=Gd(i.shape,r,a),c=Hd(l.length,r.length),u=jd(i.shape,r,a),d=gw(o,r.length),h=xw(u,o,r.length),p=[],g=Xt({inputs:{x:i},backend:t,attrs:{shape:l}}),y=$r({inputs:{x:g},backend:t,attrs:{perm:c}}),x=Xt({inputs:{x:y},backend:t,attrs:{shape:u}}),v=rm({inputs:{x},backend:t,attrs:{begin:d,size:h}});return p.push(g),p.push(y),p.push(x),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),v},X_e={kernelName:m0,backendName:"webgl",kernelFunc:j_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q_e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=t.readSync(i.dataId),l=t.readSync(r.dataId),c=D8(a,l,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,c)}const K_e={kernelName:yy,backendName:"webgl",kernelFunc:q_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y_e=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Z_e=`
  return float(int(a.r) & int(b.r));
`;function Q_e(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,r=ze().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=ze().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([s,i])||o===1){const l=t.texData.get(s.dataId).values,c=t.texData.get(i.dataId).values,[u,d]=oSe(s.shape,i.shape,l,c,s.dtype),h=t.makeTensorInfo(d,s.dtype),p=t.texData.get(h.dataId);return p.values=u,h}let a;return r?a=new sm(Y_e,s.shape,i.shape,!1):a=new Dd(Z_e,s.shape,i.shape),t.runWebGLProgram(a,[s,i],s.dtype)}const J_e={kernelName:eT,backendName:"webgl",kernelFunc:Q_e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eEe(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.readSync(s.dataId),o=t.readSync(i.dataId),a=Mn(Array.from(r),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const tEe={kernelName:tT,backendName:"webgl",kernelFunc:eEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nEe="return float(a != b);",q8=hr({opSnippet:nEe,cpuKernelImpl:ISe,dtype:"bool"}),sEe={kernelName:W0,backendName:"webgl",kernelFunc:q8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return yo({inputs:{x:i.complexTensorInfos.real},backend:t})}const iEe={kernelName:Wy,backendName:"webgl",kernelFunc:k1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rEe="return float(int(x));";function oEe(n,e){const t=new ul(n.shape,rEe),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return yo({inputs:{x:i},backend:t});const o=Oi(i.shape),a=M_({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Su({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(i.dtype==="complex64"){const o=k1({inputs:{input:i},backend:t}),a=M_({inputs:{x:o},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(o),a}if(!YE(i.dtype,r)){const o=yo({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const o=t.texData.get(i.dataId).values,[a,l,c]=aSe(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}if(r==="int32")return oEe(i,t);if(r==="bool"){const o=t.makeTensorInfo([],"bool",Qi("bool",1)),l=q8({inputs:{a:i,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const aEe={kernelName:ip,backendName:"webgl",kernelFunc:M_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD="return ceil(x);",lEe=vs({opSnippet:ZD,packedOpSnippet:ZD,cpuKernelImpl:lSe}),cEe={kernelName:rp,backendName:"webgl",kernelFunc:lEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uEe=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dEe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hEe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:r,clipValueMax:o}=s;let a;ze().getBool("WEBGL_PACK_CLIP")?a=new dEe(i.shape):a=new uEe(i.shape);const l=[[r],[o]];return t.runWebGLProgram(a,[i],i.dtype,l)}const fEe={kernelName:op,backendName:"webgl",kernelFunc:hEe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pEe=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QD(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function mEe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.texData.get(s.dataId),r=new pEe(s.shape),o=[QD(s,i.complexTensorInfos.real),QD(s,i.complexTensorInfos.imag)];return t.runWebGLProgram(r,o,o[0].dtype)}const gEe={kernelName:g0,backendName:"webgl",kernelFunc:mEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xEe=class{constructor(e){this.outputShape=[],this.outputShape=Zr(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const i=t.length,r=t[t.length-1];s.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vEe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Zr(e,t);const s=this.outputShape,i=s.length,r=Fs(i),o=Dr("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((y,x)=>`T${x}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let y=1;y<l.length;y++)l[y]=l[y-1]+e[y][t];const c=a[t],u=a.slice(-2),d=a.join();let h=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${u.join()}));
        }`;for(let y=1;y<l.length;y++){const x=l[y-1];h+=`
        if (${c} < ${l[y]}  && ${c} >= ${l[y-1]}) {
          return getChannel(
            getT${y}(${_v(a,c,x)}),
            vec2(${_v(u,c,x)}));
        }`}const p=l.length,g=l[l.length-1];h+=`
        return getChannel(
          getT${p}(${_v(a,c,g)}),
          vec2(${_v(u,c,g)}));`,this.userCode=`
      float getValue(${a.map(y=>"int "+y)}) {
        ${h}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${s[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${s[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${s[i-2]} &&
            ${o[i-1]} < ${s[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function _v(n,e,t){const s=n.indexOf(e);return n.map((r,o)=>o===s?`${r} - ${t}`:r).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return yo({inputs:{x:i.complexTensorInfos.imag},backend:t})}const yEe={kernelName:$y,backendName:"webgl",kernelFunc:Xw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lg(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(b=>k1({inputs:{input:b},backend:t})),g=n.map(b=>Xw({inputs:{input:b},backend:t})),y=lg(p,e,t),x=lg(g,e,t),v=Su({inputs:{real:y,imag:x},backend:t});return p.forEach(b=>t.disposeIntermediateTensorInfo(b)),g.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),v}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const p=n.map(C=>{const k=[-1,Le(C.shape.slice(e))];return Xt({inputs:{x:C},backend:t,attrs:{shape:k}})}),g=p.map(C=>({vals:t.readSync(C.dataId),shape:C.shape})),y=Zr(p.map(C=>C.shape),1),x=p[0].shape[0]===1,v=cSe(g,y,s,x),b=Zr(n.map(C=>C.shape),e),S=t.makeTensorInfo(b,s,v);return p.forEach(C=>t.disposeIntermediateTensorInfo(C)),S}const r=n.filter(p=>Le(p.shape)>0),o=ze().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const p=o?new ul(n[0].shape,jc):new Zc(n[0].shape,jc);return t.runWebGLProgram(p,n,s)}const a=ze().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>a){const p=[];for(let y=0;y<r.length;y+=a){const x=r.slice(y,y+a);p.push(lg(x,e,t))}const g=lg(p,e,t);for(const y of p)t.disposeIntermediateTensorInfo(y);return g}if(o){const p=new vEe(r.map(g=>g.shape),e);return t.runWebGLProgram(p,r,s)}const{tensors2D:l,outShape:c}=wEe(r,e,t),u=new xEe(l.map(p=>p.shape)),d=t.runWebGLProgram(u,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const h=Xt({inputs:{x:d},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(d),h}function wEe(n,e,t){const s=Zr(n.map(r=>r.shape),e);return{tensors2D:n.map(r=>Xt({inputs:{x:r},attrs:{shape:[-1,Le(r.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K8(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Hn(i,e[0].shape)[0],o=e.map(c=>c.shape);fw(o,r);const a=Zr(e.map(c=>c.shape),r);if(Le(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Le(c.shape)>0);return l.length===1?yo({inputs:{x:l[0]},backend:t}):lg(l,r,t)}const bEe={kernelName:x0,backendName:"webgl",kernelFunc:K8};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y8{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,p=e.filterWidth,g=Math.floor(e.inChannels/4)*4,y=e.inChannels%4,x=e.dataFormat==="channelsLast",v=x?1:2,b=x?2:3,S=x?3:1;let C="",E="";s&&(i?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:C=`
          float activation(float x) {
            ${s}
          }
        `,E="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${x}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y===1}) {

              if (${x}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${y===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${x}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${x}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${E}
        setOutput(result);
      }
    `}}class SEe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,h=e.filterHeight,p=e.filterWidth,g=Math.floor(e.inChannels/4)*4,y=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${y===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z8{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Cr(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,d=u;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<u;x++)h+=`
           vec4 xTexelC${x*2};
           int xTexelC${x*2}Ready;
           vec4 xTexelC${x*2+1};
           int xTexelC${x*2+1}Ready;
           vec4 xC${x};`;h+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let x=0;x<u;x++)h+=`
           xTexelC${x*2} = vec4(0.0);
           xTexelC${x*2}Ready = 0;
           xTexelC${x*2+1} = vec4(0.0);
           xTexelC${x*2+1}Ready = 0;
           xC${x} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let x=0;x<(d+1)/2;x++){const v=x*2;if(h+=`
           xC = xCCorner + ${v*l};
           `,a===1){if(v<u&&(o%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,l===1&&v>0?h+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<u)){const b=o%2===0?qE(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,l>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:h+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):b===1?h+=`
                     xC${v+1} = xTexelC${v};
                     `:h+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<u&&(o%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<u&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<u&&(h+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<u&&(h+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<u&&(h+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",g="";s&&(i?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:r?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,g="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${g}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CEe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Cr(this.outputShape.length);const{dataFormat:s}=t,i=Fr(),r=s==="channelsLast",o=r?1:2,a=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function Q8({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=s.texData.get(n.dataId),u=t.inChannels,d=l[0]*l[1]*l[2],h=t.outChannels,p=t.dataFormat==="channelsLast",g=!1,y=!1;let x;const v=[];if(r!=null){const C=B2(r.shape,p);C!=null&&(r=Xt({inputs:{x:r},backend:s,attrs:{shape:C}}),v.push(r))}if(i!=null){const C=B2(i.shape,p);C!=null&&(i=Xt({inputs:{x:i},backend:s,attrs:{shape:C}}),v.push(i))}if(!((d===1||h===1)&&u>G8)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!==0&&ds(c.shape.slice(-3),l.slice(-3))){const C=l[0]*l[1]*(l[2]+1),E={dataId:n.dataId,shape:[1,C,t.inChannels],dtype:n.dtype},k=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,re(O2(c.shape,E.shape),()=>`packed reshape ${c.shape} to ${E.shape} isn't free`);const R=Xt({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});v.push(R);const L=z2({a:E,b:R,backend:s,transposeA:g,transposeB:y,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),I=s.texData.get(L.dataId);re(I.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=k,I.shape=t.outShape,x=yo({inputs:{x:L},backend:s}),x.shape=t.outShape,v.push(L)}else{const C=t.outHeight*t.outWidth,E=Xt({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,C,t.inChannels]:[t.batchSize,t.inChannels,C]}}),k=Xt({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),R=z2({a:p?E:k,b:p?k:E,transposeA:!p,transposeB:y,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o});x=Xt({inputs:{x:R},backend:s,attrs:{shape:t.outShape}}),v.push(E),v.push(k),v.push(R)}for(const C of v)s.disposeIntermediateTensorInfo(C);return x}function J8({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:h,dataFormat:p}=t,g=p==="channelsLast",y=l*c*u,x=h*d,v=[t.batchSize,y,x],b=!0,S=!1,C=[];if(r!=null){const K=B2(r.shape,g);K!=null&&(r=Xt({inputs:{x:r},backend:s,attrs:{shape:K}}),C.push(r))}if(i!=null){const K=B2(i.shape,g);K!=null&&(i=Xt({inputs:{x:i},backend:s,attrs:{shape:K}}),C.push(i))}const E=Xt({inputs:{x:e},backend:s,attrs:{shape:[1,y,Le(e.shape)/y]}});C.push(E);const k=new CEe(v,t),R=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],L=s.runWebGLProgram(k,[n],"float32",R),I=Xt({inputs:{x:L},backend:s,attrs:{shape:v}});C.push(L),C.push(I);const T=i!=null,M=r!=null,j=a==="leakyrelu",W=a?jg(a,!0):null,z=new W8(g?I.shape:E.shape,g?E.shape:I.shape,g?[t.batchSize,x,t.outChannels]:[t.batchSize,t.outChannels,x],b,S,T,W,M,j),X=g?[I,E]:[E,I];if(i&&X.push(i),M&&X.push(r),j){const K=s.makeTensorInfo([],"float32",mu(o,"float32"));X.push(K),C.push(K)}const B=s.runWebGLProgram(z,X,"float32"),J=Xt({inputs:{x:B},backend:s,attrs:{shape:t.outShape}});C.push(B);for(const K of C)s.disposeIntermediateTensorInfo(K);return J}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ee(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s,d=bo(l),h=Js(i.shape,r.shape,o,c,a,u,!1,d);let p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=Q8({x:i,filter:r,convInfo:h,backend:t});else if(h.strideWidth<=2&&d==="channelsLast"&&ze().getBool("WEBGL_EXP_CONV")){const y=new Z8(h),x=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=t.runWebGLProgram(y,[i,r],"float32",x)}else if(ze().getBool("WEBGL_CONV_IM2COL"))p=J8({x:i,filter:r,convInfo:h,backend:t});else{const y=new Y8(h);p=t.runWebGLProgram(y,[i,r],"float32")}const g=Xt({inputs:{x:p},backend:t,attrs:{shape:h.outShape}});return t.disposeIntermediateTensorInfo(p),g}const EEe={kernelName:v0,backendName:"webgl",kernelFunc:_Ee};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TEe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},IEe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=o?1:2,u=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},kEe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},AEe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function REe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,d=bo(l),h=Js(i.shape,u,o,1,a,c,!1,d),p=new TEe(h);return t.runWebGLProgram(p,[i,r],"float32")}const MEe={kernelName:by,backendName:"webgl",kernelFunc:REe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NEe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Cr(this.outputShape.length);const t=e.filterHeight,s=e.filterWidth,i=t-1-e.padInfo.top,r=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PEe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,d=bo(c),h=Js(o,r.shape,a,1,l,u,!1,d);if(ze().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const p=[[h.strideHeight,h.strideWidth]],g=new NEe(h);return t.runWebGLProgram(g,[i,r],"float32",p)}else{const p=new IEe(h);return t.runWebGLProgram(p,[i,r],"float32")}}const DEe={kernelName:y0,backendName:"webgl",kernelFunc:PEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LEe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=Wa(i.shape,r.shape,o,l,a),u=new SEe(c);return t.runWebGLProgram(u,[i,r],"float32")}const $Ee={kernelName:w0,backendName:"webgl",kernelFunc:LEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FEe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s,c=Wa(i.shape,l,o,1,a),u=new kEe(c);return t.runWebGLProgram(u,[i,r],"float32")}const OEe={kernelName:Sy,backendName:"webgl",kernelFunc:FEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zEe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:o,strides:a,inputShape:l}=s,c=Wa(l,r.shape,a,1,o),u=new AEe(c);return t.runWebGLProgram(u,[i,r],"float32")}const BEe={kernelName:Cy,backendName:"webgl",kernelFunc:zEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UEe=im+`
  return cos(x);
`,VEe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Zd}
  return result;
`,WEe=vs({opSnippet:UEe,packedOpSnippet:VEe}),GEe={kernelName:ap,backendName:"webgl",kernelFunc:WEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HEe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,jEe=vs({opSnippet:HEe}),XEe={kernelName:lp,backendName:"webgl",kernelFunc:jEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qEe=class{constructor(e,t,s,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[d,h]=s;this.outputShape=[u,d,h,c];const p=i==="bilinear"?1:0,[g,y]=[`${a-1}.0`,`${l-1}.0`],[x,v,b]=d>1?[`${(a-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[S,C,E]=h>1?[`${(l-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`
      const float height_ratio = float(${x});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${C};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KEe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,u=new qEe(i.shape,r.shape,a,l,c);return t.runWebGLProgram(u,[i,r,o],"float32")},YEe={kernelName:Ey,backendName:"webgl",kernelFunc:KEe};var qg;(function(n){n.Prod="*",n.Sum="+"})(qg||(qg={}));let JD=class{constructor(e,t,s,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,o=this.op===qg.Prod?"1.0":"0.0",a=s?o:`getX(${eL(r,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";s?(c=i?`end != ${l-1}`:"end != 0",u=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Fs(r)} coords = getOutputCoords();
        int end = ${tL(r,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${tL(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${eL(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function eL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function tL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV(n,e,t,s,i,r){const o=e.shape.length,a=Os([s],o);let l=e;a!=null&&(l=$r({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=Ys(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const u=l.shape[c];let d=yo({inputs:{x:l},backend:t});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const p=new JD(n,l.shape,!1,r),g=[[h]],y=d;d=t.runWebGLProgram(p,[d],d.dtype,g),t.disposeIntermediateTensorInfo(y)}if(i){const h=new JD(n,l.shape,i,r),p=d;d=t.runWebGLProgram(h,[d],d.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const h=Nl(a),p=$r({inputs:{x:d},backend:t,attrs:{perm:h}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(l),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZEe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return eV(qg.Prod,i,t,r,o,a)}const QEe={kernelName:_y,backendName:"webgl",kernelFunc:ZEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JEe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return eV(qg.Sum,i,t,r,o,a)}const eTe={kernelName:b0,backendName:"webgl",kernelFunc:JEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s;if(i.shape.length===1){const l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=D8(l,c,r.dtype,r.shape,o);return t.makeTensorInfo([o],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=rSe(l,c,o,a);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const nTe={kernelName:Ty,backendName:"webgl",kernelFunc:tTe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sTe=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],d=l*r,h=c*r,p=u/(r*r),g=o==="NHWC"?[a,d,h,p]:[a,p,d,h],y=new sTe(g,r,o);return t.runWebGLProgram(y,[i],i.dtype)}const rTe={kernelName:Iy,backendName:"webgl",kernelFunc:iTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tV=class{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Cr(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,u="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${u}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nV{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Cr(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,h=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)p+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let v=0;v<d;v++)p+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(h+1)/2;v++){const b=v*2;if(p+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<d&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<d)){const S=a%2===0?qE(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):S===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<d&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<d&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<d&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<d&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let g="",y="";s&&(i?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:g=`vec4 activation(vec4 x) {
          ${s}
        }`,y="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${x}
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let u=l;u==null&&(u=[1,1]),re(er(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=Js(i.shape,r.shape,o,u,a,c,!0);let h;ze().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new nV(d):h=new tV(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(h,[i,r],"float32",p)}const aTe={kernelName:S0,backendName:"webgl",kernelFunc:oTe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let lTe=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},cTe=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s,d=Js(i.shape,u,o,a,l,c,!0),h=new lTe(d);return t.runWebGLProgram(h,[i,r],"float32")}const dTe={kernelName:ky,backendName:"webgl",kernelFunc:uTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s,d=Js(u,r.shape,o,a,l,c,!0),h=new cTe(d);return t.runWebGLProgram(h,[i,r],"float32")}const fTe={kernelName:Ay,backendName:"webgl",kernelFunc:hTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pTe=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mTe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],r=Le(s.shape),o=Xt({inputs:{x:s},backend:t,attrs:{shape:[r]}}),a=new pTe(r),l=t.runWebGLProgram(a,[o],o.dtype),c=Xt({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const gTe={kernelName:nT,backendName:"webgl",kernelFunc:mTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let xTe=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:i,strideHeight:r,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:d,left:h}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${o});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vTe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=gu(i.shape,r.shape,o,a,"NHWC",l);let u;const d=new xTe(c);u=t.runWebGLProgram(d,[i,r],"float32");const h=Xt({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),h}const yTe={kernelName:C0,backendName:"webgl",kernelFunc:vTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wTe(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=_w(i,r.length);Tw(o.length,l,r);const{path:c,steps:u}=Iw(a,l),d=u.length;let h=null,p=o.length;const g=[];for(let y=0;y<d;++y){for(const x of u[y]){const{permutationIndices:v,expandDims:b}=Ew(p,l[x]);let S;kw(v)?S=r[x]:(S=$r({inputs:{x:r[x]},backend:t,attrs:{perm:v}}),g.push(S));const C=S.shape.slice();for(let E=0;E<b.length;++E)C.splice(b[E],0,1);ds(S.shape,C)||(S=Xt({inputs:{x:S},backend:t,attrs:{shape:C}}),g.push(S)),h===null?h=S:(h=FI({inputs:{a:S,b:h},backend:t}),g.push(h))}y<d-1&&(c[y]>=0&&(h=jw({inputs:{x:h},backend:t,attrs:{axis:c[y]-(o.length-p),keepDims:!1}}),g.push(h)),p--)}for(const y of g)y!==h&&t.disposeIntermediateTensorInfo(y);return h}const bTe={kernelName:Ry,backendName:"webgl",kernelFunc:wTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const STe="return (x >= 0.0) ? x : (exp(x) - 1.0);",CTe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,_Te=vs({opSnippet:STe,packedOpSnippet:CTe}),ETe={kernelName:up,backendName:"webgl",kernelFunc:_Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TTe="return (b >= 0.0) ? a : a * (b + 1.0);",ITe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,kTe=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,r=ze().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new sm(ITe,s.shape,i.shape):new Dd(TTe,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],s.dtype)},ATe={kernelName:My,backendName:"webgl",kernelFunc:kTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RTe=`
  return vec4(equal(a, b));
`,MTe="return float(a == b);",NTe=hr({opSnippet:MTe,packedOpSnippet:RTe,dtype:"bool",cpuKernelImpl:uSe}),PTe={kernelName:_0,backendName:"webgl",kernelFunc:NTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DTe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${vw};
  float a1 = ${yw};
  float a2 = ${ww};
  float a3 = ${bw};
  float a4 = ${Sw};
  float a5 = ${Cw};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,LTe=vs({opSnippet:DTe}),$Te={kernelName:dp,backendName:"webgl",kernelFunc:LTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FTe=im+`
  return exp(x);
`,OTe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sV=vs({opSnippet:FTe,packedOpSnippet:OTe,cpuKernelImpl:dSe,dtype:"float32"}),zTe={kernelName:hp,backendName:"webgl",kernelFunc:sV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:r}=e,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(re(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),Xt({inputs:{x:r},backend:s,attrs:{shape:a}})}const BTe={kernelName:E0,backendName:"webgl",kernelFunc:N_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL="return exp(x) - 1.0;",UTe=vs({opSnippet:nL,packedOpSnippet:nL,cpuKernelImpl:hSe}),VTe={kernelName:fp,backendName:"webgl",kernelFunc:UTe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sL=class{constructor(e,t,s){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const r=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${i}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iV(n,e,t){const s=t.texData.get(n.dataId),i=Le(n.shape),r=n.shape[n.shape.length-1],o=i/r,a=Xt({inputs:{x:n},backend:t,attrs:{shape:[o,r]}}),l=a.shape,c=new sL("real",l,e),u=new sL("imag",l,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],h=t.runWebGLProgram(c,d,"float32"),p=t.runWebGLProgram(u,d,"float32"),g=Su({inputs:{real:h,imag:p},backend:t});t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p);const y=Xt({inputs:{x:g},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(g),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(n){const{inputs:e,backend:t}=n,{input:s}=e;return iV(s,!1,t)}const GTe={kernelName:Ny,backendName:"webgl",kernelFunc:WTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let HTe=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:r}=t;if(r=r||zd(i),r==="string"){const o=fi(r,Le(s));return o.fill(i),e.makeTensorInfo(s,r,o)}else{const o=new HTe(s,i),a=[[i]];return e.runWebGLProgram(o,[],r,a)}}const jTe={kernelName:Py,backendName:"webgl",kernelFunc:A1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let XTe=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qTe={kernelName:Dy,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new XTe(t.shape);return s.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL="return floor(x);",KTe=vs({opSnippet:iL,packedOpSnippet:iL,cpuKernelImpl:fSe}),YTe={kernelName:pp,backendName:"webgl",kernelFunc:KTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZTe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,QTe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,JTe=hr({opSnippet:ZTe,packedOpSnippet:QTe,dtype:"int32"}),eIe={kernelName:mp,backendName:"webgl",kernelFunc:JTe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tIe=class{constructor(e){this.variableNames=["A"];const t=Fr(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nIe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Fr(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sIe={kernelName:l5,backendName:"webgl",kernelFunc:iIe};let jh,lC=ze().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function iIe(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:r}=s,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],d=[c,l,r];if(a||o){const y=ze().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(jh==null||y!==lC)&&(lC=y,jh=document.createElement("canvas").getContext("2d",{willReadFrequently:lC})),jh.canvas.width=l,jh.canvas.height=c,jh.drawImage(i,0,0,l,c),i=jh.canvas}const h=t.makeTensorInfo(u,"int32");t.texData.get(h.dataId).usage=No.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(h.dataId),i);const p=ze().getBool("WEBGL_PACK")?new nIe(d):new tIe(d),g=t.runWebGLProgram(p,[h],"int32");return t.disposeData(h.dataId),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:g}=s,y=bo(u),x=Js(i.shape,r.shape,l,d,c,h,!1,y);let v;const b=[],S=o!=null,C=a!=null,E=p==="leakyrelu",k=()=>{const L=[i,r],I=(T,M)=>{if(M==="NCHW"&&T.shape.length===1&&T.shape[0]!==1){const j=Xt({inputs:{x:T},backend:t,attrs:{shape:[T.shape[0],1,1]}});return b.push(j),j}return T};if(S&&L.push(I(o,u)),C&&L.push(I(a,u)),E){const T=t.makeTensorInfo([],"float32",mu(g,"float32"));L.push(T),b.push(T)}return L};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))v=Q8({x:i,filter:r,convInfo:x,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:g});else if(x.strideWidth<=2&&y==="channelsLast"&&ze().getBool("WEBGL_EXP_CONV")){const L=p?jg(p,!0):null,I=new Z8(x,S,L,C,E),T=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],M=k();v=t.runWebGLProgram(I,M,"float32",T)}else if(ze().getBool("WEBGL_CONV_IM2COL"))v=J8({x:i,filter:r,convInfo:x,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:g});else{const L=p?jg(p,!1):null,I=new Y8(x,S,L,C,E),T=k();v=t.runWebGLProgram(I,T,"float32")}const R=Xt({inputs:{x:v},backend:t,attrs:{shape:x.outShape}});return b.push(v),b.forEach(L=>t.disposeIntermediateTensorInfo(L)),R}const oIe={kernelName:Lg,backendName:"webgl",kernelFunc:rIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aIe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=s,g=[];let y=u;y==null&&(y=[1,1]),re(er(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const x=Js(i.shape,r.shape,l,y,c,d,!0),v=ze().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,b=h?jg(h,v):null,S=[i,r],C=o!=null,E=a!=null,k=h==="leakyrelu";if(C&&S.push(o),E&&S.push(a),k){const T=t.makeTensorInfo([],"float32",mu(p,"float32"));S.push(T),g.push(T)}let R;v?R=new nV(x,C,b,E,k):R=new tV(x,C,b,E,k);const L=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],I=t.runWebGLProgram(R,S,"float32",L);return g.forEach(T=>t.disposeIntermediateTensorInfo(T)),I}const lIe={kernelName:xT,backendName:"webgl",kernelFunc:aIe};let cIe=class{constructor(e,t,s,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const r=Fs(s.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=i.shape,o=r[r.length-1],a=Le(s.shape),[l,c,u,d]=cw(s,i),h=Xt({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),p=Xt({inputs:{x:s},backend:t,attrs:{shape:[Le(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const v=t.readSync(i.dataId),b=t.bufferSync(s),S=pSe(v,b,s.dtype,c,o,u,d,s.shape,a);return t.makeTensorInfo(l,s.dtype,S.values)}const g=new cIe(o,d,[c,u],s.shape),y=t.runWebGLProgram(g,[p,h],p.dtype),x=Xt({inputs:{x:y},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),x}const dIe={kernelName:sT,backendName:"webgl",kernelFunc:uIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hIe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Fs(this.rank),i=fIe(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}};function fIe(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${t[i]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s,l=Hn(o,i.shape)[0];if(ze().get("DEBUG")){const b=t.readSync(r.dataId),S=i.shape[l];for(let C=0;C<b.length;++C){const E=b[C];re(E<=S-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${S-1}]`)}}const c=Rw(i,r,l,a),u=Le(r.shape),d=[],h=Xt({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Xt({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(h),d.push(p);const g=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const b=t.bufferSync(p),S=t.bufferSync(h),C=mSe(S,b,g);return d.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(c.outputShape,C.dtype,C.values)}const y=new hIe(h.shape,g),x=t.runWebGLProgram(y,[h,p],h.dtype);d.push(x);const v=Xt({inputs:{x},backend:t,attrs:{shape:c.outputShape}});return d.forEach(b=>t.disposeIntermediateTensorInfo(b)),v}const pIe={kernelName:I0,backendName:"webgl",kernelFunc:rV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mIe="return float(a > b);",gIe=`
  return vec4(greaterThan(a, b));
`,xIe=hr({opSnippet:mIe,packedOpSnippet:gIe,cpuKernelImpl:gSe,dtype:"bool"}),vIe={kernelName:k0,backendName:"webgl",kernelFunc:xIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yIe="return float(a >= b);",wIe=`
  return vec4(greaterThanEqual(a, b));
`,bIe=hr({opSnippet:yIe,packedOpSnippet:wIe,dtype:"bool",cpuKernelImpl:xSe}),SIe={kernelName:gp,backendName:"webgl",kernelFunc:bIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CIe(n){const{inputs:e,backend:t}=n,{input:s}=e;return iV(s,!0,t)}const _Ie={kernelName:Ly,backendName:"webgl",kernelFunc:CIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EIe="return float(!isnan(x) && !isinf(x));",TIe=vs({opSnippet:EIe,dtype:"bool"}),IIe={kernelName:vp,backendName:"webgl",kernelFunc:TIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kIe="return float(isinf(x));",AIe=vs({opSnippet:kIe,dtype:"bool"}),RIe={kernelName:yp,backendName:"webgl",kernelFunc:AIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MIe="return float(isnan(x));",NIe=vs({opSnippet:MIe,dtype:"bool"}),PIe={kernelName:wp,backendName:"webgl",kernelFunc:NIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DIe="return float(a < b);",LIe=`
  return vec4(lessThan(a, b));
`,$Ie=hr({opSnippet:DIe,packedOpSnippet:LIe,cpuKernelImpl:vSe,dtype:"bool"}),FIe={kernelName:R0,backendName:"webgl",kernelFunc:$Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OIe="return float(a <= b);",zIe=`
  return vec4(lessThanEqual(a, b));
`,BIe=hr({opSnippet:OIe,packedOpSnippet:zIe,cpuKernelImpl:ySe,dtype:"bool"}),UIe={kernelName:M0,backendName:"webgl",kernelFunc:BIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VIe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=wSe(s,i,r);return e.makeTensorInfo([o.length],"float32",o)}const WIe={kernelName:iT,backendName:"webgl",kernelFunc:VIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GIe=im+`
  return x < 0.0 ? 0./0. : log(x);
`,HIe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,jIe=vs({opSnippet:GIe,packedOpSnippet:HIe,cpuKernelImpl:bSe}),XIe={kernelName:bp,backendName:"webgl",kernelFunc:jIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qIe=im+`
  return log(1.0 + x);
`,KIe=vs({opSnippet:qIe}),YIe={kernelName:Sp,backendName:"webgl",kernelFunc:KIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZIe="return float(a >= 1.0 && b >= 1.0);",QIe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,JIe=hr({opSnippet:ZIe,packedOpSnippet:QIe,dtype:"bool"}),e4e={kernelName:N0,backendName:"webgl",kernelFunc:JIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t4e="return float(!(x >= 1.0));",n4e=vs({opSnippet:t4e}),s4e={kernelName:P0,backendName:"webgl",kernelFunc:n4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4e="return float(a >= 1.0 || b >= 1.0);",r4e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,o4e=hr({opSnippet:i4e,packedOpSnippet:r4e,dtype:"bool"}),a4e={kernelName:D0,backendName:"webgl",kernelFunc:o4e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l4e=class{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c4e{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u4e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s,c=ze().getBool("WEBGL_PACK_NORMALIZATION")?new c4e(i.shape,r,o,a,l):new l4e(i.shape,r,o,a,l);return t.runWebGLProgram(c,[i],i.dtype)},d4e={kernelName:L0,backendName:"webgl",kernelFunc:u4e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let h4e=class{constructor(e,t,s,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f4e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s,d=new h4e(i.shape,a,l,c,u);return t.runWebGLProgram(d,[i,r,o],i.dtype)},p4e={kernelName:Fy,backendName:"webgl",kernelFunc:f4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4e(n,e,t,s){const i=Le(e),o=Le(n.shape)/i,a=Xt({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),l=Qd(a,n.dtype,"max",s),c=Xt({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s,a=i.shape.length,l=Hn(r,i.shape);let c=l;const u=Os(c,a),d=u!=null,h=t.shouldExecuteOnCPU([i]);let p=i;if(d){if(h){const S=t.texData.get(p.dataId).values,C=new Array(a);for(let R=0;R<C.length;R++)C[R]=i.shape[u[R]];const E=LI(S,i.shape,i.dtype,u,C);p=t.makeTensorInfo(C,i.dtype);const k=t.texData.get(p.dataId);k.values=E}else p=Hw(i,u,t);c=Ys(c.length,a)}Ai("max",c,a);const[g,y]=Ci(p.shape,c);let x=g;o&&(x=Si(g,l));let v;if(h){const S=t.texData.get(p.dataId).values,C=SSe(S,Le(y),x,i.dtype);v=t.makeTensorInfo(x,i.dtype);const E=t.texData.get(v.dataId);E.values=C}else v=m4e(p,y,x,t);return d&&t.disposeIntermediateTensorInfo(p),v}const g4e={kernelName:$0,backendName:"webgl",kernelFunc:oV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x4e=$I+`
  return max(a, b);
`,v4e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Zd+`
  return result;
`,y4e=hr({opSnippet:x4e,packedOpSnippet:v4e,cpuKernelImpl:CSe}),w4e={kernelName:Cp,backendName:"webgl",kernelFunc:y4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;T1(i,"maxPool");const{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,c=1;re(er(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=br(i.shape,r,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&ds(u.inShape,u.outShape))return yo({inputs:{x:i},backend:t});const d=new Xg(u,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const S4e={kernelName:F0,backendName:"webgl",kernelFunc:b4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],d=Fo(i.shape,r,o,u,a,c,l),h=new OI(d,"max",!1);return t.runWebGLProgram(h,[i],i.dtype)}const _4e={kernelName:O0,backendName:"webgl",kernelFunc:C4e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let E4e=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,r=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=r-1-e.padInfo.top,l=o-1-e.padInfo.left,c=r*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},T4e=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=l-1-e.padInfo.front,h=c-1-e.padInfo.top,p=u-1-e.padInfo.left,g=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I4e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,d=[1,1,1],h=Fo(o.shape,a,l,d,c,u),p=new OI(h,"max",!0),g=t.runWebGLProgram(p,[o],o.dtype),y=new T4e(h),x=t.runWebGLProgram(y,[i,g],o.dtype);return t.disposeIntermediateTensorInfo(g),x}const k4e={kernelName:zy,backendName:"webgl",kernelFunc:I4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A4e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;T1([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=s,h=br(a.shape,l,c,1,u,d),p=!0,g=new Xg(h,"max",p),y=t.runWebGLProgram(g,[a],a.dtype),x=new E4e(h),v=t.runWebGLProgram(x,[i,y],a.dtype);return t.disposeIntermediateTensorInfo(y),v}const R4e={kernelName:Oy,backendName:"webgl",kernelFunc:A4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4e(n,e,t,s){let i=new Xg(t,"max",!1);const r=s.runWebGLProgram(i,[n],"float32");i=new Xg(t,"max",!0,!0,e);const o=s.runWebGLProgram(i,[n],"float32");return[r,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N4e={kernelName:rT,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=e,l=t;re(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];re(er(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const u=br(s.shape,i,r,c,o),[d,h]=M4e(s,a,u,l);return[d,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4e(n,e,t,s){const i=Le(e),o=Le(n.shape)/i,a=Xt({inputs:{x:n},attrs:{shape:[o,i]},backend:s}),l=Qd(a,"float32","mean",s),c=Xt({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4e={kernelName:z0,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:i,axis:r}=e,o=t,a=s.shape.length,l=Hn(r,s.shape);let c=l;const u=Os(c,a),d=u!=null,h=o.shouldExecuteOnCPU([s]),p=[];let g=s;if(d){if(h){const C=o.texData.get(g.dataId).values,E=new Array(a);for(let L=0;L<E.length;L++)E[L]=s.shape[u[L]];const k=LI(C,s.shape,s.dtype,u,E);g=o.makeTensorInfo(E,s.dtype);const R=o.texData.get(g.dataId);R.values=k}else g=Hw(s,u,o);p.push(g),c=Ys(c.length,a)}Ai("sum",c,a);const[y,x]=Ci(g.shape,c);let v=y;i&&(v=Si(y,l));const b=P4e(g,x,v,o);for(const S of p)o.disposeIntermediateTensorInfo(S);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=Hn(r,i.shape);let c=l;const u=Os(c,a);let d=i;u!=null&&(d=$r({inputs:{x:i},backend:t,attrs:{perm:u}}),c=Ys(c.length,i.shape.length)),Ai("min",c,a);const[h,p]=Ci(d.shape,c),g=Le(p),y=Xt({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),x=Qd(y,y.dtype,"min",t);let v;if(o){const b=Si(h,l);v=Xt({inputs:{x},backend:t,attrs:{shape:b}})}else v=Xt({inputs:{x},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),u!=null&&t.disposeIntermediateTensorInfo(d),v}const $4e={kernelName:B0,backendName:"webgl",kernelFunc:L4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F4e=$I+`
  return min(a, b);
`,O4e=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Zd+`
  return result;
`,z4e=hr({opSnippet:F4e,packedOpSnippet:O4e,cpuKernelImpl:_Se}),B4e={kernelName:_p,backendName:"webgl",kernelFunc:z4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U4e=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((u,d)=>u[0]+e[d]+u[1]);const i=e.length,r=Fs(i),o=t.map(u=>u[0]).join(","),a=t.map((u,d)=>u[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V4e{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,y)=>g[0]+e[y]+g[1]);const i=e.length,r=Fs(i),o=t.map(g=>g[0]).join(","),a=t.map((g,y)=>g[0]+e[y]).join(","),l=Dr("rc",i),c=Dr("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,h=s==="reflect"?0:1;let p="";if(i===1){const g=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${u}) {
          ${g}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const g=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${u}) {
          ${g}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${g}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[i-1]} += 1;
          if(${u}) {
            ${g}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W4e=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:i,mode:r}=t,o=ze().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new V4e(s.shape,i,r):new U4e(s.shape,i,r);return e.runWebGLProgram(o,[s],s.dtype)},G4e={kernelName:U0,backendName:"webgl",kernelFunc:W4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H4e=`if (b == 0.0) return NAN;
  return mod(a, b);`,j4e=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Zd+`
  return result;
`,X4e=hr({opSnippet:H4e,packedOpSnippet:j4e}),q4e={kernelName:Ep,backendName:"webgl",kernelFunc:X4e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K4e=class{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y4e=`
if (a == b) {
  return 1.0;
};
return a / b;`,Z4e=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,aV=hr({opSnippet:Y4e,packedOpSnippet:Z4e,checkOutOfBounds:!0}),Q4e={kernelName:cp,backendName:"webgl",kernelFunc:aV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rL="return a - b;",lV=hr({opSnippet:rL,packedOpSnippet:rL,supportsComplex:!0,cpuKernelImpl:HSe}),J4e={kernelName:Up,backendName:"webgl",kernelFunc:lV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cV(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=Hn([r],i.shape),a=oV({inputs:{x:i},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Si(a.shape,o),c=Xt({inputs:{x:a},backend:t,attrs:{shape:l}}),u=lV({inputs:{a:i,b:c},backend:t}),d=sV({inputs:{x:u},backend:t}),h=jw({inputs:{x:d},backend:t,attrs:{axis:o,keepDims:!1}}),p=Xt({inputs:{x:h},backend:t,attrs:{shape:l}}),g=aV({inputs:{a:d,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),g}const eke={kernelName:r1,backendName:"webgl",kernelFunc:cV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tke(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s,l=a?i:cV({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],d=new K4e(c,u,r),h=[[o]],p=t.runWebGLProgram(d,[l],"int32",h);return a||t.disposeIntermediateTensorInfo(l),p}const nke={kernelName:oT,backendName:"webgl",kernelFunc:tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ske=ca+`
  return -x;
`,ike=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function rke(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const r=t.texData.get(s.dataId),[o,a]=TSe(r.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let i;return ze().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Zc(s.shape,ike):i=new ul(s.shape,ske),t.runWebGLProgram(i,[s],s.dtype)}const oke={kernelName:V0,backendName:"webgl",kernelFunc:rke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ake=aw;function lke(n){Ro("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),{selectedIndices:d}=ake(c,u,o,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const cke={kernelName:By,backendName:"webgl",kernelFunc:lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uke=jT;function dke(n){Ro("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,u=t.readSync(i.dataId),d=t.readSync(r.dataId),{selectedIndices:h,validOutputs:p}=uke(u,d,o,a,l,c);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const hke={kernelName:aT,backendName:"webgl",kernelFunc:dke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fke=lw;function pke(n){Ro("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(i.dataId),d=t.readSync(r.dataId),h=o,p=a,g=l,y=c,{selectedIndices:x,selectedScores:v}=fke(u,d,h,p,g,y);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const mke={kernelName:Uy,backendName:"webgl",kernelFunc:pke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gke=class{constructor(e,t,s,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xke=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s,c=Le(i.shape),u=new gke(c,o,a,l),d=Xt({inputs:{x:i},backend:t,attrs:{shape:[c]}}),h=t.runWebGLProgram(u,[d],r);t.disposeIntermediateTensorInfo(d);const p=[...i.shape,o],g=Xt({inputs:{x:h},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(h),g},vke={kernelName:H0,backendName:"webgl",kernelFunc:xke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=k1({inputs:{input:s},backend:t}),r=U2({inputs:{x:i},backend:t}),o=Xw({inputs:{input:s},backend:t}),a=U2({inputs:{x:o},backend:t}),l=Su({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return A1({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const yke={kernelName:l1,backendName:"webgl",kernelFunc:U2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uV(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=k1({inputs:{input:s},backend:t}),r=uV({inputs:{x:i},backend:t}),o=Xw({inputs:{input:s},backend:t}),a=U2({inputs:{x:o},backend:t}),l=Su({inputs:{real:r,imag:a},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return A1({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const wke={kernelName:G0,backendName:"webgl",kernelFunc:uV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bke(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return N_({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{fy(r,u.shape,"All tensors passed to stack must have matching shapes"),re(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const d=N_({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(d),d}),c=K8({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const Ske={kernelName:j0,backendName:"webgl",kernelFunc:bke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Cke=class{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const i=e.length,r=Fs(i),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${o});
      ${r} end = ${r}(${a});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ke{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((y,x)=>y[0]+e[x]+y[1]);const i=e.length,r=Fs(i),o=t.map(y=>y[0]).join(","),a=t.map((y,x)=>y[0]+e[x]).join(","),l=Dr("rc",i),c=Dr("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${u}) {`],p=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let y=0,x=i===1?2:4;y<x;y++)g+=`
        ${h[y]}
        if (${p}) {
          result[${y}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${y}] = getChannel(getX(${c.join()}), ${d});
        }
      `;g+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${o});
      const ${r} end = ${r}(${a});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dV=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;if(Le(i.shape)===0){const c=r.map((u,d)=>u[0]+i.shape[d]+u[1]);return A1({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=ze().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _ke(i.shape,r,o):new Cke(i.shape,r,o),l=[[o]];return t.runWebGLProgram(a,[i],i.dtype,l)},Eke={kernelName:X0,backendName:"webgl",kernelFunc:dV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tke=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ike=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Zd+`
  return result;
`,kke=hr({opSnippet:Tke,packedOpSnippet:Ike}),Ake={kernelName:Ip,backendName:"webgl",kernelFunc:kke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rke(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s,a=i.shape.length,l=[],c=Hn(r,i.shape);let u=c;const d=Os(u,a);let h=i;d!=null&&(h=$r({inputs:{x:i},backend:t,attrs:{perm:d}}),u=Ys(u.length,a),l.push(h)),Ai("prod",u,a);let p;if(t.shouldExecuteOnCPU([h])){const g=t.texData.get(h.dataId).values,{outVals:y,outShape:x,outDtype:v}=kSe(h.shape,h.dtype,g,u);p=t.makeTensorInfo(x,v,y)}else{const[g,y]=Ci(h.shape,u),x=Le(y),v=Xt({inputs:{x:h},backend:t,attrs:{shape:[-1,x]}}),b=Qy(i.dtype),S=Qd(v,b,"prod",t);p=Xt({inputs:{x:S},backend:t,attrs:{shape:g}}),l.push(v),l.push(S)}if(o){l.push(p);const g=Si(p.shape,c);p=Xt({inputs:{x:p},backend:t,attrs:{shape:g}})}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const Mke={kernelName:K0,backendName:"webgl",kernelFunc:Rke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nke(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:o}=e,{outputRaggedRank:a}=s,l=i.map(v=>t.readSync(v.dataId)),c=i.map(v=>v.shape),u=t.readSync(r.dataId),d=t.readSync(o.dataId),[h,p,g]=ASe(l,c,u,r.shape,r.dtype,d,o.shape,a),y=h.map(v=>t.makeTensorInfo([v.length],"int32",v)),x=t.makeTensorInfo(g,r.dtype,p);return y.concat([x])}const Pke={kernelName:t5,backendName:"webgl",kernelFunc:Nke};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dke(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=RSe(o,s.shape,s.dtype,a,i.shape,l,r.shape),d=t.makeTensorInfo([c.length],"int32",c),h=t.makeTensorInfo([u.length],s.dtype,u);return[d,h]}const Lke={kernelName:n5,backendName:"webgl",kernelFunc:Dke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ke(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),d=t.readSync(o.dataId),h=a.map(x=>t.readSync(x.dataId)),p=a.map(x=>x.shape),[g,y]=MSe(c,i.shape,u,r.shape,r.dtype,d,o.shape,h,p,l);return t.makeTensorInfo(g,r.dtype,y)}const Fke={kernelName:s5,backendName:"webgl",kernelFunc:$ke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hV=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:r,dtype:o}=t,a=NSe(s,i,r,o);return e.makeTensorInfo([a.length],o,a)},Oke={kernelName:Vy,backendName:"webgl",kernelFunc:hV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zke="return 1.0 / x;",Bke=vs({opSnippet:zke}),Uke={kernelName:kp,backendName:"webgl",kernelFunc:Bke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke=ca+`
  return (x < 0.0) ? 0.0 : x;
`,Wke=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Gke=vs({opSnippet:Vke,packedOpSnippet:Wke}),Hke={kernelName:Ap,backendName:"webgl",kernelFunc:Gke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jke=ca+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Xke=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,qke=vs({opSnippet:jke,packedOpSnippet:Xke}),Kke={kernelName:Rp,backendName:"webgl",kernelFunc:qke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yke=class{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s];let h;r?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zke{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s];let h;r?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qke(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=ze().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Zke(i.shape,l,c,r,o):new Yke(i.shape,l,c,r,o);return t.runWebGLProgram(u,[i],"float32")}const Jke={kernelName:Q0,backendName:"webgl",kernelFunc:Qke};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eAe=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,o,a]=e,l=[s&&o>1?i-1:i,s&&a>1?r-1:r],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,p=1/d,g=Math.ceil(h)*2+2,y=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,a=new eAe(r.shape,i.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const nAe={kernelName:Hy,backendName:"webgl",kernelFunc:tAe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sAe=class{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s],h=i?"0.5":"0.0";let p;r?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iAe{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[i&&t>1?a-1:a,i&&s>1?l-1:l],d=[i&&t>1?t-1:t,i&&s>1?s-1:s],h=i?"0.5":"0.0";let p;r?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=ze().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new iAe(i.shape,l,c,r,o):new sAe(i.shape,l,c,r,o);return t.runWebGLProgram(u,[i],i.dtype)}const oAe={kernelName:Z0,backendName:"webgl",kernelFunc:rAe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let aAe=class{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,o,a]=e,l=[s&&o>1?i-1:i,s&&a>1?r-1:r],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],h=1/u,p=1/d,g=Math.ceil(h)*2+2,y=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${g});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lAe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,a=new aAe(r.shape,i.shape,o);return t.runWebGLProgram(a,[r],r.dtype)}const cAe={kernelName:Gy,backendName:"webgl",kernelFunc:lAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uAe=class{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,r=e.map((a,l)=>i(l)).join(","),o=Fs(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dAe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const i=Dr("rc",s),r=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Fs(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${r}){
            result.g = ${c(i.slice())};
          }
          if(${o}) {
            result.b = ${u(i.slice())};
            if(${r}) {
              result.a = ${d(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(g){return h(g)}function c(g){return g[s-1]="("+g[s-1]+" + 1)",h(g)}function u(g){return g[s-2]="("+g[s-2]+" + 1)",h(g)}function d(g){return g[s-1]="("+g[s-1]+" + 1)",g[s-2]="("+g[s-2]+" + 1)",h(g)}function h(g){const y=e.map((b,S)=>p(S,g)),x=y.join(","),v=y.slice(-2).join(",");return`getChannel(getX(${x}), vec2(${v}))`}function p(g,y){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${y[g]} - 1`:`${y[g]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hAe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s,o=i.shape.length,a=Hn(r,i.shape);if(o===0)return yo({inputs:{x:i},backend:t});const l=ze().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dAe(i.shape,a):new uAe(i.shape,a);return t.runWebGLProgram(l,[i],i.dtype)}const fAe={kernelName:J0,backendName:"webgl",kernelFunc:hAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pAe=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],i=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mAe={kernelName:Yy,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=new pAe(s.shape,r),[c,u]=mw(o,s.shape[1],s.shape[2]),d=[[c,u,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(l,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gAe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,xAe=vs({opSnippet:gAe}),vAe={kernelName:Mp,backendName:"webgl",kernelFunc:xAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yAe="return inversesqrt(x);",wAe=vs({opSnippet:yAe,cpuKernelImpl:PSe}),bAe={kernelName:Np,backendName:"webgl",kernelFunc:wAe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zI=class{constructor(e,t,s,i,r,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Fs(r.length),u=Fs(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const h=`getIndices(${d})`;let p="";i===1?p="i":i===2&&(p="i, coords[1]");const g=`getUpdates(${p})`;let y="";l&&(y="coords[0], coords[1]");const x=`getDefaultValue(${y})`,v=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${x}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SAe{constructor(e,t,s,i,r,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const c=Fs(r.length),u=Fs(o.length);let d="";s===1?d="i":s===2&&(d="i, j");const h=`getIndices(${d})`;let p="";i===1?p="i":i===2&&(p="i, coords[1]");const g=`getUpdates(${p})`;let y="";l&&(y="coords[0], coords[1]");const x=`getDefaultValue(${y})`,v=t>1?"strides[j]":"strides",b=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${r});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${x}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CAe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Pl(r,i,o),h=[d/c,c];if(d===0)return t.makeTensorInfo(o,i.dtype);const p=Xt({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),g=Xt({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),y=t.makeTensorInfo([],"float32",new Float32Array([0]));let x;ze().getBool("WEBGL_PACK")?x=new SAe(l,a,p.shape.length,g.shape.length,u,h):x=new zI(l,a,p.shape.length,g.shape.length,u,h);const v=t.runWebGLProgram(x,[g,p,y],g.dtype),b=Xt({inputs:{x:v},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(y),b}const _Ae={kernelName:lT,backendName:"webgl",kernelFunc:CAe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EAe=class{constructor(e,t,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const r="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=ze().getNumber("WEBGL_VERSION")===2?r:o,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TAe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=new EAe(i.shape[0],i.shape[1],r.shape[1],o),l=[[i.shape[1]]];return t.runWebGLProgram(a,[i,r],"int32",l)}const IAe={kernelName:uT,backendName:"webgl",kernelFunc:TAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let kAe=class{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let i,r;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)r="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);i=l.join(),r=c.join()}const o=Fs(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AAe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e,o=new kAe(s.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(o,[s,i,r],Ji(i.dtype,r.dtype))}const RAe={kernelName:e1,backendName:"webgl",kernelFunc:AAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MAe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${p1};
  float scale = ${m1};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,NAe=vs({opSnippet:MAe}),PAe={kernelName:Pp,backendName:"webgl",kernelFunc:NAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DAe=im+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,LAe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$Ae=vs({opSnippet:DAe,packedOpSnippet:LAe,cpuKernelImpl:LSe}),FAe={kernelName:Fp,backendName:"webgl",kernelFunc:$Ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OAe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,zAe=vs({opSnippet:OAe}),BAe={kernelName:$p,backendName:"webgl",kernelFunc:zAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UAe=im+`
  return sin(x);
`,VAe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Zd}
  return result;
`,WAe=vs({opSnippet:UAe,packedOpSnippet:VAe}),GAe={kernelName:Dp,backendName:"webgl",kernelFunc:WAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HAe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,jAe=vs({opSnippet:HAe}),XAe={kernelName:Lp,backendName:"webgl",kernelFunc:jAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qAe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,KAe=vs({opSnippet:qAe}),YAe={kernelName:Op,backendName:"webgl",kernelFunc:KAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZAe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;re(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=r.reduce((v,b)=>v*b),l=[[0,0]];l.push(...o);for(let v=1+r.length;v<i.shape.length;++v)l.push([0,0]);const c=[],u=dV({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),d=Gd(u.shape,r,a,!1),h=Hd(d.length,r.length,!1),p=jd(u.shape,r,a,!1),g=Xt({inputs:{x:u},backend:t,attrs:{shape:d}}),y=$r({inputs:{x:g},backend:t,attrs:{perm:h}}),x=Xt({inputs:{x:y},backend:t,attrs:{shape:p}});return c.push(u),c.push(g),c.push(y),c.forEach(v=>t.disposeIntermediateTensorInfo(v)),x},QAe={kernelName:s1,backendName:"webgl",kernelFunc:ZAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JAe(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:o}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=t.readSync(o.dataId)[0],[d,h,p,g,y]=FSe(a,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(h,s.dtype,d),t.makeTensorInfo([h[0]],i.dtype,p),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(x=>Number(x)))),t.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}const eRe={kernelName:i5,backendName:"webgl",kernelFunc:JAe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tRe(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const o=Array.from(t.readSync(i.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(r.dataId)),[c,u,d]=OSe(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([d.length],r.dtype,new Int32Array(d))]}const nRe={kernelName:r5,backendName:"webgl",kernelFunc:tRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sRe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=$8(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const iRe={kernelName:dT,backendName:"webgl",kernelFunc:sRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rRe(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const o=t.readSync(s.dataId),a=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=$8(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const oRe={kernelName:hT,backendName:"webgl",kernelFunc:rRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aRe(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Pl(r,i,a),p=!1;if(r.dtype==="string"){const v=t.bufferSync(i),b=t.bufferSync(r),S=$a(t.readSync(o.dataId)[0]),C=DSe(v,b,a,h,u,c,l,d,S,p);return t.makeTensorInfo(a,C.dtype,C.values)}const g=new zI(c,l,i.shape.length,r.shape.length,d,[h,1],p),y=t.runWebGLProgram(g,[r,i,o],r.dtype),x=Xt({inputs:{x:y},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(y),x}const lRe={kernelName:fT,backendName:"webgl",kernelFunc:aRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Hn(o,i.shape)[0],l=Aw(i,r,a),c=i.shape.length,u=new Array(c).fill(0),d=i.shape.slice();return l.map(h=>{const p=[...d];p[a]=h;const g=rm({inputs:{x:i},backend:t,attrs:{begin:u,size:p}});return u[a]+=h,g})}const uRe={kernelName:i1,backendName:"webgl",kernelFunc:cRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oL="return sqrt(x);",dRe=vs({opSnippet:oL,packedOpSnippet:oL,cpuKernelImpl:zSe}),hRe={kernelName:zp,backendName:"webgl",kernelFunc:dRe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fRe="return x * x;",pRe=vs({opSnippet:fRe}),mRe={kernelName:jy,backendName:"webgl",kernelFunc:pRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL="return (a - b) * (a - b);",gRe=hr({opSnippet:aL,packedOpSnippet:aL}),xRe={kernelName:Bp,backendName:"webgl",kernelFunc:gRe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const r=t.readSync(i.dataId),o=Oa(r),a=BSe(o,"string",s);return t.makeTensorInfo(i.shape,"string",a)}const yRe={kernelName:pT,backendName:"webgl",kernelFunc:vRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wRe({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=ca+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,r=new ul(s.shape,i);return t.runWebGLProgram(r,[s],s.dtype)}const bRe={kernelName:Hp,backendName:"webgl",kernelFunc:wRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SRe=class{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,r=Fs(s.length),o=Fs(s.length);let a="";if(i===1)a="coords * strides + begin";else{let l=0;a=s.map((c,u)=>(l++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:p,finalShape:g,isIdentity:y,sliceDim0:x,isSimpleSlice:v,begin:b,end:S,strides:C}=hw(i.shape,r,o,a,l,c,u,d,h);let E;if(y)E=Xt({inputs:{x:i},backend:t,attrs:{shape:g}});else if(x||v){re(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const R=dw(b,S,C),L=rm({inputs:{x:i},backend:t,attrs:{begin:b,size:R}});E=Xt({inputs:{x:L},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(L)}else if(t.shouldExecuteOnCPU([i])){const L=t.readSync(i.dataId),I=Yn(i.shape,i.dtype,L),T=USe(p,I,C,b);E=t.makeTensorInfo(g,i.dtype,T.values)}else{const L=new SRe(b,C,p);E=t.runWebGLProgram(L,[i],i.dtype)}const k=Xt({inputs:{x:E},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(E),k}const _Re={kernelName:Xy,backendName:"webgl",kernelFunc:CRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ERe(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:d}=e,h=t.readSync(u.dataId),p=t.readSync(d.dataId),[g,y]=VSe(h,p,i,r,o,a,l,c);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(d.shape,"int32",y)]}const TRe={kernelName:mT,backendName:"webgl",kernelFunc:ERe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IRe(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:o}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(o.dataId)[0],[c,u,d]=WSe(a,l,i),h=u.length;return[t.makeTensorInfo([h,2],"int32",c),t.makeTensorInfo([h],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const kRe={kernelName:o5,backendName:"webgl",kernelFunc:IRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ARe(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(r.dataId),a=GSe(o,i);return t.makeTensorInfo(r.shape,"int32",a)}const RRe={kernelName:a5,backendName:"webgl",kernelFunc:ARe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MRe="return tan(x);",NRe=vs({opSnippet:MRe}),PRe={kernelName:Vp,backendName:"webgl",kernelFunc:NRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DRe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,LRe=vs({opSnippet:DRe}),$Re={kernelName:Wp,backendName:"webgl",kernelFunc:LRe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FRe(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:i,indices:r,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Pl(o,r,i.shape),h=[d/c,c];if(d===0)return t.makeTensorInfo(i.shape,r.dtype);const p=Xt({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),g=Xt({inputs:{x:o},backend:t,attrs:{shape:[l,c]}}),y=Xt({inputs:{x:i},backend:t,attrs:{shape:h}}),x=new zI(l,a,p.shape.length,g.shape.length,u,h,!1,!0),v=t.runWebGLProgram(x,[g,p,y],y.dtype),b=Xt({inputs:{x:v},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(v),b}const ORe={kernelName:cT,backendName:"webgl",kernelFunc:FRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zRe=class{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const i=Fs(this.rank),r=BRe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function BRe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${t[i]}, ${n[i]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;if(i.dtype==="string"||i.shape.length>5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(h=>$a(h)):l,u=Yn(i.shape,i.dtype,c),d=jSe(u,r);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new zRe(i.shape,r);return t.runWebGLProgram(o,[i],i.dtype)}const URe={kernelName:Gp,backendName:"webgl",kernelFunc:fV};let VRe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},WRe=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gu(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function lL(n){let e=1;for(;e<n;)e*=2;return e}function GRe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s,a=ze().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ze().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([i])||u<a||r>l){const T=t.readSync(i.dataId),[M,j]=XSe(T,c,i.dtype,r,o);return[t.makeTensorInfo(M.shape,M.dtype,M.values),t.makeTensorInfo(j.shape,j.dtype,j.values)]}if(r===0)return c[c.length-1]=0,[t.makeTensorInfo(c,i.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[i,A1({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const d=t.texData.get(i.dataId),h=d!==null&&d.isPacked,p=h?t.unpackTensor(i):i,y=Le(c)/u,x=Xt({inputs:{x:p},attrs:{shape:[y,u]},backend:t});h&&Gu(t,p);const v=lL(r),b=lL(u);let S=null;const C=()=>S===null?[x,x]:[x,S],E=(T,M,j)=>{const W=C(),z=new VRe(j),B=[[u],[S===null?1:0],[Number.NEGATIVE_INFINITY],[T],[M]],J=S;S=t.runWebGLProgram(z,W,"int32",B),Gu(t,J)};for(let T=1;T<v;T*=2){const M=T*2;for(let j=T;j>=1;j/=2)E(M,j,[y,b])}for(let T=b;T>v;T/=2){const M=C(),j=new WRe([y,T/2]),z=[[u],[S===null?1:0],[v]],X=S;S=t.runWebGLProgram(j,M,"int32",z),Gu(t,X);const B=v/2,J=B*2;for(let K=B;K>=1;K/=2)E(J,K,S.shape)}let k=S;S=rm({inputs:{x:S},backend:t,attrs:{begin:0,size:[y,r]}}),Gu(t,k);let R=rV({inputs:{x,indices:S},backend:t,attrs:{axis:1,batchDims:1}});Gu(t,x);const L=c.slice(0,-1);L.push(r),k=S,S=Xt({inputs:{x:S},attrs:{shape:L},backend:t}),Gu(t,k);const I=R;return R=Xt({inputs:{x:R},attrs:{shape:L},backend:t}),Gu(t,I),[R,S]}const HRe={kernelName:qy,backendName:"webgl",kernelFunc:GRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jRe=class{constructor(e,t,s,i,r,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XRe(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[u,d,h,p]=i.shape,[g,y]=c??[d,h],x=[u,g,y,p],v=new jRe(d,h,o,a,l,x);return t.runWebGLProgram(v,[i,r],"float32")}const qRe={kernelName:Ky,backendName:"webgl",kernelFunc:XRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KRe(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;T1(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(r.dataId),{outputValues:a,outputShape:l,indices:c}=qSe(o,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const YRe={kernelName:gT,backendName:"webgl",kernelFunc:KRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZRe(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[r],c=new Array(a-1);let u=0;for(let y=0;y<a;y++)y!==r&&(c[u++]=o.shape[y]);const d=[],h=new Array(a).fill(0),p=o.shape.slice();p[r]=1;const g=new Array(l);for(let y=0;y<g.length;y++){h[r]=y;const x=rm({inputs:{x:o},backend:t,attrs:{begin:h,size:p}}),v=Xt({inputs:{x},backend:t,attrs:{shape:c}});g[y]=v,d.push(x)}return d.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}const QRe={kernelName:o1,backendName:"webgl",kernelFunc:ZRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JRe{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,i=e.batchSize,r=e.inSize,o=e.numSegments,a=o*Math.ceil(r/s);this.outputShape=[i,a];const l="0.0",c="sumValue",u=Math.floor(s/4)*4,d=s%4,h=`
        sumValue += dot(values, segFilter);
    `;let p="";r%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let g="";r%s>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eMe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s,a=i.shape.length,l=[];let c=0;const u=Os([c],a);let d=i;u!=null&&(d=$r({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(d),c=Ys(1,a)[0]);const h=JT(d.shape,c,o),p=Le([d.shape[c]]),g=Xt({inputs:{x:d},backend:t,attrs:{shape:[-1,p]}});l.push(g);const y=Qy(i.dtype),x=(C,E,k,R,L)=>{const I=C.shape[0],T=C.shape[1],M=X6(T,L),j={windowSize:M,inSize:T,batchSize:I,numSegments:L},W=new JRe(j,E),z=t.compileAndRun(W,[C,k],R);if(l.push(z),z.shape[1]===L)return z;const X=hV({backend:t,attrs:{start:0,stop:L,step:1,dtype:"float32"}}),B=fV({inputs:{x:X},backend:t,attrs:{reps:[T/M]}});return l.push(X),l.push(B),x(z,E,B,R,L)},v=x(g,"unsortedSegmentSum",r,y,o),b=Xt({inputs:{x:v},backend:t,attrs:{shape:h}});let S=b;if(u!=null){l.push(b);const C=Nl(u);S=$r({inputs:{x:S},backend:t,attrs:{perm:C}})}return l.forEach(C=>t.disposeIntermediateTensorInfo(C)),S}const tMe={kernelName:a1,backendName:"webgl",kernelFunc:eMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nMe=[zCe,UCe,GCe,XCe,KCe,QCe,e_e,n_e,o_e,l_e,d_e,p_e,x_e,b_e,__e,T_e,k_e,N_e,D_e,$_e,B_e,X_e,K_e,J_e,tEe,aEe,cEe,fEe,SCe,gEe,bEe,EEe,MEe,DEe,$Ee,OEe,BEe,GEe,XEe,YEe,QEe,eTe,nTe,rTe,aTe,dTe,fTe,gTe,yTe,bTe,ETe,ATe,PTe,$Te,zTe,BTe,VTe,GTe,jTe,qTe,YTe,eIe,sIe,oIe,lIe,dIe,pIe,vIe,SIe,bCe,_Ie,yEe,IIe,RIe,PIe,_Ce,FIe,UIe,WIe,XIe,YIe,e4e,s4e,a4e,d4e,p4e,g4e,w4e,S4e,_4e,k4e,R4e,N4e,D4e,$4e,B4e,G4e,q4e,nke,ICe,oke,cke,hke,mke,sEe,vke,wke,Ske,Eke,Ake,TCe,Mke,Pke,Lke,Fke,Oke,iEe,Q4e,Uke,Hke,Kke,ACe,Jke,nAe,oAe,cAe,fAe,mAe,vAe,bAe,_Ae,IAe,RAe,PAe,FAe,BAe,GAe,XAe,H_e,eke,YAe,QAe,eRe,nRe,iRe,oRe,lRe,uRe,hRe,mRe,xRe,yRe,bRe,_Re,TRe,kRe,RRe,J4e,$Ce,PRe,$Re,ORe,URe,HRe,qRe,FCe,YRe,QRe,tMe,yke];for(const n of nMe)vT(n);ze().set("DEBUG",!1);ze().set("WEBGL_VERSION",2);ze().set("WEBGL_FORCE_F16_TEXTURES",!1);ze().set("WEBGL_PACK",!0);Fv("webgl").then(()=>{console.log("TensorFlow.js initialized")});const P_=[{name:"Collier 1",path:"collier1.png"},{name:"Collier 2",path:"collier2.png"},{name:"Collier 3",path:"collier3.png"},{name:"Collier 4",path:"collier4.png"}];function sMe({onSelect:n}){const[e,t]=le.useState(P_[0].path);return G.jsxs("div",{children:[G.jsx("label",{children:"Choisir un collier :"}),G.jsx("select",{value:e,onChange:s=>{t(s.target.value),n(s.target.value)},children:P_.map(s=>G.jsx("option",{value:s.path,children:s.name},s.path))}),G.jsx("div",{style:{marginTop:16},children:G.jsx("img",{src:e,alt:"Collier sélectionné",height:60})})]})}function iMe(){const[n,e]=le.useState(!0),t=le.useRef(null),[s,i]=le.useState(P_[0].path);return le.useEffect(()=>{(async()=>{await a_(),setTimeout(()=>{e(!1)},2e3)})()},[]),G.jsx(rK,{children:G.jsx(Xv,{mode:"wait",children:n?G.jsx(sae,{},"loading"):G.jsx(wn.div,{initial:{opacity:0},animate:{opacity:1},exit:{opacity:0},className:"min-h-screen bg-white text-gray-900 relative",children:G.jsx("div",{className:"relative z-10",children:G.jsxs(Lq,{children:[G.jsx(Rv,{path:"/",element:G.jsxs("main",{children:[G.jsx(xK,{}),G.jsx(gK,{}),G.jsx("section",{id:"why",className:"relative",children:G.jsx(BK,{})}),G.jsx("section",{id:"shop",className:"relative",children:G.jsx(HK,{})}),G.jsx("section",{id:"test",className:"relative",children:G.jsx(nae,{})}),G.jsx("section",{id:"demo",className:"py-20 bg-gradient-to-b from-transparent to-gray-900",children:G.jsx("div",{className:"max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative",children:G.jsx(OK,{videoRef:t,children:t.current&&G.jsx(LF,{videoRef:t})})})}),G.jsx(sMe,{onSelect:i})]})}),G.jsx(Rv,{path:"/test",element:G.jsx(iae,{})}),G.jsx(Rv,{path:"/photo",element:G.jsx(XO,{})})]})})},"main")})})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bo=ze();Bo.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Bo.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Bo.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Bo.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Bo.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Bo.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Bo.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Bo.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Bo.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Bo.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Bo.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Bo.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Bo.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rMe{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oMe{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,s=!1,i=!0){let r;const o=cL(e,t);return i?(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).length>0?(r=this.freeBuffers.get(o).pop(),this.numFreeBuffers--):(r=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e)):(r=this.device.createBuffer({size:e,usage:t,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.usedBuffers.get(o).push(r),this.numUsedBuffers++,this.numBytesUsed+=e,r}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const s=e.size,i=e.usage,r=cL(s,i),o=this.usedBuffers.get(r),a=o.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");o[a]=o[o.length-1],o.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,t?(this.freeBuffers.get(r).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function cL(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aMe{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,s,i){const r=dL(s),o=e*t*r,a=uL(e,t,s,i);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=o,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const c=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(c),c}this.numBytesAllocated+=o;const l=this.device.createTexture({size:[e,t],format:s,usage:i});return this.usedTextures.get(a).push(l),l}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,s=e.height,i=e.format,r=e.usage,o=uL(t,s,i,r);this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.freeTextures.get(o).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(o),l=a.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(l,1);const c=dL(i),u=t*s*c;this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function uL(n,e,t,s){return`${n}_${e}_${t}_${s}`}function dL(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lMe(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,s="xyzwuv",i=n.map(o=>`${e}.${s[o]}`),r=new Array(t-1);r[t-2]=i[t-1];for(let o=t-3;o>=0;--o)r[o]=`(${r[o+1]} * ${i[o+1]})`;return r}const Cu=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var zf;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(zf||(zf={}));const cMe=(n,e,t,s,i)=>{const r={dtype:s.dtype,shape:s.shape},o=dMe(t,r,e),a=n.createShaderModule({code:o,label:e.constructor.name});let l=ze().get("WEBGPU_PRINT_SHADER");if(l!==""){l=l.toLowerCase();const c=l.split(",");(l==="all"||c.some(u=>e.shaderKey.toLowerCase().includes(u)))&&(console.group(e.shaderKey),console.debug(o),console.groupEnd())}return i?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},es=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function yi(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function cc(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function Ot(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function hL(n,e){let t;return t=`
     ${uMe(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function uMe(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function dMe(n,e,t){const s=[],i=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${pV(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${i}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const g=t.pixelsOpType===zf.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${sd(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${sd(n[0].dtype,t.outputComponent)}>;`,y=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${y},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${g}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const x=pL(t);return[fL,s.join(`
`),jv(e.shape),t.getUserCode(),hL(x,t)].join(`
`)}let r,o,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((g,y)=>{const x=yi(n[y].shape.length);a+=`${g.charAt(0).toLowerCase()+g.slice(1)}Shape : ${x}, `,r=n[y].shape.length-1,o=yi(r),a+=`${g.charAt(0).toLowerCase()+g.slice(1)}ShapeStrides: ${o}, `});const l=yi(e.shape.length);a+=`outShape : ${l}, `,r=e.shape.length-1,o=yi(r),a+=`
         outShapeStrides: ${o}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=wMe(a),s.push(a),t.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${sd(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((g,y)=>{s.push(`
      @group(0) @binding(${1+y}) var<storage, read> ${g}: array<${t.variableComponents?sd(n[y].dtype,t.variableComponents[y]):sd(n[y].dtype,t.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const c=xMe(e.shape,t.dispatchLayout),u=[fL,s.join(`
`)+fMe,jv(e.shape),c,vMe(e.shape.length)];t.atomic||u.push(yMe(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((g,y)=>{u.push(`${jv(n[y].shape,g)}`)});const d=n.map((g,y)=>gMe(g,e.shape,t.variableComponents?t.variableComponents[y]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);u.push(d),u.push(t.getUserCode());const h=pL(t);return u.push(hL(h,t)),u.join(`
`)}function hMe(n,e,t){let s=n.shaderKey;if(n.pixelsOpType!=null)return s;const i=[],r=[];e.forEach(u=>{i.push(u.shape),r.push(u.dtype)}),i.push(t.shape),r.push(t.dtype);const o=e.map(u=>ou(u.shape,t.shape)),a=e.map(u=>ds(u.shape,t.shape)).join("_"),l=o.map(u=>u.join("_")).join(";"),c=pV(n)?"flatDispatch":"";return s+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+i.map(u=>u.length).join(",")+r.join(",")+n.variableNames.join(",")+l+a+c,s}const fL=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,fMe=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function jv(n,e=""){const t=n.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const r=gn(n),o=yi(t),a=[];for(let c=0;c<t;c++)a.push(`d${c}`);if(r.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`;let l;return l="var index2 = index;"+r.map((c,u)=>{const d=`let ${a[u]} = index2 / uniforms.${i}.${cc(u)}`,h=u===r.length-1?`let ${a[u+1]} = index2 - ${a[u]} * uniforms.${i}.${cc(u)}`:`index2 = index2 - ${a[u]} * uniforms.${i}.${cc(u)}`;return`${d}; ${h};`}).join(""),`
    fn ${s}(index : i32) -> ${o} {
      ${l}
      return ${o}(${a.join(",")});
    }
  `}function pMe(n,e){const t=n.name,s=n.shape.length,i=yi(s),r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=o.map(u=>`${u} : i32`).join(", ");if(s<1)return`
      fn ${r}() -> ${es(e)} {
        return ${es(e)}(${t}[0]);
      }
    `;const l=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let c=`${s}D`;return s===0&&(c="1D"),`
    fn ${r}(${a}) -> ${es(e)} {
      return ${es(e)}(${t}[getIndexFromCoords${c}(${i}(${o.join(",")}),
        ${l})${e===1?"":` / ${e}`}]);
    }
   `}function mMe(n,e,t,s){const i=n.name,r=i.charAt(0).toUpperCase()+i.slice(1),o="get"+r+"ByOutput",a=n.shape.length,l=e.length,c=yi(l);if(ds(n.shape,e)&&s)return`
    fn ${o}Index(globalIndex : i32) -> ${es(t)} {
      return ${es(t)}(${i}[globalIndex]);
    }

    fn ${o}Coords(coords : ${c}) -> ${es(t)} {
      return ${es(t)}(${i}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const u=ou(n.shape,e),d=l-a;let h="";if(a===0)return`
    fn ${o}Index(globalIndex : i32) -> ${es(t)}{
      return get${r}();
    }

    fn ${o}Coords(coords : ${c}) -> ${es(t)}{
      return get${r}();
    }
  `;l<2&&u.length>=1?h="coords = 0;":h=u.map(x=>`coords.${cc(x+d)} = 0;`).join(`
`);let p="";if(l<2&&a>0)p="coords";else if(l>1){const x=yi(a),v=n.shape.map((b,S)=>`coords.${cc(S+d)}`).join(", ");p=`${x}(${v})`}else p="coords";const g=`uniforms.${i.charAt(0).toLowerCase()+i.slice(1)}Shape`,y=`${a}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${es(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${h}
    return ${es(t)}(${i}[getIndexFromCoords${y}(${p}, ${g})${t===1?"":` / ${t}`}]);
  }

  fn ${o}Coords(coordsIn : ${c}) -> ${es(t)} {
    var coords = coordsIn;
    ${h}
    return ${es(t)}(${i}[getIndexFromCoords${y}(${p}, ${g})${t===1?"":` / ${t}`}]);
  }
`}function gMe(n,e,t,s){let i=pMe(n,t);return n.shape.length<=e.length&&(i+=mMe(n,e,t,s)),i}function xMe(n,e){const{x:t,y:s=[],z:i=[]}=e,r=n.length,o=t.length+s.length+i.length;if(o!==r)return"";if(t.length===r)return`fn getOutputCoords() -> ${yi(r)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const l=[t,s,i];for(let h=0;h<l.length;h++){const p=l[h];if(p.length!==0)if(p.length===1)a+=`let d${p[0]} = i32(globalId[${h}]);`;else{const g=lMe(p,"uniforms.outShape");a+=`var index${h} = i32(globalId[${h}]);`;for(let y=0;y<g.length;y++)a+=`let d${p[y]} = index${h} / ${g[y]};`,y===g.length-1?a+=`let d${p[y+1]} = index${h} - d${p[y]} * ${g[y]};`:a+=`index${h} = index${h} - d${p[y]} * ${g[y]};`}}const c=[];for(let h=0;h<o;h++)c.push(`d${h}`);const u=yi(o);let d=`fn getOutputCoords() -> ${u} {
  ${a}
`;return c.length===0?d+=`return ${u}(0); }`:d+=`return ${u}(${c.join(",")}); }`,d}function vMe(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:re(!1,()=>`Unsupported ${n}D shape`);break}return e}function pV(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function sd(n,e=1){if(n==="float32")return es(e,"f32");if(n==="int32"||n==="bool")return es(e,"i32");throw new Error(`type ${n} is not supported.`)}function yMe(n,e,t){const s=n.length,i=sd(e,t);let r=`fn setOutputAtIndex(flatIndex : i32, value : ${es(t)}) {
      result[flatIndex] = ${i}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${es(t,"i32")}) {
      result[flatIndex] = ${i}(value);
    }
    `;if(s>=2){const o=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=yi(s);r+=`
      fn setOutputAtCoords(${o.map(l=>`${l} : i32`).join(", ")}, value : ${es(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${o.map(l=>`${l} : i32`).join(", ")}, value : ${es(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${o.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return r}function wMe(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,s=>"@align(16) "+s);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(s,i,r)=>`vec${i}, @align(16) ${r}`),n}function pL(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xd=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function Ut(n,e,t=[1,1,1],s=[1,1,1]){const[i,r,o]=[Math.ceil(xd(n.x.map(a=>e[a]))/(t[0]*s[0])),n.y?Math.ceil(xd(n.y.map(a=>e[a]))/(t[1]*s[1])):1,n.z?Math.ceil(xd(n.z.map(a=>e[a]))/(t[2]*s[2])):1];return[i,r,o]}function bMe(n,e,t,s=!1){const i=[8,8,1],r=[4,4,1];return s||(n<=8&&(r[1]=1),e<=16&&t<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:r}}function mV(n,e,t=!1){if(t)return[8,8,1];const s=xd(n.x.map(r=>e[r])),i=xd(n.y.map(r=>e[r]));return s<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function gV(n,e,t=!1){if(t)return[4,4,1];const s=xd(n.x.map(r=>e[r])),i=xd(n.y.map(r=>e[r]));return s<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function en(n){return{x:n.map((e,t)=>t)}}function mL(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function xV(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function vV(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&re(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var tl;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(tl||(tl={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SMe=ze().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),CMe=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,i=e.dispatch;if(i.every(o=>o<=t))return i;re(i[0]>t&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let r=Math.ceil(Math.sqrt(i[0]));return r>t?(r=Math.ceil(Math.cbrt(i[0])),re(r<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[r,r,r]):[r,r,1]};class qw extends hy{nextDataId(){return qw.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!xV())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new rMe(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new oMe(this.device),this.textureManager=new aMe(this.device),this.tensorMap=new XE(this,Ao()),ze().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return t?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.tensorMap.set(i,{dtype:s,shape:t,values:e,refCount:1}),i}move(e,t,s,i,r){if(i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:i,shape:s,values:t,refCount:r})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,s)=>{this.pipelineCache[t]=e[s]})}async getBufferData(e){if(ze().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,s=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const i=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),ze().getBool("WEBGPU_USE_PROFILE_TOOL")&&(re(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const s=this.tensorMap.get(e);return s.values=t,s.values}readSync(e){const t=this.tensorMap.get(e),{values:s,complexTensorInfos:i}=t;if(s!=null||t.dtype==="string")return s;if(t.dtype==="complex64"){const y=this.readSync(i.real.dataId),x=this.readSync(i.imag.dataId),v=Lv(Fa(y,x).buffer,"float32");return this.convertAndCacheOnCPU(e,v),v}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const r=["opaque","premultiplied"],o=t.resource,a=o.size;re(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const l=a/4,c=new ArrayBuffer(a),u=256,d=256,h=r.map(y=>new OffscreenCanvas(u,d)),p=new OffscreenCanvas(u,d);this.endComputePassEncoder(),h.map((y,x)=>{const v=y.getContext("webgpu");return v.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:r[x]}),v.getCurrentTexture()}).map((y,x)=>{const v=u*4,b=(L,I,T)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:o,bytesPerRow:v,offset:T},{texture:y},{width:L,height:I}),this.submitQueue();const M=p.getContext("2d",{willReadFrequently:!0});M.clearRect(0,0,L,I),M.drawImage(h[x],0,0);const j=M.getImageData(0,0,L,I).data,W=r[x],z=new Uint8ClampedArray(c,T,L*I*4);for(let X=0;X<z.length;X+=4)if(W==="premultiplied")z[X+3]=j[X+3];else{const B=j[X];z[X]=j[X+2],z[X+1]=j[X+1],z[X+2]=B}},S=Math.floor(l/(u*d));let C=u,E=d,k=0;for(let L=0;L<S;L++)b(C,E,k),k+=u*d*4;const R=l%(u*d);E=Math.floor(R/u),E>0&&(b(C,E,k),k+=E*(u*4)),C=R%u,C>0&&b(C,1,k)});const g=Lv(c,t.dtype);return this.convertAndCacheOnCPU(e,g),g}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:s}=t;if(s!=null)return s;let i;if(t.dtype==="complex64"){const r=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),o=r[0],a=r[1];i=Fa(o,a)}else{const r=await this.getBufferData(t.resource);i=Lv(r,t.dtype)}return this.convertAndCacheOnCPU(e,i),i}copyBuffer(e){const t=e.size,s=e.usage,i=this.bufferManager.acquireBuffer(t,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,i,0,t),this.submitQueue(),i}createTensorFromGPUData(e,t,s){let i=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const r={id:this.nextDataId()};this.tensorMap.set(r,{dtype:s,shape:t,values:null,refCount:1,external:e.zeroCopy});const o=this.tensorMap.get(r),a=mL(o.dtype)*Le(o.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(i=this.copyBuffer(i)),o.resource=i,Ao().makeTensorFromDataId(r,t,s,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:s,dtype:i,shape:r,resource:o}=t;if(i==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(o==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=o,l=a.size,c=a.usage,u=this.bufferManager.acquireBuffer(l,c);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,u,0,l),this.submitQueue();const d=this.makeTensorInfo(r,i),h=Ao().makeTensorFromTensorInfo(d),p=this.tensorMap.get(d.dataId);return p.resource=u,{tensorRef:h,buffer:u}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>$a(i));return Yn(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Yn(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const r=hc(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=hc(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},l=await Promise.all(r);return a.kernelMs=qO(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,s){return t==="string"&&s!=null&&s.length>0&&Kf(s[0])&&(s=s.map(r=>ac(r))),{dataId:this.write(s,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const s=mL(t.dtype)*Le(t.shape);let i;const r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(i=this.bufferManager.acquireBuffer(s,r,!0),i.mapState==="unmapped"){const o=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=o.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),o.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(o,0,i,0,s),this.stagingPendingDisposal.push(o)}else{const o=i.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(o).set(t.values):new Float32Array(o).set(t.values),i.unmap()}t.values=null}else i=this.bufferManager.acquireBuffer(s,r);t.resource=i}makeUniforms(e){let t=0,s=0;const i=[];let r=1;e.forEach(l=>{l.data.length===0&&(l.data=[1]);let c;switch(l.data.length){case 1:c=4;break;case 2:c=8;break;case 3:c=16;break;case 4:c=16;break;case 5:c=16;break;case 6:c=16;break;default:re(!1,()=>`Unsupported ${l.data.length}D shape`)}(s===5||s===6)&&(c=16),c>r&&(r=c),t=Math.ceil(t/c)*c,s=l.data.length,i.push(t),t+=l.data.length*4}),t=Math.ceil(t/r)*r;const o=new ArrayBuffer(t);e.forEach((l,c)=>{const u=i[c];l.type==="int32"?new Int32Array(o,u,l.data.length).set(l.data):l.type==="uint32"?new Uint32Array(o,u,l.data.length).set(l.data):new Float32Array(o,u,l.data.length).set(l.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,o,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,s,i,r){if(r||(r=this.makeTensorInfo(e.outputShape,s)),Le(r.shape)===0)return this.tensorMap.get(r.dataId).values=Qi(r.dtype,0),r;this.uploadToGPU(r.dataId),e.dispatch=CMe(this.device,e);const o=t.map((l,c)=>{if(l.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(l.dataId),{dtype:this.tensorMap.get(l.dataId).dtype,shape:l.shape,name:e.variableNames[c]}});e.shaderKey=hMe(e,o,r);const a=ze().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=cMe(this.device,e,o,r,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,r,t,i),r}recordAndSubmit(e,t,s,i){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let r=[],o=[];const a="int32";if(e.pixelsOpType==null){r.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),o=s.concat(t).map(p=>p.shape);const h="int32";o.map(p=>{r.push({type:h,data:p});const g=gn(p);r.push({type:h,data:g})})}else{const h=gn(t.shape);r.push({type:a,data:h})}if(e.size){const h=Le(e.outputShape);r.push({type:a,data:[e.outputComponent?h/e.outputComponent:h]})}i&&(r=[...r,...i]);const l=[this.tensorToBinding(t),...s.map(h=>this.tensorToBinding(h)),this.makeUniforms(r)];s.forEach(h=>{this.commandQueueOwnedIds.add(h.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const c=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:l.map((h,p)=>({binding:p,resource:h}))}),u=this.activeTimers!=null;this.ensureCommandEncoderReady();const d={};u&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),d.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(d)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(d)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,c),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(u||ze().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===zf.DRAW)&&(this.endComputePassEncoder(),u?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),s=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,t=SMe){return ze().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&Le(s.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}qw.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */xV()&&yT("webgpu",async()=>{const n={powerPreference:ze().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),t.requiredFeatures=s;const i=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:i.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:i.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:i.maxStorageBufferBindingSize,maxBufferSize:i.maxBufferSize,maxComputeWorkgroupSizeX:i.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:i.maxComputeInvocationsPerWorkgroup};const r=await e.requestDevice(t),o="info"in e?e.info:"requestAdapterInfo"in e?await e.requestAdapterInfo():void 0;return new qw(r,o)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Fn;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(Fn||(Fn={}));const _Me="let resultTemp = a + b;",EMe="let resultTemp = atan2(a, b);",TMe="let resultTemp = areal * breal - aimag * bimag;",IMe="let resultTemp = areal * bimag + aimag * breal;",kMe="let resultTemp = a / b;",AMe="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",RMe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,MMe=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,NMe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,PMe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,DMe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,LMe=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,$Me="return f32(a >= 1.0 && b >= 1.0);",FMe=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,OMe="return f32(a >= 1.0 || b >= 1.0);",zMe=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,BMe="let resultTemp = max(a, b);",UMe="let resultTemp = min(a, b);",VMe=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,WMe=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,GMe="let resultTemp = a * b;",HMe=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,jMe=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,XMe=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,qMe=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,KMe="if (a < 0.0) { return b * a; }  return a;",YMe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,ZMe="let resultTemp = (a - b) * (a - b);",QMe="let resultTemp = a - b;";function BI(n,e){let t;do{switch(n){case Fn.ATAN2:t=EMe;break;case Fn.MAX:t=BMe;break;case Fn.MIN:t=UMe;break;case Fn.MOD:t=e?WMe:VMe;break;case Fn.NOT_EQUAL:t=e?jMe:HMe;break;case Fn.POW:t=e?qMe:XMe;break;default:continue}let s,i,r;return e?(s="isnanVec4",i="vec4<f32>",r="vec4<bool>"):(s="isnan",i="f32",r="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${i}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${i}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${i}(valueForNaN),
            ${r}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case Fn.ADD:t=_Me;break;case Fn.COMPLEX_MULTIPLY_IMAG:t=IMe;break;case Fn.COMPLEX_MULTIPLY_REAL:t=TMe;break;case Fn.DIV:t=kMe;break;case Fn.ELU_DER:t=AMe;break;case Fn.EQUAL:t=RMe;break;case Fn.FLOOR_DIV:t=MMe;break;case Fn.GREATER:t=NMe;break;case Fn.GREATER_EQUAL:t=PMe;break;case Fn.LESS:t=DMe;break;case Fn.LESS_EQUAL:t=LMe;break;case Fn.LOGICAL_AND:return e?FMe:$Me;case Fn.LOGICAL_OR:return e?zMe:OMe;case Fn.MUL:t=GMe;break;case Fn.PRELU:return e?YMe:KMe;case Fn.SQUARED_DIFFERENCE:t=ZMe;break;case Fn.SUB:t=QMe;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $t;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})($t||($t={}));const JMe="return abs(a);",eNe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,tNe=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,nNe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,sNe="return asinh(a);",iNe=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,rNe=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,oNe="return ceil(a);",aNe="return cos(a);",lNe=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,cNe="return exp(a) - 1.0;",uNe="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",dNe=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,hNe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${vw};
  let a1 = ${yw};
  let a2 = ${ww};
  let a3 = ${bw};
  let a4 = ${Sw};
  let a5 = ${Cw};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,fNe="return exp(a);",pNe="return floor(a);",mNe="return f32(!isnan(a) && !isinf(a));",gNe="return f32(isinf(a));",xNe="return f32(isnan(a));",vNe="return a;",yNe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,wNe=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,bNe="return f32(!(a >= 1.0));",SNe="return -a;",CNe="if (a < 0.0) { return uniforms.alpha * a; } return a;",_Ne=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,ENe="return 1.0 / a;",TNe="return select(a, 0.0, a < 0.0);",INe="return clamp(a, 0.0, 6.0);",kNe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",ANe=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,RNe="return round(a);",MNe="return inverseSqrt(a);",NNe=`
  if (a >= 0.0) {
    return ${m1} * a;
  } else {
    return ${p1} * (exp(a) - 1.0);
  }
`,PNe="return 1.0 / (1.0 + exp(-1.0 * a));",DNe="return sign(a);",LNe="return sin(a);",$Ne=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,FNe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,ONe="return sqrt(a);",zNe="return a * a;",BNe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,UNe="return tan(a);",VNe=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,WNe="return f32(i32((a)));";function Ku(n,e){switch(n){case $t.ABS:return JMe;case $t.ACOS:return eNe;case $t.ACOSH:return tNe;case $t.ASIN:return nNe;case $t.ASINH:return sNe;case $t.ATAN:return iNe;case $t.ATANH:return rNe;case $t.COS:return aNe;case $t.COSH:return lNe;case $t.CEIL:return oNe;case $t.ELU:return e?dNe:uNe;case $t.ERF:return hNe;case $t.EXP:return fNe;case $t.EXPM1:return cNe;case $t.FLOOR:return pNe;case $t.IS_FINITE:return mNe;case $t.IS_INF:return gNe;case $t.IS_NAN:return xNe;case $t.LINEAR:return vNe;case $t.LOG:return yNe;case $t.LOG1P:return wNe;case $t.LOGICAL_NOT:return bNe;case $t.NEG:return SNe;case $t.LEAKYRELU:return e?_Ne:CNe;case $t.RECIPROCAL:return ENe;case $t.RELU:return e?ANe:TNe;case $t.RELU6:return e?kNe:INe;case $t.ROUND:return RNe;case $t.RSQRT:return MNe;case $t.SELU:return NNe;case $t.SIGMOID:return PNe;case $t.SIGN:return DNe;case $t.SIN:return LNe;case $t.SINH:return $Ne;case $t.SOFTPLUS:return FNe;case $t.SQRT:return ONe;case $t.SQUARE:return zNe;case $t.STEP:return BNe;case $t.TAN:return UNe;case $t.TANH:return VNe;case $t.TO_INT:return WNe;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vc(n,e=!1,t=!1,s=3){if(n===null)return"";let i="";if(n==="linear")i=Ku($t.LINEAR);else if(n==="relu")i=Ku($t.RELU,t);else if(n==="elu")i=Ku($t.ELU,t);else if(n==="relu6")i=Ku($t.RELU6,t);else if(n==="prelu")i=BI(Fn.PRELU,t);else if(n==="sigmoid")i=Ku($t.SIGMOID,t);else if(n==="leakyrelu")i=Ku($t.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const o=es(t?4:1);let a="";return e?a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${i}
      }`:a=`
      fn activation(a : ${o}, coords : vec${s}<i32>) -> ${o} {
        ${i}
      }`,a}function Jd(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yV(n,e,t=!1,s=!1,i=!1,r=1){re(n&&r===1||!n,()=>`transposeA ${n} is not compatible with component size ${r}`);const o=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${es(r)} {
    var value = ${es(r)}(0.0);
    ${t&&i?o:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${es(r)} {
    var value = ${es(r)}(0.0);
    ${a}
    return value;
  }
  `}function UI(n,e,t,s,i=!1,r=!1,o=!1,a=1){return`
  ${yV(t,s,i,r,o,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${es(a)}) {
    ${i&&r?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Jd(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const GNe=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,HNe=(n,e,t,s)=>{if(n)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let i="",r="";for(let o=0;o<e;o++)i+=`let BCached${o} = mm_Bsub[k * ${e} + ${o}][tileCol];`,r+=`acc[i] = fma(BCached${o}, vec4<f32>(ACached[${o}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${i}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${r}
        }
      }`}};function Kw(n,e,t=!1,s=32,i=!1,r=32,o=!1){const a=e[1]*n[1],l=e[0]*n[0],c=t?a:s,u=t?s:a,d=c/e[0],h=s/e[1],p=n[1],g=n[0];return re((t&&d===4&&n[1]===4||!t&&(d===3||d===4))&&c%e[0]===0&&s%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${d} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${d} must be 3 or 4.
      tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${d}<f32>, ${c/d}>, ${u}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${l/n[0]}>, ${s}>;

  ${Ot()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p};
    let globalCol = i32(globalId.x) * ${g};
    let batch = ${i?"0":"i32(globalId.z)"};
    let batchA = ${i||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${i||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${i?`${Math.ceil(r/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${i?`i32(globalId.z) * ${r}`:"0"};

    var acc: array<vec4<f32>, ${p}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${h};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${GNe(t,d)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${h}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${HNe(t,d,p,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const gL=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,jNe=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Yw(n,e,t=!1,s=32,i=!1,r=32,o=!1,a=!1){const l=n[1]*e[1],c=n[0]*e[0],u=t?l:s,d=t?s:l;re(d%e[1]===0&&u%e[0]===0&&s%e[1]===0,()=>`tileAHight ${d} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const h=d/e[1],p=u/e[0],g=s/e[1],y=n[1],x=n[0],v=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${l};
      let globalColStart = i32(workgroupId.x) * ${c};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${gL(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${x}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${x}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${y}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${x}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${x}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${y};
  let tileCol = i32(localId.x) * ${x};

  let globalRow = i32(globalId.y) * ${y};
  let globalCol = i32(globalId.x) * ${x};
  let globalRowStart = i32(workgroupId.y) * ${l};

  let tileRowA = i32(localId.y) * ${h};
  let tileColA = i32(localId.x) * ${p};
  let tileRowB = i32(localId.y) * ${g};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${h}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${gL(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${g}; innerRow++) {
      for (var innerCol = 0; innerCol < ${x}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${x}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${x}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        ${jNe(t)}
        for (var innerCol = 0; innerCol < ${x}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${y}; innerRow++) {
    for (var innerCol = 0; innerCol < ${x}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${d}>;
    var<workgroup> mm_Bsub : array<array<f32, ${c}>, ${s}>;

    ${Ot()} {
      let batch = ${i?"0":"i32(globalId.z)"};
      let batchA = ${i||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${i||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${i?`${Math.ceil(r/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${i?`i32(globalId.z) * ${r}`:"0"};

      var acc : array<array<f32, ${x}>, ${y}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        for (var innerCol = 0; innerCol < ${x}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${v}
    }
  `}const XNe=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function qNe(n,e=!1){re(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${Ot()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${XNe(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class KNe{constructor(e,t,s=!1,i=!1,r=null,o=null,a=null,l=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const c=s?e[1]:e[2];if(this.isVec4=(c%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!i,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const h=bMe(t[1],c,t[2],s);this.workgroupSize=h.workgroupSize,this.elementsPerThread=h.elementsPerThread}this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const u=r!=null,d=a!=null;u&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=l,this.transposeA=s,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=d,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],c),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${i}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,s){const i=this.workgroupSize[1]*this.elementsPerThread[1],r=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=r;const o=e%i===0,a=t%r===0,l=s%this.tileInner===0;return[o,a,l]}getUserCode(){return`
      ${vc(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${UI(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Kw(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?qNe(this.workgroupSize,this.transposeA):Yw(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YNe(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${Ot()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class ZNe{constructor(e,t=!1,s=!1,i=null,r=null,o=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=i!=null,l=o!=null;a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=s,this.addBias=a,this.activation=r,this.hasPreluActivationWeights=l,this.shaderKey=`matMulReduce_${this.activation}_${t}_${s}`}getUserCode(){return`
      ${vc(this.activation,this.hasPreluActivationWeights)}
      ${UI(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${YNe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QNe(n){const e=n[1],t=n[0],s=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ot()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class JNe{constructor(e,t,s,i=!1,r=!1,o=null,a=null,l=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const c=o!=null;c&&this.variableNames.push("bias");const u=l!=null;u&&this.variableNames.push("preluActivationWeights"),this.transposeA=i,this.transposeB=r,this.addBias=c,this.activation=a,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${i}_${r}`}getUserCode(){return`
      ${vc(this.activation,this.hasPreluActivationWeights)}
      ${UI(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${QNe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ePe{constructor(e,t,s=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,re(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const r=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=r?4:1,r||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Ut(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=i,this.shaderKey=`matMulSplitK_${s}_${i}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${yV(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${es(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Cu("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?Kw(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Yw(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class tPe{constructor(e,t=null,s=null,i=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=i!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${vc(this.activation,this.hasPreluActivationWeights)}
    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Jd(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nPe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qr(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:r}=t;if(r=r||zd(i),r==="string"){const o=fi(r,Le(s));return o.fill(i),e.makeTensorInfo(s,r,o)}else{const o=new nPe(s),a=[{type:"float32",data:[i]}];return e.runWebGPUProgram(o,[],r,a)}}const sPe={kernelName:Py,backendName:"webgpu",kernelFunc:Qr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(n){const{inputs:e,attrs:t}=n,{x:s}=e,{shape:i}=t,r=Le(s.shape),o=KE(i,r),a=Le(o);return re(r===a,()=>`The new shape (${o}) has ${a} elements and the old shape (${s.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(s.dataId),{dataId:s.dataId,shape:o,dtype:s.dtype}}const iPe={kernelName:Y0,backendName:"webgpu",kernelFunc:cn};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zw({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,d=t?n.shape[c-2]:n.shape[c-1],h=s?e.shape[u-1]:e.shape[u-2],p=t?n.shape[c-1]:n.shape[c-2],g=s?e.shape[u-2]:e.shape[u-1],y=n.shape.slice(0,-2),x=e.shape.slice(0,-2),v=Le(y),b=Le(x),C=Mn(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,g]);re(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const E=t?[v,d,p]:[v,p,d],k=s?[b,g,h]:[b,h,g],R=cn({inputs:{x:n},backend:i,attrs:{shape:E}}),L=cn({inputs:{x:e},backend:i,attrs:{shape:k}}),I=[R,L],T=Math.max(v,b),M=[R,L],j=[{type:"int32",data:[p]},{type:"int32",data:[g]},{type:"int32",data:[d]}];let W,z;const X=[T,p,g];let B=ze().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(B<0){const K=ze().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),ee=K>0?K:i.thresholdToIncreaseWorkgroups,ne=T*Math.ceil(p/32)*Math.ceil(g/32);ne<=ee||p<=8&&ne<=ee*2?T*p*g<=128?B=tl.MatMulReduceProgram:T===1&&h>=2e3?B=tl.MatMulSplitKProgram:B=tl.MatMulSmallOutputSizeProgram:B=tl.MatMulPackedProgram}switch(B){case tl.MatMulReduceProgram:W=new ZNe(X,t,s,r,l,o);break;case tl.MatMulSplitKProgram:{if(z=Qr({backend:i,attrs:{shape:X,value:0,dtype:n.dtype}}),W=new ePe(X,h,t,s),r||l){z=i.runWebGPUProgram(W,M,n.dtype,j,z);const ee=new tPe(z.shape,r,l,o);let ne=null;const V=[z];r&&V.push(r),o&&V.push(o),l==="leakyrelu"&&(ne=[{type:"float32",data:[a]}],ee.uniforms+=" alpha : f32,");const Z=i.runWebGPUProgram(ee,V,z.dtype,ne);I.push(z);const he=cn({inputs:{x:Z},backend:i,attrs:{shape:C}});I.push(Z);for(const ve of I)i.disposeData(ve.dataId);return he}break}case tl.MatMulSmallOutputSizeProgram:W=new JNe(E,k,X,t,s,r,l,o);break;case tl.MatMulPackedProgram:const K=i.adapterInfo.isIntel();W=new KNe(E,X,t,s,r,l,o,K);break;default:throw new Error(`Unsupported MatMulProgramType ${B}.`)}r&&M.push(r),o&&M.push(o),l==="leakyrelu"&&(j.push({type:"float32",data:[a]}),W.uniforms+=" alpha : f32,"),z=i.runWebGPUProgram(W,M,n.dtype,j,z);const J=cn({inputs:{x:z},backend:i,attrs:{shape:C}});I.push(z);for(const K of I)i.disposeData(K.dataId);return J}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rPe(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=s;return Zw({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}const oPe={kernelName:Dg,backendName:"webgpu",kernelFunc:rPe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xL{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Mn(t,s),this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${BI(this.op,!1)}
      }

      ${Ot("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class V2{constructor(e,t,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Mn(t,s),this.dispatchLayout=en(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&s.length>1&&t[0]<128,this.useSharedMemoryWithB=s.length<=1&&t.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const i=t.length>0&&t[t.length-1]%4===0,r=s.length>0&&s[s.length-1]%4===0;i&&r?(this.outputComponent=4,this.variableComponents=[4,4]):i&&(bP(s)||s[s.length-1]===1)||r&&(bP(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=i?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${BI(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const i=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${i}];`:`let a = sharedBuf[${i}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ot("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${r}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${Ot("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const aPe={kernelName:xp,backendName:"webgpu",kernelFunc:wo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eh(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.makeTensorInfo(s.shape,"complex64"),o=t.tensorMap.get(r.dataId),a=wo({inputs:{x:s},backend:t}),l=wo({inputs:{x:i},backend:t});return o.complexTensorInfos={real:a,imag:l},r}const lPe={kernelName:wy,backendName:"webgpu",kernelFunc:eh};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class om{constructor(e,t,s=""){this.variableNames=["A"],this.size=!0;const i=128;this.workgroupSize=[i,1,1],this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Ku(this.op,!1)}
      }
      ${Ot("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:s,backend:i})=>{const{x:r}=s,o=i,a=t||r.dtype;if(o.shouldExecuteOnCPU([r])&&e!=null){const c=o.tensorMap.get(r.dataId),u=e(c.values,a);return o.makeTensorInfo(r.shape,a,u)}const l=new om(r.shape,n);return o.runWebGPUProgram(l,[r],a)}}function tr({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:s}){return({inputs:i,backend:r})=>{const{a:o,b:a}=i,l=r;if(t&&o.dtype==="complex64"){const d=l.tensorMap.get(o.dataId),h=l.tensorMap.get(a.dataId);let p,g;if(n!==Fn.MUL)[p,g]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(x=>{const[v,b]=x,S={dataId:v.dataId,dtype:v.dtype,shape:o.shape},C={dataId:b.dataId,dtype:b.dtype,shape:a.shape},E=new V2(n,o.shape,a.shape);return l.runWebGPUProgram(E,[S,C],Ji(v.dtype,b.dtype))});else{const x=new xL(Fn.COMPLEX_MULTIPLY_REAL,o.shape,a.shape),v=new xL(Fn.COMPLEX_MULTIPLY_IMAG,o.shape,a.shape),b=[{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:o.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:a.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:a.shape}];p=l.runWebGPUProgram(x,b,"float32"),g=l.runWebGPUProgram(v,b,"float32")}const y=eh({inputs:{real:p,imag:g},backend:l});return l.disposeData(p.dataId),l.disposeData(g.dataId),y}const c=s||Ji(o.dtype,a.dtype);if((o.dtype==="string"||a.dtype==="string"||l.shouldExecuteOnCPU([o,a]))&&e!=null){const d=l.tensorMap.get(o.dataId).values,h=l.tensorMap.get(a.dataId).values,p=o.dtype==="string"?Oa(d):d,g=o.dtype==="string"?Oa(h):h,[y,x]=e(o.shape,a.shape,p,g,c);return l.makeTensorInfo(x,c,y)}const u=new V2(n,o.shape,a.shape);return l.runWebGPUProgram(u,[o,a],c)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:cPe,castImpl:uPe,ceilImpl:dPe,concatImpl:hPe,equalImpl:fPe,expImpl:pPe,expm1Impl:mPe,floorImpl:gPe,floorDivImpl:xPe,gatherNdImpl:vPe,gatherV2Impl:yPe,greaterEqualImpl:wPe,greaterImpl:bPe,lessEqualImpl:SPe,lessImpl:CPe,logImpl:_Pe,maxImpl:EPe,maximumImpl:TPe,minimumImpl:IPe,multiplyImpl:kPe,negImpl:APe,notEqualImpl:RPe,prodImpl:MPe,rangeImpl:NPe,rsqrtImpl:PPe,scatterImpl:DPe,simpleAbsImpl:LPe,sliceImpl:$Pe,stridedSliceImpl:FPe,stringNGramsImpl:OPe,subImpl:zPe,tileImpl:BPe,topKImpl:UPe,transposeImpl:VPe}=o8;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WPe=ys({opType:$t.ABS,cpuKernelImpl:LPe}),GPe={kernelName:c0,backendName:"webgpu",kernelFunc:WPe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HPe=ys({opType:$t.ACOS}),jPe={kernelName:Zf,backendName:"webgpu",kernelFunc:HPe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XPe=ys({opType:$t.ACOSH}),qPe={kernelName:Qf,backendName:"webgpu",kernelFunc:XPe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KPe=tr({opType:Fn.ADD,cpuKernelImpl:cPe,supportsComplex:!0}),YPe={kernelName:Bd,backendName:"webgpu",kernelFunc:KPe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZPe{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(i=>{e.push(`let v${i} = get${i}ByOutputCoords(coords);`)});const t=this.variableNames.map(i=>`v${i}`).join(" + ");return`
      ${Ot("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QPe(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return wo({inputs:{x:s[0]},backend:t});const i=s.map(a=>a.dtype).reduce((a,l)=>Ji(a,l)),r=s.map(a=>a.shape),o=new ZPe(r);return t.runWebGPUProgram(o,s,i)}const JPe={kernelName:py,backendName:"webgpu",kernelFunc:QPe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eDe{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){re(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Ot()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tDe{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[t[i]];this.outputShape=s,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=yi(this.outputShape.length),t=wV(this.newDim);return`
      ${Ot("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function wV(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let s=0;s<n.length;s++)t[n[s]]=`coords.${cc(s)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kl(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:r}=s,o=t,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[r[u]];if(t.shouldExecuteOnCPU([i])){const d=o.tensorMap.get(i.dataId).values,h=VPe(d,i.shape,i.dtype,r,l);return t.makeTensorInfo(l,i.dtype,h)}if(i.shape.length===2&&ds(r,[1,0])){const u=new eDe(i.shape,r);return o.runWebGPUProgram(u,[i],i.dtype)}const c=new tDe(i.shape,r);return o.runWebGPUProgram(c,[i],i.dtype)}const nDe={kernelName:fd,backendName:"webgpu",kernelFunc:kl};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sDe{constructor(e,t,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[i]=Ci(this.inputShape,[1]);this.outputShape=i.length===0?[1]:i,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const i=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ot("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${i}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iDe={mean:"float32",all:"bool",any:"bool"};function th(n,e,t,s,i){const r=n.shape.length,o=[],a=Hn(e,n.shape);let l=a;const c=Os(l,r);let u=n;c!=null&&(u=kl({inputs:{x:n},attrs:{perm:c},backend:i}),l=Ys(l.length,r),o.push(u)),Ai(s,l,r);const[d,h]=Ci(u.shape,l);let p=d;t&&(p=Si(d,a));let g;if((s==="max"||s==="prod")&&i.shouldExecuteOnCPU([u])){const y=i.tensorMap.get(u.dataId).values;switch(s){case"max":const x=EPe(y,Le(h),p,n.dtype);g=i.makeTensorInfo(p,n.dtype,x);break;case"prod":const{outVals:v,outShape:b,outDtype:S}=MPe(u.shape,u.dtype,y,l);g=i.makeTensorInfo(b,S,v);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const y=Le(h),v=Le(u.shape)/y,b={windowSize:y,inSize:y,batchSize:v,outSize:1},S=iDe[s]||Qy(n.dtype),C=[{type:"int32",data:[y]}],E=new sDe(b,s,i.device.limits.maxComputeWorkgroupSizeX),k=i.runWebGPUProgram(E,[u],S,C);o.push(k),g=cn({inputs:{x:k},attrs:{shape:p},backend:i})}return o.forEach(y=>i.disposeData(y.dataId)),g}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{keepDims:r,axis:o}=s;return th(i,o,r,"all",t)}const oDe={kernelName:my,backendName:"webgpu",kernelFunc:rDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{keepDims:r,axis:o}=s;return th(i,o,r,"any",t)}const lDe={kernelName:gy,backendName:"webgpu",kernelFunc:aDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bV{constructor(e,t,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op=s==="min"?"<":">";const[r,o]=Ci(e,i);this.outputShape=r.length===0?[1]:r,this.dispatchLayout=en(this.outputShape),Le(o)<32?(this.type="plain",this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Ut(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${cc(this.inputShape.length-1)}`,s=()=>{let i="";if(this.outputShape.length===1)this.inputShape.length!==1&&(i+="outputCoords,");else for(let r=0;r<this.outputShape.length;r++)i+=`outputCoords.${cc(r)},`;return i};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Ot("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Hn(r,i.shape);const a=Os(o,i.shape.length);let l=i;const c=[];a!=null&&(l=kl({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Ys(o.length,l.shape.length)),Ai("argMax",[o[0]],l.shape.length);const u=new bV(l.shape,o[0],"max"),d=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],h=t.runWebGPUProgram(u,[l],"int32",d);return c.forEach(p=>t.disposeData(p.dataId)),h}const uDe={kernelName:u0,backendName:"webgpu",kernelFunc:cDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let o=Hn(r,i.shape);const a=Os(o,i.shape.length);let l=i;const c=[];a!=null&&(l=kl({inputs:{x:i},backend:t,attrs:{perm:a}}),c.push(l),o=Ys(o.length,l.shape.length)),Ai("argMin",[o[0]],l.shape.length);const u=new bV(l.shape,o[0],"min"),d=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],h=t.runWebGPUProgram(u,[l],"int32",d);return c.forEach(p=>t.disposeData(p.dataId)),h}const hDe={kernelName:d0,backendName:"webgpu",kernelFunc:dDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fDe=ys({opType:$t.ASIN}),pDe={kernelName:Jf,backendName:"webgpu",kernelFunc:fDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mDe=ys({opType:$t.ASINH}),gDe={kernelName:ep,backendName:"webgpu",kernelFunc:mDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xDe=ys({opType:$t.ATAN}),vDe={kernelName:tp,backendName:"webgpu",kernelFunc:xDe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yDe=tr({opType:Fn.ATAN2}),wDe={kernelName:sp,backendName:"webgpu",kernelFunc:yDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bDe=ys({opType:$t.ATANH}),SDe={kernelName:np,backendName:"webgpu",kernelFunc:bDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CDe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kg{constructor(e,t,s=!1,i=!1,r=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=r,this.shaderKey=`pool2D_${t}_${s}_${i}_${r}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class VI{constructor(e,t,s=!1,i=!1,r=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=s,this.flattenPositions=i,this.includeBatchIndex=r,this.shaderKey=`pool3D_${t}_${s}_${i}_${r}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:o}=s;return th(i,r,o,"max",t)}const _De={kernelName:$0,backendName:"webgpu",kernelFunc:SV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{keepDims:r,axis:o}=s;return th(i,o,r,"mean",t)}const EDe={kernelName:z0,backendName:"webgpu",kernelFunc:CV};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _V(n,e,t,s){if(e.filterWidth===1&&e.filterHeight===1&&ds(e.inShape,e.outShape))return wo({inputs:{x:n},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const o=n.shape.length,a=cn({inputs:{x:n},backend:s,attrs:{shape:[n.shape[o-3]*n.shape[o-2],n.shape[o-1]]}});let l;t==="avg"?l=CV({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(re(t==="max",()=>`Invalid pool type ${t}`),l=SV({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const c=cn({inputs:{x:l},backend:s,attrs:{shape:e.outShape}});return s.disposeData(a.dataId),s.disposeData(l.dataId),c}let i;const r=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?i=new CDe(e):(t==="avg"?i=new Kg(e,"avg"):(re(t==="max",()=>`Invalid pool type ${t}`),i=new Kg(e,"max")),r.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(i,[n],n.dtype,r)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,u=br(i.shape,r,o,1,a,l);return _V(i,u,"avg",t)}const IDe={kernelName:h0,backendName:"webgpu",kernelFunc:TDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],d=Fo(i.shape,r,o,u,a,c,l),h=new VI(d,"avg"),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return t.runWebGPUProgram(h,[i],i.dtype,p)}const ADe={kernelName:f0,backendName:"webgpu",kernelFunc:kDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RDe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class MDe{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NDe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,d=Fo(o.shape,a,l,1,c,u),h=new MDe(d),p=1/(d.filterDepth*d.filterHeight*d.filterWidth),g=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[p]}];return t.runWebGPUProgram(h,[i],o.dtype,g)}const PDe={kernelName:vy,backendName:"webgpu",kernelFunc:NDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DDe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r;vV([i,r],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=br(o.shape,a,l,1,c),d=new RDe(u),h=1/(u.filterHeight*u.filterWidth),p=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.effectiveFilterHeight-1-u.padInfo.top,u.effectiveFilterWidth-1-u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]},{type:"int32",data:[u.outHeight]},{type:"int32",data:[u.outWidth]},{type:"float32",data:[h]}];return t.runWebGPUProgram(d,[i],o.dtype,p)}const LDe={kernelName:xy,backendName:"webgpu",kernelFunc:DDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $De(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:o,transposeB:a}=s;return Zw({a:i,b:r,transposeA:o,transposeB:a,backend:t})}const FDe={kernelName:p0,backendName:"webgpu",kernelFunc:$De};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ODe{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${yi(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=yi(this.rank),t=zDe(this.rank);let s;return this.start.length===1?s=this.outputShape.map((r,o)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((r,o)=>`sourceLoc.${D_[o]} = uniforms.start.${cc(o)} + coords.${D_[o]};`),`
      ${Ot("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const D_=["x","y","z","w","u","v"];function zDe(n){if(n===1)return"sourceLoc";if(n<=6)return D_.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function am(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:o}=s,[a,l]=f1(i,r,o);if(uw(i,a,l),t.shouldExecuteOnCPU([i])||i.dtype==="string"){const d=t.tensorMap.get(i.dataId),h=$Pe(d.values,a,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,h)}if(Le(l)===0)return t.makeTensorInfo(l,i.dtype,[]);const c=new ODe(a,l),u=[{type:"int32",data:a}];return t.runWebGPUProgram(c,[i],i.dtype,u)}const BDe={kernelName:t1,backendName:"webgpu",kernelFunc:am};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UDe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:o}=s;re(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=r.reduce((b,S)=>b*S),l=Gd(i.shape,r,a),c=Hd(l.length,r.length),u=jd(i.shape,r,a),d=gw(o,r.length),h=xw(u,o,r.length),p=[],g=cn({inputs:{x:i},backend:t,attrs:{shape:l}}),y=kl({inputs:{x:g},backend:t,attrs:{perm:c}}),x=cn({inputs:{x:y},backend:t,attrs:{shape:u}}),v=am({inputs:{x},backend:t,attrs:{begin:d,size:h}});return p.push(g),p.push(y),p.push(x),p.forEach(b=>t.disposeData(b.dataId)),v},VDe={kernelName:m0,backendName:"webgpu",kernelFunc:UDe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WDe=`
  fn bincount_write(index: i32, value: f32) {
    ${Cu("&result[index]","value","float32")}
  }
`,GDe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class EV{constructor(e,t,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?GDe:WDe}
  ${Ot("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HDe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o}=s,a=Le(i.shape),c=Le(r.shape)>0,u=[o],d=r.dtype,h=Qr({backend:t,attrs:{shape:u,value:0,dtype:d}}),p=new EV([a],c),g=[{type:"int32",data:[o]}],y=c?[i,r]:[i];return t.runWebGPUProgram(p,y,d,g,h)}const jDe={kernelName:yy,backendName:"webgpu",kernelFunc:HDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XDe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Ot("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qDe(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e;if(t.shouldExecuteOnCPU([s,i])){const u=t.tensorMap.get(s.dataId),d=t.tensorMap.get(i.dataId),h=u.values,p=d.values,g=Mn(Array.from(h),Array.from(p));return t.makeTensorInfo([g.length],"int32",Int32Array.from(g))}const r=Le(s.shape),o=Le(i.shape),a=Math.max(r,o),l=new XDe(a),c=[{type:"int32",data:[r]},{type:"int32",data:[o]}];return t.runWebGPUProgram(l,[s,i],"int32",c)}const KDe={kernelName:tT,backendName:"webgpu",kernelFunc:qDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TV=tr({opType:Fn.NOT_EQUAL,dtype:"bool",cpuKernelImpl:RPe}),YDe={kernelName:W0,backendName:"webgpu",kernelFunc:TV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.tensorMap.get(s.dataId);return wo({inputs:{x:i.complexTensorInfos.real},backend:t})}const ZDe={kernelName:Wy,backendName:"webgpu",kernelFunc:R1};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QDe(n,e){const t=new om(n.shape,$t.TO_INT),s=e.runWebGPUProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return wo({inputs:{x:i},backend:t});const o=Oi(i.shape),a=L_({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=eh({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeData(a.dataId),l}if(i.dtype==="complex64"){const o=R1({inputs:{input:i},backend:t}),a=L_({inputs:{x:o},backend:t,attrs:{dtype:r}});return t.disposeData(o.dataId),a}if(!YE(i.dtype,r)){const o=wo({inputs:{x:i},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const o=t.tensorMap.get(i.dataId).values,[a,l,c]=uPe(o,i.shape,i.dtype,r);return t.makeTensorInfo(a,l,c)}if(r==="int32")return QDe(i,t);if(r==="bool"){const o=t.makeTensorInfo([],"bool",Qi("bool",1)),l=TV({inputs:{a:i,b:o},backend:t});return t.disposeData(o.dataId),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const JDe={kernelName:ip,backendName:"webgpu",kernelFunc:L_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eLe=ys({opType:$t.CEIL,cpuKernelImpl:dPe}),tLe={kernelName:rp,backendName:"webgpu",kernelFunc:eLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nLe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ot("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sLe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ot("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:r,clipValueMax:o}=s;let a;const l=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return Le(i.shape)%4===0?a=new nLe(i.shape):a=new sLe(i.shape),t.runWebGPUProgram(a,[i],i.dtype,l)}const rLe={kernelName:op,backendName:"webgpu",kernelFunc:iLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oLe{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vL(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function aLe(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.tensorMap.get(s.dataId),r=new oLe(s.shape),o=[vL(s,i.complexTensorInfos.real),vL(s,i.complexTensorInfos.imag)];return t.runWebGPUProgram(r,o,o[0].dtype)}const lLe={kernelName:g0,backendName:"webgpu",kernelFunc:aLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cLe{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Zr(e,1),this.variableNames=e.map((t,s)=>`T${s}`),this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let r=1;r<this.offsetLength;r++)e.push(`else if (yC < uniforms.offset${[r]}){ setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${r-1})); }`);const s=this.offsetLength,i=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${i})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ot("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.tensorMap.get(s.dataId);return wo({inputs:{x:i.complexTensorInfos.imag},backend:t})}const uLe={kernelName:$y,backendName:"webgpu",kernelFunc:Qw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cg(n,e,t){const s=n[0].dtype;if(s==="complex64"){const g=n.map(S=>R1({inputs:{input:S},backend:t})),y=n.map(S=>Qw({inputs:{input:S},backend:t})),x=cg(g,e,t),v=cg(y,e,t),b=eh({inputs:{real:x,imag:v},backend:t});return g.forEach(S=>t.disposeData(S.dataId)),y.forEach(S=>t.disposeData(S.dataId)),t.disposeData(x.dataId),t.disposeData(v.dataId),b}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const g=n.map(E=>{const R=[-1,Le(E.shape.slice(e))];return cn({inputs:{x:E},backend:t,attrs:{shape:R}})}),y=g.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),x=Zr(g.map(E=>E.shape),1),v=g[0].shape[0]===1,b=hPe(y,x,s,v),S=Zr(n.map(E=>E.shape),e),C=t.makeTensorInfo(S,s,b);return g.forEach(E=>t.disposeData(E.dataId)),C}const r=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>r){const g=[];for(let x=0;x<n.length;x+=r){const v=n.slice(x,x+r);g.push(cg(v,e,t))}const y=cg(g,e,t);for(const x of g)t.disposeData(x.dataId);return y}const{tensors2D:o,outShape:a}=dLe(n,e,t),l=o.map(g=>g.shape),c=new cLe(l),u=[],d=new Array(l.length-1);if(d.length>0){d[0]=l[0][1],u.push({type:"int32",data:[d[0]]});for(let g=1;g<d.length;g++)d[g]=d[g-1]+l[g][1],u.push({type:"int32",data:[d[g]]})}const h=t.runWebGPUProgram(c,o,o[0].dtype,u);o.forEach(g=>t.disposeData(g.dataId));const p=cn({inputs:{x:h},backend:t,attrs:{shape:a}});return t.disposeData(h.dataId),p}function dLe(n,e,t){const s=Zr(n.map(r=>r.shape),e);return{tensors2D:n.map(r=>cn({inputs:{x:r},backend:t,attrs:{shape:[Le(r.shape.slice(0,e)),Le(r.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IV(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=Hn(i,e[0].shape)[0],o=e.map(c=>c.shape);fw(o,r);const a=Zr(e.map(c=>c.shape),r);if(Le(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Le(c.shape)>0);return l.length===1?wo({inputs:{x:l[0]},backend:t}):cg(l,r,t)}const hLe={kernelName:x0,backendName:"webgpu",kernelFunc:IV};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fLe(n,e,t,s,i=!1,r=null,o=!1,a=4,l=4,c=4){const u=I=>{switch(I){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${I} is not supported.`)}},d=I=>{switch(I){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${I} is not supported.`)}},h=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,p=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,g=n?"uniforms.xShape[1]":"uniforms.xShape[2]",y=n?"uniforms.xShape[2]":"uniforms.xShape[3]",x=n?"row":"col",v=n?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${x} / outWidth;
      let outCol = ${x} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${v} % inChannels;
      var resData = ${es(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${g} && xCol >= 0 && xCol < ${y}) {
        ${h}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${u(a)}
      }
      return resData;`,S=n?e&&s?`
      ${b}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${es(a)}(0.0);`:s&&t?`
      ${b}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${es(a)}(0.0);`,C=`${d(l)}`,E=es(c),k=es(n?a:l),R=es(n?l:a);return`
      ${vc(r,o,c===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${k} {
        ${n?S:C}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${R} {
        ${n?C:S}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${E}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${p}
        ${Jd(i,r)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class pLe{constructor(e,t,s,i,r=!1,o=null,a=!1,l=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=mV(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=gV(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),r&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=l,this.addBias=r,this.activation=o,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=i%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?Kw(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Yw(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${fLe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mLe{constructor(e,t=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=s,this.hasPreluActivationWeights=i,t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${vc(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Jd(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Ot("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gLe{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",i=this.isChannelsLast?"coords[2]":"coords[1]",r=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Ot("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${i};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${r};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W2(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function xLe({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.dataFormat==="channelsLast",c=!l,u=!1,d=l&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",h=[];let p,g;if(d){const v=t.inHeight*t.inWidth*t.inChannels;p=cn({inputs:{x:n},backend:s,attrs:{shape:[1,t.batchSize,v]}}),g=cn({inputs:{x:e},backend:s,attrs:{shape:[1,v,t.outChannels]}})}else p=cn({inputs:{x:n},backend:s,attrs:{shape:l?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),g=cn({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(h.push(p),h.push(g),r!=null){const v=W2(r.shape,l);v!=null&&(r=cn({inputs:{x:r},backend:s,attrs:{shape:v}}),h.push(r))}if(i!=null){const v=W2(i.shape,l);v!=null&&(i=cn({inputs:{x:i},backend:s,attrs:{shape:v}}),h.push(i))}const y=Zw({a:l?p:g,b:l?g:p,transposeA:c,transposeB:u,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),x=cn({inputs:{x:y},backend:s,attrs:{shape:t.outShape}});h.push(y);for(const v of h)s.disposeData(v.dataId);return x}function vLe({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,strideWidth:d,strideHeight:h,padInfo:p,outWidth:g,outHeight:y,dilationWidth:x,dilationHeight:v,dataFormat:b}=t,S=b==="channelsLast",C=l*c*u,E=y*g,k=S?[t.batchSize,E,C]:[t.batchSize,C,E],R=new gLe(k,S),L=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[h,d]},{type:"int32",data:[v,x]},{type:"int32",data:[g]},{type:"int32",data:[u*l]},{type:"int32",data:[u]}],I=s.runWebGPUProgram(R,[n],n.dtype,L),T=[];T.push(I);const M=cn({inputs:{x:e},backend:s,attrs:{shape:[1,C,-1]}});if(T.push(M),r!=null){const B=W2(r.shape,S);B!=null&&(r=cn({inputs:{x:r},backend:s,attrs:{shape:B}}),T.push(r))}if(i!=null){const B=W2(i.shape,S);B!=null&&(i=cn({inputs:{x:i},backend:s,attrs:{shape:B}}),T.push(i))}const z=Zw({a:S?I:M,b:S?M:I,transposeA:!S,transposeB:!1,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o}),X=cn({inputs:{x:z},backend:s,attrs:{shape:t.outShape}});T.push(z);for(const B of T)s.disposeData(B.dataId);return X}function kV({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:o=0,activation:a=null}){const l=i!=null,c=r!=null,u=t.dataFormat==="channelsLast",d=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",h=ze().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!h&&(d||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return xLe({x:n,filter:e,convInfo:t,backend:s,bias:i,activation:a,preluActivationWeights:r,leakyreluAlpha:o});const p=ze().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),g=p>-1?p:s.thresholdToIncreaseWorkgroups,y=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(ze().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||y<=g)return vLe({x:n,filter:e,convInfo:t,backend:s,bias:i,preluActivationWeights:r,leakyreluAlpha:o,activation:a});let x;const v=[t.padInfo.top,t.padInfo.left],b=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...v]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(h)x=new mLe(t,l,a,c);else{const k=u?t.outHeight*t.outWidth:t.outChannels,R=u?t.outChannels:t.outHeight*t.outWidth,L=t.filterHeight*t.filterWidth*t.inChannels;b.push({type:"int32",data:[k]},{type:"int32",data:[R]},{type:"int32",data:[L]});const I=s.adapterInfo.isIntel();x=new pLe(t,k,R,L,l,a,c,I)}const S=[],C=[n,e];l&&(!u&&i.shape.length===1&&(i=cn({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),S.push(i)),C.push(i)),c&&(!u&&r.shape.length===1&&(r=cn({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),S.push(r)),C.push(r)),a==="leakyrelu"&&(b.push({type:"float32",data:[o]}),x.uniforms+=" alpha : f32,");const E=s.runWebGPUProgram(x,C,n.dtype,b);for(const k of S)s.disposeData(k.dataId);return E}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yLe(n){const{inputs:e,attrs:t,backend:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=t,d=bo(l),h=Js(i.shape,r.shape,o,c,a,u,!1,d);return kV({x:i,filter:r,convInfo:h,backend:s})}const wLe={kernelName:v0,backendName:"webgpu",kernelFunc:yLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bLe{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,i=`
    ${Ot()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${i}
    `:`
    ${Ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class SLe{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class CLe{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class _Le{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Ot("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ELe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,d=bo(l),h=Js(i.shape,u,o,1,a,c,!1,d),p=new SLe(h),g=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]}];return t.runWebGPUProgram(p,[i,r],i.dtype,g)}const TLe={kernelName:by,backendName:"webgpu",kernelFunc:ELe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ILe(n=4){const e=r=>{switch(r){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${r} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${es(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${es(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${es(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${es(n)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${es(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${es(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${es(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class kLe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,re(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=mV(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=gV(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?Kw(this.elementsPerThread,this.workgroupSize):Yw(this.elementsPerThread,this.workgroupSize);return`
    ${ILe(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ALe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,d=bo(c),h=Js(o,r.shape,a,1,l,u,!1,d),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.batchSize,h.outHeight,h.outWidth,h.outChannels]}];let g;if(ze().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||h.dataFormat!=="channelsLast")g=new bLe(h);else{g=new kLe(h);const y=h.inHeight*h.inWidth,x=h.inChannels,v=h.filterHeight*h.filterWidth*h.outChannels;p.push({type:"uint32",data:[y]},{type:"uint32",data:[x]},{type:"uint32",data:[v]})}return t.runWebGPUProgram(g,[i,r],"float32",p)}const RLe={kernelName:y0,backendName:"webgpu",kernelFunc:ALe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MLe{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=Wa(i.shape,r.shape,o,l,a),u=[c.padInfo.front,c.padInfo.top,c.padInfo.left],d=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationDepth,c.dilationHeight,c.dilationWidth]}],h=new MLe(c),p=Ji(i.dtype,r.dtype);return t.runWebGPUProgram(h,[i,r],p,d)}const PLe={kernelName:w0,backendName:"webgpu",kernelFunc:NLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,pad:a,filterShape:l}=s,c=Wa(i.shape,l,o,1,a),u=new CLe(c),d=[{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inDepth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return t.runWebGPUProgram(u,[i,r],r.dtype,d)}const LLe={kernelName:Sy,backendName:"webgpu",kernelFunc:DLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Le(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,pad:a,inputShape:l}=s,c=Wa(l,r.shape,o,1,a),u=new _Le(c),d=[{type:"int32",data:[c.filterDepth,c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterDepth-1-c.padInfo.front,c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels]}];return t.runWebGPUProgram(u,[i,r],i.dtype,d)}const FLe={kernelName:Cy,backendName:"webgpu",kernelFunc:$Le};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OLe=ys({opType:$t.COS}),zLe={kernelName:ap,backendName:"webgpu",kernelFunc:OLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BLe=ys({opType:$t.COSH}),ULe={kernelName:lp,backendName:"webgpu",kernelFunc:BLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VLe{constructor(e,t,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[r]=t;this.outputShape=[r,s[0],s[1],e],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=i==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,i,r]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[o,a,l]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${o});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${i};
        let width_scale = ${a};
        let in_y = ${r};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${l};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WLe=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,u=new VLe(i.shape[3],r.shape,a,l),d=[{type:"float32",data:[c]}];return t.runWebGPUProgram(u,[i,r,o],"float32",d)},GLe={kernelName:Ey,backendName:"webgpu",kernelFunc:WLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Yg;(function(n){n.Prod="*",n.Sum="+"})(Yg||(Yg={}));class yL{constructor(e,t,s,i){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=i,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Yg.Prod?"1.0":"0.0",s=this.exclusive?t:`getX(${wL(e,"coords",this.op)})`,i=this.outputShape[this.outputShape.length-1];let r="",o="";return this.exclusive?(r=this.reverse?`end != ${i-1}`:"end != 0",o=this.reverse?"end + 1":"end - 1"):(r=this.reverse?`end + pow2 < ${i}`:"end >= pow2",o=this.reverse?"end + pow2":"end - pow2"),`
      ${Ot("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${bL(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${r}) {
           let idx = ${o};
           ${bL(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${wL(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function wL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function bL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AV(n,e,t,s,i,r){const o=e.shape.length,a=Os([s],o);let l=e;a!=null&&(l=kl({inputs:{x:e},backend:t,attrs:{perm:a}}));const c=Ys(1,o)[0];if(c!==o-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const u=l.shape[c];let d=wo({inputs:{x:l},backend:t});for(let h=0;h<=Math.ceil(Math.log2(u))-1;h++){const p=new yL(n,l.shape,!1,r),g=d,y=[{type:"float32",data:[h]}];d=t.runWebGPUProgram(p,[d],d.dtype,y),t.disposeData(g.dataId)}if(i){const h=new yL(n,l.shape,i,r),p=d,g=[{type:"float32",data:[0]}];d=t.runWebGPUProgram(h,[d],d.dtype,g),t.disposeData(p.dataId)}if(a!=null){const h=Nl(a),p=kl({inputs:{x:d},backend:t,attrs:{perm:h}});return t.disposeData(d.dataId),t.disposeData(l.dataId),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return AV(Yg.Prod,i,t,r,o,a)}const jLe={kernelName:_y,backendName:"webgpu",kernelFunc:HLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:o,reverse:a}=s;return AV(Yg.Sum,i,t,r,o,a)}const qLe={kernelName:b0,backendName:"webgpu",kernelFunc:XLe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:o,binaryOutput:a}=s,l=i.shape.length===1,u=Le(r.shape)>0,d=r.dtype,h=l?[i.shape[0]]:[i.shape[0],i.shape[1]],p=l?[o]:[i.shape[0],o],g=Qr({backend:t,attrs:{shape:p,value:0,dtype:d}}),y=new EV(h,u,a),x=[{type:"int32",data:[o]}],v=u?[i,r]:[i];return t.runWebGPUProgram(y,v,d,x,g)}const YLe={kernelName:Ty,backendName:"webgpu",kernelFunc:KLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZLe{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QLe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:o}=s,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],d=l*r,h=c*r,p=u/(r*r),g=o==="NHWC"?[a,d,h,p]:[a,p,d,h],y=[{type:"int32",data:[r]}],x=new ZLe(g,o);return t.runWebGPUProgram(x,[i],i.dtype,y)}const JLe={kernelName:Iy,backendName:"webgpu",kernelFunc:QLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e$e{constructor(e,t,s,i=!1,r=null,o=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=r,this.hasPreluActivation=o,this.filterHeight=t,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,i=this.workgroupSize[0]+this.filterWidth-1;return`
      ${vc(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${i}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ot()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${i}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Jd(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RV{constructor(e,t=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const r=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=en(r),this.dispatch=Ut(this.dispatchLayout,r,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),re(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${vc(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Ot("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Jd(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MV{constructor(e,t=!1,s=null,i=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=s,this.hasPreluActivation=i,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${vc(this.activation,this.hasPreluActivation,!1,4)}

      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Jd(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s,d=bo(l);let h=c;h==null&&(h=[1,1]);const p=Js(i.shape,r.shape,o,h,a,u,!0,d),g=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],y=p.dataFormat==="channelsLast";let x;return!y&&p.inHeight>16&&p.inWidth>16&&p.strideHeight===1&&p.strideWidth===1&&p.dilationWidth===1&&p.dilationHeight===1&&p.inChannels===p.outChannels?x=new e$e(p.outShape,p.filterHeight,p.filterWidth):y&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&p.dilationHeight===1&&p.dilationWidth===1&&p.inChannels%4===0?(x=new RV(p),g.push({type:"int32",data:[x.virtualWidth]})):(x=new MV(p),g.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),t.runWebGPUProgram(x,[i,r],i.dtype,g)}const n$e={kernelName:S0,backendName:"webgpu",kernelFunc:t$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s$e{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class i$e{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s,d=Js(i.shape,u,o,a,l,c,!0),h=new s$e(d),p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outChannels/d.inChannels]}];return t.runWebGPUProgram(h,[i,r],"float32",p)}const o$e={kernelName:ky,backendName:"webgpu",kernelFunc:r$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$e(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s,d=Js(u,r.shape,o,a,l,c,!0),h=new i$e(d),p=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.outChannels/d.inChannels]}];return t.runWebGPUProgram(h,[i,r],i.dtype,p)}const l$e={kernelName:Ay,backendName:"webgpu",kernelFunc:a$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c$e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$e(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],r=Le(s.shape),o=cn({inputs:{x:s},backend:t,attrs:{shape:[r]}}),a=new c$e(r),l=t.runWebGPUProgram(a,[o],o.dtype),c=cn({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const d$e={kernelName:nT,backendName:"webgpu",kernelFunc:u$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class h$e{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Ot("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:o,pad:a,dilations:l}=s,c=gu(i.shape,r.shape,o,a,"NHWC",l),u=[c.padInfo.top,c.padInfo.left],d=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[...u]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]}],h=new h$e(c);return t.runWebGPUProgram(h,[i,r],i.dtype,d)}const p$e={kernelName:C0,backendName:"webgpu",kernelFunc:f$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m$e{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=en(e.outShape),this.dispatch=Ut(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Ot("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Cu("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class g$e{constructor(e,t,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=en(e.outShape),this.dispatch=Ut(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Ot("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Cu("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,dy:o}=e,{strides:a,pad:l,dilations:c}=s,u=gu(i.shape,r.shape,a,l,"NHWC",c),d=r.dtype,h=new g$e(u,r.shape,d),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Le(u.outShape)]}],g=Qr({backend:t,attrs:{shape:r.shape,value:0,dtype:d}});return t.runWebGPUProgram(h,[i,r,o],d,p,g)}const v$e={kernelName:g2,backendName:"webgpu",kernelFunc:x$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,dy:o}=e,{strides:a,pad:l,dilations:c}=s,u=gu(i.shape,r.shape,a,l,"NHWC",c),d=i.dtype,h=new m$e(u,d),p=[{type:"int32",data:[u.filterHeight,u.filterWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[Le(u.outShape)]}],g=Qr({backend:t,attrs:{shape:u.inShape,value:0,dtype:d}});return t.runWebGPUProgram(h,[i,r,o],d,p,g)}const w$e={kernelName:m2,backendName:"webgpu",kernelFunc:y$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b$e{constructor(e,t,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=zf.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=s,this.shaderKey=`draw_${t}_${s}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Ot("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$e(n){const{inputs:e,backend:t,attrs:s}=n,{image:i}=e,{canvas:r,options:o}=s,[a,l]=i.shape.slice(0,2),{imageOptions:c}=o||{},u=(c==null?void 0:c.alpha)||1,d=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",h=[a,l],p=new b$e(h,i.dtype,d);r.width=l,r.height=a;const g="webgpu";let y=r.getContext(g),x;y||(x=new OffscreenCanvas(l,a),y=x.getContext(g));const v=i.shape.length===3?i.shape[2]:1;y.configure({device:t.device,format:d,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",S=t.makeTensorInfo(h,b),C=t.tensorMap.get(S.dataId);C.resource=y.getCurrentTexture(),C.external=!0;const E=[{type:"uint32",data:[v]},{type:"float32",data:[u]}];if(t.runWebGPUProgram(p,[i],b,E,S),x){const k=r.getContext("2d");if(!k)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");k.drawImage(x,0,0)}return t.disposeData(S.dataId),i}const C$e={kernelName:e5,backendName:"webgpu",kernelFunc:S$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NV=tr({opType:Fn.MUL,cpuKernelImpl:kPe,supportsComplex:!0}),_$e={kernelName:Tp,backendName:"webgpu",kernelFunc:NV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return th(i,r,o,"sum",t)}const E$e={kernelName:n1,backendName:"webgpu",kernelFunc:PV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$e(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:o,summedDims:a,idDims:l}=_w(i,r.length);Tw(o.length,l,r);const{path:c,steps:u}=Iw(a,l),d=u.length;let h=null,p=o.length;const g=[];for(let y=0;y<d;++y){for(const x of u[y]){const{permutationIndices:v,expandDims:b}=Ew(p,l[x]);let S;kw(v)?S=r[x]:(S=kl({inputs:{x:r[x]},backend:t,attrs:{perm:v}}),g.push(S));const C=S.shape.slice();for(let E=0;E<b.length;++E)C.splice(b[E],0,1);ds(S.shape,C)||(S=cn({inputs:{x:S},backend:t,attrs:{shape:C}}),g.push(S)),h===null?h=S:(h=NV({inputs:{a:S,b:h},backend:t}),g.push(h))}y<d-1&&(c[y]>=0&&(h=PV({inputs:{x:h},backend:t,attrs:{axis:c[y]-(o.length-p),keepDims:!1}}),g.push(h)),p--)}for(const y of g)y!==h&&t.disposeData(y.dataId);return h}const I$e={kernelName:Ry,backendName:"webgpu",kernelFunc:T$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k$e=ys({opType:$t.ELU}),A$e={kernelName:up,backendName:"webgpu",kernelFunc:k$e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R$e=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,r=new V2(Fn.ELU_DER,s.shape,i.shape);return t.runWebGPUProgram(r,[s,i],s.dtype)},M$e={kernelName:My,backendName:"webgpu",kernelFunc:R$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$e=tr({opType:Fn.EQUAL,dtype:"bool",cpuKernelImpl:fPe}),P$e={kernelName:_0,backendName:"webgpu",kernelFunc:N$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D$e=ys({opType:$t.ERF}),L$e={kernelName:dp,backendName:"webgpu",kernelFunc:D$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $$e=ys({opType:$t.EXP,cpuKernelImpl:pPe,dtype:"float32"}),F$e={kernelName:hp,backendName:"webgpu",kernelFunc:$$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:r}=e,o=r.shape.length,a=r.shape.slice();let l=i;return i<0&&(re(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),cn({inputs:{x:r},backend:s,attrs:{shape:a}})}const O$e={kernelName:E0,backendName:"webgpu",kernelFunc:$_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z$e=ys({opType:$t.EXPM1,cpuKernelImpl:mPe}),B$e={kernelName:fp,backendName:"webgpu",kernelFunc:z$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SL{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DV(n,e,t){const s=t.tensorMap.get(n.dataId),i=Le(n.shape),r=n.shape[n.shape.length-1],o=i/r,a=[],l=cn({inputs:{x:n},backend:t,attrs:{shape:[o,r]}});a.push(l);const c=l.shape,u=new SL("real",c),d=new SL("imag",c),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],p=e?2*Math.PI:-2*Math.PI,g=e?c[1]:1,y=[{type:"float32",data:[p]},{type:"float32",data:[g]}],x=t.runWebGPUProgram(u,h,"float32",y);a.push(x);const v=t.runWebGPUProgram(d,h,"float32",y);a.push(v);const b=eh({inputs:{real:x,imag:v},backend:t});a.push(b);const S=cn({inputs:{x:b},backend:t,attrs:{shape:n.shape}});return a.forEach(C=>t.disposeData(C.dataId)),S}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$e(n){const{inputs:e,backend:t}=n,{input:s}=e;return DV(s,!1,t)}const V$e={kernelName:Ny,backendName:"webgpu",kernelFunc:U$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W$e{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G$e={kernelName:Dy,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new W$e(t.shape);return s.runWebGPUProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$e=ys({opType:$t.FLOOR,cpuKernelImpl:gPe}),j$e={kernelName:pp,backendName:"webgpu",kernelFunc:H$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X$e=tr({opType:Fn.FLOOR_DIV,cpuKernelImpl:xPe,dtype:"int32"}),q$e={kernelName:mp,backendName:"webgpu",kernelFunc:X$e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class K$e{constructor(e,t,s=!1){this.pixelsOpType=zf.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ot("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$e={kernelName:l5,backendName:"webgpu",kernelFunc:Z$e};let Xh,cC=ze().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Z$e(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:r}=s;if(i==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,l=typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&i instanceof OffscreenCanvas,c=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,[u,d]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],h=[d,u,r],p=ze().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&o,g=o||a;if(c||l||g){let b;if(p)b=t.device.importExternalTexture({source:i});else{if(g){const W=ze().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Xh==null||W!==cC)&&(cC=W,Xh=document.createElement("canvas").getContext("2d",{willReadFrequently:cC})),Xh.canvas.width=u,Xh.canvas.height=d,Xh.drawImage(i,0,0,u,d),i=Xh.canvas}const T=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,j=t.textureManager.acquireTexture(h[1],h[0],"rgba8unorm",T);t.queue.copyExternalImageToTexture({source:i},{texture:j},[h[1],h[0]]),b=j}const S=Le(h),C=gn(h),E=new K$e(h,r,p),k=[{type:"uint32",data:[S]},{type:"uint32",data:[r]},{type:"uint32",data:[...C]}],R=t.makeTensorInfo([d,u],"int32"),L=t.tensorMap.get(R.dataId);L.resource=b;const I=t.runWebGPUProgram(E,[R],"int32",k);return t.disposeData(R.dataId),I}const y=i.data;let x=y;if(r!=null&&r!==4){x=new Uint8Array(i.width*i.height*r);const b=y.length;let S=0;for(let C=0;C<b;C++)C%4<r&&(x[S++]=y[C])}const v=t.makeTensorInfo(h,"int32",new Int32Array(x));return t.uploadToGPU(v.dataId),v}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q$e{constructor(e,t,s,i,r){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Mn(e,t),Mn(e,s),this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),i!=null&&(Mn(e,i),this.variableNames.push("offset")),r!=null&&(Mn(e,r),this.variableNames.push("scale")),this.offsetShape=i,this.scaleShape=r,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${Ot("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J$e={kernelName:T0,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s,scale:i,offset:r,mean:o,variance:a}=n,{varianceEpsilon:l}=e,c=t,u=[s,o,a];let d=null;r!=null&&(d=r.shape,u.push(r));let h=null;i!=null&&(h=i.shape,u.push(i));const p=new Q$e(s.shape,o.shape,a.shape,d,h),g=[{type:"float32",data:[l]}];return c.runWebGPUProgram(p,u,s.dtype,g)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:g}=s,y=bo(u),x=Js(i.shape,r.shape,l,d,c,h,!1,y);return kV({x:i,filter:r,convInfo:x,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:g,activation:p})}const tFe={kernelName:Lg,backendName:"webgpu",kernelFunc:eFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=s;let g=u;g==null&&(g=[1,1]),re(er(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const y=Js(i.shape,r.shape,l,g,c,d,!0),x=[i,r],v=o!=null,b=a!=null;v&&x.push(o),b&&x.push(a);const S=[{type:"int32",data:[y.padInfo.top,y.padInfo.left]},{type:"int32",data:[y.inHeight,y.inWidth]}];let C;return y.outHeight>4&&y.outWidth>4&&y.strideWidth<=2&&y.inChannels===y.outChannels&&y.dilationHeight===1&&y.dilationWidth===1&&y.inChannels%4===0?(C=new RV(y,v,h,b),S.push({type:"int32",data:[C.virtualWidth]})):(C=new MV(y,v,h,b),S.push({type:"int32",data:[y.filterHeight]},{type:"int32",data:[y.filterWidth]},{type:"int32",data:[y.strideHeight,y.strideWidth]},{type:"int32",data:[y.dilationHeight,y.dilationWidth]})),h==="leakyrelu"&&(S.push({type:"float32",data:[p]}),C.uniforms+=" alpha : f32,"),t.runWebGPUProgram(C,x,"float32",S)}const sFe={kernelName:xT,backendName:"webgpu",kernelFunc:nFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iFe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${yi(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rFe(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=i.shape,o=r[r.length-1],a=Le(s.shape),[l,c,u,d]=cw(s,i),h=cn({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),p=cn({inputs:{x:s},backend:t,attrs:{shape:[Le(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const b=t.readSync(i.dataId),S=t.bufferSync(s),C=vPe(b,S,s.dtype,c,o,u,d,s.shape,a);return t.makeTensorInfo(l,s.dtype,C.values)}const g=new iFe(o,[c,u]),y=[{type:"int32",data:[o]},{type:"int32",data:d}],x=t.runWebGPUProgram(g,[p,h],p.dtype,y),v=cn({inputs:{x},backend:t,attrs:{shape:l}});return t.disposeData(h.dataId),t.disposeData(p.dataId),t.disposeData(x.dataId),v}const oFe={kernelName:sT,backendName:"webgpu",kernelFunc:rFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aFe{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=lFe(this.aShape);return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function lFe(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let s=0;s<n.length;s++)s===2?t.push("indexZ"):t.push(`${e[s]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LV(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:o,batchDims:a}=s,l=Hn(o,i.shape)[0],c=Rw(i,r,l,a),u=Le(r.shape),d=[],h=cn({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=cn({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(h),d.push(p);const g=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])){const S=t.tensorMap.get(p.dataId).values,C=Yn(p.shape,p.dtype,S),k=t.tensorMap.get(h.dataId).values,R=Yn(h.shape,h.dtype,k),L=yPe(R,C,g);return d.forEach(I=>t.disposeData(I.dataId)),t.makeTensorInfo(c.outputShape,L.dtype,L.values)}const y=new aFe(h.shape,g),x=t.runWebGPUProgram(y,[h,p],h.dtype);d.push(x);const v=cn({inputs:{x},backend:t,attrs:{shape:c.outputShape}});return d.forEach(b=>t.disposeData(b.dataId)),v}const cFe={kernelName:I0,backendName:"webgpu",kernelFunc:LV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uFe=tr({opType:Fn.GREATER,cpuKernelImpl:bPe,dtype:"bool"}),dFe={kernelName:k0,backendName:"webgpu",kernelFunc:uFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hFe=tr({opType:Fn.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:wPe}),fFe={kernelName:gp,backendName:"webgpu",kernelFunc:hFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pFe(n){const{inputs:e,backend:t}=n,{input:s}=e;return DV(s,!0,t)}const mFe={kernelName:Ly,backendName:"webgpu",kernelFunc:pFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gFe=ys({opType:$t.IS_FINITE,dtype:"bool"}),xFe={kernelName:vp,backendName:"webgpu",kernelFunc:gFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vFe=ys({opType:$t.IS_INF,dtype:"bool"}),yFe={kernelName:yp,backendName:"webgpu",kernelFunc:vFe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wFe=ys({opType:$t.IS_NAN,dtype:"bool"}),bFe={kernelName:wp,backendName:"webgpu",kernelFunc:wFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s,o=[{type:"float32",data:[r]}],a=new om(i.shape,$t.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[i],"float32",o)}const CFe={kernelName:A0,backendName:"webgpu",kernelFunc:SFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Fe=tr({opType:Fn.LESS,dtype:"bool",cpuKernelImpl:CPe}),EFe={kernelName:R0,backendName:"webgpu",kernelFunc:_Fe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TFe=tr({opType:Fn.LESS_EQUAL,dtype:"bool",cpuKernelImpl:SPe}),IFe={kernelName:M0,backendName:"webgpu",kernelFunc:TFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kFe{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AFe(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,o=(i-s)/(r-1),a=new kFe(r),l=[{type:"float32",data:[s]},{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],"float32",l)}const RFe={kernelName:iT,backendName:"webgpu",kernelFunc:AFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MFe=ys({opType:$t.LOG,cpuKernelImpl:_Pe}),NFe={kernelName:bp,backendName:"webgpu",kernelFunc:MFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PFe=ys({opType:$t.LOG1P}),DFe={kernelName:Sp,backendName:"webgpu",kernelFunc:PFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LFe=tr({opType:Fn.LOGICAL_AND,dtype:"bool"}),$Fe={kernelName:N0,backendName:"webgpu",kernelFunc:LFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FFe=ys({opType:$t.LOGICAL_NOT}),OFe={kernelName:P0,backendName:"webgpu",kernelFunc:FFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zFe=tr({opType:Fn.LOGICAL_OR}),BFe={kernelName:D0,backendName:"webgpu",kernelFunc:zFe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $V=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class UFe{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${$V}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class VFe{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,re(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Ut(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Ot()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${$V}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:o,alpha:a,beta:l}=s;let c;r>16?c=new UFe(i.shape):c=new VFe(i.shape,r);const u=[{type:"int32",data:[r]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[l]}];return t.runWebGPUProgram(c,[i],i.dtype,u)}const GFe={kernelName:L0,backendName:"webgpu",kernelFunc:WFe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HFe{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s,d=new HFe(i.shape),h=[{type:"int32",data:[a]},{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[u]}];return t.runWebGPUProgram(d,[i,r,o],i.dtype,h)}const XFe={kernelName:Fy,backendName:"webgpu",kernelFunc:jFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qFe=tr({opType:Fn.MAX,cpuKernelImpl:TPe}),KFe={kernelName:Cp,backendName:"webgpu",kernelFunc:qFe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dimRoundingMode:l}=s,u=br(i.shape,r,o,1,a,l);return _V(i,u,"max",t)}const ZFe={kernelName:F0,backendName:"webgpu",kernelFunc:YFe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QFe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],d=Fo(i.shape,r,o,u,a,c,l),h=new VI(d,"max"),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return t.runWebGPUProgram(h,[i],i.dtype,p)}const JFe={kernelName:O0,backendName:"webgpu",kernelFunc:QFe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eOe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class tOe{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nOe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,o=r,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,d=[1,1,1],h=Fo(o.shape,a,l,d,c,u),p=new VI(h,"max",!0);let g=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];const y=t.runWebGPUProgram(p,[o],"int32",g),x=new tOe(h);g=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const v=t.runWebGPUProgram(x,[i,y],o.dtype,g);return t.disposeData(y.dataId),v}const sOe={kernelName:zy,backendName:"webgpu",kernelFunc:nOe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iOe(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:o}=e,a=r;vV([r,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=s,h=br(a.shape,l,c,1,u,d),p=new Kg(h,"max",!0);let g=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];const y=t.runWebGPUProgram(p,[a],"int32",g),x=new eOe(h);g=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];const v=t.runWebGPUProgram(x,[i,y],a.dtype,g);return t.disposeData(y.dataId),v}const rOe={kernelName:Oy,backendName:"webgpu",kernelFunc:iOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oOe(n){const{inputs:e,backend:t,attrs:s}=n,{filterSize:i,strides:r,pad:o,includeBatchInIndex:a}=s,{x:l}=e;re(l.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.shape.length}.`);const c=[1,1];re(er(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const u=br(l.shape,i,r,c,o),d=[{type:"int32",data:[u.strideHeight,u.strideWidth]},{type:"int32",data:[u.padInfo.top,u.padInfo.left]},{type:"int32",data:[u.dilationHeight,u.dilationWidth]},{type:"int32",data:[u.inHeight,u.inWidth]},{type:"int32",data:[u.effectiveFilterHeight,u.effectiveFilterWidth]}];let h=new Kg(u,"max",!1);const p=t.runWebGPUProgram(h,[l],l.dtype,d);h=new Kg(u,"max",!0,!0,a);const g=t.runWebGPUProgram(h,[l],"int32",d);return[p,g]}const aOe={kernelName:rT,backendName:"webgpu",kernelFunc:oOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lOe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return th(i,r,o,"min",t)}const cOe={kernelName:B0,backendName:"webgpu",kernelFunc:lOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uOe=tr({opType:Fn.MIN,cpuKernelImpl:IPe}),dOe={kernelName:_p,backendName:"webgpu",kernelFunc:uOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hOe{constructor(e,t,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((i,r)=>i[0]+e[r]+i[1]),this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((i,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((c,u)=>`uniforms.pad${u}[0]`).join(","),s=this.xShape.map((c,u)=>`uniforms.pad${u}[0] + uniforms.xShape${e>1?`[${u}]`:""}`).join(","),i=e===1?"start":"start[i]",r=e===1?"end":"end[i]",o=e===1?"outC":"outC[i]",a=yi(e),l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${o} < ${i}) {
              ${o} = ${i} * 2 - ${o} - ${this.offset};
            } else if(${o} >= ${r}) {
              ${o} = (${r} - 1) * 2 - ${o} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fOe={kernelName:U0,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{paddings:i,mode:r}=e,o=t,a=i.map(u=>({type:"int32",data:[u[0],u[1]]})),l=new hOe(s.shape,i,r);return o.runWebGPUProgram(l,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pOe=tr({opType:Fn.MOD}),mOe={kernelName:Ep,backendName:"webgpu",kernelFunc:pOe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gOe{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ot("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xOe{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Ot("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,o=cn({inputs:{x:i},backend:t,attrs:{shape:[Le(i.shape)/i.shape[r],i.shape[r]]}}),a=new xOe(o.shape),l=t.runWebGPUProgram(a,[o],i.dtype),c=cn({inputs:{x:l},backend:t,attrs:{shape:i.shape}});return t.disposeData(o.dataId),t.disposeData(l.dataId),c}const vOe={kernelName:r1,backendName:"webgpu",kernelFunc:FV};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yOe(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:o,normalized:a}=s,l=a?i:FV({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],d=new gOe(c,r),h=[{type:"float32",data:[o]},{type:"int32",data:[u]}],p=t.runWebGPUProgram(d,[l],"int32",h);return a||t.disposeData(l.dataId),p}const wOe={kernelName:oT,backendName:"webgpu",kernelFunc:yOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bOe(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const r=t.tensorMap.get(s.dataId),[o,a]=APe(r.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}const i=new om(s.shape,$t.NEG);return t.runWebGPUProgram(i,[s],s.dtype)}const SOe={kernelName:V0,backendName:"webgpu",kernelFunc:bOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function COe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),{selectedIndices:d}=aw(c,u,o,a,l);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const _Oe={kernelName:By,backendName:"webgpu",kernelFunc:COe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EOe(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(i.dataId),d=t.readSync(r.dataId),h=o,p=a,g=l,y=c,{selectedIndices:x,selectedScores:v}=lw(u,d,h,p,g,y);return[t.makeTensorInfo([x.length],"int32",new Int32Array(x)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const TOe={kernelName:Uy,backendName:"webgpu",kernelFunc:EOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IOe{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Ot("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kOe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:o,onValue:a,offValue:l}=s,c=Le(i.shape),u=new IOe(c,o),d=cn({inputs:{x:i},backend:t,attrs:{shape:[c]}}),h=[{type:"float32",data:[a]},{type:"float32",data:[l]}],p=t.runWebGPUProgram(u,[d],r,h);t.disposeData(d.dataId);const g=[...i.shape,o],y=cn({inputs:{x:p},backend:t,attrs:{shape:g}});return t.disposeData(p.dataId),y}const AOe={kernelName:H0,backendName:"webgpu",kernelFunc:kOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=R1({inputs:{input:s},backend:t}),r=G2({inputs:{x:i},backend:t}),o=Qw({inputs:{input:s},backend:t}),a=G2({inputs:{x:o},backend:t}),l=eh({inputs:{real:r,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(r.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return Qr({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const ROe={kernelName:l1,backendName:"webgpu",kernelFunc:G2};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=R1({inputs:{input:s},backend:t}),r=OV({inputs:{x:i},backend:t}),o=Qw({inputs:{input:s},backend:t}),a=G2({inputs:{x:o},backend:t}),l=eh({inputs:{real:r,imag:a},backend:t});return t.disposeData(i.dataId),t.disposeData(r.dataId),t.disposeData(o.dataId),t.disposeData(a.dataId),l}else return Qr({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const MOe={kernelName:G0,backendName:"webgpu",kernelFunc:OV};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NOe(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return $_({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,o=e[0].dtype;e.forEach(u=>{fy(r,u.shape,"All tensors passed to stack must have matching shapes"),re(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const d=$_({inputs:{input:u},backend:t,attrs:{dim:i}});return a.push(d),d}),c=IV({inputs:l,backend:t,attrs:{axis:i}});return a.forEach(u=>t.disposeData(u.dataId)),c}const POe={kernelName:j0,backendName:"webgpu",kernelFunc:NOe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n,e=!1){const t=n.length,s=yi(t),i=n.map((d,h)=>`uniforms.pad${h}[0]`).join(","),r=n.map((d,h)=>`uniforms.pad${h}[0] + uniforms.xShape${t>1?`[${h}]`:""}`).join(","),o=t>1?`${s}(${i})`:`${i}`,a=t>1?`${s}(${r})`:`${r}`,l=t>1?"any(paddedCoords < start)":"paddedCoords < start",c=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${o};
        let end = ${a};
        if (${l} || ${c}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${u}));
        }
  `}class DOe{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,i)=>s[0]+e[i]+s[1]),this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((s,i)=>{this.uniforms+=` pad${i} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${zV(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LOe=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:o}=s;if(r.every(c=>ds(c,[0,0])))return wo({inputs:{x:i},backend:t});if(Le(i.shape)===0){const c=r.map((u,d)=>u[0]+i.shape[d]+u[1]);return Qr({backend:t,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=[{type:"float32",data:[o]}];r.map(c=>a.push({type:"int32",data:[c[0],c[1]]}));const l=new DOe(i.shape,r);return t.runWebGPUProgram(l,[i],i.dtype,a)},$Oe={kernelName:X0,backendName:"webgpu",kernelFunc:LOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FOe=tr({opType:Fn.POW}),OOe={kernelName:Ip,backendName:"webgpu",kernelFunc:FOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zOe(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,r=new V2(Fn.PRELU,s.shape,i.shape);return t.runWebGPUProgram(r,[s,i],"float32")}const BOe={kernelName:q0,backendName:"webgpu",kernelFunc:zOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UOe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:o}=s;return th(i,r,o,"prod",t)}const VOe={kernelName:K0,backendName:"webgpu",kernelFunc:UOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WOe=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:r,dtype:o}=t,a=NPe(s,i,r,o);return e.makeTensorInfo([a.length],o,a)},GOe={kernelName:Vy,backendName:"webgpu",kernelFunc:WOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HOe=tr({opType:Fn.DIV}),jOe={kernelName:cp,backendName:"webgpu",kernelFunc:HOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XOe=ys({opType:$t.RECIPROCAL}),qOe={kernelName:kp,backendName:"webgpu",kernelFunc:XOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KOe=ys({opType:$t.RELU}),YOe={kernelName:Ap,backendName:"webgpu",kernelFunc:KOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZOe=ys({opType:$t.RELU6}),QOe={kernelName:Rp,backendName:"webgpu",kernelFunc:ZOe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JOe{constructor(e,t,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,size:o,halfPixelCenters:a}=s,[l,c]=o,u=r&&l>1?1:0,d=r&&c>1?1:0,p=[{type:"float32",data:[u,d]},{type:"float32",data:[a?.5:0]}],g=new JOe(i.shape,l,c);return t.runWebGPUProgram(g,[i],"float32",p)}const t5e={kernelName:Q0,backendName:"webgpu",kernelFunc:e5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n5e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,[,a,l]=i.shape,[,c,u]=r.shape,d=[o&&c>1?a-1:a,o&&u>1?l-1:l],h=[o&&c>1?c-1:c,o&&u>1?u-1:u],p=d[0]/h[0],g=d[1]/h[1],y=1/p,x=1/g,v=Math.ceil(y)*2+2,b=Math.ceil(x)*2+2,S=new n5e(i.shape,o),C=[{type:"int32",data:d},{type:"int32",data:h},{type:"float32",data:[p]},{type:"float32",data:[g]},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"int32",data:[v]},{type:"int32",data:[b]}];return t.runWebGPUProgram(S,[r],r.dtype,C)}const i5e={kernelName:Hy,backendName:"webgpu",kernelFunc:s5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r5e{constructor(e,t,s,i){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,s,e[3]],this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=i,this.shaderKey=`resizeNearest_${i}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:o,size:a}=s,[l,c]=a,u=r&&l>1?1:0,d=r&&c>1?1:0,p=[{type:"float32",data:[u,d]},{type:"float32",data:[r?.5:0]}],g=new r5e(i.shape,l,c,o);return t.runWebGPUProgram(g,[i],i.dtype,p)}const a5e={kernelName:Z0,backendName:"webgpu",kernelFunc:o5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l5e{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c5e(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:o}=s,[,a,l]=i.shape,[,c,u]=r.shape,d=[o&&c>1?a-1:a,o&&u>1?l-1:l],h=[o&&c>1?c-1:c,o&&u>1?u-1:u],p=d[0]/h[0],g=d[1]/h[1],y=1/p,x=1/g,v=Math.ceil(y)*2+2,b=Math.ceil(x)*2+2,S=new l5e(i.shape,o),C=[{type:"int32",data:d},{type:"int32",data:h},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"int32",data:[v]},{type:"int32",data:[b]}];return t.runWebGPUProgram(S,[r],r.dtype,C)}const u5e={kernelName:Gy,backendName:"webgpu",kernelFunc:c5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d5e{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s,o=i.shape.length;if(o===0)return wo({inputs:{x:i},backend:t});const a=i.shape,l=[1,1,1,1];a.forEach((x,v)=>{const b=v+4-o;l[b]=x});const c=Hn(r,i.shape),u=[0,0,0,0];c.forEach(x=>{const v=x+4-o;u[v]=1});const d=[{type:"int32",data:u}],h=cn({inputs:{x:i},backend:t,attrs:{shape:l}}),p=new d5e(l),g=t.runWebGPUProgram(p,[h],h.dtype,d);t.disposeData(h.dataId);const y=cn({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeData(g.dataId),y}const f5e={kernelName:J0,backendName:"webgpu",kernelFunc:h5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p5e{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ot("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m5e={kernelName:Yy,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:o}=e,a=t,l=new p5e(s.shape,r),[c,u]=mw(o,s.shape[1],s.shape[2]),d=[{type:"float32",data:[c]},{type:"float32",data:[u]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return typeof r=="number"?d.push({type:"float32",data:[Number.parseFloat(r.toFixed(2))]}):d.push({type:"float32",data:r}),a.runWebGPUProgram(l,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g5e=ys({opType:$t.ROUND}),x5e={kernelName:Mp,backendName:"webgpu",kernelFunc:g5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v5e=ys({opType:$t.RSQRT,cpuKernelImpl:PPe}),y5e={kernelName:Np,backendName:"webgpu",kernelFunc:v5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _g{constructor(e,t,s,i,r,o,a,l=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=o,this.type=a,this.sumDupeIndices=l,this.dispatchLayout=en(e),this.dispatch=Ut(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${s}_${i}_${this.sliceDimGreaterThanOne}_${a}_${l}_${r.length}`;const c=yi(r.length);this.uniforms=`sliceDim : i32, strides: ${c}, updatesSize: i32,`,this.updatesRank=i,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let i="",r="";this.dispatchLayout.x.length===1?(i="flattenedIndex",r=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(i="vec2<i32>(flattenedIndex, coords[1])",r=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(c,u)=>`coords[${u}]`).join(", ")})`;return`
    ${r}
      ${Ot("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${sd(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${i});

          ${this.sumDupeIndices?Cu("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5e(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Pl(r,i,o),h=[d/c,c];if(d===0)return t.makeTensorInfo(o,i.dtype);const p=cn({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),g=cn({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),y=g.dtype,x=Qr({backend:t,attrs:{shape:h,value:0,dtype:y}}),v=Le(g.shape),b=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[v]}],S=new _g(g.shape,a,p.shape.length,g.shape.length,u,h,y),C=t.runWebGPUProgram(S,[g,p],y,b,x),E=cn({inputs:{x:C},backend:t,attrs:{shape:o}});return t.disposeData(p.dataId),t.disposeData(g.dataId),t.disposeData(C.dataId),E}const b5e={kernelName:lT,backendName:"webgpu",kernelFunc:w5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S5e{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Ot("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C5e(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:o}=s,a=new S5e([r.shape[0],r.shape[1]],o),l=[{type:"int32",data:[i.shape[1]]}];return t.runWebGPUProgram(a,[i,r],"int32",l)}const _5e={kernelName:uT,backendName:"webgpu",kernelFunc:C5e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E5e{constructor(e,t,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],o=[];for(let a=0;a<this.outputShape.length;a++)o.push(`${i[a]}`),a<this.cRank&&r.push(`${i[a]}`);e=r.join(),t=o.join()}return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5e(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e,o=new E5e(s.shape.length,i.shape,i.shape.length);return t.runWebGPUProgram(o,[s,i,r],Ji(i.dtype,r.dtype))}const I5e={kernelName:e1,backendName:"webgpu",kernelFunc:T5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k5e=ys({opType:$t.SELU}),A5e={kernelName:Pp,backendName:"webgpu",kernelFunc:k5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R5e=ys({opType:$t.SIGMOID}),M5e={kernelName:Fp,backendName:"webgpu",kernelFunc:R5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N5e=ys({opType:$t.SIGN}),P5e={kernelName:$p,backendName:"webgpu",kernelFunc:N5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D5e=ys({opType:$t.SIN}),L5e={kernelName:Dp,backendName:"webgpu",kernelFunc:D5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $5e=ys({opType:$t.SINH}),F5e={kernelName:Lp,backendName:"webgpu",kernelFunc:$5e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O5e=ys({opType:$t.SOFTPLUS}),z5e={kernelName:Op,backendName:"webgpu",kernelFunc:O5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B5e{constructor(e,t,s,i,r,o){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[r[l]];this.outputShape=a,this.newDim=r,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${yi(i.length)}, paddedXShapeStrides : ${yi(o)}, `,s.map((l,c)=>{this.uniforms+=` pad${c} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${r}`}getUserCode(){const e=yi(this.outputShape.length),t=wV(this.newDim);return`
      ${jv(this.paddedXShape,"PaddedX")}
      ${Ot("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${zV(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U5e=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:o}=s;re(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=r.reduce((b,S)=>b*S),l=[[0,0]];l.push(...o);for(let b=1+r.length;b<i.shape.length;++b)l.push([0,0]);const c=l.map((b,S)=>b[0]+i.shape[S]+b[1]),u=Gd(c,r,a,!1),d=Hd(u.length,r.length,!1),h=jd(c,r,a,!1),p=gn(c),g=new B5e(i.shape,c,l,u,d,p.length),y=[{type:"int32",data:u},{type:"int32",data:p}];l.map(b=>y.push({type:"int32",data:[b[0],b[1]]}));const x=t.runWebGPUProgram(g,[i],i.dtype,y),v=cn({inputs:{x},backend:t,attrs:{shape:h}});return t.disposeData(x.dataId),v},V5e={kernelName:s1,backendName:"webgpu",kernelFunc:U5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W5e{constructor(e,t,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=en([t]),this.dispatch=Ut(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Cu("&result[outIndex]","value",this.type)}
      }
    }
  `}}class G5e{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=en(t),this.dispatch=Ut(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Cu("&result[segmentId]","1","int32")}
      }
    }
  `}}class H5e{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=en(e),this.dispatch=Ut(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BV(n,e,t,s=!1,i){const o=Le(n.shape)/n.shape[0],a=n.dtype,l=Le(e.shape),c=i.readSync(t.dataId),d=l>0?c[l-1]+1:0;let h;const p=n.shape.slice();p[0]=d;const g=l*o,y=Qr({backend:i,attrs:{shape:p,value:0,dtype:a}});h=new W5e(p,g,a);let x=[{type:"int32",data:[o]},{type:"int32",data:[g]}];const v=i.runWebGPUProgram(h,[n,e,t],a,x,y);if(s)return v;const b=Qr({backend:i,attrs:{shape:[d],value:0,dtype:"int32"}});h=new G5e(d,t.shape);const S=i.runWebGPUProgram(h,[t],"int32",null,b),C=Qr({backend:i,attrs:{shape:p,value:0,dtype:a}});h=new H5e(p,a),x=[{type:"int32",data:[o]}];const E=i.runWebGPUProgram(h,[v,S],a,x,C);return i.disposeData(v.dataId),i.disposeData(S.dataId),E}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j5e(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;return BV(s,i,r,!1,t)}const X5e={kernelName:dT,backendName:"webgpu",kernelFunc:j5e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5e(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;return BV(s,i,r,!0,t)}const K5e={kernelName:hT,backendName:"webgpu",kernelFunc:q5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Y5e{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*t[i];this.outputShape=s,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=Z5e(this.rank,"uniforms.");return`
      ${Ot("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function Z5e(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n;i++)s.push(`(${t[i]} % ${e}aShape[${i}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;if(t.shouldExecuteOnCPU([i])||i.dtype==="string"||i.shape.length>=5){const l=t.readSync(i.dataId),c=i.dtype==="string"?l.map(h=>$a(h)):l,u=Yn(i.shape,i.dtype,c),d=BPe(u,r);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new Y5e(i.shape,r);return t.runWebGPUProgram(o,[i],i.dtype)}const Q5e={kernelName:Gp,backendName:"webgpu",kernelFunc:WI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J5e(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:h}=Pl(r,i,a),p=!1;if(r.dtype==="string"){const L=t.bufferSync(i),I=t.bufferSync(r),T=$a(t.readSync(o.dataId)[0]),M=DPe(L,I,a,h,u,c,l,d,T,p);return t.makeTensorInfo(a,M.dtype,M.values)}const g=[h/u,u],y=cn({inputs:{x:i},backend:t,attrs:{shape:[c,l]}}),x=r.shape.length?cn({inputs:{x:r},backend:t,attrs:{shape:[c,u]}}):wo({inputs:{x:r},backend:t}),v=x.dtype,b=t.makeTensorInfo([],v,dr(1,v)),S=cn({inputs:{x:o},backend:t,attrs:{shape:Array(g.length).fill(1)}}),C=WI({inputs:{x:S},backend:t,attrs:{reps:g}}),E=Le([c,u]),k=[{type:"int32",data:[l]},{type:"int32",data:d},{type:"int32",data:[E]}];switch(c){case 0:break;case 1:{const L=new _g([c,u],l,y.shape.length,x.shape.length,d,g,v,p);t.runWebGPUProgram(L,[x,y],v,k,C)}break;default:{const L=new _g([c,u],l,y.shape.length,b.shape.length,d,g,v,p);t.runWebGPUProgram(L,[b,y],v,k,C)}{const L=new _g([c,u],l,y.shape.length,x.shape.length,d,g,v);t.runWebGPUProgram(L,[x,y],v,k,C)}}const R=cn({inputs:{x:C},backend:t,attrs:{shape:a}});return t.disposeData(y.dataId),t.disposeData(x.dataId),t.disposeData(S.dataId),t.disposeData(b.dataId),t.disposeData(C.dataId),R}const e6e={kernelName:fT,backendName:"webgpu",kernelFunc:J5e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t6e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:o}=s,a=Hn(o,i.shape)[0],l=Aw(i,r,a),c=i.shape.length,u=new Array(c).fill(0),d=i.shape.slice();return l.map(h=>{const p=[...d];p[a]=h;const g=am({inputs:{x:i},backend:t,attrs:{begin:u,size:p}});return u[a]+=h,g})}const n6e={kernelName:i1,backendName:"webgpu",kernelFunc:t6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s6e=ys({opType:$t.SQRT}),i6e={kernelName:zp,backendName:"webgpu",kernelFunc:s6e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r6e={kernelName:jy,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e,i=new om(t.shape,$t.SQUARE);return s.runWebGPUProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o6e=tr({opType:Fn.SQUARED_DIFFERENCE}),a6e={kernelName:Bp,backendName:"webgpu",kernelFunc:o6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6e({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=new om(s.shape,$t.STEP,"stepAlpha : f32,"),r=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(i,[s],s.dtype,r)}const c6e={kernelName:Hp,backendName:"webgpu",kernelFunc:l6e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class u6e{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=yi(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let i=0;t=this.outputShape.map((r,o)=>(i++,this.outputShape.length===1?`coords * uniforms.strides[${o}] + uniforms.begin[${o}]`:`coords[${i-1}] * uniforms.strides[${o}] + uniforms.begin[${o}]`)).join(",")}return`
       ${Ot("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d6e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:p,finalShape:g,isIdentity:y,sliceDim0:x,isSimpleSlice:v,begin:b,end:S,strides:C}=hw(i.shape,r,o,a,l,c,u,d,h);let E;if(y)E=cn({inputs:{x:i},backend:t,attrs:{shape:g}});else if(x||v){re(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const k=dw(b,S,C),R=am({inputs:{x:i},backend:t,attrs:{begin:b,size:k}});E=cn({inputs:{x:R},backend:t,attrs:{shape:g}}),t.disposeData(R.dataId)}else if(t.shouldExecuteOnCPU([i])){const R=t.readSync(i.dataId),L=Yn(i.shape,i.dtype,R),I=FPe(p,L,C,b);E=t.makeTensorInfo(g,i.dtype,I.values)}else{const R=new u6e(p),L=[{type:"int32",data:b},{type:"int32",data:C}],I=t.runWebGPUProgram(R,[i],i.dtype,L);E=cn({inputs:{x:I},backend:t,attrs:{shape:g}}),t.disposeData(I.dataId)}return E}const h6e={kernelName:Xy,backendName:"webgpu",kernelFunc:d6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6e(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:d}=e,h=t.readSync(u.dataId),p=t.readSync(d.dataId),[g,y]=OPe(h,p,i,r,o,a,l,c);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(d.shape,"int32",y)]}const p6e={kernelName:mT,backendName:"webgpu",kernelFunc:f6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m6e=tr({opType:Fn.SUB,cpuKernelImpl:zPe,supportsComplex:!0}),g6e={kernelName:Up,backendName:"webgpu",kernelFunc:m6e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x6e=ys({opType:$t.TAN}),v6e={kernelName:Vp,backendName:"webgpu",kernelFunc:x6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6e=ys({opType:$t.TANH}),w6e={kernelName:Wp,backendName:"webgpu",kernelFunc:y6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b6e(n){const{inputs:e,backend:t,attrs:s}=n,{tensor:i,indices:r,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=Pl(o,r,i.shape),h=[d/c,c];if(d===0)return t.makeTensorInfo(i.shape,r.dtype);const p=[],g=cn({inputs:{x:r},backend:t,attrs:{shape:[l,a]}});p.push(g);const y=cn({inputs:{x:o},backend:t,attrs:{shape:[l,c]}});p.push(y);const x=cn({inputs:{x:i},backend:t,attrs:{shape:h}});p.push(x);const v=WI({inputs:{x},backend:t,attrs:{reps:Array(h.length).fill(1)}}),b=new _g([l,c],a,g.shape.length,y.shape.length,u,h,i.dtype,!1),S=Le([l,c]),C=[{type:"int32",data:[a]},{type:"int32",data:u},{type:"int32",data:[S]}],E=t.runWebGPUProgram(b,[y,g],x.dtype,C,v);p.push(E);const k=cn({inputs:{x:E},backend:t,attrs:{shape:i.shape}});return p.forEach(R=>t.disposeData(R.dataId)),k}const S6e={kernelName:cT,backendName:"webgpu",kernelFunc:b6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C6e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ot("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class _6e{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ot("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qh(n,e){e!==null&&n.disposeData(e.dataId)}function CL(n){let e=1;for(;e<n;)e*=2;return e}function E6e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:o}=s,a=i.shape,l=a[a.length-1];if(t.shouldExecuteOnCPU([i])){const E=t.readSync(i.dataId),[k,R]=UPe(E,a,i.dtype,r,o);return[t.makeTensorInfo(k.shape,k.dtype,k.values),t.makeTensorInfo(R.shape,R.dtype,R.values)]}if(r===0)return a[a.length-1]=0,[t.makeTensorInfo(a,i.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(l===1)return[i,Qr({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const u=Le(a)/l,d=cn({inputs:{x:i},attrs:{shape:[u,l]},backend:t}),h=CL(r),p=CL(l);let g=null;const y=()=>g===null?[d,d]:[d,g],x=(E,k,R)=>{const L=y(),I=new C6e(R),M=[{type:"int32",data:[l]},{type:"int32",data:[g===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[E]},{type:"int32",data:[k]}],j=g;g=t.runWebGPUProgram(I,L,"int32",M),qh(t,j)};for(let E=1;E<h;E*=2){const k=E*2;for(let R=E;R>=1;R/=2)x(k,R,[u,p])}for(let E=p;E>h;E/=2){const k=y(),R=new _6e([u,E/2]),I=[{type:"int32",data:[l]},{type:"int32",data:[g===null?1:0]},{type:"int32",data:[h]}],T=g;g=t.runWebGPUProgram(R,k,"int32",I),qh(t,T);const M=h/2,j=M*2;for(let W=M;W>=1;W/=2)x(j,W,g.shape)}let v=g;g=am({inputs:{x:g},backend:t,attrs:{begin:0,size:[u,r]}}),qh(t,v);let b=LV({inputs:{x:d,indices:g},backend:t,attrs:{axis:1,batchDims:1}});qh(t,d);const S=a.slice(0,-1);S.push(r),v=g,g=cn({inputs:{x:g},attrs:{shape:S},backend:t}),qh(t,v);const C=b;return b=cn({inputs:{x:b},attrs:{shape:S},backend:t}),qh(t,C),[b,g]}const T6e={kernelName:qy,backendName:"webgpu",kernelFunc:E6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I6e{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=en(this.outputShape),this.dispatch=Ut(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ot("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k6e(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:r}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[u,d,h,p]=i.shape,[g,y]=c??[d,h],x=[u,g,y,p],v=new I6e(x),b=o==="nearest"?1:2;let S;switch(a){case"constant":S=1;break;case"reflect":S=2;break;case"wrap":S=3;break;case"nearest":S=4;break;default:S=1;break}const C=[{type:"int32",data:[b]},{type:"int32",data:[S]},{type:"float32",data:[l]}];return t.runWebGPUProgram(v,[i,r],"float32",C)}const A6e={kernelName:Ky,backendName:"webgpu",kernelFunc:k6e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6e(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[r],c=new Array(a-1);let u=0;for(let y=0;y<a;y++)y!==r&&(c[u++]=o.shape[y]);const d=[],h=new Array(a).fill(0),p=o.shape.slice();p[r]=1;const g=new Array(l);for(let y=0;y<g.length;y++){h[r]=y;const x=am({inputs:{x:o},backend:t,attrs:{begin:h,size:p}}),v=cn({inputs:{x},backend:t,attrs:{shape:c}});g[y]=v,d.push(x)}return d.forEach(y=>t.disposeData(y.dataId)),g}const M6e={kernelName:o1,backendName:"webgpu",kernelFunc:R6e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N6e{constructor(e,t,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=en(e),this.dispatch=Ut(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Ot("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Cu("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P6e(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:o}=s,a=i.shape.length,l=[];let c=0;const u=Os([c],a);let d=i;u!=null&&(d=kl({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(d),c=Ys(1,a)[0]);const h=JT(d.shape,c,o),p=Le([d.shape[c]]),g=cn({inputs:{x:d},backend:t,attrs:{shape:[-1,p]}});l.push(g);const y=i.dtype,x=[g.shape[0],o],v=Qr({backend:t,attrs:{shape:x,value:0,dtype:y}}),b=new N6e(g.shape,x,y),S=[{type:"int32",data:[o]},{type:"int32",data:[Le(g.shape)]}],C=t.runWebGPUProgram(b,[g,r],y,S,v),E=cn({inputs:{x:C},backend:t,attrs:{shape:h}});l.push(C);let k=E;if(u!=null){l.push(E);const R=Nl(u);k=kl({inputs:{x:k},backend:t,attrs:{perm:R}})}return l.forEach(R=>t.disposeData(R.dataId)),k}const D6e={kernelName:a1,backendName:"webgpu",kernelFunc:P6e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L6e=[oPe,GPe,jPe,qPe,YPe,JPe,oDe,lDe,uDe,hDe,pDe,gDe,vDe,wDe,SDe,IDe,ADe,PDe,LDe,FDe,VDe,jDe,KDe,JDe,tLe,rLe,lPe,lLe,hLe,wLe,TLe,RLe,PLe,LLe,FLe,zLe,ULe,GLe,jLe,qLe,YLe,JLe,o$e,l$e,n$e,d$e,p$e,v$e,w$e,C$e,I$e,A$e,M$e,P$e,L$e,F$e,O$e,B$e,V$e,sPe,G$e,Y$e,j$e,q$e,J$e,tFe,sFe,oFe,cFe,dFe,fFe,aPe,mFe,uLe,xFe,yFe,bFe,CFe,EFe,IFe,RFe,DFe,NFe,$Fe,OFe,BFe,GFe,XFe,_De,KFe,ZFe,rOe,JFe,sOe,aOe,EDe,cOe,dOe,fOe,mOe,wOe,_$e,SOe,_Oe,TOe,YDe,AOe,MOe,POe,$Oe,OOe,BOe,VOe,GOe,ZDe,jOe,qOe,YOe,QOe,iPe,t5e,i5e,a5e,u5e,f5e,m5e,x5e,y5e,b5e,_5e,I5e,A5e,M5e,P5e,L5e,F5e,BDe,c6e,h6e,p6e,vOe,z5e,V5e,X5e,K5e,e6e,n6e,i6e,r6e,a6e,g6e,E$e,v6e,w6e,S6e,Q5e,T6e,A6e,nDe,M6e,D6e,ROe];for(const n of L6e)vT(n);/**
    * @license
    * Copyright 2024 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function Uc(n){var e=n.map(function(t){return t[0]});return e.push(n[n.length-1][1]),e}var $6e={lips:Uc([[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]]),leftEye:Uc([[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]]),leftEyebrow:Uc([[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]]),leftIris:Uc([[474,475],[475,476],[476,477],[477,474]]),rightEye:Uc([[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]]),rightEyebrow:Uc([[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]]),rightIris:Uc([[469,470],[470,471],[471,472],[472,469]]),faceOval:Uc([[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]])},F6e=Object.entries($6e).map(function(n){var e=n[0];return n[1].map(function(t){return[t,e]})}).flat();new Map(F6e);var uC=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};(function(){var n;function e(A){var U=0;return function(){return U<A.length?{done:!1,value:A[U++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(A,U,Q){return A==Array.prototype||A==Object.prototype||(A[U]=Q.value),A},s=function(A){A=[typeof globalThis=="object"&&globalThis,A,typeof window=="object"&&window,typeof self=="object"&&self,typeof uC=="object"&&uC];for(var U=0;U<A.length;++U){var Q=A[U];if(Q&&Q.Math==Math)return Q}throw Error("Cannot find global object")}(this);function i(A,U){if(U)e:{var Q=s;A=A.split(".");for(var ie=0;ie<A.length-1;ie++){var de=A[ie];if(!(de in Q))break e;Q=Q[de]}(U=U(ie=Q[A=A[A.length-1]]))!=ie&&U!=null&&t(Q,A,{configurable:!0,writable:!0,value:U})}}function r(A){return(A={next:A})[Symbol.iterator]=function(){return this},A}function o(A){var U=typeof Symbol<"u"&&Symbol.iterator&&A[Symbol.iterator];return U?U.call(A):{next:e(A)}}function a(A){if(!(A instanceof Array)){A=o(A);for(var U,Q=[];!(U=A.next()).done;)Q.push(U.value);A=Q}return A}i("Symbol",function(A){function U(de,ue){this.g=de,t(this,"description",{configurable:!0,writable:!0,value:ue})}if(A)return A;U.prototype.toString=function(){return this.g};var Q="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ie=0;return function de(ue){if(this instanceof de)throw new TypeError("Symbol is not a constructor");return new U(Q+(ue||"")+"_"+ie++,ue)}}),i("Symbol.iterator",function(A){if(A)return A;A=Symbol("Symbol.iterator");for(var U="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),Q=0;Q<U.length;Q++){var ie=s[U[Q]];typeof ie=="function"&&typeof ie.prototype[A]!="function"&&t(ie.prototype,A,{configurable:!0,writable:!0,value:function(){return r(e(this))}})}return A});var l,c=typeof Object.create=="function"?Object.create:function(A){function U(){}return U.prototype=A,new U};if(typeof Object.setPrototypeOf=="function")l=Object.setPrototypeOf;else{var u;e:{var d={};try{d.__proto__={a:!0},u=d.a;break e}catch{}u=!1}l=u?function(A,U){if(A.__proto__=U,A.__proto__!==U)throw new TypeError(A+" is not extensible");return A}:null}var h=l;function p(A,U){if(A.prototype=c(U.prototype),A.prototype.constructor=A,h)h(A,U);else for(var Q in U)if(Q!="prototype")if(Object.defineProperties){var ie=Object.getOwnPropertyDescriptor(U,Q);ie&&Object.defineProperty(A,Q,ie)}else A[Q]=U[Q];A.na=U.prototype}function g(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.u=this.o=0,this.j=null}function y(A){if(A.l)throw new TypeError("Generator is already running");A.l=!0}function x(A,U){A.j={da:U,ea:!0},A.g=A.o||A.u}function v(A,U,Q){return A.g=Q,{value:U}}function b(A){this.g=new g,this.h=A}function S(A,U,Q,ie){try{var de=U.call(A.g.i,Q);if(!(de instanceof Object))throw new TypeError("Iterator result "+de+" is not an object");if(!de.done)return A.g.l=!1,de;var ue=de.value}catch(fe){return A.g.i=null,x(A.g,fe),C(A)}return A.g.i=null,ie.call(A.g,ue),C(A)}function C(A){for(;A.g.g;)try{var U=A.h(A.g);if(U)return A.g.l=!1,{value:U.value,done:!1}}catch(Q){A.g.h=void 0,x(A.g,Q)}if(A.g.l=!1,A.g.j){if(U=A.g.j,A.g.j=null,U.ea)throw U.da;return{value:U.return,done:!0}}return{value:void 0,done:!0}}function E(A){this.next=function(U){return y(A.g),A.g.i?U=S(A,A.g.i.next,U,A.g.s):(A.g.s(U),U=C(A)),U},this.throw=function(U){return y(A.g),A.g.i?U=S(A,A.g.i.throw,U,A.g.s):(x(A.g,U),U=C(A)),U},this.return=function(U){return function(Q,ie){y(Q.g);var de=Q.g.i;return de?S(Q,"return"in de?de.return:function(ue){return{value:ue,done:!0}},ie,Q.g.return):(Q.g.return(ie),C(Q))}(A,U)},this[Symbol.iterator]=function(){return this}}function k(A){return function(U){function Q(de){return U.next(de)}function ie(de){return U.throw(de)}return new Promise(function(de,ue){(function fe(we){we.done?de(we.value):Promise.resolve(we.value).then(Q,ie).then(fe,ue)})(U.next())})}(new E(new b(A)))}g.prototype.s=function(A){this.h=A},g.prototype.return=function(A){this.j={return:A},this.g=this.u},i("Promise",function(A){function U(fe){this.h=0,this.i=void 0,this.g=[],this.s=!1;var we=this.j();try{fe(we.resolve,we.reject)}catch(Ke){we.reject(Ke)}}function Q(){this.g=null}function ie(fe){return fe instanceof U?fe:new U(function(we){we(fe)})}if(A)return A;Q.prototype.h=function(fe){if(this.g==null){this.g=[];var we=this;this.i(function(){we.l()})}this.g.push(fe)};var de=s.setTimeout;Q.prototype.i=function(fe){de(fe,0)},Q.prototype.l=function(){for(;this.g&&this.g.length;){var fe=this.g;this.g=[];for(var we=0;we<fe.length;++we){var Ke=fe[we];fe[we]=null;try{Ke()}catch(lt){this.j(lt)}}}this.g=null},Q.prototype.j=function(fe){this.i(function(){throw fe})},U.prototype.j=function(){function fe(lt){return function(ft){Ke||(Ke=!0,lt.call(we,ft))}}var we=this,Ke=!1;return{resolve:fe(this.D),reject:fe(this.l)}},U.prototype.D=function(fe){if(fe===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(fe instanceof U)this.H(fe);else{e:switch(typeof fe){case"object":var we=fe!=null;break e;case"function":we=!0;break e;default:we=!1}we?this.A(fe):this.o(fe)}},U.prototype.A=function(fe){var we=void 0;try{we=fe.then}catch(Ke){return void this.l(Ke)}typeof we=="function"?this.I(we,fe):this.o(fe)},U.prototype.l=function(fe){this.u(2,fe)},U.prototype.o=function(fe){this.u(1,fe)},U.prototype.u=function(fe,we){if(this.h!=0)throw Error("Cannot settle("+fe+", "+we+"): Promise already settled in state"+this.h);this.h=fe,this.i=we,this.h===2&&this.G(),this.B()},U.prototype.G=function(){var fe=this;de(function(){if(fe.C()){var we=s.console;we!==void 0&&we.error(fe.i)}},1)},U.prototype.C=function(){if(this.s)return!1;var fe=s.CustomEvent,we=s.Event,Ke=s.dispatchEvent;return Ke===void 0||(typeof fe=="function"?fe=new fe("unhandledrejection",{cancelable:!0}):typeof we=="function"?fe=new we("unhandledrejection",{cancelable:!0}):(fe=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,fe),fe.promise=this,fe.reason=this.i,Ke(fe))},U.prototype.B=function(){if(this.g!=null){for(var fe=0;fe<this.g.length;++fe)ue.h(this.g[fe]);this.g=null}};var ue=new Q;return U.prototype.H=function(fe){var we=this.j();fe.M(we.resolve,we.reject)},U.prototype.I=function(fe,we){var Ke=this.j();try{fe.call(we,Ke.resolve,Ke.reject)}catch(lt){Ke.reject(lt)}},U.prototype.then=function(fe,we){function Ke(Ft,Bt){return typeof Ft=="function"?function(Ln){try{lt(Ft(Ln))}catch(qn){ft(qn)}}:Bt}var lt,ft,Dt=new U(function(Ft,Bt){lt=Ft,ft=Bt});return this.M(Ke(fe,lt),Ke(we,ft)),Dt},U.prototype.catch=function(fe){return this.then(void 0,fe)},U.prototype.M=function(fe,we){function Ke(){switch(lt.h){case 1:fe(lt.i);break;case 2:we(lt.i);break;default:throw Error("Unexpected state: "+lt.h)}}var lt=this;this.g==null?ue.h(Ke):this.g.push(Ke),this.s=!0},U.resolve=ie,U.reject=function(fe){return new U(function(we,Ke){Ke(fe)})},U.race=function(fe){return new U(function(we,Ke){for(var lt=o(fe),ft=lt.next();!ft.done;ft=lt.next())ie(ft.value).M(we,Ke)})},U.all=function(fe){var we=o(fe),Ke=we.next();return Ke.done?ie([]):new U(function(lt,ft){function Dt(Ln){return function(qn){Ft[Ln]=qn,--Bt==0&&lt(Ft)}}var Ft=[],Bt=0;do Ft.push(void 0),Bt++,ie(Ke.value).M(Dt(Ft.length-1),ft),Ke=we.next();while(!Ke.done)})},U});var R=typeof Object.assign=="function"?Object.assign:function(A,U){for(var Q=1;Q<arguments.length;Q++){var ie=arguments[Q];if(ie)for(var de in ie)Object.prototype.hasOwnProperty.call(ie,de)&&(A[de]=ie[de])}return A};i("Object.assign",function(A){return A||R}),i("Object.is",function(A){return A||function(U,Q){return U===Q?U!==0||1/U==1/Q:U!=U&&Q!=Q}}),i("Array.prototype.includes",function(A){return A||function(U,Q){var ie=this;ie instanceof String&&(ie=String(ie));var de=ie.length;for(0>(Q=Q||0)&&(Q=Math.max(Q+de,0));Q<de;Q++){var ue=ie[Q];if(ue===U||Object.is(ue,U))return!0}return!1}}),i("String.prototype.includes",function(A){return A||function(U,Q){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(U instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(U,Q||0)!==-1}}),i("Array.prototype.keys",function(A){return A||function(){return function(U,Q){U instanceof String&&(U+="");var ie=0,de=!1,ue={next:function(){if(!de&&ie<U.length){var fe=ie++;return{value:Q(fe,U[fe]),done:!1}}return de=!0,{done:!0,value:void 0}}};return ue[Symbol.iterator]=function(){return ue},ue}(this,function(U){return U})}});var L=this||self;function I(A,U){A=A.split(".");var Q,ie=L;for((A[0]in ie)||ie.execScript===void 0||ie.execScript("var "+A[0]);A.length&&(Q=A.shift());)A.length||U===void 0?ie=ie[Q]&&ie[Q]!==Object.prototype[Q]?ie[Q]:ie[Q]={}:ie[Q]=U}function T(){throw Error("Invalid UTF8")}function M(A,U){return U=String.fromCharCode.apply(null,U),A==null?U:A+U}var j,W,z=typeof TextDecoder<"u",X=typeof TextEncoder<"u",B={},J=null;function K(A){var U;U===void 0&&(U=0),ne(),U=B[U];for(var Q=Array(Math.floor(A.length/3)),ie=U[64]||"",de=0,ue=0;de<A.length-2;de+=3){var fe=A[de],we=A[de+1],Ke=A[de+2],lt=U[fe>>2];fe=U[(3&fe)<<4|we>>4],we=U[(15&we)<<2|Ke>>6],Ke=U[63&Ke],Q[ue++]=lt+fe+we+Ke}switch(lt=0,Ke=ie,A.length-de){case 2:Ke=U[(15&(lt=A[de+1]))<<2]||ie;case 1:A=A[de],Q[ue]=U[A>>2]+U[(3&A)<<4|lt>>4]+Ke+ie}return Q.join("")}function ee(A){var U=A.length,Q=3*U/4;Q%3?Q=Math.floor(Q):"=.".indexOf(A[U-1])!=-1&&(Q="=.".indexOf(A[U-2])!=-1?Q-2:Q-1);var ie=new Uint8Array(Q),de=0;return function(ue,fe){function we(Bt){for(;Ke<ue.length;){var Ln=ue.charAt(Ke++),qn=J[Ln];if(qn!=null)return qn;if(!/^[\s\xa0]*$/.test(Ln))throw Error("Unknown base64 encoding at char: "+Ln)}return Bt}ne();for(var Ke=0;;){var lt=we(-1),ft=we(0),Dt=we(64),Ft=we(64);if(Ft===64&&lt===-1)break;fe(lt<<2|ft>>4),Dt!=64&&(fe(ft<<4&240|Dt>>2),Ft!=64&&fe(Dt<<6&192|Ft))}}(A,function(ue){ie[de++]=ue}),de!==Q?ie.subarray(0,de):ie}function ne(){if(!J){J={};for(var A="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),U=["+/=","+/","-_=","-_.","-_"],Q=0;5>Q;Q++){var ie=A.concat(U[Q].split(""));B[Q]=ie;for(var de=0;de<ie.length;de++){var ue=ie[de];J[ue]===void 0&&(J[ue]=de)}}}}var V,Z=typeof Uint8Array=="function";function he(A){return Z&&A!=null&&A instanceof Uint8Array}function ve(A){if(this.L=A,A!==null&&A.length===0)throw Error("ByteString should be constructed with non-empty values")}var be=typeof Uint8Array.prototype.slice=="function",Ie=0;function Xe(A,U){return Error("Invalid wire type: "+A+" (at position "+U+")")}function Fe(){return Error("Failed to read varint, encoding is invalid.")}function Pe(A,U){U=(U=U===void 0?{}:U).v!==void 0&&U.v,this.h=null,this.g=this.i=this.j=0,this.v=U,A&&ct(this,A)}function ct(A,U){A.h=function(Q,ie){if(Q.constructor===Uint8Array)return Q;if(Q.constructor===ArrayBuffer)return new Uint8Array(Q);if(Q.constructor===Array)return new Uint8Array(Q);if(Q.constructor===String)return ee(Q);if(Q.constructor===ve)return!ie&&(ie=Q.L)&&ie.constructor===Uint8Array?ie:(ie=(ie=Q.L)==null||he(ie)?ie:typeof ie=="string"?ee(ie):null,(Q=Q.L=ie)?new Uint8Array(Q):V||(V=new Uint8Array(0)));if(Q instanceof Uint8Array)return new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")}(U,A.v),A.j=0,A.i=A.h.length,A.g=A.j}function at(A){if(A.g>A.i)throw Error("Tried to read past the end of the data "+A.g+" > "+A.i)}function Ee(A){var U=A.h,Q=U[A.g],ie=127&Q;if(128>Q)return A.g+=1,at(A),ie;if(ie|=(127&(Q=U[A.g+1]))<<7,128>Q)return A.g+=2,at(A),ie;if(ie|=(127&(Q=U[A.g+2]))<<14,128>Q)return A.g+=3,at(A),ie;if(ie|=(127&(Q=U[A.g+3]))<<21,128>Q)return A.g+=4,at(A),ie;if(Q=U[A.g+4],A.g+=5,ie|=(15&Q)<<28,128>Q)return at(A),ie;if(128<=U[A.g++]&&128<=U[A.g++]&&128<=U[A.g++]&&128<=U[A.g++]&&128<=U[A.g++])throw Fe();return at(A),ie}Pe.prototype.reset=function(){this.g=this.j};var nn=[];function gt(){this.g=[]}function vt(A,U){for(;127<U;)A.g.push(127&U|128),U>>>=7;A.g.push(U)}function wt(A){var U={},Q=U.W!==void 0&&U.W;this.l={v:U.v!==void 0&&U.v},this.W=Q,U=this.l,nn.length?(Q=nn.pop(),U&&(Q.v=U.v),A&&ct(Q,A),A=Q):A=new Pe(A,U),this.g=A,this.j=this.g.g,this.h=this.i=-1}function Vt(A){var U=A.g;if(U.g==U.i)return!1;A.j=A.g.g;var Q=Ee(A.g)>>>0;if(U=Q>>>3,!(0<=(Q&=7)&&5>=Q))throw Xe(Q,A.j);if(1>U)throw Error("Invalid field number: "+U+" (at position "+A.j+")");return A.i=U,A.h=Q,!0}function It(A){switch(A.h){case 0:if(A.h!=0)It(A);else e:{for(var U=(A=A.g).g,Q=U+10;U<Q;)if((128&A.h[U++])==0){A.g=U,at(A);break e}throw Fe()}break;case 1:(A=A.g).g+=8,at(A);break;case 2:A.h!=2?It(A):(U=Ee(A.g)>>>0,(A=A.g).g+=U,at(A));break;case 5:(A=A.g).g+=4,at(A);break;case 3:for(U=A.i;;){if(!Vt(A))throw Error("Unmatched start-group tag: stream EOF");if(A.h==4){if(A.i!=U)throw Error("Unmatched end-group tag");break}It(A)}break;default:throw Xe(A.h,A.j)}}gt.prototype.length=function(){return this.g.length},gt.prototype.end=function(){var A=this.g;return this.g=[],A},wt.prototype.reset=function(){this.g.reset(),this.j=this.g.g,this.h=this.i=-1};var zt=[];function Gt(){this.i=[],this.h=0,this.g=new gt}function dn(A,U){U.length!==0&&(A.i.push(U),A.h+=U.length)}var vn=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol(void 0):void 0;function ce(A,U){Object.isFrozen(A)||(vn?A[vn]|=U:A.N!==void 0?A.N|=U:Object.defineProperties(A,{N:{value:U,configurable:!0,writable:!0,enumerable:!1}}))}function Y(A){var U;return(U=vn?A[vn]:A.N)==null?0:U}function ye(A){return ce(A,1),A}function Qe(A){return!!Array.isArray(A)&&!!(2&Y(A))}function tt(A){if(!Array.isArray(A))throw Error("cannot mark non-array as immutable");ce(A,2)}function rt(A){return A!==null&&typeof A=="object"&&!Array.isArray(A)&&A.constructor===Object}var Pt=Object.freeze(ye([]));function pt(A){if(Qe(A.m))throw Error("Cannot mutate an immutable Message")}var At,xe=typeof Symbol<"u"&&Symbol.hasInstance!==void 0;function xt(A){return{value:A,configurable:!1,writable:!1,enumerable:!1}}function Ye(A,U,Q){return U===-1?null:U>=A.i?A.g?A.g[U]:void 0:Q!==void 0&&Q&&A.g&&(Q=A.g[U])!=null?Q:A.m[U+A.h]}function kt(A,U,Q,ie){ie=ie!==void 0&&ie,pt(A),U<A.i&&!ie?A.m[U+A.h]=Q:(A.g||(A.g=A.m[A.i+A.h]={}))[U]=Q}function Et(A,U,Q,ie){Q=Q===void 0||Q;var de=Ye(A,U,ie=ie!==void 0&&ie);return de==null&&(de=Pt),Qe(A.m)?Q&&(tt(de),Object.freeze(de)):(de===Pt||Qe(de))&&kt(A,U,de=ye(de.slice()),ie),de}function bt(A,U,Q){return(A=(A=Ye(A,U))==null?A:+A)==null?Q===void 0?0:Q:A}function Wt(A,U,Q,ie){A.j||(A.j={});var de=Qe(A.m),ue=A.j[Q];if(!ue){ie=Et(A,Q,!0,ie!==void 0&&ie),ue=[],de=de||Qe(ie);for(var fe=0;fe<ie.length;fe++)ue[fe]=new U(ie[fe]),de&&tt(ue[fe].m);de&&(tt(ue),Object.freeze(ue)),A.j[Q]=ue}return ue}function ht(A,U,Q,ie,de){var ue=ue!==void 0&&ue;return pt(A),ue=Wt(A,Q,U,ue),Q=ie||new Q,A=Et(A,U),de!=null?(ue.splice(de,0,Q),A.splice(de,0,Q.m)):(ue.push(Q),A.push(Q.m)),Q}function Ht(A,U){return(A=Ye(A,U))==null?0:A}function Ce(A,U){return(A=Ye(A,U))==null?"":A}function St(A){var U=Rt;return Be(A,U=U===void 0?rn:U)}function dt(A,U){if(A!=null){if(Array.isArray(A))A=Be(A,U);else if(rt(A)){var Q,ie={};for(Q in A)ie[Q]=dt(A[Q],U);A=ie}else A=U(A);return A}}function Be(A,U){for(var Q=A.slice(),ie=0;ie<Q.length;ie++)Q[ie]=dt(Q[ie],U);return Array.isArray(A)&&1&Y(A)&&ye(Q),Q}function Rt(A){return A&&typeof A=="object"&&A.toJSON?A.toJSON():(A=function(U){switch(typeof U){case"number":return isFinite(U)?U:String(U);case"object":if(U&&!Array.isArray(U)){if(he(U))return K(U);if(U instanceof ve){var Q=U.L;return Q=Q==null||typeof Q=="string"?Q:Z&&Q instanceof Uint8Array?K(Q):null,(U.L=Q)||""}}}return U}(A),Array.isArray(A)?St(A):A)}function rn(A){return he(A)?new Uint8Array(A):A}function In(A,U,Q){A||(A=At),At=null;var ie=this.constructor.h;if(A||(A=ie?[ie]:[]),this.h=(ie?0:-1)-(this.constructor.g||0),this.j=void 0,this.m=A,A=(ie=this.m.length)-1,ie&&rt(ie=this.m[A])?(this.i=A-this.h,this.g=ie):U!==void 0&&-1<U?(this.i=Math.max(U,A+1-this.h),this.g=void 0):this.i=Number.MAX_VALUE,Q)for(U=0;U<Q.length;U++)if((A=Q[U])<this.i)A+=this.h,(ie=this.m[A])?Array.isArray(ie)&&ye(ie):this.m[A]=Pt;else{var de=(ie=this.g||(this.g=this.m[this.i+this.h]={}))[A];de?Array.isArray(de)&&ye(de):ie[A]=Pt}}function zn(){In.apply(this,arguments)}if(In.prototype.toJSON=function(){return St(this.m)},In.prototype.toString=function(){return this.m.toString()},p(zn,In),xe){var _s={};Object.defineProperties(zn,(_s[Symbol.hasInstance]=xt(function(){throw Error("Cannot perform instanceof checks for MutableMessage")}),_s))}function ns(A,U,Q){if(Q){var ie,de={};for(ie in Q){var ue=Q[ie],fe=ue.ha;fe||(de.F=ue.la||ue.fa.P,ue.aa?(de.U=fr(ue.aa),fe=function(we){return function(Ke,lt,ft){return we.F(Ke,lt,ft,we.U)}}(de)):ue.ca?(de.T=no(ue.X.g,ue.ca),fe=function(we){return function(Ke,lt,ft){return we.F(Ke,lt,ft,we.T)}}(de)):fe=de.F,ue.ha=fe),fe(U,A,ue.X),de={F:de.F,U:de.U,T:de.T}}}(function(we,Ke){if(Ke=Ke.ba){dn(we,we.g.end());for(var lt=0;lt<Ke.length;lt++)dn(we,Ke[lt])}})(U,A)}var hs=Symbol();function Ls(A,U,Q){return A[hs]||(A[hs]=function(ie,de){return U(ie,de,Q)})}function Or(A){var U=A[hs];if(!U){var Q=bn(A);U=function(ie,de){return Yt(ie,de,Q)},A[hs]=U}return U}function So(A){var U=function(de){var ue=de.aa;return ue?Or(ue):(ue=de.ka)?Ls(de.X.g,ue,de.ca):void 0}(A),Q=A.X,ie=A.fa.O;return U?function(de,ue){return ie(de,ue,Q,U)}:function(de,ue){return ie(de,ue,Q)}}function ks(A,U,Q,ie,de,ue){var fe=0;for((A=A()).length&&typeof A[0]!="number"&&(Q(U,A[0]),fe++);fe<A.length;){Q=A[fe++];for(var we=fe+1;we<A.length&&typeof A[we]!="number";)we++;var Ke=A[fe++];switch(we-=fe){case 0:ie(U,Q,Ke);break;case 1:ie(U,Q,Ke,A[fe++]);break;case 2:de(U,Q,Ke,A[fe++],A[fe++]);break;case 3:we=A[fe++];var lt=A[fe++],ft=A[fe++];Array.isArray(ft)?de(U,Q,Ke,we,lt,ft):ue(U,Q,Ke,we,lt,ft);break;case 4:ue(U,Q,Ke,A[fe++],A[fe++],A[fe++],A[fe++]);break;default:throw Error("unexpected number of binary field arguments: "+we)}}return U}var Ri=Symbol();function fr(A){var U=A[Ri];if(!U){var Q=We(A);U=function(ie,de){return _n(ie,de,Q)},A[Ri]=U}return U}function no(A,U){var Q=A[Ri];return Q||(Q=function(ie,de){return ns(ie,de,U)},A[Ri]=Q),Q}var ua=Symbol();function so(A,U){A.push(U)}function pr(A,U,Q){A.push(U,Q.P)}function Co(A,U,Q,ie,de){var ue=fr(de),fe=Q.P;A.push(U,function(we,Ke,lt){return fe(we,Ke,lt,ie,ue)})}function oe(A,U,Q,ie,de,ue){var fe=no(ie,ue),we=Q.P;A.push(U,function(Ke,lt,ft){return we(Ke,lt,ft,ie,fe)})}function We(A){var U=A[ua];return U||ks(A,A[ua]=[],so,pr,Co,oe)}var Ze=Symbol();function Je(A,U){A[0]=U}function nt(A,U,Q,ie){var de=Q.O;A[U]=ie?function(ue,fe,we){return de(ue,fe,we,ie)}:de}function Kt(A,U,Q,ie,de,ue){var fe=Q.O,we=Or(de);A[U]=function(Ke,lt,ft){return fe(Ke,lt,ft,ie,we,ue)}}function on(A,U,Q,ie,de,ue,fe){var we=Q.O,Ke=Ls(ie,de,ue);A[U]=function(lt,ft,Dt){return we(lt,ft,Dt,ie,Ke,fe)}}function bn(A){var U=A[Ze];return U||ks(A,A[Ze]={},Je,nt,Kt,on)}function Yt(A,U,Q){for(;Vt(U)&&U.h!=4;){var ie=U.i,de=Q[ie];if(!de){var ue=Q[0];ue&&(ue=ue[ie])&&(de=Q[ie]=So(ue))}if(!(de&&de(U,A,ie)||(de=U,ie=A,ue=de.j,It(de),de.W))){var fe=de.g.h;de=ue===(de=de.g.g)?V||(V=new Uint8Array(0)):be?fe.slice(ue,de):new Uint8Array(fe.subarray(ue,de)),(ue=ie.ba)?ue.push(de):ie.ba=[de]}}return A}function Bn(A,U,Q){if(zt.length){var ie=zt.pop();A&&(ct(ie.g,A),ie.i=-1,ie.h=-1),A=ie}else A=new wt(A);try{return Yt(new U,A,bn(Q))}finally{(U=A.g).h=null,U.j=0,U.i=0,U.g=0,U.v=!1,A.i=-1,A.h=-1,100>zt.length&&zt.push(A)}}function _n(A,U,Q){for(var ie=Q.length,de=ie%2==1,ue=de?1:0;ue<ie;ue+=2)(0,Q[ue+1])(U,A,Q[ue]);ns(A,U,de?Q[0]:void 0)}function En(A,U){var Q=new Gt;_n(A,Q,We(U)),dn(Q,Q.g.end()),A=new Uint8Array(Q.h);for(var ie=(U=Q.i).length,de=0,ue=0;ue<ie;ue++){var fe=U[ue];A.set(fe,de),de+=fe.length}return Q.i=[A],A}function fs(A,U){return{O:A,P:U}}var ws=fs(function(A,U,Q){if(A.h!==5)return!1;var ie=(A=A.g).h[A.g],de=A.h[A.g+1],ue=A.h[A.g+2],fe=A.h[A.g+3];return A.g+=4,at(A),A=2*((de=(ie<<0|de<<8|ue<<16|fe<<24)>>>0)>>31)+1,ie=de>>>23&255,de&=8388607,kt(U,Q,ie==255?de?NaN:1/0*A:ie==0?A*Math.pow(2,-149)*de:A*Math.pow(2,ie-150)*(de+Math.pow(2,23))),!0},function(A,U,Q){if((U=Ye(U,Q))!=null){vt(A.g,8*Q+5),A=A.g;var ie=U;(ie=(Q=0>ie?1:0)?-ie:ie)===0?0<1/ie?Ie=0:Ie=2147483648:isNaN(ie)?Ie=2147483647:34028234663852886e22<ie?Ie=(Q<<31|2139095040)>>>0:11754943508222875e-54>ie?(ie=Math.round(ie/Math.pow(2,-149)),Ie=(Q<<31|ie)>>>0):(U=Math.floor(Math.log(ie)/Math.LN2),ie*=Math.pow(2,-U),16777216<=(ie=Math.round(8388608*ie))&&++U,Ie=(Q<<31|U+127<<23|8388607&ie)>>>0),Q=Ie,A.g.push(Q>>>0&255),A.g.push(Q>>>8&255),A.g.push(Q>>>16&255),A.g.push(Q>>>24&255)}}),Ws=fs(function(A,U,Q){if(A.h!==0)return!1;for(var ie=A.g,de=128,ue=0,fe=A=0;4>fe&&128<=de;fe++)de=ie.h[ie.g++],at(ie),ue|=(127&de)<<7*fe;if(128<=de&&(de=ie.h[ie.g++],at(ie),ue|=(127&de)<<28,A|=(127&de)>>4),128<=de)for(fe=0;5>fe&&128<=de;fe++)de=ie.h[ie.g++],at(ie),A|=(127&de)<<7*fe+3;if(!(128>de))throw Fe();return ie=ue>>>0,(A=2147483648&(de=A>>>0))&&(de=~de>>>0,(ie=1+~ie>>>0)==0&&(de=de+1>>>0)),ie=4294967296*de+(ie>>>0),kt(U,Q,A?-ie:ie),!0},function(A,U,Q){if((U=Ye(U,Q))!=null&&U!=null){vt(A.g,8*Q),A=A.g;var ie=U;for(Q=0>ie,U=(ie=Math.abs(ie))>>>0,ie=Math.floor((ie-U)/4294967296),ie>>>=0,Q&&(ie=~ie>>>0,4294967295<(U=1+(~U>>>0))&&(U=0,4294967295<++ie&&(ie=0))),Q=Ie=U,U=ie;0<U||127<Q;)A.g.push(127&Q|128),Q=(Q>>>7|U<<25)>>>0,U>>>=7;A.g.push(Q)}}),Mi=fs(function(A,U,Q){return A.h===0&&(kt(U,Q,Ee(A.g)),!0)},function(A,U,Q){if((U=Ye(U,Q))!=null&&U!=null)if(vt(A.g,8*Q),A=A.g,0<=(Q=U))vt(A,Q);else{for(U=0;9>U;U++)A.g.push(127&Q|128),Q>>=7;A.g.push(1)}}),ss=fs(function(A,U,Q){if(A.h!==2)return!1;var ie,de=Ee(A.g)>>>0,ue=(A=A.g).g;if(A.g+=de,at(A),A=A.h,z)(ie=j)||(ie=j=new TextDecoder("utf-8",{fatal:!0})),ie=ie.decode(A.subarray(ue,ue+de));else{de=ue+de;for(var fe,we,Ke,lt=[],ft=null;ue<de;)128>(fe=A[ue++])?lt.push(fe):224>fe?ue>=de?T():(we=A[ue++],194>fe||(192&we)!=128?(ue--,T()):lt.push((31&fe)<<6|63&we)):240>fe?ue>=de-1?T():(192&(we=A[ue++]))!=128||fe===224&&160>we||fe===237&&160<=we||(192&(ie=A[ue++]))!=128?(ue--,T()):lt.push((15&fe)<<12|(63&we)<<6|63&ie):244>=fe?ue>=de-2?T():(192&(we=A[ue++]))!=128||we-144+(fe<<28)>>30!=0||(192&(ie=A[ue++]))!=128||(192&(Ke=A[ue++]))!=128?(ue--,T()):(fe=(7&fe)<<18|(63&we)<<12|(63&ie)<<6|63&Ke,fe-=65536,lt.push(55296+(fe>>10&1023),56320+(1023&fe))):T(),8192<=lt.length&&(ft=M(ft,lt),lt.length=0);ie=M(ft,lt)}return kt(U,Q,ie),!0},function(A,U,Q){if((U=Ye(U,Q))!=null){var ie=!1;if(ie=ie!==void 0&&ie,X){if(ie&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(U))throw Error("Found an unpaired surrogate");U=(W||(W=new TextEncoder)).encode(U)}else{for(var de=0,ue=new Uint8Array(3*U.length),fe=0;fe<U.length;fe++){var we=U.charCodeAt(fe);if(128>we)ue[de++]=we;else{if(2048>we)ue[de++]=we>>6|192;else{if(55296<=we&&57343>=we){if(56319>=we&&fe<U.length){var Ke=U.charCodeAt(++fe);if(56320<=Ke&&57343>=Ke){we=1024*(we-55296)+Ke-56320+65536,ue[de++]=we>>18|240,ue[de++]=we>>12&63|128,ue[de++]=we>>6&63|128,ue[de++]=63&we|128;continue}fe--}if(ie)throw Error("Found an unpaired surrogate");we=65533}ue[de++]=we>>12|224,ue[de++]=we>>6&63|128}ue[de++]=63&we|128}}U=ue.subarray(0,de)}vt(A.g,8*Q+2),vt(A.g,U.length),dn(A,A.g.end()),dn(A,U)}}),Vn=fs(function(A,U,Q,ie,de){if(A.h!==2)return!1;U=ht(U,Q,ie),Q=A.g.i,ie=Ee(A.g)>>>0;var ue=A.g.g+ie,fe=ue-Q;if(0>=fe&&(A.g.i=ue,de(U,A),fe=ue-A.g.g),fe)throw Error("Message parsing ended unexpectedly. Expected to read "+ie+" bytes, instead read "+(ie-fe)+" bytes, either the data ended unexpectedly or the message misreported its own length");return A.g.g=ue,A.g.i=Q,!0},function(A,U,Q,ie,de){if((U=Wt(U,ie,Q))!=null)for(ie=0;ie<U.length;ie++){var ue=A;vt(ue.g,8*Q+2);var fe=ue.g.end();dn(ue,fe),fe.push(ue.h),ue=fe,de(U[ie],A),fe=A;var we=ue.pop();for(we=fe.h+fe.g.length()-we;127<we;)ue.push(127&we|128),we>>>=7,fe.h++;ue.push(we),fe.h++}});function Ss(){zn.apply(this,arguments)}if(p(Ss,zn),xe){var D={};Object.defineProperties(Ss,(D[Symbol.hasInstance]=xt(Object[Symbol.hasInstance]),D))}function H(A){Ss.call(this,A)}function q(){return[1,Mi,2,ws,3,ss,4,ss]}function pe(A){Ss.call(this,A,-1,st)}function Oe(){return[1,Vn,H,q]}p(H,Ss),p(pe,Ss),pe.prototype.addClassification=function(A,U){return ht(this,1,H,A,U),this};var st=[1];function Ue(A){Ss.call(this,A)}function ot(){return[1,ws,2,ws,3,ws,4,ws,5,ws]}function mt(A){Ss.call(this,A,-1,Tn)}function qt(){return[1,Vn,Ue,ot]}p(Ue,Ss),p(mt,Ss);var Tn=[1];function Jn(A){Ss.call(this,A)}function Dn(){return[1,ws,2,ws,3,ws,4,ws,5,ws,6,Ws]}p(Jn,Ss);var Nn=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],sn=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],jt=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],Un=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],Qn=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],Gs=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],ps=[].concat(a(Nn),a(sn),a(jt),a(Un),a(Qn),a(Gs));function P(A,U,Q){if(Q=A.createShader(Q===0?A.VERTEX_SHADER:A.FRAGMENT_SHADER),A.shaderSource(Q,U),A.compileShader(Q),!A.getShaderParameter(Q,A.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+A.getShaderInfoLog(Q));return Q}function F(A){return Wt(A,H,1).map(function(U){return{index:Ht(U,1),ga:bt(U,2),label:Ye(U,3)!=null?Ce(U,3):void 0,displayName:Ye(U,4)!=null?Ce(U,4):void 0}})}function O(A){return{x:bt(A,1),y:bt(A,2),z:bt(A,3),visibility:Ye(A,4)!=null?bt(A,4):void 0}}function ae(A,U){this.h=A,this.g=U,this.l=0}function Se(A,U,Q){return function(ie,de){var ue=ie.g;if(ie.o===void 0){var fe=P(ue,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),we=P(ue,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),Ke=ue.createProgram();if(ue.attachShader(Ke,fe),ue.attachShader(Ke,we),ue.linkProgram(Ke),!ue.getProgramParameter(Ke,ue.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+ue.getProgramInfoLog(Ke));fe=ie.o=Ke,ue.useProgram(fe),we=ue.getUniformLocation(fe,"sampler0"),ie.j={K:ue.getAttribLocation(fe,"aVertex"),J:ue.getAttribLocation(fe,"aTex"),ma:we},ie.u=ue.createBuffer(),ue.bindBuffer(ue.ARRAY_BUFFER,ie.u),ue.enableVertexAttribArray(ie.j.K),ue.vertexAttribPointer(ie.j.K,2,ue.FLOAT,!1,0,0),ue.bufferData(ue.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),ue.STATIC_DRAW),ue.bindBuffer(ue.ARRAY_BUFFER,null),ie.s=ue.createBuffer(),ue.bindBuffer(ue.ARRAY_BUFFER,ie.s),ue.enableVertexAttribArray(ie.j.J),ue.vertexAttribPointer(ie.j.J,2,ue.FLOAT,!1,0,0),ue.bufferData(ue.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),ue.STATIC_DRAW),ue.bindBuffer(ue.ARRAY_BUFFER,null),ue.uniform1i(we,0)}fe=ie.j,ue.useProgram(ie.o),ue.canvas.width=de.width,ue.canvas.height=de.height,ue.viewport(0,0,de.width,de.height),ue.activeTexture(ue.TEXTURE0),ie.h.bindTexture2d(de.glName),ue.enableVertexAttribArray(fe.K),ue.bindBuffer(ue.ARRAY_BUFFER,ie.u),ue.vertexAttribPointer(fe.K,2,ue.FLOAT,!1,0,0),ue.enableVertexAttribArray(fe.J),ue.bindBuffer(ue.ARRAY_BUFFER,ie.s),ue.vertexAttribPointer(fe.J,2,ue.FLOAT,!1,0,0),ue.bindFramebuffer(ue.DRAW_FRAMEBUFFER?ue.DRAW_FRAMEBUFFER:ue.FRAMEBUFFER,null),ue.clearColor(0,0,0,0),ue.clear(ue.COLOR_BUFFER_BIT),ue.colorMask(!0,!0,!0,!0),ue.drawArrays(ue.TRIANGLE_FAN,0,4),ue.disableVertexAttribArray(fe.K),ue.disableVertexAttribArray(fe.J),ue.bindBuffer(ue.ARRAY_BUFFER,null),ie.h.bindTexture2d(0)}(A,U),typeof A.g.canvas.transferToImageBitmap=="function"?Promise.resolve(A.g.canvas.transferToImageBitmap()):Q?Promise.resolve(A.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(A.g.canvas):(A.i===void 0&&(A.i=document.createElement("canvas")),new Promise(function(ie){A.i.height=A.g.canvas.height,A.i.width=A.g.canvas.width,A.i.getContext("2d",{}).drawImage(A.g.canvas,0,0,A.g.canvas.width,A.g.canvas.height),ie(A.i)}))}function Ve(A){this.g=A}var Ae=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Ge(A,U){return U+A}function ut(A,U){window[A]=U}function Tt(A){if(this.g=A,this.listeners={},this.j={},this.H={},this.o={},this.u={},this.I=this.s=this.Z=!0,this.D=Promise.resolve(),this.Y="",this.C={},this.locateFile=A&&A.locateFile||Ge,typeof window=="object")var U=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(typeof location>"u")throw Error("solutions can only be loaded on a web page or in a web worker");U=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.$=U,A.options)for(var Q=(U=o(Object.keys(A.options))).next();!Q.done;Q=U.next()){Q=Q.value;var ie=A.options[Q].default;ie!==void 0&&(this.j[Q]=typeof ie=="function"?ie():ie)}}function kn(A){var U,Q,ie,de,ue,fe,we,Ke,lt,ft,Dt;return k(function(Ft){switch(Ft.g){case 1:return A.Z?(U=A.g.files===void 0?[]:typeof A.g.files=="function"?A.g.files(A.j):A.g.files,v(Ft,k(function(Bt){switch(Bt.g){case 1:return Bt.o=2,v(Bt,WebAssembly.instantiate(Ae),4);case 4:Bt.g=3,Bt.o=0;break;case 2:return Bt.o=0,Bt.j=null,Bt.return(!1);case 3:return Bt.return(!0)}}),2)):Ft.return();case 2:if(Q=Ft.h,typeof window=="object")return ut("createMediapipeSolutionsWasm",{locateFile:A.locateFile}),ut("createMediapipeSolutionsPackedAssets",{locateFile:A.locateFile}),fe=U.filter(function(Bt){return Bt.data!==void 0}),we=U.filter(function(Bt){return Bt.data===void 0}),Ke=Promise.all(fe.map(function(Bt){var Ln=jn(A,Bt.url);if(Bt.path!==void 0){var qn=Bt.path;Ln=Ln.then(function(As){return A.overrideFile(qn,As),Promise.resolve(As)})}return Ln})),lt=Promise.all(we.map(function(Bt){return Bt.simd===void 0||Bt.simd&&Q||!Bt.simd&&!Q?function(Ln){var qn=document.createElement("script");return qn.setAttribute("src",Ln),qn.setAttribute("crossorigin","anonymous"),new Promise(function(As){qn.addEventListener("load",function(){As()},!1),qn.addEventListener("error",function(){As()},!1),document.body.appendChild(qn)})}(A.locateFile(Bt.url,A.$)):Promise.resolve()})).then(function(){var Bt,Ln,qn;return k(function(As){if(As.g==1)return Bt=window.createMediapipeSolutionsWasm,Ln=window.createMediapipeSolutionsPackedAssets,qn=A,v(As,Bt(Ln),2);qn.h=As.h,As.g=0})}),ft=k(function(Bt){return A.g.graph&&A.g.graph.url?Bt=v(Bt,jn(A,A.g.graph.url),0):(Bt.g=0,Bt=void 0),Bt}),v(Ft,Promise.all([lt,Ke,ft]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return ie=U.filter(function(Bt){return Bt.simd===void 0||Bt.simd&&Q||!Bt.simd&&!Q}).map(function(Bt){return A.locateFile(Bt.url,A.$)}),importScripts.apply(null,a(ie)),de=A,v(Ft,createMediapipeSolutionsWasm(Module),6);case 6:de.h=Ft.h,A.l=new OffscreenCanvas(1,1),A.h.canvas=A.l,ue=A.h.GL.createContext(A.l,{antialias:!1,alpha:!1,ja:typeof WebGL2RenderingContext<"u"?2:1}),A.h.GL.makeContextCurrent(ue),Ft.g=4;break;case 7:if(A.l=document.createElement("canvas"),!(Dt=A.l.getContext("webgl2",{}))&&!(Dt=A.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),Ft.return();A.G=Dt,A.h.canvas=A.l,A.h.createContext(A.l,!0,!0,{});case 4:A.i=new A.h.SolutionWasm,A.Z=!1,Ft.g=0}})}function jn(A,U){var Q,ie;return k(function(de){return U in A.H?de.return(A.H[U]):(Q=A.locateFile(U,""),ie=fetch(Q).then(function(ue){return ue.arrayBuffer()}),A.H[U]=ie,de.return(ie))})}function Xn(A,U,Q){var ie,de,ue,fe,we,Ke,lt,ft,Dt,Ft,Bt,Ln,qn,As;return k(function(Rs){switch(Rs.g){case 1:if(!Q)return Rs.return(U);for(ie={},de=0,ue=o(Object.keys(Q)),fe=ue.next();!fe.done;fe=ue.next())we=fe.value,typeof(Ke=Q[we])!="string"&&Ke.type==="texture"&&U[Ke.stream]!==void 0&&++de;1<de&&(A.I=!1),lt=o(Object.keys(Q)),fe=lt.next();case 2:if(fe.done){Rs.g=4;break}if(ft=fe.value,typeof(Dt=Q[ft])=="string")return qn=ie,As=ft,v(Rs,function(Ll,nh,Ha){var ja;return k(function(yc){return typeof Ha=="number"||Ha instanceof Uint8Array||Ha instanceof Ll.h.Uint8BlobList?yc.return(Ha):Ha instanceof Ll.h.Texture2dDataOut?((ja=Ll.u[nh])||(ja=new ae(Ll.h,Ll.G),Ll.u[nh]=ja),yc.return(Se(ja,Ha,Ll.I))):yc.return(void 0)})}(A,ft,U[Dt]),14);if(Ft=U[Dt.stream],Dt.type==="detection_list"){if(Ft){for(var Ni=Ft.getRectList(),zr=Ft.getLandmarksList(),zs=Ft.getClassificationsList(),as=[],Ti=0;Ti<Ni.size();++Ti){var io=Bn(Ni.get(Ti),Jn,Dn);io={boundingBox:{xCenter:bt(io,1),yCenter:bt(io,2),height:bt(io,3),width:bt(io,4),rotation:bt(io,5,0),rectId:Ht(io,6)},landmarks:Wt(Bn(zr.get(Ti),mt,qt),Ue,1).map(O),V:F(Bn(zs.get(Ti),pe,Oe))},as.push(io)}Ni=as}else Ni=[];ie[ft]=Ni,Rs.g=7;break}if(Dt.type==="proto_list"){if(Ft){for(Ni=Array(Ft.size()),zr=0;zr<Ft.size();zr++)Ni[zr]=Ft.get(zr);Ft.delete()}else Ni=[];ie[ft]=Ni,Rs.g=7;break}if(Ft===void 0){Rs.g=3;break}if(Dt.type==="float_list"){ie[ft]=Ft,Rs.g=7;break}if(Dt.type==="proto"){ie[ft]=Ft,Rs.g=7;break}if(Dt.type!=="texture")throw Error("Unknown output config type: '"+Dt.type+"'");return(Bt=A.u[ft])||(Bt=new ae(A.h,A.G),A.u[ft]=Bt),v(Rs,Se(Bt,Ft,A.I),13);case 13:Ln=Rs.h,ie[ft]=Ln;case 7:Dt.transform&&ie[ft]&&(ie[ft]=Dt.transform(ie[ft])),Rs.g=3;break;case 14:qn[As]=Rs.h;case 3:fe=lt.next(),Rs.g=2;break;case 4:return Rs.return(ie)}})}function Wn(A,U){for(var Q=U.name||"$",ie=[].concat(a(U.wants)),de=new A.h.StringList,ue=o(U.wants),fe=ue.next();!fe.done;fe=ue.next())de.push_back(fe.value);ue=A.h.PacketListener.implement({onResults:function(we){for(var Ke={},lt=0;lt<U.wants.length;++lt)Ke[ie[lt]]=we.get(lt);var ft=A.listeners[Q];ft&&(A.D=Xn(A,Ke,U.outs).then(function(Dt){Dt=ft(Dt);for(var Ft=0;Ft<U.wants.length;++Ft){var Bt=Ke[ie[Ft]];typeof Bt=="object"&&Bt.hasOwnProperty&&Bt.hasOwnProperty("delete")&&Bt.delete()}Dt&&(A.D=Dt)}))}}),A.i.attachMultiListener(de,ue),de.delete()}function ln(A){var U=this;A=A||{};var Q={url:"face_detection_short.binarypb"},ie={type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}};this.g=new Tt({locateFile:A.locateFile,files:[{data:!0,url:"face_detection_short.binarypb"},{data:!0,url:"face_detection_short_range.tflite"},{simd:!0,url:"face_detection_solution_simd_wasm_bin.js"},{simd:!1,url:"face_detection_solution_wasm_bin.js"}],graph:Q,listeners:[{wants:["detections","image_transformed"],outs:{image:"image_transformed",detections:{type:"detection_list",stream:"detections"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window=="object"&&window.navigator!==void 0&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},model:{type:0,onChange:function(de){var ue,fe,we,Ke,lt;return k(function(ft){switch(ft.g){case 1:ue=o(de==="short"?["face_detection_short_range.tflite"]:["face_detection_full_range_sparse.tflite"]),fe=ue.next();case 2:if(fe.done){ft.g=4;break}return we=fe.value,Ke="third_party/mediapipe/modules/face_detection/"+we,v(ft,jn(U.g,we),5);case 5:lt=ft.h,U.g.overrideFile(Ke,lt),fe=ue.next(),ft.g=2;break;case 4:return Q.url=de==="short"?"face_detection_short.binarypb":"face_detection_full.binarypb",ie.graphOptionXref.calculatorName=de==="short"?"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator":"facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator",ft.return(!0)}})}},minDetectionConfidence:ie}})}(n=Tt.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},n.reset=function(){var A=this;return k(function(U){A.i&&(A.i.reset(),A.o={},A.u={}),U.g=0})},n.setOptions=function(A,U){var Q=this;if(U=U||this.g.options){for(var ie=[],de=[],ue={},fe=o(Object.keys(A)),we=fe.next();!we.done;ue={R:ue.R,S:ue.S},we=fe.next()){var Ke=we.value;Ke in this.j&&this.j[Ke]===A[Ke]||(this.j[Ke]=A[Ke],(we=U[Ke])!==void 0&&(we.onChange&&(ue.R=we.onChange,ue.S=A[Ke],ie.push(function(lt){return function(){return k(function(ft){if(ft.g==1)return v(ft,lt.R(lt.S),2);ft.h===!0&&(Q.s=!0),ft.g=0})}}(ue))),we.graphOptionXref&&(Ke={valueNumber:we.type===1?A[Ke]:0,valueBoolean:we.type===0&&A[Ke],valueString:we.type===2?A[Ke]:""},we=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),we.graphOptionXref),Ke),de.push(we))))}ie.length===0&&de.length===0||(this.s=!0,this.B=(this.B===void 0?[]:this.B).concat(de),this.A=(this.A===void 0?[]:this.A).concat(ie))}},n.initialize=function(){var A=this;return k(function(U){return U.g==1?v(U,kn(A),2):U.g!=3?v(U,function(Q){var ie,de,ue,fe,we,Ke,lt,ft;return k(function(Dt){if(Dt.g==1)return Q.g.graph&&Q.g.graph.url&&Q.Y===Q.g.graph.url?Dt.return():(Q.s=!0,Q.g.graph&&Q.g.graph.url?(Q.Y=Q.g.graph.url,v(Dt,jn(Q,Q.g.graph.url),3)):void(Dt.g=2));for(Dt.g!=2&&(ie=Dt.h,Q.i.loadGraph(ie)),de=o(Object.keys(Q.C)),ue=de.next();!ue.done;ue=de.next())fe=ue.value,Q.i.overrideFile(fe,Q.C[fe]);if(Q.C={},Q.g.listeners)for(we=o(Q.g.listeners),Ke=we.next();!Ke.done;Ke=we.next())lt=Ke.value,Wn(Q,lt);ft=Q.j,Q.j={},Q.setOptions(ft),Dt.g=0})}(A),3):v(U,function(Q){var ie,de,ue,fe,we,Ke;return k(function(lt){switch(lt.g){case 1:if(!Q.s)return lt.return();if(!Q.A){lt.g=2;break}ie=o(Q.A),de=ie.next();case 3:if(de.done){lt.g=5;break}return v(lt,(0,de.value)(),4);case 4:de=ie.next(),lt.g=3;break;case 5:Q.A=void 0;case 2:if(Q.B){for(ue=new Q.h.GraphOptionChangeRequestList,fe=o(Q.B),we=fe.next();!we.done;we=fe.next())Ke=we.value,ue.push_back(Ke);Q.i.changeOptions(ue),ue.delete(),Q.B=void 0}Q.s=!1,lt.g=0}})}(A),0)})},n.overrideFile=function(A,U){this.i?this.i.overrideFile(A,U):this.C[A]=U},n.clearOverriddenFiles=function(){this.C={},this.i&&this.i.clearOverriddenFiles()},n.send=function(A,U){var Q,ie,de,ue,fe,we,Ke,lt,ft,Dt=this;return k(function(Ft){switch(Ft.g){case 1:return Dt.g.inputs?(Q=1e3*(U??performance.now()),v(Ft,Dt.D,2)):Ft.return();case 2:return v(Ft,Dt.initialize(),3);case 3:for(ie=new Dt.h.PacketDataList,de=o(Object.keys(A)),ue=de.next();!ue.done;ue=de.next())if(fe=ue.value,we=Dt.g.inputs[fe]){e:{var Bt=A[fe];switch(we.type){case"video":var Ln=Dt.o[we.stream];if(Ln||(Ln=new ae(Dt.h,Dt.G),Dt.o[we.stream]=Ln),Ln.l===0&&(Ln.l=Ln.h.createTexture()),typeof HTMLVideoElement<"u"&&Bt instanceof HTMLVideoElement)var qn=Bt.videoWidth,As=Bt.videoHeight;else typeof HTMLImageElement<"u"&&Bt instanceof HTMLImageElement?(qn=Bt.naturalWidth,As=Bt.naturalHeight):(qn=Bt.width,As=Bt.height);As={glName:Ln.l,width:qn,height:As},(qn=Ln.g).canvas.width=As.width,qn.canvas.height=As.height,qn.activeTexture(qn.TEXTURE0),Ln.h.bindTexture2d(Ln.l),qn.texImage2D(qn.TEXTURE_2D,0,qn.RGBA,qn.RGBA,qn.UNSIGNED_BYTE,Bt),Ln.h.bindTexture2d(0),Ln=As;break e;case"detections":for((Ln=Dt.o[we.stream])||(Ln=new Ve(Dt.h),Dt.o[we.stream]=Ln),Ln.data||(Ln.data=new Ln.g.DetectionListData),Ln.data.reset(Bt.length),As=0;As<Bt.length;++As){qn=Bt[As];var Rs=Ln.data,Ni=Rs.setBoundingBox,zr=As,zs=qn.boundingBox,as=new Jn;if(kt(as,1,zs.xCenter),kt(as,2,zs.yCenter),kt(as,3,zs.height),kt(as,4,zs.width),kt(as,5,zs.rotation),kt(as,6,zs.rectId),zs=En(as,Dn),Ni.call(Rs,zr,zs),qn.landmarks)for(Rs=0;Rs<qn.landmarks.length;++Rs){var Ti=!!(as=qn.landmarks[Rs]).visibility;zr=(Ni=Ln.data).addNormalizedLandmark,zs=As,as=Object.assign(Object.assign({},as),{visibility:Ti?as.visibility:0}),kt(Ti=new Ue,1,as.x),kt(Ti,2,as.y),kt(Ti,3,as.z),as.visibility&&kt(Ti,4,as.visibility),as=En(Ti,ot),zr.call(Ni,zs,as)}if(qn.V)for(Rs=0;Rs<qn.V.length;++Rs)zr=(Ni=Ln.data).addClassification,zs=As,as=qn.V[Rs],kt(Ti=new H,2,as.ga),as.index&&kt(Ti,1,as.index),as.label&&kt(Ti,3,as.label),as.displayName&&kt(Ti,4,as.displayName),as=En(Ti,q),zr.call(Ni,zs,as)}Ln=Ln.data;break e;default:Ln={}}}switch(Ke=Ln,lt=we.stream,we.type){case"video":ie.pushTexture2d(Object.assign(Object.assign({},Ke),{stream:lt,timestamp:Q}));break;case"detections":(ft=Ke).stream=lt,ft.timestamp=Q,ie.pushDetectionList(ft);break;default:throw Error("Unknown input config type: '"+we.type+"'")}}return Dt.i.send(ie),v(Ft,Dt.D,4);case 4:ie.delete(),Ft.g=0}})},n.onResults=function(A,U){this.listeners[U||"$"]=A},I("Solution",Tt),I("OptionType",{BOOL:0,NUMBER:1,ia:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(n=ln.prototype).close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(A){this.g.onResults(A)},n.initialize=function(){var A=this;return k(function(U){return v(U,A.g.initialize(),0)})},n.reset=function(){this.g.reset()},n.send=function(A){var U=this;return k(function(Q){return v(Q,U.g.send(A),0)})},n.setOptions=function(A){this.g.setOptions(A)},I("FaceDetection",ln),I("FACEDETECTION_LIPS",Nn),I("FACEDETECTION_LEFT_EYE",sn),I("FACEDETECTION_LEFT_EYEBROW",jt),I("FACEDETECTION_RIGHT_EYE",Un),I("FACEDETECTION_RIGHT_EYEBROW",Qn),I("FACEDETECTION_FACE_OVAL",Gs),I("FACEDETECTION_CONTOURS",ps),I("FACEDETECTION_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),I("VERSION","0.4.1646425229")}).call(uC);var _L;(_L||(_L={})).MediaPipeFaceDetector="MediaPipeFaceDetector";Array.from(Array(468).keys());var EL;(function(n){n.MediaPipeFaceMesh="MediaPipeFaceMesh"})(EL||(EL={}));/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var UV=function(n,e){return(UV=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var i in s)Object.prototype.hasOwnProperty.call(s,i)&&(t[i]=s[i])})(n,e)};function VV(n,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function t(){this.constructor=n}UV(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var F_=function(){return(F_=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var i in e=arguments[t])Object.prototype.hasOwnProperty.call(e,i)&&(n[i]=e[i]);return n}).apply(this,arguments)};function ug(n,e,t){if(t||arguments.length===2)for(var s,i=0,r=e.length;i<r;i++)!s&&i in e||(s||(s=Array.prototype.slice.call(e,0,i)),s[i]=e[i]);return n.concat(s||Array.prototype.slice.call(e))}var O6e=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],TL,IL,WV=function(){function n(e){(function(t){if(t.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(t.maxTracks));if(t.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(t.maxAge));if(t.keypointTrackerParams!==void 0){if(t.keypointTrackerParams.keypointConfidenceThreshold<0||t.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(t.keypointTrackerParams.keypointConfidenceThreshold));if(t.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(t.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,i=t.keypointTrackerParams.keypointFalloff;s<i.length;s++){var r=i[s];if(r<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(r))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return n.prototype.apply=function(e,t){this.filterOldTracks(t);var s=this.computeSimilarity(e);return this.assignTracks(e,s,t),this.updateTracks(t),e},n.prototype.getTracks=function(){return this.tracks.slice()},n.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},n.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter(function(s){return e-s.lastTimestamp<=t.maxAge})},n.prototype.assignTracks=function(e,t,s){for(var i=Array.from(Array(t[0].length).keys()),r=[],o=0,a=Array.from(Array(e.length).keys());o<a.length;o++){var l=a[o];if(i.length!==0){for(var c=-1,u=-1,d=0,h=i;d<h.length;d++){var p=h[d],g=t[l][p];g>=this.minSimilarity&&g>u&&(c=p,u=g)}if(c>=0){var y=this.tracks[c];y=Object.assign(y,this.createTrack(e[l],s,y.id)),e[l].id=y.id;var x=i.indexOf(c);i.splice(x,1)}else r.push(l)}else r.push(l)}for(var v=0,b=r;v<b.length;v++){l=b[v];var S=this.createTrack(e[l],s);this.tracks.push(S),e[l].id=S.id}},n.prototype.updateTracks=function(e){this.tracks.sort(function(t,s){return s.lastTimestamp-t.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},n.prototype.createTrack=function(e,t,s){var i={id:s||this.nextTrackID(),lastTimestamp:t,keypoints:ug([],e.keypoints,!0).map(function(r){return F_({},r)})};return e.box!==void 0&&(i.box=F_({},e.box)),i},n.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},n.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter(function(s){return!e.includes(s.id)})},n.prototype.reset=function(){this.tracks=[]},n}();(function(n){function e(t){return n.call(this,t)||this}return VV(e,n),e.prototype.computeSimilarity=function(t){var s=this;return t.length===0||this.tracks.length===0?[[]]:t.map(function(i){return s.tracks.map(function(r){return s.iou(i,r)})})},e.prototype.iou=function(t,s){var i=Math.max(t.box.xMin,s.box.xMin),r=Math.max(t.box.yMin,s.box.yMin),o=Math.min(t.box.xMax,s.box.xMax),a=Math.min(t.box.yMax,s.box.yMax);if(i>=o||r>=a)return 0;var l=(o-i)*(a-r);return l/(t.box.width*t.box.height+s.box.width*s.box.height-l)},e})(WV);(function(n){function e(t){var s=n.call(this,t)||this;return s.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=t.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,s}return VV(e,n),e.prototype.computeSimilarity=function(t){if(t.length===0||this.tracks.length===0)return[[]];for(var s=[],i=0,r=t;i<r.length;i++){for(var o=r[i],a=[],l=0,c=this.tracks;l<c.length;l++){var u=c[l];a.push(this.oks(o,u))}s.push(a)}return s},e.prototype.oks=function(t,s){for(var i=this.area(s.keypoints)+1e-6,r=0,o=0,a=0;a<t.keypoints.length;++a){var l=t.keypoints[a],c=s.keypoints[a];if(!(l.score<this.keypointThreshold||c.score<this.keypointThreshold)){o+=1;var u=Math.pow(l.x-c.x,2)+Math.pow(l.y-c.y,2),d=2*this.keypointFalloff[a];r+=Math.exp(-1*u/(2*i*Math.pow(d,2)))}}return o<this.minNumKeyoints?0:r/o},e.prototype.area=function(t){var s=this,i=t.filter(function(l){return l.score>s.keypointThreshold}),r=Math.min.apply(Math,ug([1],i.map(function(l){return l.x}),!1)),o=Math.max.apply(Math,ug([0],i.map(function(l){return l.x}),!1)),a=Math.min.apply(Math,ug([1],i.map(function(l){return l.y}),!1));return(o-r)*(Math.max.apply(Math,ug([0],i.map(function(l){return l.y}),!1))-a)},e})(WV);(function(n){n.Keypoint="keypoint",n.BoundingBox="boundingBox"})(TL||(TL={})),function(n){n.MoveNet="MoveNet",n.BlazePose="BlazePose",n.PoseNet="PoseNet"}(IL||(IL={}));var kL=O6e.reduce(function(n,e,t){return n[e]=t,n},{}),GV=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(n){var e=n[0],t=n[1];return[kL[e],kL[t]]});GV.map(function(n){return n[1]});GV.map(function(n){return n[0]});async function z6e(){try{Xae("webgpu")?(await Fv("webgpu"),console.log("TensorFlow.js initialized with WebGPU backend")):(await Fv("webgl"),console.log("TensorFlow.js initialized with WebGL backend")),await a_()}catch(n){console.error("Error initializing TensorFlow:",n),await Fv("webgl"),await a_()}}z6e().then(()=>{k9.createRoot(document.getElementById("root")).render(G.jsx(AL.StrictMode,{children:G.jsx(iMe,{})}))});
